'use strict';
(self.webpackChunkng2_pdf_viewer = self.webpackChunkng2_pdf_viewer || []).push([
  [179],
  {
    541: (Tb, nM, Kc) => {
      var Ls = {};
      Kc.r(Ls),
        Kc.d(Ls, {
          AbortException: () => Ose,
          AnnotationEditorLayer: () => Lse,
          AnnotationEditorParamsType: () => Nse,
          AnnotationEditorType: () => qB,
          AnnotationEditorUIManager: () => Vse,
          AnnotationLayer: () => Bse,
          AnnotationMode: () => Hse,
          CMapCompressionType: () => Wse,
          ColorPicker: () => jse,
          DOMSVGFactory: () => zse,
          DrawLayer: () => Use,
          FeatureTest: () => $se,
          GlobalWorkerOptions: () => XB,
          ImageKind: () => Gse,
          InvalidPDFException: () => qse,
          MissingPDFException: () => Xse,
          OPS: () => Yse,
          PDFDataRangeTransport: () => Kse,
          PDFDateString: () => Zse,
          PDFWorker: () => Qse,
          PasswordResponses: () => Jse,
          PermissionFlag: () => eoe,
          PixelsPerInch: () => toe,
          RenderingCancelledException: () => noe,
          TextLayer: () => ioe,
          UnexpectedResponseException: () => roe,
          Util: () => soe,
          VerbosityLevel: () => YB,
          XfaLayer: () => ooe,
          build: () => aoe,
          createValidAbsoluteUrl: () => loe,
          fetchData: () => coe,
          getDocument: () => KB,
          getFilenameFromUrl: () => doe,
          getPdfFilenameFromUrl: () => uoe,
          getXfaPageViewport: () => hoe,
          isDataScheme: () => foe,
          isPdfFile: () => poe,
          noContextMenu: () => moe,
          normalizeUnicode: () => goe,
          setLayerDimensions: () => _oe,
          shadow: () => boe,
          version: () => V_,
        });
      var Ib = {};
      function ot(n) {
        return 'function' == typeof n;
      }
      function iM(n) {
        const t = n((i) => {
          Error.call(i), (i.stack = new Error().stack);
        });
        return (
          (t.prototype = Object.create(Error.prototype)),
          (t.prototype.constructor = t),
          t
        );
      }
      Kc.r(Ib),
        Kc.d(Ib, {
          AnnotationLayerBuilder: () => cce,
          DownloadManager: () => dce,
          EventBus: () => uce,
          FindState: () => hce,
          GenericL10n: () => qW,
          LinkTarget: () => Xc,
          PDFFindController: () => XW,
          PDFHistory: () => fce,
          PDFLinkService: () => YW,
          PDFPageView: () => pce,
          PDFScriptingManager: () => mce,
          PDFSinglePageViewer: () => KW,
          PDFViewer: () => ZW,
          ProgressBar: () => gce,
          RenderingStates: () => _ce,
          ScrollMode: () => bce,
          SimpleLinkService: () => vce,
          SpreadMode: () => yce,
          StructTreeLayerBuilder: () => wce,
          TextLayerBuilder: () => Ece,
          XfaLayerBuilder: () => Cce,
          parseQueryString: () => xce,
        });
      const kb = iM(
        (n) =>
          function (t) {
            n(this),
              (this.message = t
                ? `${t.length} errors occurred during unsubscription:\n${t
                    .map((i, r) => `${r + 1}) ${i.toString()}`)
                    .join('\n  ')}`
                : ''),
              (this.name = 'UnsubscriptionError'),
              (this.errors = t);
          }
      );
      function wf(n, e) {
        if (n) {
          const t = n.indexOf(e);
          0 <= t && n.splice(t, 1);
        }
      }
      class $t {
        constructor(e) {
          (this.initialTeardown = e),
            (this.closed = !1),
            (this._parentage = null),
            (this._finalizers = null);
        }
        unsubscribe() {
          let e;
          if (!this.closed) {
            this.closed = !0;
            const { _parentage: t } = this;
            if (t)
              if (((this._parentage = null), Array.isArray(t)))
                for (const s of t) s.remove(this);
              else t.remove(this);
            const { initialTeardown: i } = this;
            if (ot(i))
              try {
                i();
              } catch (s) {
                e = s instanceof kb ? s.errors : [s];
              }
            const { _finalizers: r } = this;
            if (r) {
              this._finalizers = null;
              for (const s of r)
                try {
                  oM(s);
                } catch (o) {
                  (e = e ?? []),
                    o instanceof kb ? (e = [...e, ...o.errors]) : e.push(o);
                }
            }
            if (e) throw new kb(e);
          }
        }
        add(e) {
          var t;
          if (e && e !== this)
            if (this.closed) oM(e);
            else {
              if (e instanceof $t) {
                if (e.closed || e._hasParent(this)) return;
                e._addParent(this);
              }
              (this._finalizers =
                null !== (t = this._finalizers) && void 0 !== t ? t : []).push(
                e
              );
            }
        }
        _hasParent(e) {
          const { _parentage: t } = this;
          return t === e || (Array.isArray(t) && t.includes(e));
        }
        _addParent(e) {
          const { _parentage: t } = this;
          this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
        }
        _removeParent(e) {
          const { _parentage: t } = this;
          t === e ? (this._parentage = null) : Array.isArray(t) && wf(t, e);
        }
        remove(e) {
          const { _finalizers: t } = this;
          t && wf(t, e), e instanceof $t && e._removeParent(this);
        }
      }
      $t.EMPTY = (() => {
        const n = new $t();
        return (n.closed = !0), n;
      })();
      const rM = $t.EMPTY;
      function sM(n) {
        return (
          n instanceof $t ||
          (n && 'closed' in n && ot(n.remove) && ot(n.add) && ot(n.unsubscribe))
        );
      }
      function oM(n) {
        ot(n) ? n() : n.unsubscribe();
      }
      const ko = {
          onUnhandledError: null,
          onStoppedNotification: null,
          Promise: void 0,
          useDeprecatedSynchronousErrorHandling: !1,
          useDeprecatedNextContext: !1,
        },
        Ef = {
          setTimeout(n, e, ...t) {
            const { delegate: i } = Ef;
            return i?.setTimeout
              ? i.setTimeout(n, e, ...t)
              : setTimeout(n, e, ...t);
          },
          clearTimeout(n) {
            const { delegate: e } = Ef;
            return (e?.clearTimeout || clearTimeout)(n);
          },
          delegate: void 0,
        };
      function aM(n) {
        Ef.setTimeout(() => {
          const { onUnhandledError: e } = ko;
          if (!e) throw n;
          e(n);
        });
      }
      function Pb() {}
      const _j = Rb('C', void 0, void 0);
      function Rb(n, e, t) {
        return { kind: n, value: e, error: t };
      }
      let Po = null;
      function Cf(n) {
        if (ko.useDeprecatedSynchronousErrorHandling) {
          const e = !Po;
          if ((e && (Po = { errorThrown: !1, error: null }), n(), e)) {
            const { errorThrown: t, error: i } = Po;
            if (((Po = null), t)) throw i;
          }
        } else n();
      }
      class Fb extends $t {
        constructor(e) {
          super(),
            (this.isStopped = !1),
            e
              ? ((this.destination = e), sM(e) && e.add(this))
              : (this.destination = xj);
        }
        static create(e, t, i) {
          return new Zc(e, t, i);
        }
        next(e) {
          this.isStopped
            ? Lb(
                (function vj(n) {
                  return Rb('N', n, void 0);
                })(e),
                this
              )
            : this._next(e);
        }
        error(e) {
          this.isStopped
            ? Lb(
                (function bj(n) {
                  return Rb('E', void 0, n);
                })(e),
                this
              )
            : ((this.isStopped = !0), this._error(e));
        }
        complete() {
          this.isStopped
            ? Lb(_j, this)
            : ((this.isStopped = !0), this._complete());
        }
        unsubscribe() {
          this.closed ||
            ((this.isStopped = !0),
            super.unsubscribe(),
            (this.destination = null));
        }
        _next(e) {
          this.destination.next(e);
        }
        _error(e) {
          try {
            this.destination.error(e);
          } finally {
            this.unsubscribe();
          }
        }
        _complete() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        }
      }
      const wj = Function.prototype.bind;
      function Ob(n, e) {
        return wj.call(n, e);
      }
      class Ej {
        constructor(e) {
          this.partialObserver = e;
        }
        next(e) {
          const { partialObserver: t } = this;
          if (t.next)
            try {
              t.next(e);
            } catch (i) {
              xf(i);
            }
        }
        error(e) {
          const { partialObserver: t } = this;
          if (t.error)
            try {
              t.error(e);
            } catch (i) {
              xf(i);
            }
          else xf(e);
        }
        complete() {
          const { partialObserver: e } = this;
          if (e.complete)
            try {
              e.complete();
            } catch (t) {
              xf(t);
            }
        }
      }
      class Zc extends Fb {
        constructor(e, t, i) {
          let r;
          if ((super(), ot(e) || !e))
            r = {
              next: e ?? void 0,
              error: t ?? void 0,
              complete: i ?? void 0,
            };
          else {
            let s;
            this && ko.useDeprecatedNextContext
              ? ((s = Object.create(e)),
                (s.unsubscribe = () => this.unsubscribe()),
                (r = {
                  next: e.next && Ob(e.next, s),
                  error: e.error && Ob(e.error, s),
                  complete: e.complete && Ob(e.complete, s),
                }))
              : (r = e);
          }
          this.destination = new Ej(r);
        }
      }
      function xf(n) {
        ko.useDeprecatedSynchronousErrorHandling
          ? (function yj(n) {
              ko.useDeprecatedSynchronousErrorHandling &&
                Po &&
                ((Po.errorThrown = !0), (Po.error = n));
            })(n)
          : aM(n);
      }
      function Lb(n, e) {
        const { onStoppedNotification: t } = ko;
        t && Ef.setTimeout(() => t(n, e));
      }
      const xj = {
          closed: !0,
          next: Pb,
          error: function Cj(n) {
            throw n;
          },
          complete: Pb,
        },
        Nb =
          ('function' == typeof Symbol && Symbol.observable) || '@@observable';
      function Xa(n) {
        return n;
      }
      let Mt = (() => {
        class n {
          constructor(t) {
            t && (this._subscribe = t);
          }
          lift(t) {
            const i = new n();
            return (i.source = this), (i.operator = t), i;
          }
          subscribe(t, i, r) {
            const s = (function Sj(n) {
              return (
                (n && n instanceof Fb) ||
                ((function Aj(n) {
                  return n && ot(n.next) && ot(n.error) && ot(n.complete);
                })(n) &&
                  sM(n))
              );
            })(t)
              ? t
              : new Zc(t, i, r);
            return (
              Cf(() => {
                const { operator: o, source: a } = this;
                s.add(
                  o
                    ? o.call(s, a)
                    : a
                    ? this._subscribe(s)
                    : this._trySubscribe(s)
                );
              }),
              s
            );
          }
          _trySubscribe(t) {
            try {
              return this._subscribe(t);
            } catch (i) {
              t.error(i);
            }
          }
          forEach(t, i) {
            return new (i = cM(i))((r, s) => {
              const o = new Zc({
                next: (a) => {
                  try {
                    t(a);
                  } catch (l) {
                    s(l), o.unsubscribe();
                  }
                },
                error: s,
                complete: r,
              });
              this.subscribe(o);
            });
          }
          _subscribe(t) {
            var i;
            return null === (i = this.source) || void 0 === i
              ? void 0
              : i.subscribe(t);
          }
          [Nb]() {
            return this;
          }
          pipe(...t) {
            return (function lM(n) {
              return 0 === n.length
                ? Xa
                : 1 === n.length
                ? n[0]
                : function (t) {
                    return n.reduce((i, r) => r(i), t);
                  };
            })(t)(this);
          }
          toPromise(t) {
            return new (t = cM(t))((i, r) => {
              let s;
              this.subscribe(
                (o) => (s = o),
                (o) => r(o),
                () => i(s)
              );
            });
          }
        }
        return (n.create = (e) => new n(e)), n;
      })();
      function cM(n) {
        var e;
        return null !== (e = n ?? ko.Promise) && void 0 !== e ? e : Promise;
      }
      const Mj = iM(
        (n) =>
          function () {
            n(this),
              (this.name = 'ObjectUnsubscribedError'),
              (this.message = 'object unsubscribed');
          }
      );
      let Le = (() => {
        class n extends Mt {
          constructor() {
            super(),
              (this.closed = !1),
              (this.currentObservers = null),
              (this.observers = []),
              (this.isStopped = !1),
              (this.hasError = !1),
              (this.thrownError = null);
          }
          lift(t) {
            const i = new dM(this, this);
            return (i.operator = t), i;
          }
          _throwIfClosed() {
            if (this.closed) throw new Mj();
          }
          next(t) {
            Cf(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.currentObservers ||
                  (this.currentObservers = Array.from(this.observers));
                for (const i of this.currentObservers) i.next(t);
              }
            });
          }
          error(t) {
            Cf(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                (this.hasError = this.isStopped = !0), (this.thrownError = t);
                const { observers: i } = this;
                for (; i.length; ) i.shift().error(t);
              }
            });
          }
          complete() {
            Cf(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.isStopped = !0;
                const { observers: t } = this;
                for (; t.length; ) t.shift().complete();
              }
            });
          }
          unsubscribe() {
            (this.isStopped = this.closed = !0),
              (this.observers = this.currentObservers = null);
          }
          get observed() {
            var t;
            return (
              (null === (t = this.observers) || void 0 === t
                ? void 0
                : t.length) > 0
            );
          }
          _trySubscribe(t) {
            return this._throwIfClosed(), super._trySubscribe(t);
          }
          _subscribe(t) {
            return (
              this._throwIfClosed(),
              this._checkFinalizedStatuses(t),
              this._innerSubscribe(t)
            );
          }
          _innerSubscribe(t) {
            const { hasError: i, isStopped: r, observers: s } = this;
            return i || r
              ? rM
              : ((this.currentObservers = null),
                s.push(t),
                new $t(() => {
                  (this.currentObservers = null), wf(s, t);
                }));
          }
          _checkFinalizedStatuses(t) {
            const { hasError: i, thrownError: r, isStopped: s } = this;
            i ? t.error(r) : s && t.complete();
          }
          asObservable() {
            const t = new Mt();
            return (t.source = this), t;
          }
        }
        return (n.create = (e, t) => new dM(e, t)), n;
      })();
      class dM extends Le {
        constructor(e, t) {
          super(), (this.destination = e), (this.source = t);
        }
        next(e) {
          var t, i;
          null ===
            (i =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.next) ||
            void 0 === i ||
            i.call(t, e);
        }
        error(e) {
          var t, i;
          null ===
            (i =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.error) ||
            void 0 === i ||
            i.call(t, e);
        }
        complete() {
          var e, t;
          null ===
            (t =
              null === (e = this.destination) || void 0 === e
                ? void 0
                : e.complete) ||
            void 0 === t ||
            t.call(e);
        }
        _subscribe(e) {
          var t, i;
          return null !==
            (i =
              null === (t = this.source) || void 0 === t
                ? void 0
                : t.subscribe(e)) && void 0 !== i
            ? i
            : rM;
        }
      }
      class uM extends Le {
        constructor(e) {
          super(), (this._value = e);
        }
        get value() {
          return this.getValue();
        }
        _subscribe(e) {
          const t = super._subscribe(e);
          return !t.closed && e.next(this._value), t;
        }
        getValue() {
          const { hasError: e, thrownError: t, _value: i } = this;
          if (e) throw t;
          return this._throwIfClosed(), i;
        }
        next(e) {
          super.next((this._value = e));
        }
      }
      function gn(n) {
        return (e) => {
          if (
            (function Dj(n) {
              return ot(n?.lift);
            })(e)
          )
            return e.lift(function (t) {
              try {
                return n(t, this);
              } catch (i) {
                this.error(i);
              }
            });
          throw new TypeError('Unable to lift unknown Observable type');
        };
      }
      function hn(n, e, t, i, r) {
        return new Tj(n, e, t, i, r);
      }
      class Tj extends Fb {
        constructor(e, t, i, r, s, o) {
          super(e),
            (this.onFinalize = s),
            (this.shouldUnsubscribe = o),
            (this._next = t
              ? function (a) {
                  try {
                    t(a);
                  } catch (l) {
                    e.error(l);
                  }
                }
              : super._next),
            (this._error = r
              ? function (a) {
                  try {
                    r(a);
                  } catch (l) {
                    e.error(l);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._error),
            (this._complete = i
              ? function () {
                  try {
                    i();
                  } catch (a) {
                    e.error(a);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._complete);
        }
        unsubscribe() {
          var e;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            const { closed: t } = this;
            super.unsubscribe(),
              !t &&
                (null === (e = this.onFinalize) ||
                  void 0 === e ||
                  e.call(this));
          }
        }
      }
      function Gt(n, e) {
        return gn((t, i) => {
          let r = 0;
          t.subscribe(
            hn(i, (s) => {
              i.next(n.call(e, s, r++));
            })
          );
        });
      }
      function Ns(n) {
        return this instanceof Ns ? ((this.v = n), this) : new Ns(n);
      }
      function mM(n) {
        if (!Symbol.asyncIterator)
          throw new TypeError('Symbol.asyncIterator is not defined.');
        var t,
          e = n[Symbol.asyncIterator];
        return e
          ? e.call(n)
          : ((n = (function Wb(n) {
              var e = 'function' == typeof Symbol && Symbol.iterator,
                t = e && n[e],
                i = 0;
              if (t) return t.call(n);
              if (n && 'number' == typeof n.length)
                return {
                  next: function () {
                    return (
                      n && i >= n.length && (n = void 0),
                      { value: n && n[i++], done: !n }
                    );
                  },
                };
              throw new TypeError(
                e
                  ? 'Object is not iterable.'
                  : 'Symbol.iterator is not defined.'
              );
            })(n)),
            (t = {}),
            i('next'),
            i('throw'),
            i('return'),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(s) {
          t[s] =
            n[s] &&
            function (o) {
              return new Promise(function (a, l) {
                !(function r(s, o, a, l) {
                  Promise.resolve(l).then(function (c) {
                    s({ value: c, done: a });
                  }, o);
                })(a, l, (o = n[s](o)).done, o.value);
              });
            };
        }
      }
      const jb = (n) =>
        n && 'number' == typeof n.length && 'function' != typeof n;
      function gM(n) {
        return ot(n?.then);
      }
      function _M(n) {
        return ot(n[Nb]);
      }
      function bM(n) {
        return Symbol.asyncIterator && ot(n?.[Symbol.asyncIterator]);
      }
      function vM(n) {
        return new TypeError(
          `You provided ${
            null !== n && 'object' == typeof n ? 'an invalid object' : `'${n}'`
          } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`
        );
      }
      const yM = (function Xj() {
        return 'function' == typeof Symbol && Symbol.iterator
          ? Symbol.iterator
          : '@@iterator';
      })();
      function wM(n) {
        return ot(n?.[yM]);
      }
      function EM(n) {
        return (function pM(n, e, t) {
          if (!Symbol.asyncIterator)
            throw new TypeError('Symbol.asyncIterator is not defined.');
          var r,
            i = t.apply(n, e || []),
            s = [];
          return (
            (r = {}),
            o('next'),
            o('throw'),
            o('return'),
            (r[Symbol.asyncIterator] = function () {
              return this;
            }),
            r
          );
          function o(f) {
            i[f] &&
              (r[f] = function (p) {
                return new Promise(function (m, g) {
                  s.push([f, p, m, g]) > 1 || a(f, p);
                });
              });
          }
          function a(f, p) {
            try {
              !(function l(f) {
                f.value instanceof Ns
                  ? Promise.resolve(f.value.v).then(c, u)
                  : h(s[0][2], f);
              })(i[f](p));
            } catch (m) {
              h(s[0][3], m);
            }
          }
          function c(f) {
            a('next', f);
          }
          function u(f) {
            a('throw', f);
          }
          function h(f, p) {
            f(p), s.shift(), s.length && a(s[0][0], s[0][1]);
          }
        })(this, arguments, function* () {
          const t = n.getReader();
          try {
            for (;;) {
              const { value: i, done: r } = yield Ns(t.read());
              if (r) return yield Ns(void 0);
              yield yield Ns(i);
            }
          } finally {
            t.releaseLock();
          }
        });
      }
      function CM(n) {
        return ot(n?.getReader);
      }
      function Bn(n) {
        if (n instanceof Mt) return n;
        if (null != n) {
          if (_M(n))
            return (function Yj(n) {
              return new Mt((e) => {
                const t = n[Nb]();
                if (ot(t.subscribe)) return t.subscribe(e);
                throw new TypeError(
                  'Provided object does not correctly implement Symbol.observable'
                );
              });
            })(n);
          if (jb(n))
            return (function Kj(n) {
              return new Mt((e) => {
                for (let t = 0; t < n.length && !e.closed; t++) e.next(n[t]);
                e.complete();
              });
            })(n);
          if (gM(n))
            return (function Zj(n) {
              return new Mt((e) => {
                n.then(
                  (t) => {
                    e.closed || (e.next(t), e.complete());
                  },
                  (t) => e.error(t)
                ).then(null, aM);
              });
            })(n);
          if (bM(n)) return xM(n);
          if (wM(n))
            return (function Qj(n) {
              return new Mt((e) => {
                for (const t of n) if ((e.next(t), e.closed)) return;
                e.complete();
              });
            })(n);
          if (CM(n))
            return (function Jj(n) {
              return xM(EM(n));
            })(n);
        }
        throw vM(n);
      }
      function xM(n) {
        return new Mt((e) => {
          (function ez(n, e) {
            var t, i, r, s;
            return (function hM(n, e, t, i) {
              return new (t || (t = Promise))(function (s, o) {
                function a(u) {
                  try {
                    c(i.next(u));
                  } catch (h) {
                    o(h);
                  }
                }
                function l(u) {
                  try {
                    c(i.throw(u));
                  } catch (h) {
                    o(h);
                  }
                }
                function c(u) {
                  u.done
                    ? s(u.value)
                    : (function r(s) {
                        return s instanceof t
                          ? s
                          : new t(function (o) {
                              o(s);
                            });
                      })(u.value).then(a, l);
                }
                c((i = i.apply(n, e || [])).next());
              });
            })(this, void 0, void 0, function* () {
              try {
                for (t = mM(n); !(i = yield t.next()).done; )
                  if ((e.next(i.value), e.closed)) return;
              } catch (o) {
                r = { error: o };
              } finally {
                try {
                  i && !i.done && (s = t.return) && (yield s.call(t));
                } finally {
                  if (r) throw r.error;
                }
              }
              e.complete();
            });
          })(n, e).catch((t) => e.error(t));
        });
      }
      function es(n, e, t, i = 0, r = !1) {
        const s = e.schedule(function () {
          t(), r ? n.add(this.schedule(null, i)) : this.unsubscribe();
        }, i);
        if ((n.add(s), !r)) return s;
      }
      function Qc(n, e, t = 1 / 0) {
        return ot(e)
          ? Qc((i, r) => Gt((s, o) => e(i, s, r, o))(Bn(n(i, r))), t)
          : ('number' == typeof e && (t = e),
            gn((i, r) =>
              (function tz(n, e, t, i, r, s, o, a) {
                const l = [];
                let c = 0,
                  u = 0,
                  h = !1;
                const f = () => {
                    h && !l.length && !c && e.complete();
                  },
                  p = (g) => (c < i ? m(g) : l.push(g)),
                  m = (g) => {
                    s && e.next(g), c++;
                    let w = !1;
                    Bn(t(g, u++)).subscribe(
                      hn(
                        e,
                        (y) => {
                          r?.(y), s ? p(y) : e.next(y);
                        },
                        () => {
                          w = !0;
                        },
                        void 0,
                        () => {
                          if (w)
                            try {
                              for (c--; l.length && c < i; ) {
                                const y = l.shift();
                                o ? es(e, o, () => m(y)) : m(y);
                              }
                              f();
                            } catch (y) {
                              e.error(y);
                            }
                        }
                      )
                    );
                  };
                return (
                  n.subscribe(
                    hn(e, p, () => {
                      (h = !0), f();
                    })
                  ),
                  () => {
                    a?.();
                  }
                );
              })(i, r, n, t)
            ));
      }
      function AM(n = 1 / 0) {
        return Qc(Xa, n);
      }
      const Af = new Mt((n) => n.complete());
      function SM(n) {
        return n && ot(n.schedule);
      }
      function zb(n) {
        return n[n.length - 1];
      }
      function MM(n) {
        return ot(zb(n)) ? n.pop() : void 0;
      }
      function Jc(n) {
        return SM(zb(n)) ? n.pop() : void 0;
      }
      function DM(n, e = 0) {
        return gn((t, i) => {
          t.subscribe(
            hn(
              i,
              (r) => es(i, n, () => i.next(r), e),
              () => es(i, n, () => i.complete(), e),
              (r) => es(i, n, () => i.error(r), e)
            )
          );
        });
      }
      function TM(n, e = 0) {
        return gn((t, i) => {
          i.add(n.schedule(() => t.subscribe(i), e));
        });
      }
      function IM(n, e) {
        if (!n) throw new Error('Iterable cannot be null');
        return new Mt((t) => {
          es(t, e, () => {
            const i = n[Symbol.asyncIterator]();
            es(
              t,
              e,
              () => {
                i.next().then((r) => {
                  r.done ? t.complete() : t.next(r.value);
                });
              },
              0,
              !0
            );
          });
        });
      }
      function Vs(n, e) {
        return e
          ? (function cz(n, e) {
              if (null != n) {
                if (_M(n))
                  return (function rz(n, e) {
                    return Bn(n).pipe(TM(e), DM(e));
                  })(n, e);
                if (jb(n))
                  return (function oz(n, e) {
                    return new Mt((t) => {
                      let i = 0;
                      return e.schedule(function () {
                        i === n.length
                          ? t.complete()
                          : (t.next(n[i++]), t.closed || this.schedule());
                      });
                    });
                  })(n, e);
                if (gM(n))
                  return (function sz(n, e) {
                    return Bn(n).pipe(TM(e), DM(e));
                  })(n, e);
                if (bM(n)) return IM(n, e);
                if (wM(n))
                  return (function az(n, e) {
                    return new Mt((t) => {
                      let i;
                      return (
                        es(t, e, () => {
                          (i = n[yM]()),
                            es(
                              t,
                              e,
                              () => {
                                let r, s;
                                try {
                                  ({ value: r, done: s } = i.next());
                                } catch (o) {
                                  return void t.error(o);
                                }
                                s ? t.complete() : t.next(r);
                              },
                              0,
                              !0
                            );
                        }),
                        () => ot(i?.return) && i.return()
                      );
                    });
                  })(n, e);
                if (CM(n))
                  return (function lz(n, e) {
                    return IM(EM(n), e);
                  })(n, e);
              }
              throw vM(n);
            })(n, e)
          : Bn(n);
      }
      function Ro(...n) {
        const e = Jc(n),
          t = (function iz(n, e) {
            return 'number' == typeof zb(n) ? n.pop() : e;
          })(n, 1 / 0),
          i = n;
        return i.length ? (1 === i.length ? Bn(i[0]) : AM(t)(Vs(i, e))) : Af;
      }
      function ts(...n) {
        return Vs(n, Jc(n));
      }
      function Ub(n = {}) {
        const {
          connector: e = () => new Le(),
          resetOnError: t = !0,
          resetOnComplete: i = !0,
          resetOnRefCountZero: r = !0,
        } = n;
        return (s) => {
          let o,
            a,
            l,
            c = 0,
            u = !1,
            h = !1;
          const f = () => {
              a?.unsubscribe(), (a = void 0);
            },
            p = () => {
              f(), (o = l = void 0), (u = h = !1);
            },
            m = () => {
              const g = o;
              p(), g?.unsubscribe();
            };
          return gn((g, w) => {
            c++, !h && !u && f();
            const y = (l = l ?? e());
            w.add(() => {
              c--, 0 === c && !h && !u && (a = $b(m, r));
            }),
              y.subscribe(w),
              !o &&
                c > 0 &&
                ((o = new Zc({
                  next: (E) => y.next(E),
                  error: (E) => {
                    (h = !0), f(), (a = $b(p, t, E)), y.error(E);
                  },
                  complete: () => {
                    (u = !0), f(), (a = $b(p, i)), y.complete();
                  },
                })),
                Bn(g).subscribe(o));
          })(s);
        };
      }
      function $b(n, e, ...t) {
        if (!0 === e) return void n();
        if (!1 === e) return;
        const i = new Zc({
          next: () => {
            i.unsubscribe(), n();
          },
        });
        return Bn(e(...t)).subscribe(i);
      }
      function Gb(n, e) {
        return gn((t, i) => {
          let r = null,
            s = 0,
            o = !1;
          const a = () => o && !r && i.complete();
          t.subscribe(
            hn(
              i,
              (l) => {
                r?.unsubscribe();
                let c = 0;
                const u = s++;
                Bn(n(l, u)).subscribe(
                  (r = hn(
                    i,
                    (h) => i.next(e ? e(l, h, u, c++) : h),
                    () => {
                      (r = null), a();
                    }
                  ))
                );
              },
              () => {
                (o = !0), a();
              }
            )
          );
        });
      }
      function Sf(n, e = Xa) {
        return (
          (n = n ?? dz),
          gn((t, i) => {
            let r,
              s = !0;
            t.subscribe(
              hn(i, (o) => {
                const a = e(o);
                (s || !n(r, a)) && ((s = !1), (r = a), i.next(o));
              })
            );
          })
        );
      }
      function dz(n, e) {
        return n === e;
      }
      function pt(n) {
        for (let e in n) if (n[e] === pt) return e;
        throw Error('Could not find renamed property on target object.');
      }
      function Mf(n, e) {
        for (const t in e)
          e.hasOwnProperty(t) && !n.hasOwnProperty(t) && (n[t] = e[t]);
      }
      function nn(n) {
        if ('string' == typeof n) return n;
        if (Array.isArray(n)) return '[' + n.map(nn).join(', ') + ']';
        if (null == n) return '' + n;
        if (n.overriddenName) return `${n.overriddenName}`;
        if (n.name) return `${n.name}`;
        const e = n.toString();
        if (null == e) return '' + e;
        const t = e.indexOf('\n');
        return -1 === t ? e : e.substring(0, t);
      }
      function qb(n, e) {
        return null == n || '' === n
          ? null === e
            ? ''
            : e
          : null == e || '' === e
          ? n
          : n + ' ' + e;
      }
      const uz = pt({ __forward_ref__: pt });
      function mt(n) {
        return (
          (n.__forward_ref__ = mt),
          (n.toString = function () {
            return nn(this());
          }),
          n
        );
      }
      function be(n) {
        return Xb(n) ? n() : n;
      }
      function Xb(n) {
        return (
          'function' == typeof n &&
          n.hasOwnProperty(uz) &&
          n.__forward_ref__ === mt
        );
      }
      function Yb(n) {
        return n && !!n.ɵproviders;
      }
      const kM = 'https://g.co/ng/security#xss';
      class N extends Error {
        constructor(e, t) {
          super(
            (function Df(n, e) {
              return `NG0${Math.abs(n)}${e ? ': ' + e : ''}`;
            })(e, t)
          ),
            (this.code = e);
        }
      }
      function ve(n) {
        return 'string' == typeof n ? n : null == n ? '' : String(n);
      }
      function Tf(n, e) {
        throw new N(-201, !1);
      }
      function Hi(n, e) {
        null == n &&
          (function lt(n, e, t, i) {
            throw new Error(
              `ASSERTION ERROR: ${n}` +
                (null == i ? '' : ` [Expected=> ${t} ${i} ${e} <=Actual]`)
            );
          })(e, n, null, '!=');
      }
      function ee(n) {
        return {
          token: n.token,
          providedIn: n.providedIn || null,
          factory: n.factory,
          value: void 0,
        };
      }
      function qe(n) {
        return { providers: n.providers || [], imports: n.imports || [] };
      }
      function If(n) {
        return PM(n, kf) || PM(n, FM);
      }
      function PM(n, e) {
        return n.hasOwnProperty(e) ? n[e] : null;
      }
      function RM(n) {
        return n && (n.hasOwnProperty(Kb) || n.hasOwnProperty(bz))
          ? n[Kb]
          : null;
      }
      const kf = pt({ ɵprov: pt }),
        Kb = pt({ ɵinj: pt }),
        FM = pt({ ngInjectableDef: pt }),
        bz = pt({ ngInjectorDef: pt });
      var me = (() => (
        ((me = me || {})[(me.Default = 0)] = 'Default'),
        (me[(me.Host = 1)] = 'Host'),
        (me[(me.Self = 2)] = 'Self'),
        (me[(me.SkipSelf = 4)] = 'SkipSelf'),
        (me[(me.Optional = 8)] = 'Optional'),
        me
      ))();
      let Zb;
      function Jn(n) {
        const e = Zb;
        return (Zb = n), e;
      }
      function LM(n, e, t) {
        const i = If(n);
        return i && 'root' == i.providedIn
          ? void 0 === i.value
            ? (i.value = i.factory())
            : i.value
          : t & me.Optional
          ? null
          : void 0 !== e
          ? e
          : void Tf(nn(n));
      }
      const yt = (() =>
          (typeof globalThis < 'u' && globalThis) ||
          (typeof global < 'u' && global) ||
          (typeof window < 'u' && window) ||
          (typeof self < 'u' &&
            typeof WorkerGlobalScope < 'u' &&
            self instanceof WorkerGlobalScope &&
            self))(),
        ed = {},
        Qb = '__NG_DI_FLAG__',
        Pf = 'ngTempTokenPath',
        yz = /\n/gm,
        NM = '__source';
      let Ya;
      function Hs(n) {
        const e = Ya;
        return (Ya = n), e;
      }
      function Cz(n, e = me.Default) {
        if (void 0 === Ya) throw new N(-203, !1);
        return null === Ya
          ? LM(n, void 0, e)
          : Ya.get(n, e & me.Optional ? null : void 0, e);
      }
      function L(n, e = me.Default) {
        return (
          (function OM() {
            return Zb;
          })() || Cz
        )(be(n), e);
      }
      function Te(n, e = me.Default) {
        return L(n, Rf(e));
      }
      function Rf(n) {
        return typeof n > 'u' || 'number' == typeof n
          ? n
          : 0 |
              (n.optional && 8) |
              (n.host && 1) |
              (n.self && 2) |
              (n.skipSelf && 4);
      }
      function Jb(n) {
        const e = [];
        for (let t = 0; t < n.length; t++) {
          const i = be(n[t]);
          if (Array.isArray(i)) {
            if (0 === i.length) throw new N(900, !1);
            let r,
              s = me.Default;
            for (let o = 0; o < i.length; o++) {
              const a = i[o],
                l = xz(a);
              'number' == typeof l
                ? -1 === l
                  ? (r = a.token)
                  : (s |= l)
                : (r = a);
            }
            e.push(L(r, s));
          } else e.push(L(i));
        }
        return e;
      }
      function td(n, e) {
        return (n[Qb] = e), (n.prototype[Qb] = e), n;
      }
      function xz(n) {
        return n[Qb];
      }
      function ns(n) {
        return { toString: n }.toString();
      }
      var Cr = (() => (
          ((Cr = Cr || {})[(Cr.OnPush = 0)] = 'OnPush'),
          (Cr[(Cr.Default = 1)] = 'Default'),
          Cr
        ))(),
        ei = (() => {
          return (
            ((n = ei || (ei = {}))[(n.Emulated = 0)] = 'Emulated'),
            (n[(n.None = 2)] = 'None'),
            (n[(n.ShadowDom = 3)] = 'ShadowDom'),
            ei
          );
          var n;
        })();
      const xr = {},
        et = [],
        Ff = pt({ ɵcmp: pt }),
        ev = pt({ ɵdir: pt }),
        tv = pt({ ɵpipe: pt }),
        BM = pt({ ɵmod: pt }),
        is = pt({ ɵfac: pt }),
        nd = pt({ __NG_ELEMENT_ID__: pt }),
        HM = pt({ __NG_ENV_ID__: pt });
      function WM(n, e, t) {
        let i = n.length;
        for (;;) {
          const r = n.indexOf(e, t);
          if (-1 === r) return r;
          if (0 === r || n.charCodeAt(r - 1) <= 32) {
            const s = e.length;
            if (r + s === i || n.charCodeAt(r + s) <= 32) return r;
          }
          t = r + 1;
        }
      }
      function nv(n, e, t) {
        let i = 0;
        for (; i < t.length; ) {
          const r = t[i];
          if ('number' == typeof r) {
            if (0 !== r) break;
            i++;
            const s = t[i++],
              o = t[i++],
              a = t[i++];
            n.setAttribute(e, o, a, s);
          } else {
            const s = r,
              o = t[++i];
            zM(s) ? n.setProperty(e, s, o) : n.setAttribute(e, s, o), i++;
          }
        }
        return i;
      }
      function jM(n) {
        return 3 === n || 4 === n || 6 === n;
      }
      function zM(n) {
        return 64 === n.charCodeAt(0);
      }
      function id(n, e) {
        if (null !== e && 0 !== e.length)
          if (null === n || 0 === n.length) n = e.slice();
          else {
            let t = -1;
            for (let i = 0; i < e.length; i++) {
              const r = e[i];
              'number' == typeof r
                ? (t = r)
                : 0 === t ||
                  UM(n, t, r, null, -1 === t || 2 === t ? e[++i] : null);
            }
          }
        return n;
      }
      function UM(n, e, t, i, r) {
        let s = 0,
          o = n.length;
        if (-1 === e) o = -1;
        else
          for (; s < n.length; ) {
            const a = n[s++];
            if ('number' == typeof a) {
              if (a === e) {
                o = -1;
                break;
              }
              if (a > e) {
                o = s - 1;
                break;
              }
            }
          }
        for (; s < n.length; ) {
          const a = n[s];
          if ('number' == typeof a) break;
          if (a === t) {
            if (null === i) return void (null !== r && (n[s + 1] = r));
            if (i === n[s + 1]) return void (n[s + 2] = r);
          }
          s++, null !== i && s++, null !== r && s++;
        }
        -1 !== o && (n.splice(o, 0, e), (s = o + 1)),
          n.splice(s++, 0, t),
          null !== i && n.splice(s++, 0, i),
          null !== r && n.splice(s++, 0, r);
      }
      const $M = 'ng-template';
      function Mz(n, e, t) {
        let i = 0,
          r = !0;
        for (; i < n.length; ) {
          let s = n[i++];
          if ('string' == typeof s && r) {
            const o = n[i++];
            if (t && 'class' === s && -1 !== WM(o.toLowerCase(), e, 0))
              return !0;
          } else {
            if (1 === s) {
              for (; i < n.length && 'string' == typeof (s = n[i++]); )
                if (s.toLowerCase() === e) return !0;
              return !1;
            }
            'number' == typeof s && (r = !1);
          }
        }
        return !1;
      }
      function GM(n) {
        return 4 === n.type && n.value !== $M;
      }
      function Dz(n, e, t) {
        return e === (4 !== n.type || t ? n.value : $M);
      }
      function Tz(n, e, t) {
        let i = 4;
        const r = n.attrs || [],
          s = (function Pz(n) {
            for (let e = 0; e < n.length; e++) if (jM(n[e])) return e;
            return n.length;
          })(r);
        let o = !1;
        for (let a = 0; a < e.length; a++) {
          const l = e[a];
          if ('number' != typeof l) {
            if (!o)
              if (4 & i) {
                if (
                  ((i = 2 | (1 & i)),
                  ('' !== l && !Dz(n, l, t)) || ('' === l && 1 === e.length))
                ) {
                  if (Qi(i)) return !1;
                  o = !0;
                }
              } else {
                const c = 8 & i ? l : e[++a];
                if (8 & i && null !== n.attrs) {
                  if (!Mz(n.attrs, c, t)) {
                    if (Qi(i)) return !1;
                    o = !0;
                  }
                  continue;
                }
                const h = Iz(8 & i ? 'class' : l, r, GM(n), t);
                if (-1 === h) {
                  if (Qi(i)) return !1;
                  o = !0;
                  continue;
                }
                if ('' !== c) {
                  let f;
                  f = h > s ? '' : r[h + 1].toLowerCase();
                  const p = 8 & i ? f : null;
                  if ((p && -1 !== WM(p, c, 0)) || (2 & i && c !== f)) {
                    if (Qi(i)) return !1;
                    o = !0;
                  }
                }
              }
          } else {
            if (!o && !Qi(i) && !Qi(l)) return !1;
            if (o && Qi(l)) continue;
            (o = !1), (i = l | (1 & i));
          }
        }
        return Qi(i) || o;
      }
      function Qi(n) {
        return 0 == (1 & n);
      }
      function Iz(n, e, t, i) {
        if (null === e) return -1;
        let r = 0;
        if (i || !t) {
          let s = !1;
          for (; r < e.length; ) {
            const o = e[r];
            if (o === n) return r;
            if (3 === o || 6 === o) s = !0;
            else {
              if (1 === o || 2 === o) {
                let a = e[++r];
                for (; 'string' == typeof a; ) a = e[++r];
                continue;
              }
              if (4 === o) break;
              if (0 === o) {
                r += 4;
                continue;
              }
            }
            r += s ? 1 : 2;
          }
          return -1;
        }
        return (function Rz(n, e) {
          let t = n.indexOf(4);
          if (t > -1)
            for (t++; t < n.length; ) {
              const i = n[t];
              if ('number' == typeof i) return -1;
              if (i === e) return t;
              t++;
            }
          return -1;
        })(e, n);
      }
      function qM(n, e, t = !1) {
        for (let i = 0; i < e.length; i++) if (Tz(n, e[i], t)) return !0;
        return !1;
      }
      function Fz(n, e) {
        e: for (let t = 0; t < e.length; t++) {
          const i = e[t];
          if (n.length === i.length) {
            for (let r = 0; r < n.length; r++) if (n[r] !== i[r]) continue e;
            return !0;
          }
        }
        return !1;
      }
      function XM(n, e) {
        return n ? ':not(' + e.trim() + ')' : e;
      }
      function Oz(n) {
        let e = n[0],
          t = 1,
          i = 2,
          r = '',
          s = !1;
        for (; t < n.length; ) {
          let o = n[t];
          if ('string' == typeof o)
            if (2 & i) {
              const a = n[++t];
              r += '[' + o + (a.length > 0 ? '="' + a + '"' : '') + ']';
            } else 8 & i ? (r += '.' + o) : 4 & i && (r += ' ' + o);
          else
            '' !== r && !Qi(o) && ((e += XM(s, r)), (r = '')),
              (i = o),
              (s = s || !Qi(i));
          t++;
        }
        return '' !== r && (e += XM(s, r)), e;
      }
      function _n(n) {
        return ns(() => {
          const e = KM(n),
            t = {
              ...e,
              decls: n.decls,
              vars: n.vars,
              template: n.template,
              consts: n.consts || null,
              ngContentSelectors: n.ngContentSelectors,
              onPush: n.changeDetection === Cr.OnPush,
              directiveDefs: null,
              pipeDefs: null,
              dependencies: (e.standalone && n.dependencies) || null,
              getStandaloneInjector: null,
              signals: n.signals ?? !1,
              data: n.data || {},
              encapsulation: n.encapsulation || ei.Emulated,
              styles: n.styles || et,
              _: null,
              schemas: n.schemas || null,
              tView: null,
              id: '',
            };
          ZM(t);
          const i = n.dependencies;
          return (
            (t.directiveDefs = Of(i, !1)),
            (t.pipeDefs = Of(i, !0)),
            (t.id = (function zz(n) {
              let e = 0;
              const t = [
                n.selectors,
                n.ngContentSelectors,
                n.hostVars,
                n.hostAttrs,
                n.consts,
                n.vars,
                n.decls,
                n.encapsulation,
                n.standalone,
                n.signals,
                n.exportAs,
                JSON.stringify(n.inputs),
                JSON.stringify(n.outputs),
                Object.getOwnPropertyNames(n.type.prototype),
                !!n.contentQueries,
                !!n.viewQuery,
              ].join('|');
              for (const r of t) e = (Math.imul(31, e) + r.charCodeAt(0)) << 0;
              return (e += 2147483648), 'c' + e;
            })(t)),
            t
          );
        });
      }
      function Bz(n) {
        return it(n) || Sn(n);
      }
      function Hz(n) {
        return null !== n;
      }
      function Ze(n) {
        return ns(() => ({
          type: n.type,
          bootstrap: n.bootstrap || et,
          declarations: n.declarations || et,
          imports: n.imports || et,
          exports: n.exports || et,
          transitiveCompileScopes: null,
          schemas: n.schemas || null,
          id: n.id || null,
        }));
      }
      function YM(n, e) {
        if (null == n) return xr;
        const t = {};
        for (const i in n)
          if (n.hasOwnProperty(i)) {
            let r = n[i],
              s = r;
            Array.isArray(r) && ((s = r[1]), (r = r[0])),
              (t[r] = i),
              e && (e[r] = s);
          }
        return t;
      }
      function J(n) {
        return ns(() => {
          const e = KM(n);
          return ZM(e), e;
        });
      }
      function ti(n) {
        return {
          type: n.type,
          name: n.name,
          factory: null,
          pure: !1 !== n.pure,
          standalone: !0 === n.standalone,
          onDestroy: n.type.prototype.ngOnDestroy || null,
        };
      }
      function it(n) {
        return n[Ff] || null;
      }
      function Sn(n) {
        return n[ev] || null;
      }
      function ni(n) {
        return n[tv] || null;
      }
      function KM(n) {
        const e = {};
        return {
          type: n.type,
          providersResolver: null,
          factory: null,
          hostBindings: n.hostBindings || null,
          hostVars: n.hostVars || 0,
          hostAttrs: n.hostAttrs || null,
          contentQueries: n.contentQueries || null,
          declaredInputs: e,
          inputTransforms: null,
          inputConfig: n.inputs || xr,
          exportAs: n.exportAs || null,
          standalone: !0 === n.standalone,
          signals: !0 === n.signals,
          selectors: n.selectors || et,
          viewQuery: n.viewQuery || null,
          features: n.features || null,
          setInput: null,
          findHostDirectiveDefs: null,
          hostDirectives: null,
          inputs: YM(n.inputs, e),
          outputs: YM(n.outputs),
        };
      }
      function ZM(n) {
        n.features?.forEach((e) => e(n));
      }
      function Of(n, e) {
        if (!n) return null;
        const t = e ? ni : Bz;
        return () =>
          ('function' == typeof n ? n() : n).map((i) => t(i)).filter(Hz);
      }
      const rn = 0,
        Z = 1,
        Ce = 2,
        It = 3,
        Ji = 4,
        sd = 5,
        Mn = 6,
        Ka = 7,
        qt = 8,
        Za = 9,
        Fo = 10,
        xe = 11,
        od = 12,
        QM = 13,
        Qa = 14,
        Xt = 15,
        ad = 16,
        Ja = 17,
        Ar = 18,
        ld = 19,
        JM = 20,
        Ws = 21,
        rs = 22,
        Lf = 23,
        Nf = 24,
        ze = 25,
        iv = 1,
        eD = 2,
        Sr = 7,
        el = 9,
        Dn = 11;
      function Si(n) {
        return Array.isArray(n) && 'object' == typeof n[iv];
      }
      function ii(n) {
        return Array.isArray(n) && !0 === n[iv];
      }
      function rv(n) {
        return 0 != (4 & n.flags);
      }
      function Oo(n) {
        return n.componentOffset > -1;
      }
      function Bf(n) {
        return 1 == (1 & n.flags);
      }
      function er(n) {
        return !!n.template;
      }
      function sv(n) {
        return 0 != (512 & n[Ce]);
      }
      function Lo(n, e) {
        return n.hasOwnProperty(is) ? n[is] : null;
      }
      let Yz =
          yt.WeakRef ??
          class Xz {
            constructor(e) {
              this.ref = e;
            }
            deref() {
              return this.ref;
            }
          },
        Zz = 0,
        Mr = null,
        Hf = !1;
      function fn(n) {
        const e = Mr;
        return (Mr = n), e;
      }
      class sD {
        constructor() {
          (this.id = Zz++),
            (this.ref = (function Kz(n) {
              return new Yz(n);
            })(this)),
            (this.producers = new Map()),
            (this.consumers = new Map()),
            (this.trackingVersion = 0),
            (this.valueVersion = 0);
        }
        consumerPollProducersForChange() {
          for (const [e, t] of this.producers) {
            const i = t.producerNode.deref();
            if (void 0 !== i && t.atTrackingVersion === this.trackingVersion) {
              if (i.producerPollStatus(t.seenValueVersion)) return !0;
            } else this.producers.delete(e), i?.consumers.delete(this.id);
          }
          return !1;
        }
        producerMayHaveChanged() {
          const e = Hf;
          Hf = !0;
          try {
            for (const [t, i] of this.consumers) {
              const r = i.consumerNode.deref();
              void 0 !== r && r.trackingVersion === i.atTrackingVersion
                ? r.onConsumerDependencyMayHaveChanged()
                : (this.consumers.delete(t), r?.producers.delete(this.id));
            }
          } finally {
            Hf = e;
          }
        }
        producerAccessed() {
          if (Hf) throw new Error('');
          if (null === Mr) return;
          let e = Mr.producers.get(this.id);
          void 0 === e
            ? ((e = {
                consumerNode: Mr.ref,
                producerNode: this.ref,
                seenValueVersion: this.valueVersion,
                atTrackingVersion: Mr.trackingVersion,
              }),
              Mr.producers.set(this.id, e),
              this.consumers.set(Mr.id, e))
            : ((e.seenValueVersion = this.valueVersion),
              (e.atTrackingVersion = Mr.trackingVersion));
        }
        get hasProducers() {
          return this.producers.size > 0;
        }
        get producerUpdatesAllowed() {
          return !1 !== Mr?.consumerAllowSignalWrites;
        }
        producerPollStatus(e) {
          return (
            this.valueVersion !== e ||
            (this.onProducerUpdateValueVersion(), this.valueVersion !== e)
          );
        }
      }
      let oD = null;
      const lD = () => {};
      class tU extends sD {
        constructor(e, t, i) {
          super(),
            (this.watch = e),
            (this.schedule = t),
            (this.dirty = !1),
            (this.cleanupFn = lD),
            (this.registerOnCleanup = (r) => {
              this.cleanupFn = r;
            }),
            (this.consumerAllowSignalWrites = i);
        }
        notify() {
          this.dirty || this.schedule(this), (this.dirty = !0);
        }
        onConsumerDependencyMayHaveChanged() {
          this.notify();
        }
        onProducerUpdateValueVersion() {}
        run() {
          if (
            ((this.dirty = !1),
            0 !== this.trackingVersion &&
              !this.consumerPollProducersForChange())
          )
            return;
          const e = fn(this);
          this.trackingVersion++;
          try {
            this.cleanupFn(),
              (this.cleanupFn = lD),
              this.watch(this.registerOnCleanup);
          } finally {
            fn(e);
          }
        }
        cleanup() {
          this.cleanupFn();
        }
      }
      class nU {
        constructor(e, t, i) {
          (this.previousValue = e),
            (this.currentValue = t),
            (this.firstChange = i);
        }
        isFirstChange() {
          return this.firstChange;
        }
      }
      function ri() {
        return cD;
      }
      function cD(n) {
        return n.type.prototype.ngOnChanges && (n.setInput = rU), iU;
      }
      function iU() {
        const n = uD(this),
          e = n?.current;
        if (e) {
          const t = n.previous;
          if (t === xr) n.previous = e;
          else for (let i in e) t[i] = e[i];
          (n.current = null), this.ngOnChanges(e);
        }
      }
      function rU(n, e, t, i) {
        const r = this.declaredInputs[t],
          s =
            uD(n) ||
            (function sU(n, e) {
              return (n[dD] = e);
            })(n, { previous: xr, current: null }),
          o = s.current || (s.current = {}),
          a = s.previous,
          l = a[r];
        (o[r] = new nU(l && l.currentValue, e, a === xr)), (n[i] = e);
      }
      ri.ngInherit = !0;
      const dD = '__ngSimpleChanges__';
      function uD(n) {
        return n[dD] || null;
      }
      const Dr = function (n, e, t) {},
        hD = 'svg';
      function At(n) {
        for (; Array.isArray(n); ) n = n[rn];
        return n;
      }
      function zf(n, e) {
        return At(e[n]);
      }
      function si(n, e) {
        return At(e[n.index]);
      }
      function pD(n, e) {
        return n.data[e];
      }
      function tl(n, e) {
        return n[e];
      }
      function Mi(n, e) {
        const t = e[n];
        return Si(t) ? t : t[rn];
      }
      function js(n, e) {
        return null == e ? null : n[e];
      }
      function mD(n) {
        n[Ja] = 0;
      }
      function hU(n) {
        1024 & n[Ce] || ((n[Ce] |= 1024), _D(n, 1));
      }
      function gD(n) {
        1024 & n[Ce] && ((n[Ce] &= -1025), _D(n, -1));
      }
      function _D(n, e) {
        let t = n[It];
        if (null === t) return;
        t[sd] += e;
        let i = t;
        for (
          t = t[It];
          null !== t && ((1 === e && 1 === i[sd]) || (-1 === e && 0 === i[sd]));

        )
          (t[sd] += e), (i = t), (t = t[It]);
      }
      const fe = {
        lFrame: DD(null),
        bindingsEnabled: !0,
        skipHydrationRootTNode: null,
      };
      function yD() {
        return fe.bindingsEnabled;
      }
      function nl() {
        return null !== fe.skipHydrationRootTNode;
      }
      function H() {
        return fe.lFrame.lView;
      }
      function Xe() {
        return fe.lFrame.tView;
      }
      function Hn(n) {
        return (fe.lFrame.contextLView = n), n[qt];
      }
      function Wn(n) {
        return (fe.lFrame.contextLView = null), n;
      }
      function bn() {
        let n = wD();
        for (; null !== n && 64 === n.type; ) n = n.parent;
        return n;
      }
      function wD() {
        return fe.lFrame.currentTNode;
      }
      function Tr(n, e) {
        const t = fe.lFrame;
        (t.currentTNode = n), (t.isParent = e);
      }
      function uv() {
        return fe.lFrame.isParent;
      }
      function hv() {
        fe.lFrame.isParent = !1;
      }
      function il() {
        return fe.lFrame.bindingIndex++;
      }
      function os(n) {
        const e = fe.lFrame,
          t = e.bindingIndex;
        return (e.bindingIndex = e.bindingIndex + n), t;
      }
      function xU(n, e) {
        const t = fe.lFrame;
        (t.bindingIndex = t.bindingRootIndex = n), fv(e);
      }
      function fv(n) {
        fe.lFrame.currentDirectiveIndex = n;
      }
      function pv(n) {
        const e = fe.lFrame.currentDirectiveIndex;
        return -1 === e ? null : n[e];
      }
      function AD() {
        return fe.lFrame.currentQueryIndex;
      }
      function mv(n) {
        fe.lFrame.currentQueryIndex = n;
      }
      function SU(n) {
        const e = n[Z];
        return 2 === e.type ? e.declTNode : 1 === e.type ? n[Mn] : null;
      }
      function SD(n, e, t) {
        if (t & me.SkipSelf) {
          let r = e,
            s = n;
          for (
            ;
            !((r = r.parent),
            null !== r ||
              t & me.Host ||
              ((r = SU(s)), null === r || ((s = s[Qa]), 10 & r.type)));

          );
          if (null === r) return !1;
          (e = r), (n = s);
        }
        const i = (fe.lFrame = MD());
        return (i.currentTNode = e), (i.lView = n), !0;
      }
      function gv(n) {
        const e = MD(),
          t = n[Z];
        (fe.lFrame = e),
          (e.currentTNode = t.firstChild),
          (e.lView = n),
          (e.tView = t),
          (e.contextLView = n),
          (e.bindingIndex = t.bindingStartIndex),
          (e.inI18n = !1);
      }
      function MD() {
        const n = fe.lFrame,
          e = null === n ? null : n.child;
        return null === e ? DD(n) : e;
      }
      function DD(n) {
        const e = {
          currentTNode: null,
          isParent: !0,
          lView: null,
          tView: null,
          selectedIndex: -1,
          contextLView: null,
          elementDepthCount: 0,
          currentNamespace: null,
          currentDirectiveIndex: -1,
          bindingRootIndex: -1,
          bindingIndex: -1,
          currentQueryIndex: 0,
          parent: n,
          child: null,
          inI18n: !1,
        };
        return null !== n && (n.child = e), e;
      }
      function TD() {
        const n = fe.lFrame;
        return (
          (fe.lFrame = n.parent), (n.currentTNode = null), (n.lView = null), n
        );
      }
      const ID = TD;
      function _v() {
        const n = TD();
        (n.isParent = !0),
          (n.tView = null),
          (n.selectedIndex = -1),
          (n.contextLView = null),
          (n.elementDepthCount = 0),
          (n.currentDirectiveIndex = -1),
          (n.currentNamespace = null),
          (n.bindingRootIndex = -1),
          (n.bindingIndex = -1),
          (n.currentQueryIndex = 0);
      }
      function zn() {
        return fe.lFrame.selectedIndex;
      }
      function No(n) {
        fe.lFrame.selectedIndex = n;
      }
      function kt() {
        const n = fe.lFrame;
        return pD(n.tView, n.selectedIndex);
      }
      function Wi() {
        fe.lFrame.currentNamespace = hD;
      }
      function tr() {
        !(function IU() {
          fe.lFrame.currentNamespace = null;
        })();
      }
      let PD = !0;
      function Uf() {
        return PD;
      }
      function zs(n) {
        PD = n;
      }
      function $f(n, e) {
        for (let t = e.directiveStart, i = e.directiveEnd; t < i; t++) {
          const s = n.data[t].type.prototype,
            {
              ngAfterContentInit: o,
              ngAfterContentChecked: a,
              ngAfterViewInit: l,
              ngAfterViewChecked: c,
              ngOnDestroy: u,
            } = s;
          o && (n.contentHooks ??= []).push(-t, o),
            a &&
              ((n.contentHooks ??= []).push(t, a),
              (n.contentCheckHooks ??= []).push(t, a)),
            l && (n.viewHooks ??= []).push(-t, l),
            c &&
              ((n.viewHooks ??= []).push(t, c),
              (n.viewCheckHooks ??= []).push(t, c)),
            null != u && (n.destroyHooks ??= []).push(t, u);
        }
      }
      function Gf(n, e, t) {
        RD(n, e, 3, t);
      }
      function qf(n, e, t, i) {
        (3 & n[Ce]) === t && RD(n, e, t, i);
      }
      function bv(n, e) {
        let t = n[Ce];
        (3 & t) === e && ((t &= 8191), (t += 1), (n[Ce] = t));
      }
      function RD(n, e, t, i) {
        const s = i ?? -1,
          o = e.length - 1;
        let a = 0;
        for (let l = void 0 !== i ? 65535 & n[Ja] : 0; l < o; l++)
          if ('number' == typeof e[l + 1]) {
            if (((a = e[l]), null != i && a >= i)) break;
          } else
            e[l] < 0 && (n[Ja] += 65536),
              (a < s || -1 == s) &&
                (PU(n, t, e, l), (n[Ja] = (4294901760 & n[Ja]) + l + 2)),
              l++;
      }
      function FD(n, e) {
        Dr(4, n, e);
        const t = fn(null);
        try {
          e.call(n);
        } finally {
          fn(t), Dr(5, n, e);
        }
      }
      function PU(n, e, t, i) {
        const r = t[i] < 0,
          s = t[i + 1],
          a = n[r ? -t[i] : t[i]];
        r
          ? n[Ce] >> 13 < n[Ja] >> 16 &&
            (3 & n[Ce]) === e &&
            ((n[Ce] += 8192), FD(a, s))
          : FD(a, s);
      }
      const rl = -1;
      class ud {
        constructor(e, t, i) {
          (this.factory = e),
            (this.resolving = !1),
            (this.canSeeViewProviders = t),
            (this.injectImpl = i);
        }
      }
      function OD(n) {
        return n !== rl;
      }
      function Xf(n) {
        return 32767 & n;
      }
      function Yf(n, e) {
        let t = (function LU(n) {
            return n >> 16;
          })(n),
          i = e;
        for (; t > 0; ) (i = i[Qa]), t--;
        return i;
      }
      let yv = !0;
      function Kf(n) {
        const e = yv;
        return (yv = n), e;
      }
      const LD = 255,
        ND = 5;
      let NU = 0;
      const Ir = {};
      function Zf(n, e) {
        const t = VD(n, e);
        if (-1 !== t) return t;
        const i = e[Z];
        i.firstCreatePass &&
          ((n.injectorIndex = e.length),
          wv(i.data, n),
          wv(e, null),
          wv(i.blueprint, null));
        const r = Ev(n, e),
          s = n.injectorIndex;
        if (OD(r)) {
          const o = Xf(r),
            a = Yf(r, e),
            l = a[Z].data;
          for (let c = 0; c < 8; c++) e[s + c] = a[o + c] | l[o + c];
        }
        return (e[s + 8] = r), s;
      }
      function wv(n, e) {
        n.push(0, 0, 0, 0, 0, 0, 0, 0, e);
      }
      function VD(n, e) {
        return -1 === n.injectorIndex ||
          (n.parent && n.parent.injectorIndex === n.injectorIndex) ||
          null === e[n.injectorIndex + 8]
          ? -1
          : n.injectorIndex;
      }
      function Ev(n, e) {
        if (n.parent && -1 !== n.parent.injectorIndex)
          return n.parent.injectorIndex;
        let t = 0,
          i = null,
          r = e;
        for (; null !== r; ) {
          if (((i = $D(r)), null === i)) return rl;
          if ((t++, (r = r[Qa]), -1 !== i.injectorIndex))
            return i.injectorIndex | (t << 16);
        }
        return rl;
      }
      function Cv(n, e, t) {
        !(function VU(n, e, t) {
          let i;
          'string' == typeof t
            ? (i = t.charCodeAt(0) || 0)
            : t.hasOwnProperty(nd) && (i = t[nd]),
            null == i && (i = t[nd] = NU++);
          const r = i & LD;
          e.data[n + (r >> ND)] |= 1 << r;
        })(n, e, t);
      }
      function BD(n, e, t) {
        if (t & me.Optional || void 0 !== n) return n;
        Tf();
      }
      function HD(n, e, t, i) {
        if (
          (t & me.Optional && void 0 === i && (i = null),
          !(t & (me.Self | me.Host)))
        ) {
          const r = n[Za],
            s = Jn(void 0);
          try {
            return r ? r.get(e, i, t & me.Optional) : LM(e, i, t & me.Optional);
          } finally {
            Jn(s);
          }
        }
        return BD(i, 0, t);
      }
      function WD(n, e, t, i = me.Default, r) {
        if (null !== n) {
          if (2048 & e[Ce] && !(i & me.Self)) {
            const o = (function zU(n, e, t, i, r) {
              let s = n,
                o = e;
              for (
                ;
                null !== s && null !== o && 2048 & o[Ce] && !(512 & o[Ce]);

              ) {
                const a = jD(s, o, t, i | me.Self, Ir);
                if (a !== Ir) return a;
                let l = s.parent;
                if (!l) {
                  const c = o[JM];
                  if (c) {
                    const u = c.get(t, Ir, i);
                    if (u !== Ir) return u;
                  }
                  (l = $D(o)), (o = o[Qa]);
                }
                s = l;
              }
              return r;
            })(n, e, t, i, Ir);
            if (o !== Ir) return o;
          }
          const s = jD(n, e, t, i, Ir);
          if (s !== Ir) return s;
        }
        return HD(e, t, i, r);
      }
      function jD(n, e, t, i, r) {
        const s = (function WU(n) {
          if ('string' == typeof n) return n.charCodeAt(0) || 0;
          const e = n.hasOwnProperty(nd) ? n[nd] : void 0;
          return 'number' == typeof e ? (e >= 0 ? e & LD : jU) : e;
        })(t);
        if ('function' == typeof s) {
          if (!SD(e, n, i)) return i & me.Host ? BD(r, 0, i) : HD(e, t, i, r);
          try {
            const o = s(i);
            if (null != o || i & me.Optional) return o;
            Tf();
          } finally {
            ID();
          }
        } else if ('number' == typeof s) {
          let o = null,
            a = VD(n, e),
            l = rl,
            c = i & me.Host ? e[Xt][Mn] : null;
          for (
            (-1 === a || i & me.SkipSelf) &&
            ((l = -1 === a ? Ev(n, e) : e[a + 8]),
            l !== rl && UD(i, !1)
              ? ((o = e[Z]), (a = Xf(l)), (e = Yf(l, e)))
              : (a = -1));
            -1 !== a;

          ) {
            const u = e[Z];
            if (zD(s, a, u.data)) {
              const h = HU(a, e, t, o, i, c);
              if (h !== Ir) return h;
            }
            (l = e[a + 8]),
              l !== rl && UD(i, e[Z].data[a + 8] === c) && zD(s, a, e)
                ? ((o = u), (a = Xf(l)), (e = Yf(l, e)))
                : (a = -1);
          }
        }
        return r;
      }
      function HU(n, e, t, i, r, s) {
        const o = e[Z],
          a = o.data[n + 8],
          u = Qf(
            a,
            o,
            t,
            null == i ? Oo(a) && yv : i != o && 0 != (3 & a.type),
            r & me.Host && s === a
          );
        return null !== u ? Vo(e, o, u, a) : Ir;
      }
      function Qf(n, e, t, i, r) {
        const s = n.providerIndexes,
          o = e.data,
          a = 1048575 & s,
          l = n.directiveStart,
          u = s >> 20,
          f = r ? a + u : n.directiveEnd;
        for (let p = i ? a : a + u; p < f; p++) {
          const m = o[p];
          if ((p < l && t === m) || (p >= l && m.type === t)) return p;
        }
        if (r) {
          const p = o[l];
          if (p && er(p) && p.type === t) return l;
        }
        return null;
      }
      function Vo(n, e, t, i) {
        let r = n[t];
        const s = e.data;
        if (
          (function RU(n) {
            return n instanceof ud;
          })(r)
        ) {
          const o = r;
          o.resolving &&
            (function hz(n, e) {
              const t = e ? `. Dependency path: ${e.join(' > ')} > ${n}` : '';
              throw new N(
                -200,
                `Circular dependency in DI detected for ${n}${t}`
              );
            })(
              (function at(n) {
                return 'function' == typeof n
                  ? n.name || n.toString()
                  : 'object' == typeof n &&
                    null != n &&
                    'function' == typeof n.type
                  ? n.type.name || n.type.toString()
                  : ve(n);
              })(s[t])
            );
          const a = Kf(o.canSeeViewProviders);
          o.resolving = !0;
          const l = o.injectImpl ? Jn(o.injectImpl) : null;
          SD(n, i, me.Default);
          try {
            (r = n[t] = o.factory(void 0, s, n, i)),
              e.firstCreatePass &&
                t >= i.directiveStart &&
                (function kU(n, e, t) {
                  const {
                    ngOnChanges: i,
                    ngOnInit: r,
                    ngDoCheck: s,
                  } = e.type.prototype;
                  if (i) {
                    const o = cD(e);
                    (t.preOrderHooks ??= []).push(n, o),
                      (t.preOrderCheckHooks ??= []).push(n, o);
                  }
                  r && (t.preOrderHooks ??= []).push(0 - n, r),
                    s &&
                      ((t.preOrderHooks ??= []).push(n, s),
                      (t.preOrderCheckHooks ??= []).push(n, s));
                })(t, s[t], e);
          } finally {
            null !== l && Jn(l), Kf(a), (o.resolving = !1), ID();
          }
        }
        return r;
      }
      function zD(n, e, t) {
        return !!(t[e + (n >> ND)] & (1 << n));
      }
      function UD(n, e) {
        return !(n & me.Self || (n & me.Host && e));
      }
      class sl {
        constructor(e, t) {
          (this._tNode = e), (this._lView = t);
        }
        get(e, t, i) {
          return WD(this._tNode, this._lView, e, Rf(i), t);
        }
      }
      function jU() {
        return new sl(bn(), H());
      }
      function pn(n) {
        return ns(() => {
          const e = n.prototype.constructor,
            t = e[is] || xv(e),
            i = Object.prototype;
          let r = Object.getPrototypeOf(n.prototype).constructor;
          for (; r && r !== i; ) {
            const s = r[is] || xv(r);
            if (s && s !== t) return s;
            r = Object.getPrototypeOf(r);
          }
          return (s) => new s();
        });
      }
      function xv(n) {
        return Xb(n)
          ? () => {
              const e = xv(be(n));
              return e && e();
            }
          : Lo(n);
      }
      function $D(n) {
        const e = n[Z],
          t = e.type;
        return 2 === t ? e.declTNode : 1 === t ? n[Mn] : null;
      }
      function Bo(n) {
        return (function BU(n, e) {
          if ('class' === e) return n.classes;
          if ('style' === e) return n.styles;
          const t = n.attrs;
          if (t) {
            const i = t.length;
            let r = 0;
            for (; r < i; ) {
              const s = t[r];
              if (jM(s)) break;
              if (0 === s) r += 2;
              else if ('number' == typeof s)
                for (r++; r < i && 'string' == typeof t[r]; ) r++;
              else {
                if (s === e) return t[r + 1];
                r += 2;
              }
            }
          }
          return null;
        })(bn(), n);
      }
      const al = '__parameters__';
      function cl(n, e, t) {
        return ns(() => {
          const i = (function Av(n) {
            return function (...t) {
              if (n) {
                const i = n(...t);
                for (const r in i) this[r] = i[r];
              }
            };
          })(e);
          function r(...s) {
            if (this instanceof r) return i.apply(this, s), this;
            const o = new r(...s);
            return (a.annotation = o), a;
            function a(l, c, u) {
              const h = l.hasOwnProperty(al)
                ? l[al]
                : Object.defineProperty(l, al, { value: [] })[al];
              for (; h.length <= u; ) h.push(null);
              return (h[u] = h[u] || []).push(o), l;
            }
          }
          return (
            t && (r.prototype = Object.create(t.prototype)),
            (r.prototype.ngMetadataName = n),
            (r.annotationCls = r),
            r
          );
        });
      }
      function pd(n, e) {
        n.forEach((t) => (Array.isArray(t) ? pd(t, e) : e(t)));
      }
      function qD(n, e, t) {
        e >= n.length ? n.push(t) : n.splice(e, 0, t);
      }
      function Jf(n, e) {
        return e >= n.length - 1 ? n.pop() : n.splice(e, 1)[0];
      }
      function md(n, e) {
        const t = [];
        for (let i = 0; i < n; i++) t.push(e);
        return t;
      }
      function Di(n, e, t) {
        let i = dl(n, e);
        return (
          i >= 0
            ? (n[1 | i] = t)
            : ((i = ~i),
              (function XU(n, e, t, i) {
                let r = n.length;
                if (r == e) n.push(t, i);
                else if (1 === r) n.push(i, n[0]), (n[0] = t);
                else {
                  for (r--, n.push(n[r - 1], n[r]); r > e; )
                    (n[r] = n[r - 2]), r--;
                  (n[e] = t), (n[e + 1] = i);
                }
              })(n, i, e, t)),
          i
        );
      }
      function Sv(n, e) {
        const t = dl(n, e);
        if (t >= 0) return n[1 | t];
      }
      function dl(n, e) {
        return (function XD(n, e, t) {
          let i = 0,
            r = n.length >> t;
          for (; r !== i; ) {
            const s = i + ((r - i) >> 1),
              o = n[s << t];
            if (e === o) return s << t;
            o > e ? (r = s) : (i = s + 1);
          }
          return ~(r << t);
        })(n, e, 1);
      }
      const ul = td(cl('Optional'), 8),
        tp = td(cl('SkipSelf'), 4);
      function sp(n) {
        return 128 == (128 & n.flags);
      }
      var oi = (() => (
        ((oi = oi || {})[(oi.Important = 1)] = 'Important'),
        (oi[(oi.DashCase = 2)] = 'DashCase'),
        oi
      ))();
      const Pv = new Map();
      let b3 = 0;
      const Fv = '__ngContext__';
      function Tn(n, e) {
        Si(e)
          ? ((n[Fv] = e[ld]),
            (function y3(n) {
              Pv.set(n[ld], n);
            })(e))
          : (n[Fv] = e);
      }
      let Ov;
      function Lv(n, e) {
        return Ov(n, e);
      }
      function bd(n) {
        const e = n[It];
        return ii(e) ? e[It] : e;
      }
      function pT(n) {
        return gT(n[od]);
      }
      function mT(n) {
        return gT(n[Ji]);
      }
      function gT(n) {
        for (; null !== n && !ii(n); ) n = n[Ji];
        return n;
      }
      function pl(n, e, t, i, r) {
        if (null != i) {
          let s,
            o = !1;
          ii(i) ? (s = i) : Si(i) && ((o = !0), (i = i[rn]));
          const a = At(i);
          0 === n && null !== t
            ? null == r
              ? wT(e, t, a)
              : Ho(e, t, a, r || null, !0)
            : 1 === n && null !== t
            ? Ho(e, t, a, r || null, !0)
            : 2 === n
            ? (function up(n, e, t) {
                const i = cp(n, e);
                i &&
                  (function B3(n, e, t, i) {
                    n.removeChild(e, t, i);
                  })(n, i, e, t);
              })(e, a, o)
            : 3 === n && e.destroyNode(a),
            null != s &&
              (function j3(n, e, t, i, r) {
                const s = t[Sr];
                s !== At(t) && pl(e, n, i, s, r);
                for (let a = Dn; a < t.length; a++) {
                  const l = t[a];
                  yd(l[Z], l, n, e, i, s);
                }
              })(e, n, s, t, r);
        }
      }
      function lp(n, e, t) {
        return n.createElement(e, t);
      }
      function bT(n, e) {
        const t = n[el],
          i = t.indexOf(e);
        gD(e), t.splice(i, 1);
      }
      function Vv(n, e) {
        if (n.length <= Dn) return;
        const t = Dn + e,
          i = n[t];
        if (i) {
          const r = i[ad];
          null !== r && r !== n && bT(r, i), e > 0 && (n[t - 1][Ji] = i[Ji]);
          const s = Jf(n, Dn + e);
          !(function k3(n, e) {
            yd(n, e, e[xe], 2, null, null), (e[rn] = null), (e[Mn] = null);
          })(i[Z], i);
          const o = s[Ar];
          null !== o && o.detachView(s[Z]),
            (i[It] = null),
            (i[Ji] = null),
            (i[Ce] &= -129);
        }
        return i;
      }
      function vT(n, e) {
        if (!(256 & e[Ce])) {
          const t = e[xe];
          e[Lf]?.destroy(),
            e[Nf]?.destroy(),
            t.destroyNode && yd(n, e, t, 3, null, null),
            (function F3(n) {
              let e = n[od];
              if (!e) return Bv(n[Z], n);
              for (; e; ) {
                let t = null;
                if (Si(e)) t = e[od];
                else {
                  const i = e[Dn];
                  i && (t = i);
                }
                if (!t) {
                  for (; e && !e[Ji] && e !== n; )
                    Si(e) && Bv(e[Z], e), (e = e[It]);
                  null === e && (e = n), Si(e) && Bv(e[Z], e), (t = e && e[Ji]);
                }
                e = t;
              }
            })(e);
        }
      }
      function Bv(n, e) {
        if (!(256 & e[Ce])) {
          (e[Ce] &= -129),
            (e[Ce] |= 256),
            (function V3(n, e) {
              let t;
              if (null != n && null != (t = n.destroyHooks))
                for (let i = 0; i < t.length; i += 2) {
                  const r = e[t[i]];
                  if (!(r instanceof ud)) {
                    const s = t[i + 1];
                    if (Array.isArray(s))
                      for (let o = 0; o < s.length; o += 2) {
                        const a = r[s[o]],
                          l = s[o + 1];
                        Dr(4, a, l);
                        try {
                          l.call(a);
                        } finally {
                          Dr(5, a, l);
                        }
                      }
                    else {
                      Dr(4, r, s);
                      try {
                        s.call(r);
                      } finally {
                        Dr(5, r, s);
                      }
                    }
                  }
                }
            })(n, e),
            (function N3(n, e) {
              const t = n.cleanup,
                i = e[Ka];
              if (null !== t)
                for (let s = 0; s < t.length - 1; s += 2)
                  if ('string' == typeof t[s]) {
                    const o = t[s + 3];
                    o >= 0 ? i[o]() : i[-o].unsubscribe(), (s += 2);
                  } else t[s].call(i[t[s + 1]]);
              null !== i && (e[Ka] = null);
              const r = e[Ws];
              if (null !== r) {
                e[Ws] = null;
                for (let s = 0; s < r.length; s++) (0, r[s])();
              }
            })(n, e),
            1 === e[Z].type && e[xe].destroy();
          const t = e[ad];
          if (null !== t && ii(e[It])) {
            t !== e[It] && bT(t, e);
            const i = e[Ar];
            null !== i && i.detachView(n);
          }
          !(function w3(n) {
            Pv.delete(n[ld]);
          })(e);
        }
      }
      function Hv(n, e, t) {
        return (function yT(n, e, t) {
          let i = e;
          for (; null !== i && 40 & i.type; ) i = (e = i).parent;
          if (null === i) return t[rn];
          {
            const { componentOffset: r } = i;
            if (r > -1) {
              const { encapsulation: s } = n.data[i.directiveStart + r];
              if (s === ei.None || s === ei.Emulated) return null;
            }
            return si(i, t);
          }
        })(n, e.parent, t);
      }
      function Ho(n, e, t, i, r) {
        n.insertBefore(e, t, i, r);
      }
      function wT(n, e, t) {
        n.appendChild(e, t);
      }
      function ET(n, e, t, i, r) {
        null !== i ? Ho(n, e, t, i, r) : wT(n, e, t);
      }
      function cp(n, e) {
        return n.parentNode(e);
      }
      function CT(n, e, t) {
        return AT(n, e, t);
      }
      let Wv,
        hp,
        $v,
        AT = function xT(n, e, t) {
          return 40 & n.type ? si(n, t) : null;
        };
      function dp(n, e, t, i) {
        const r = Hv(n, i, e),
          s = e[xe],
          a = CT(i.parent || e[Mn], i, e);
        if (null != r)
          if (Array.isArray(t))
            for (let l = 0; l < t.length; l++) ET(s, r, t[l], a, !1);
          else ET(s, r, t, a, !1);
        void 0 !== Wv && Wv(s, i, e, t, r);
      }
      function vd(n, e) {
        if (null !== e) {
          const t = e.type;
          if (3 & t) return si(e, n);
          if (4 & t) return jv(-1, n[e.index]);
          if (8 & t) {
            const i = e.child;
            if (null !== i) return vd(n, i);
            {
              const r = n[e.index];
              return ii(r) ? jv(-1, r) : At(r);
            }
          }
          if (32 & t) return Lv(e, n)() || At(n[e.index]);
          {
            const i = MT(n, e);
            return null !== i
              ? Array.isArray(i)
                ? i[0]
                : vd(bd(n[Xt]), i)
              : vd(n, e.next);
          }
        }
        return null;
      }
      function MT(n, e) {
        return null !== e ? n[Xt][Mn].projection[e.projection] : null;
      }
      function jv(n, e) {
        const t = Dn + n + 1;
        if (t < e.length) {
          const i = e[t],
            r = i[Z].firstChild;
          if (null !== r) return vd(i, r);
        }
        return e[Sr];
      }
      function zv(n, e, t, i, r, s, o) {
        for (; null != t; ) {
          const a = i[t.index],
            l = t.type;
          if (
            (o && 0 === e && (a && Tn(At(a), i), (t.flags |= 2)),
            32 != (32 & t.flags))
          )
            if (8 & l) zv(n, e, t.child, i, r, s, !1), pl(e, n, r, a, s);
            else if (32 & l) {
              const c = Lv(t, i);
              let u;
              for (; (u = c()); ) pl(e, n, r, u, s);
              pl(e, n, r, a, s);
            } else 16 & l ? TT(n, e, i, t, r, s) : pl(e, n, r, a, s);
          t = o ? t.projectionNext : t.next;
        }
      }
      function yd(n, e, t, i, r, s) {
        zv(t, i, n.firstChild, e, r, s, !1);
      }
      function TT(n, e, t, i, r, s) {
        const o = t[Xt],
          l = o[Mn].projection[i.projection];
        if (Array.isArray(l))
          for (let c = 0; c < l.length; c++) pl(e, n, r, l[c], s);
        else {
          let c = l;
          const u = o[It];
          sp(i) && (c.flags |= 128), zv(n, e, c, u, r, s, !0);
        }
      }
      function IT(n, e, t) {
        '' === t
          ? n.removeAttribute(e, 'class')
          : n.setAttribute(e, 'class', t);
      }
      function kT(n, e, t) {
        const { mergedAttrs: i, classes: r, styles: s } = t;
        null !== i && nv(n, e, i),
          null !== r && IT(n, e, r),
          null !== s &&
            (function U3(n, e, t) {
              n.setAttribute(e, 'style', t);
            })(n, e, s);
      }
      function ml(n) {
        return (
          (function Uv() {
            if (void 0 === hp && ((hp = null), yt.trustedTypes))
              try {
                hp = yt.trustedTypes.createPolicy('angular', {
                  createHTML: (n) => n,
                  createScript: (n) => n,
                  createScriptURL: (n) => n,
                });
              } catch {}
            return hp;
          })()?.createHTML(n) || n
        );
      }
      class Wo {
        constructor(e) {
          this.changingThisBreaksApplicationSecurity = e;
        }
        toString() {
          return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${kM})`;
        }
      }
      class Y3 extends Wo {
        getTypeName() {
          return 'HTML';
        }
      }
      class K3 extends Wo {
        getTypeName() {
          return 'Style';
        }
      }
      class Z3 extends Wo {
        getTypeName() {
          return 'Script';
        }
      }
      class Q3 extends Wo {
        getTypeName() {
          return 'URL';
        }
      }
      class J3 extends Wo {
        getTypeName() {
          return 'ResourceURL';
        }
      }
      function Ti(n) {
        return n instanceof Wo ? n.changingThisBreaksApplicationSecurity : n;
      }
      function kr(n, e) {
        const t = (function e$(n) {
          return (n instanceof Wo && n.getTypeName()) || null;
        })(n);
        if (null != t && t !== e) {
          if ('ResourceURL' === t && 'URL' === e) return !0;
          throw new Error(`Required a safe ${e}, got a ${t} (see ${kM})`);
        }
        return t === e;
      }
      class o$ {
        constructor(e) {
          this.inertDocumentHelper = e;
        }
        getInertBodyElement(e) {
          e = '<body><remove></remove>' + e;
          try {
            const t = new window.DOMParser().parseFromString(
              ml(e),
              'text/html'
            ).body;
            return null === t
              ? this.inertDocumentHelper.getInertBodyElement(e)
              : (t.removeChild(t.firstChild), t);
          } catch {
            return null;
          }
        }
      }
      class a$ {
        constructor(e) {
          (this.defaultDoc = e),
            (this.inertDocument =
              this.defaultDoc.implementation.createHTMLDocument(
                'sanitization-inert'
              ));
        }
        getInertBodyElement(e) {
          const t = this.inertDocument.createElement('template');
          return (t.innerHTML = ml(e)), t;
        }
      }
      const c$ = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
      function pp(n) {
        return (n = String(n)).match(c$) ? n : 'unsafe:' + n;
      }
      function as(n) {
        const e = {};
        for (const t of n.split(',')) e[t] = !0;
        return e;
      }
      function Ed(...n) {
        const e = {};
        for (const t of n)
          for (const i in t) t.hasOwnProperty(i) && (e[i] = !0);
        return e;
      }
      const LT = as('area,br,col,hr,img,wbr'),
        NT = as('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'),
        VT = as('rp,rt'),
        qv = Ed(
          LT,
          Ed(
            NT,
            as(
              'address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'
            )
          ),
          Ed(
            VT,
            as(
              'a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'
            )
          ),
          Ed(VT, NT)
        ),
        Xv = as('background,cite,href,itemtype,longdesc,poster,src,xlink:href'),
        BT = Ed(
          Xv,
          as(
            'abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width'
          ),
          as(
            'aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext'
          )
        ),
        d$ = as('script,style,template');
      class u$ {
        constructor() {
          (this.sanitizedSomething = !1), (this.buf = []);
        }
        sanitizeChildren(e) {
          let t = e.firstChild,
            i = !0;
          for (; t; )
            if (
              (t.nodeType === Node.ELEMENT_NODE
                ? (i = this.startElement(t))
                : t.nodeType === Node.TEXT_NODE
                ? this.chars(t.nodeValue)
                : (this.sanitizedSomething = !0),
              i && t.firstChild)
            )
              t = t.firstChild;
            else
              for (; t; ) {
                t.nodeType === Node.ELEMENT_NODE && this.endElement(t);
                let r = this.checkClobberedElement(t, t.nextSibling);
                if (r) {
                  t = r;
                  break;
                }
                t = this.checkClobberedElement(t, t.parentNode);
              }
          return this.buf.join('');
        }
        startElement(e) {
          const t = e.nodeName.toLowerCase();
          if (!qv.hasOwnProperty(t))
            return (this.sanitizedSomething = !0), !d$.hasOwnProperty(t);
          this.buf.push('<'), this.buf.push(t);
          const i = e.attributes;
          for (let r = 0; r < i.length; r++) {
            const s = i.item(r),
              o = s.name,
              a = o.toLowerCase();
            if (!BT.hasOwnProperty(a)) {
              this.sanitizedSomething = !0;
              continue;
            }
            let l = s.value;
            Xv[a] && (l = pp(l)), this.buf.push(' ', o, '="', HT(l), '"');
          }
          return this.buf.push('>'), !0;
        }
        endElement(e) {
          const t = e.nodeName.toLowerCase();
          qv.hasOwnProperty(t) &&
            !LT.hasOwnProperty(t) &&
            (this.buf.push('</'), this.buf.push(t), this.buf.push('>'));
        }
        chars(e) {
          this.buf.push(HT(e));
        }
        checkClobberedElement(e, t) {
          if (
            t &&
            (e.compareDocumentPosition(t) &
              Node.DOCUMENT_POSITION_CONTAINED_BY) ===
              Node.DOCUMENT_POSITION_CONTAINED_BY
          )
            throw new Error(
              `Failed to sanitize html because the element is clobbered: ${e.outerHTML}`
            );
          return t;
        }
      }
      const h$ = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        f$ = /([^\#-~ |!])/g;
      function HT(n) {
        return n
          .replace(/&/g, '&amp;')
          .replace(h$, function (e) {
            return (
              '&#' +
              (1024 * (e.charCodeAt(0) - 55296) +
                (e.charCodeAt(1) - 56320) +
                65536) +
              ';'
            );
          })
          .replace(f$, function (e) {
            return '&#' + e.charCodeAt(0) + ';';
          })
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }
      let mp;
      function WT(n, e) {
        let t = null;
        try {
          mp =
            mp ||
            (function OT(n) {
              const e = new a$(n);
              return (function l$() {
                try {
                  return !!new window.DOMParser().parseFromString(
                    ml(''),
                    'text/html'
                  );
                } catch {
                  return !1;
                }
              })()
                ? new o$(e)
                : e;
            })(n);
          let i = e ? String(e) : '';
          t = mp.getInertBodyElement(i);
          let r = 5,
            s = i;
          do {
            if (0 === r)
              throw new Error(
                'Failed to sanitize html because the input is unstable'
              );
            r--, (i = s), (s = t.innerHTML), (t = mp.getInertBodyElement(i));
          } while (i !== s);
          return ml(new u$().sanitizeChildren(Yv(t) || t));
        } finally {
          if (t) {
            const i = Yv(t) || t;
            for (; i.firstChild; ) i.removeChild(i.firstChild);
          }
        }
      }
      function Yv(n) {
        return 'content' in n &&
          (function p$(n) {
            return (
              n.nodeType === Node.ELEMENT_NODE && 'TEMPLATE' === n.nodeName
            );
          })(n)
          ? n.content
          : null;
      }
      var rt = (() => (
        ((rt = rt || {})[(rt.NONE = 0)] = 'NONE'),
        (rt[(rt.HTML = 1)] = 'HTML'),
        (rt[(rt.STYLE = 2)] = 'STYLE'),
        (rt[(rt.SCRIPT = 3)] = 'SCRIPT'),
        (rt[(rt.URL = 4)] = 'URL'),
        (rt[(rt.RESOURCE_URL = 5)] = 'RESOURCE_URL'),
        rt
      ))();
      class j {
        constructor(e, t) {
          (this._desc = e),
            (this.ngMetadataName = 'InjectionToken'),
            (this.ɵprov = void 0),
            'number' == typeof t
              ? (this.__NG_ELEMENT_ID__ = t)
              : void 0 !== t &&
                (this.ɵprov = ee({
                  token: this,
                  providedIn: t.providedIn || 'root',
                  factory: t.factory,
                }));
        }
        get multi() {
          return this;
        }
        toString() {
          return `InjectionToken ${this._desc}`;
        }
      }
      const gp = new j('ENVIRONMENT_INITIALIZER'),
        UT = new j('INJECTOR', -1),
        $T = new j('INJECTOR_DEF_TYPES');
      class GT {
        get(e, t = ed) {
          if (t === ed) {
            const i = new Error(`NullInjectorError: No provider for ${nn(e)}!`);
            throw ((i.name = 'NullInjectorError'), i);
          }
          return t;
        }
      }
      function E$(...n) {
        return { ɵproviders: XT(0, n), ɵfromNgModule: !0 };
      }
      function XT(n, ...e) {
        const t = [],
          i = new Set();
        let r;
        return (
          pd(e, (s) => {
            const o = s;
            Kv(o, t, [], i) && ((r ||= []), r.push(o));
          }),
          void 0 !== r && YT(r, t),
          t
        );
      }
      function YT(n, e) {
        for (let t = 0; t < n.length; t++) {
          const { providers: r } = n[t];
          Zv(r, (s) => {
            e.push(s);
          });
        }
      }
      function Kv(n, e, t, i) {
        if (!(n = be(n))) return !1;
        let r = null,
          s = RM(n);
        const o = !s && it(n);
        if (s || o) {
          if (o && !o.standalone) return !1;
          r = n;
        } else {
          const l = n.ngModule;
          if (((s = RM(l)), !s)) return !1;
          r = l;
        }
        const a = i.has(r);
        if (o) {
          if (a) return !1;
          if ((i.add(r), o.dependencies)) {
            const l =
              'function' == typeof o.dependencies
                ? o.dependencies()
                : o.dependencies;
            for (const c of l) Kv(c, e, t, i);
          }
        } else {
          if (!s) return !1;
          {
            if (null != s.imports && !a) {
              let c;
              i.add(r);
              try {
                pd(s.imports, (u) => {
                  Kv(u, e, t, i) && ((c ||= []), c.push(u));
                });
              } finally {
              }
              void 0 !== c && YT(c, e);
            }
            if (!a) {
              const c = Lo(r) || (() => new r());
              e.push(
                { provide: r, useFactory: c, deps: et },
                { provide: $T, useValue: r, multi: !0 },
                { provide: gp, useValue: () => L(r), multi: !0 }
              );
            }
            const l = s.providers;
            null == l ||
              a ||
              Zv(l, (u) => {
                e.push(u);
              });
          }
        }
        return r !== n && void 0 !== n.providers;
      }
      function Zv(n, e) {
        for (let t of n)
          Yb(t) && (t = t.ɵproviders), Array.isArray(t) ? Zv(t, e) : e(t);
      }
      const C$ = pt({ provide: String, useValue: pt });
      function Qv(n) {
        return null !== n && 'object' == typeof n && C$ in n;
      }
      function jo(n) {
        return 'function' == typeof n;
      }
      const Jv = new j('Set Injector scope.'),
        _p = {},
        A$ = {};
      let ey;
      function bp() {
        return void 0 === ey && (ey = new GT()), ey;
      }
      class gl {}
      class ty extends gl {
        get destroyed() {
          return this._destroyed;
        }
        constructor(e, t, i, r) {
          super(),
            (this.parent = t),
            (this.source = i),
            (this.scopes = r),
            (this.records = new Map()),
            (this._ngOnDestroyHooks = new Set()),
            (this._onDestroyHooks = []),
            (this._destroyed = !1),
            iy(e, (o) => this.processProvider(o)),
            this.records.set(UT, _l(void 0, this)),
            r.has('environment') && this.records.set(gl, _l(void 0, this));
          const s = this.records.get(Jv);
          null != s && 'string' == typeof s.value && this.scopes.add(s.value),
            (this.injectorDefTypes = new Set(this.get($T.multi, et, me.Self)));
        }
        destroy() {
          this.assertNotDestroyed(), (this._destroyed = !0);
          try {
            for (const t of this._ngOnDestroyHooks) t.ngOnDestroy();
            const e = this._onDestroyHooks;
            this._onDestroyHooks = [];
            for (const t of e) t();
          } finally {
            this.records.clear(),
              this._ngOnDestroyHooks.clear(),
              this.injectorDefTypes.clear();
          }
        }
        onDestroy(e) {
          return (
            this.assertNotDestroyed(),
            this._onDestroyHooks.push(e),
            () => this.removeOnDestroy(e)
          );
        }
        runInContext(e) {
          this.assertNotDestroyed();
          const t = Hs(this),
            i = Jn(void 0);
          try {
            return e();
          } finally {
            Hs(t), Jn(i);
          }
        }
        get(e, t = ed, i = me.Default) {
          if ((this.assertNotDestroyed(), e.hasOwnProperty(HM)))
            return e[HM](this);
          i = Rf(i);
          const r = Hs(this),
            s = Jn(void 0);
          try {
            if (!(i & me.SkipSelf)) {
              let a = this.records.get(e);
              if (void 0 === a) {
                const l =
                  (function I$(n) {
                    return (
                      'function' == typeof n ||
                      ('object' == typeof n && n instanceof j)
                    );
                  })(e) && If(e);
                (a = l && this.injectableDefInScope(l) ? _l(ny(e), _p) : null),
                  this.records.set(e, a);
              }
              if (null != a) return this.hydrate(e, a);
            }
            return (i & me.Self ? bp() : this.parent).get(
              e,
              (t = i & me.Optional && t === ed ? null : t)
            );
          } catch (o) {
            if ('NullInjectorError' === o.name) {
              if (((o[Pf] = o[Pf] || []).unshift(nn(e)), r)) throw o;
              return (function Az(n, e, t, i) {
                const r = n[Pf];
                throw (
                  (e[NM] && r.unshift(e[NM]),
                  (n.message = (function Sz(n, e, t, i = null) {
                    n =
                      n && '\n' === n.charAt(0) && '\u0275' == n.charAt(1)
                        ? n.slice(2)
                        : n;
                    let r = nn(e);
                    if (Array.isArray(e)) r = e.map(nn).join(' -> ');
                    else if ('object' == typeof e) {
                      let s = [];
                      for (let o in e)
                        if (e.hasOwnProperty(o)) {
                          let a = e[o];
                          s.push(
                            o +
                              ':' +
                              ('string' == typeof a ? JSON.stringify(a) : nn(a))
                          );
                        }
                      r = `{${s.join(', ')}}`;
                    }
                    return `${t}${i ? '(' + i + ')' : ''}[${r}]: ${n.replace(
                      yz,
                      '\n  '
                    )}`;
                  })('\n' + n.message, r, t, i)),
                  (n.ngTokenPath = r),
                  (n[Pf] = null),
                  n)
                );
              })(o, e, 'R3InjectorError', this.source);
            }
            throw o;
          } finally {
            Jn(s), Hs(r);
          }
        }
        resolveInjectorInitializers() {
          const e = Hs(this),
            t = Jn(void 0);
          try {
            const i = this.get(gp.multi, et, me.Self);
            for (const r of i) r();
          } finally {
            Hs(e), Jn(t);
          }
        }
        toString() {
          const e = [],
            t = this.records;
          for (const i of t.keys()) e.push(nn(i));
          return `R3Injector[${e.join(', ')}]`;
        }
        assertNotDestroyed() {
          if (this._destroyed) throw new N(205, !1);
        }
        processProvider(e) {
          let t = jo((e = be(e))) ? e : be(e && e.provide);
          const i = (function M$(n) {
            return Qv(n) ? _l(void 0, n.useValue) : _l(QT(n), _p);
          })(e);
          if (jo(e) || !0 !== e.multi) this.records.get(t);
          else {
            let r = this.records.get(t);
            r ||
              ((r = _l(void 0, _p, !0)),
              (r.factory = () => Jb(r.multi)),
              this.records.set(t, r)),
              (t = e),
              r.multi.push(e);
          }
          this.records.set(t, i);
        }
        hydrate(e, t) {
          return (
            t.value === _p && ((t.value = A$), (t.value = t.factory())),
            'object' == typeof t.value &&
              t.value &&
              (function T$(n) {
                return (
                  null !== n &&
                  'object' == typeof n &&
                  'function' == typeof n.ngOnDestroy
                );
              })(t.value) &&
              this._ngOnDestroyHooks.add(t.value),
            t.value
          );
        }
        injectableDefInScope(e) {
          if (!e.providedIn) return !1;
          const t = be(e.providedIn);
          return 'string' == typeof t
            ? 'any' === t || this.scopes.has(t)
            : this.injectorDefTypes.has(t);
        }
        removeOnDestroy(e) {
          const t = this._onDestroyHooks.indexOf(e);
          -1 !== t && this._onDestroyHooks.splice(t, 1);
        }
      }
      function ny(n) {
        const e = If(n),
          t = null !== e ? e.factory : Lo(n);
        if (null !== t) return t;
        if (n instanceof j) throw new N(204, !1);
        if (n instanceof Function)
          return (function S$(n) {
            const e = n.length;
            if (e > 0) throw (md(e, '?'), new N(204, !1));
            const t = (function _z(n) {
              return (n && (n[kf] || n[FM])) || null;
            })(n);
            return null !== t ? () => t.factory(n) : () => new n();
          })(n);
        throw new N(204, !1);
      }
      function QT(n, e, t) {
        let i;
        if (jo(n)) {
          const r = be(n);
          return Lo(r) || ny(r);
        }
        if (Qv(n)) i = () => be(n.useValue);
        else if (
          (function ZT(n) {
            return !(!n || !n.useFactory);
          })(n)
        )
          i = () => n.useFactory(...Jb(n.deps || []));
        else if (
          (function KT(n) {
            return !(!n || !n.useExisting);
          })(n)
        )
          i = () => L(be(n.useExisting));
        else {
          const r = be(n && (n.useClass || n.provide));
          if (
            !(function D$(n) {
              return !!n.deps;
            })(n)
          )
            return Lo(r) || ny(r);
          i = () => new r(...Jb(n.deps));
        }
        return i;
      }
      function _l(n, e, t = !1) {
        return { factory: n, value: e, multi: t ? [] : void 0 };
      }
      function iy(n, e) {
        for (const t of n)
          Array.isArray(t) ? iy(t, e) : t && Yb(t) ? iy(t.ɵproviders, e) : e(t);
      }
      const xd = new j('AppId', { providedIn: 'root', factory: () => k$ }),
        k$ = 'ng',
        JT = new j('Platform Initializer'),
        zo = new j('Platform ID', {
          providedIn: 'platform',
          factory: () => 'unknown',
        }),
        Ii = new j('AnimationModuleType'),
        ry = new j('CSP nonce', {
          providedIn: 'root',
          factory: () =>
            (function wd() {
              if (void 0 !== $v) return $v;
              if (typeof document < 'u') return document;
              throw new N(210, !1);
            })()
              .body?.querySelector('[ngCspNonce]')
              ?.getAttribute('ngCspNonce') || null,
        });
      let tI = (n, e) => null;
      function nI(n, e) {
        return tI(n, e);
      }
      class H$ {}
      class sI {}
      class j$ {
        resolveComponentFactory(e) {
          throw (function W$(n) {
            const e = Error(`No component factory found for ${nn(n)}.`);
            return (e.ngComponent = n), e;
          })(e);
        }
      }
      let Dd = (() => {
        class n {}
        return (n.NULL = new j$()), n;
      })();
      function z$() {
        return bl(bn(), H());
      }
      function bl(n, e) {
        return new Ne(si(n, e));
      }
      let Ne = (() => {
        class n {
          constructor(t) {
            this.nativeElement = t;
          }
        }
        return (n.__NG_ELEMENT_ID__ = z$), n;
      })();
      function U$(n) {
        return n instanceof Ne ? n.nativeElement : n;
      }
      class Td {}
      let Uo = (() => {
          class n {}
          return (
            (n.__NG_ELEMENT_ID__ = () =>
              (function $$() {
                const n = H(),
                  t = Mi(bn().index, n);
                return (Si(t) ? t : n)[xe];
              })()),
            n
          );
        })(),
        G$ = (() => {
          class n {}
          return (
            (n.ɵprov = ee({
              token: n,
              providedIn: 'root',
              factory: () => null,
            })),
            n
          );
        })();
      class vl {
        constructor(e) {
          (this.full = e),
            (this.major = e.split('.')[0]),
            (this.minor = e.split('.')[1]),
            (this.patch = e.split('.').slice(2).join('.'));
        }
      }
      const q$ = new vl('16.1.0'),
        my = {};
      function Id(n) {
        for (; n; ) {
          n[Ce] |= 64;
          const e = bd(n);
          if (sv(n) && !e) return n;
          n = e;
        }
        return null;
      }
      function gy(n) {
        return n.ngOriginalError;
      }
      class Pr {
        constructor() {
          this._console = console;
        }
        handleError(e) {
          const t = this._findOriginalError(e);
          this._console.error('ERROR', e),
            t && this._console.error('ORIGINAL ERROR', t);
        }
        _findOriginalError(e) {
          let t = e && gy(e);
          for (; t && gy(t); ) t = gy(t);
          return t || null;
        }
      }
      const cI = new j('', { providedIn: 'root', factory: () => !1 });
      function dI(n) {
        return n.ownerDocument.defaultView;
      }
      class mI extends sD {
        constructor() {
          super(...arguments),
            (this.consumerAllowSignalWrites = !1),
            (this._lView = null);
        }
        set lView(e) {
          this._lView = e;
        }
        onConsumerDependencyMayHaveChanged() {
          Id(this._lView);
        }
        onProducerUpdateValueVersion() {}
        get hasReadASignal() {
          return this.hasProducers;
        }
        runInContext(e, t, i) {
          const r = fn(this);
          this.trackingVersion++;
          try {
            e(t, i);
          } finally {
            fn(r);
          }
        }
        destroy() {
          this.trackingVersion++;
        }
      }
      let xp = null;
      function gI() {
        return (xp ??= new mI()), xp;
      }
      function _I(n, e) {
        return n[e] ?? gI();
      }
      function bI(n, e) {
        const t = gI();
        t.hasReadASignal && ((n[e] = xp), (t.lView = n), (xp = new mI()));
      }
      const Ae = {};
      function Y(n) {
        vI(Xe(), H(), zn() + n, !1);
      }
      function vI(n, e, t, i) {
        if (!i)
          if (3 == (3 & e[Ce])) {
            const s = n.preOrderCheckHooks;
            null !== s && Gf(e, s, t);
          } else {
            const s = n.preOrderHooks;
            null !== s && qf(e, s, 0, t);
          }
        No(t);
      }
      function CI(n, e = null, t = null, i) {
        const r = xI(n, e, t, i);
        return r.resolveInjectorInitializers(), r;
      }
      function xI(n, e = null, t = null, i, r = new Set()) {
        const s = [t || et, E$(n)];
        return (
          (i = i || ('object' == typeof n ? void 0 : nn(n))),
          new ty(s, e || bp(), i || null, r)
        );
      }
      let nr = (() => {
        class n {
          static create(t, i) {
            if (Array.isArray(t)) return CI({ name: '' }, i, t, '');
            {
              const r = t.name ?? '';
              return CI({ name: r }, t.parent, t.providers, r);
            }
          }
        }
        return (
          (n.THROW_IF_NOT_FOUND = ed),
          (n.NULL = new GT()),
          (n.ɵprov = ee({ token: n, providedIn: 'any', factory: () => L(UT) })),
          (n.__NG_ELEMENT_ID__ = -1),
          n
        );
      })();
      function D(n, e = me.Default) {
        const t = H();
        return null === t ? L(n, e) : WD(bn(), t, be(n), e);
      }
      function wl() {
        throw new Error('invalid');
      }
      function Ap(n, e, t, i, r, s, o, a, l, c, u) {
        const h = e.blueprint.slice();
        return (
          (h[rn] = r),
          (h[Ce] = 140 | i),
          (null !== c || (n && 2048 & n[Ce])) && (h[Ce] |= 2048),
          mD(h),
          (h[It] = h[Qa] = n),
          (h[qt] = t),
          (h[Fo] = o || (n && n[Fo])),
          (h[xe] = a || (n && n[xe])),
          (h[Za] = l || (n && n[Za]) || null),
          (h[Mn] = s),
          (h[ld] = (function v3() {
            return b3++;
          })()),
          (h[rs] = u),
          (h[JM] = c),
          (h[Xt] = 2 == e.type ? n[Xt] : h),
          h
        );
      }
      function El(n, e, t, i, r) {
        let s = n.data[e];
        if (null === s)
          (s = (function _y(n, e, t, i, r) {
            const s = wD(),
              o = uv(),
              l = (n.data[e] = (function f4(n, e, t, i, r, s) {
                let o = e ? e.injectorIndex : -1,
                  a = 0;
                return (
                  nl() && (a |= 128),
                  {
                    type: t,
                    index: i,
                    insertBeforeIndex: null,
                    injectorIndex: o,
                    directiveStart: -1,
                    directiveEnd: -1,
                    directiveStylingLast: -1,
                    componentOffset: -1,
                    propertyBindings: null,
                    flags: a,
                    providerIndexes: 0,
                    value: r,
                    attrs: s,
                    mergedAttrs: null,
                    localNames: null,
                    initialInputs: void 0,
                    inputs: null,
                    outputs: null,
                    tView: null,
                    next: null,
                    prev: null,
                    projectionNext: null,
                    child: null,
                    parent: e,
                    projection: null,
                    styles: null,
                    stylesWithoutHost: null,
                    residualStyles: void 0,
                    classes: null,
                    classesWithoutHost: null,
                    residualClasses: void 0,
                    classBindings: 0,
                    styleBindings: 0,
                  }
                );
              })(0, o ? s : s && s.parent, t, e, i, r));
            return (
              null === n.firstChild && (n.firstChild = l),
              null !== s &&
                (o
                  ? null == s.child && null !== l.parent && (s.child = l)
                  : null === s.next && ((s.next = l), (l.prev = s))),
              l
            );
          })(n, e, t, i, r)),
            (function CU() {
              return fe.lFrame.inI18n;
            })() && (s.flags |= 32);
        else if (64 & s.type) {
          (s.type = t), (s.value = i), (s.attrs = r);
          const o = (function dd() {
            const n = fe.lFrame,
              e = n.currentTNode;
            return n.isParent ? e : e.parent;
          })();
          s.injectorIndex = null === o ? -1 : o.injectorIndex;
        }
        return Tr(s, !0), s;
      }
      function kd(n, e, t, i) {
        if (0 === t) return -1;
        const r = e.length;
        for (let s = 0; s < t; s++)
          e.push(i), n.blueprint.push(i), n.data.push(null);
        return r;
      }
      function AI(n, e, t, i, r) {
        const s = _I(e, Lf),
          o = zn(),
          a = 2 & i;
        try {
          if (
            (No(-1),
            a && e.length > ze && vI(n, e, ze, !1),
            Dr(a ? 2 : 0, r),
            a)
          )
            s.runInContext(t, i, r);
          else {
            const c = fn(null);
            try {
              t(i, r);
            } finally {
              fn(c);
            }
          }
        } finally {
          a && null === e[Lf] && bI(e, Lf), No(o), Dr(a ? 3 : 1, r);
        }
      }
      function by(n, e, t) {
        if (rv(e)) {
          const i = fn(null);
          try {
            const s = e.directiveEnd;
            for (let o = e.directiveStart; o < s; o++) {
              const a = n.data[o];
              a.contentQueries && a.contentQueries(1, t[o], o);
            }
          } finally {
            fn(i);
          }
        }
      }
      function vy(n, e, t) {
        yD() &&
          ((function y4(n, e, t, i) {
            const r = t.directiveStart,
              s = t.directiveEnd;
            Oo(t) &&
              (function M4(n, e, t) {
                const i = si(e, n),
                  r = SI(t);
                let o = 16;
                t.signals ? (o = 4096) : t.onPush && (o = 64);
                const a = Sp(
                  n,
                  Ap(
                    n,
                    r,
                    null,
                    o,
                    i,
                    e,
                    null,
                    n[Fo].rendererFactory.createRenderer(i, t),
                    null,
                    null,
                    null
                  )
                );
                n[e.index] = a;
              })(e, t, n.data[r + t.componentOffset]),
              n.firstCreatePass || Zf(t, e),
              Tn(i, e);
            const o = t.initialInputs;
            for (let a = r; a < s; a++) {
              const l = n.data[a],
                c = Vo(e, n, a, t);
              Tn(c, e),
                null !== o && D4(0, a - r, c, l, 0, o),
                er(l) && (Mi(t.index, e)[qt] = Vo(e, n, a, t));
            }
          })(n, e, t, si(t, e)),
          64 == (64 & t.flags) && kI(n, e, t));
      }
      function yy(n, e, t = si) {
        const i = e.localNames;
        if (null !== i) {
          let r = e.index + 1;
          for (let s = 0; s < i.length; s += 2) {
            const o = i[s + 1],
              a = -1 === o ? t(e, n) : n[o];
            n[r++] = a;
          }
        }
      }
      function SI(n) {
        const e = n.tView;
        return null === e || e.incompleteFirstPass
          ? (n.tView = wy(
              1,
              null,
              n.template,
              n.decls,
              n.vars,
              n.directiveDefs,
              n.pipeDefs,
              n.viewQuery,
              n.schemas,
              n.consts,
              n.id
            ))
          : e;
      }
      function wy(n, e, t, i, r, s, o, a, l, c, u) {
        const h = ze + i,
          f = h + r,
          p = (function a4(n, e) {
            const t = [];
            for (let i = 0; i < e; i++) t.push(i < n ? null : Ae);
            return t;
          })(h, f),
          m = 'function' == typeof c ? c() : c;
        return (p[Z] = {
          type: n,
          blueprint: p,
          template: t,
          queries: null,
          viewQuery: a,
          declTNode: e,
          data: p.slice().fill(null, h),
          bindingStartIndex: h,
          expandoStartIndex: f,
          hostBindingOpCodes: null,
          firstCreatePass: !0,
          firstUpdatePass: !0,
          staticViewQueries: !1,
          staticContentQueries: !1,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: 'function' == typeof s ? s() : s,
          pipeRegistry: 'function' == typeof o ? o() : o,
          firstChild: null,
          schemas: l,
          consts: m,
          incompleteFirstPass: !1,
          ssrId: u,
        });
      }
      let MI = (n) => null;
      function DI(n, e, t, i) {
        for (let r in n)
          if (n.hasOwnProperty(r)) {
            t = null === t ? {} : t;
            const s = n[r];
            null === i
              ? TI(t, e, r, s)
              : i.hasOwnProperty(r) && TI(t, e, i[r], s);
          }
        return t;
      }
      function TI(n, e, t, i) {
        n.hasOwnProperty(t) ? n[t].push(e, i) : (n[t] = [e, i]);
      }
      function ki(n, e, t, i, r, s, o, a) {
        const l = si(e, t);
        let u,
          c = e.inputs;
        !a && null != c && (u = c[i])
          ? (Sy(n, t, u, i, r),
            Oo(e) &&
              (function g4(n, e) {
                const t = Mi(e, n);
                16 & t[Ce] || (t[Ce] |= 64);
              })(t, e.index))
          : 3 & e.type &&
            ((i = (function m4(n) {
              return 'class' === n
                ? 'className'
                : 'for' === n
                ? 'htmlFor'
                : 'formaction' === n
                ? 'formAction'
                : 'innerHtml' === n
                ? 'innerHTML'
                : 'readonly' === n
                ? 'readOnly'
                : 'tabindex' === n
                ? 'tabIndex'
                : n;
            })(i)),
            (r = null != o ? o(r, e.value || '', i) : r),
            s.setProperty(l, i, r));
      }
      function Ey(n, e, t, i) {
        if (yD()) {
          const r = null === i ? null : { '': -1 },
            s = (function E4(n, e) {
              const t = n.directiveRegistry;
              let i = null,
                r = null;
              if (t)
                for (let s = 0; s < t.length; s++) {
                  const o = t[s];
                  if (qM(e, o.selectors, !1))
                    if ((i || (i = []), er(o)))
                      if (null !== o.findHostDirectiveDefs) {
                        const a = [];
                        (r = r || new Map()),
                          o.findHostDirectiveDefs(o, a, r),
                          i.unshift(...a, o),
                          Cy(n, e, a.length);
                      } else i.unshift(o), Cy(n, e, 0);
                    else
                      (r = r || new Map()),
                        o.findHostDirectiveDefs?.(o, i, r),
                        i.push(o);
                }
              return null === i ? null : [i, r];
            })(n, t);
          let o, a;
          null === s ? (o = a = null) : ([o, a] = s),
            null !== o && II(n, e, t, o, r, a),
            r &&
              (function C4(n, e, t) {
                if (e) {
                  const i = (n.localNames = []);
                  for (let r = 0; r < e.length; r += 2) {
                    const s = t[e[r + 1]];
                    if (null == s) throw new N(-301, !1);
                    i.push(e[r], s);
                  }
                }
              })(t, i, r);
        }
        t.mergedAttrs = id(t.mergedAttrs, t.attrs);
      }
      function II(n, e, t, i, r, s) {
        for (let c = 0; c < i.length; c++) Cv(Zf(t, e), n, i[c].type);
        !(function A4(n, e, t) {
          (n.flags |= 1),
            (n.directiveStart = e),
            (n.directiveEnd = e + t),
            (n.providerIndexes = e);
        })(t, n.data.length, i.length);
        for (let c = 0; c < i.length; c++) {
          const u = i[c];
          u.providersResolver && u.providersResolver(u);
        }
        let o = !1,
          a = !1,
          l = kd(n, e, i.length, null);
        for (let c = 0; c < i.length; c++) {
          const u = i[c];
          (t.mergedAttrs = id(t.mergedAttrs, u.hostAttrs)),
            S4(n, t, e, l, u),
            x4(l, u, r),
            null !== u.contentQueries && (t.flags |= 4),
            (null !== u.hostBindings ||
              null !== u.hostAttrs ||
              0 !== u.hostVars) &&
              (t.flags |= 64);
          const h = u.type.prototype;
          !o &&
            (h.ngOnChanges || h.ngOnInit || h.ngDoCheck) &&
            ((n.preOrderHooks ??= []).push(t.index), (o = !0)),
            !a &&
              (h.ngOnChanges || h.ngDoCheck) &&
              ((n.preOrderCheckHooks ??= []).push(t.index), (a = !0)),
            l++;
        }
        !(function p4(n, e, t) {
          const r = e.directiveEnd,
            s = n.data,
            o = e.attrs,
            a = [];
          let l = null,
            c = null;
          for (let u = e.directiveStart; u < r; u++) {
            const h = s[u],
              f = t ? t.get(h) : null,
              m = f ? f.outputs : null;
            (l = DI(h.inputs, u, l, f ? f.inputs : null)),
              (c = DI(h.outputs, u, c, m));
            const g = null === l || null === o || GM(e) ? null : T4(l, u, o);
            a.push(g);
          }
          null !== l &&
            (l.hasOwnProperty('class') && (e.flags |= 8),
            l.hasOwnProperty('style') && (e.flags |= 16)),
            (e.initialInputs = a),
            (e.inputs = l),
            (e.outputs = c);
        })(n, t, s);
      }
      function kI(n, e, t) {
        const i = t.directiveStart,
          r = t.directiveEnd,
          s = t.index,
          o = (function AU() {
            return fe.lFrame.currentDirectiveIndex;
          })();
        try {
          No(s);
          for (let a = i; a < r; a++) {
            const l = n.data[a],
              c = e[a];
            fv(a),
              (null !== l.hostBindings ||
                0 !== l.hostVars ||
                null !== l.hostAttrs) &&
                w4(l, c);
          }
        } finally {
          No(-1), fv(o);
        }
      }
      function w4(n, e) {
        null !== n.hostBindings && n.hostBindings(1, e);
      }
      function Cy(n, e, t) {
        (e.componentOffset = t), (n.components ??= []).push(e.index);
      }
      function x4(n, e, t) {
        if (t) {
          if (e.exportAs)
            for (let i = 0; i < e.exportAs.length; i++) t[e.exportAs[i]] = n;
          er(e) && (t[''] = n);
        }
      }
      function S4(n, e, t, i, r) {
        n.data[i] = r;
        const s = r.factory || (r.factory = Lo(r.type)),
          o = new ud(s, er(r), D);
        (n.blueprint[i] = o),
          (t[i] = o),
          (function b4(n, e, t, i, r) {
            const s = r.hostBindings;
            if (s) {
              let o = n.hostBindingOpCodes;
              null === o && (o = n.hostBindingOpCodes = []);
              const a = ~e.index;
              (function v4(n) {
                let e = n.length;
                for (; e > 0; ) {
                  const t = n[--e];
                  if ('number' == typeof t && t < 0) return t;
                }
                return 0;
              })(o) != a && o.push(a),
                o.push(t, i, s);
            }
          })(n, e, i, kd(n, t, r.hostVars, Ae), r);
      }
      function Rr(n, e, t, i, r, s) {
        const o = si(n, e);
        !(function xy(n, e, t, i, r, s, o) {
          if (null == s) n.removeAttribute(e, r, t);
          else {
            const a = null == o ? ve(s) : o(s, i || '', r);
            n.setAttribute(e, r, a, t);
          }
        })(e[xe], o, s, n.value, t, i, r);
      }
      function D4(n, e, t, i, r, s) {
        const o = s[e];
        if (null !== o)
          for (let a = 0; a < o.length; ) PI(i, t, o[a++], o[a++], o[a++]);
      }
      function PI(n, e, t, i, r) {
        const s = fn(null);
        try {
          const o = n.inputTransforms;
          null !== o && o.hasOwnProperty(i) && (r = o[i].call(e, r)),
            null !== n.setInput ? n.setInput(e, r, t, i) : (e[i] = r);
        } finally {
          fn(s);
        }
      }
      function T4(n, e, t) {
        let i = null,
          r = 0;
        for (; r < t.length; ) {
          const s = t[r];
          if (0 !== s)
            if (5 !== s) {
              if ('number' == typeof s) break;
              if (n.hasOwnProperty(s)) {
                null === i && (i = []);
                const o = n[s];
                for (let a = 0; a < o.length; a += 2)
                  if (o[a] === e) {
                    i.push(s, o[a + 1], t[r + 1]);
                    break;
                  }
              }
              r += 2;
            } else r += 2;
          else r += 4;
        }
        return i;
      }
      function RI(n, e, t, i) {
        return [n, !0, !1, e, null, 0, i, t, null, null, null];
      }
      function FI(n, e) {
        const t = n.contentQueries;
        if (null !== t)
          for (let i = 0; i < t.length; i += 2) {
            const s = t[i + 1];
            if (-1 !== s) {
              const o = n.data[s];
              mv(t[i]), o.contentQueries(2, e[s], s);
            }
          }
      }
      function Sp(n, e) {
        return n[od] ? (n[QM][Ji] = e) : (n[od] = e), (n[QM] = e), e;
      }
      function Ay(n, e, t) {
        mv(0);
        const i = fn(null);
        try {
          e(n, t);
        } finally {
          fn(i);
        }
      }
      function OI(n) {
        return n[Ka] || (n[Ka] = []);
      }
      function LI(n) {
        return n.cleanup || (n.cleanup = []);
      }
      function NI(n, e, t) {
        return (
          (null === n || er(n)) &&
            (t = (function aU(n) {
              for (; Array.isArray(n); ) {
                if ('object' == typeof n[iv]) return n;
                n = n[rn];
              }
              return null;
            })(t[e.index])),
          t[xe]
        );
      }
      function VI(n, e) {
        const t = n[Za],
          i = t ? t.get(Pr, null) : null;
        i && i.handleError(e);
      }
      function Sy(n, e, t, i, r) {
        for (let s = 0; s < t.length; ) {
          const o = t[s++],
            a = t[s++];
          PI(n.data[o], e[o], i, a, r);
        }
      }
      function I4(n, e) {
        const t = Mi(e, n),
          i = t[Z];
        !(function k4(n, e) {
          for (let t = e.length; t < n.blueprint.length; t++)
            e.push(n.blueprint[t]);
        })(i, t);
        const r = t[rn];
        null !== r && null === t[rs] && (t[rs] = nI(r, t[Za])), My(i, t, t[qt]);
      }
      function My(n, e, t) {
        gv(e);
        try {
          const i = n.viewQuery;
          null !== i && Ay(1, i, t);
          const r = n.template;
          null !== r && AI(n, e, r, 1, t),
            n.firstCreatePass && (n.firstCreatePass = !1),
            n.staticContentQueries && FI(n, e),
            n.staticViewQueries && Ay(2, n.viewQuery, t);
          const s = n.components;
          null !== s &&
            (function P4(n, e) {
              for (let t = 0; t < e.length; t++) I4(n, e[t]);
            })(e, s);
        } catch (i) {
          throw (
            (n.firstCreatePass &&
              ((n.incompleteFirstPass = !0), (n.firstCreatePass = !1)),
            i)
          );
        } finally {
          (e[Ce] &= -5), _v();
        }
      }
      let BI = (() => {
        class n {
          constructor() {
            (this.all = new Set()), (this.queue = new Map());
          }
          create(t, i, r) {
            const s = typeof Zone > 'u' ? null : Zone.current,
              o = new tU(
                t,
                (c) => {
                  this.all.has(c) && this.queue.set(c, s);
                },
                r
              );
            let a;
            this.all.add(o), o.notify();
            const l = () => {
              o.cleanup(), a?.(), this.all.delete(o), this.queue.delete(o);
            };
            return (a = i?.onDestroy(l)), { destroy: l };
          }
          flush() {
            if (0 !== this.queue.size)
              for (const [t, i] of this.queue)
                this.queue.delete(t), i ? i.run(() => t.run()) : t.run();
          }
          get isQueueEmpty() {
            return 0 === this.queue.size;
          }
        }
        return (
          (n.ɵprov = ee({
            token: n,
            providedIn: 'root',
            factory: () => new n(),
          })),
          n
        );
      })();
      function Mp(n, e, t) {
        let i = t ? n.styles : null,
          r = t ? n.classes : null,
          s = 0;
        if (null !== e)
          for (let o = 0; o < e.length; o++) {
            const a = e[o];
            'number' == typeof a
              ? (s = a)
              : 1 == s
              ? (r = qb(r, a))
              : 2 == s && (i = qb(i, a + ': ' + e[++o] + ';'));
          }
        t ? (n.styles = i) : (n.stylesWithoutHost = i),
          t ? (n.classes = r) : (n.classesWithoutHost = r);
      }
      function Pd(n, e, t, i, r = !1) {
        for (; null !== t; ) {
          const s = e[t.index];
          if ((null !== s && i.push(At(s)), ii(s))) {
            for (let a = Dn; a < s.length; a++) {
              const l = s[a],
                c = l[Z].firstChild;
              null !== c && Pd(l[Z], l, c, i);
            }
            s[Sr] !== s[rn] && i.push(s[Sr]);
          }
          const o = t.type;
          if (8 & o) Pd(n, e, t.child, i);
          else if (32 & o) {
            const a = Lv(t, e);
            let l;
            for (; (l = a()); ) i.push(l);
          } else if (16 & o) {
            const a = MT(e, t);
            if (Array.isArray(a)) i.push(...a);
            else {
              const l = bd(e[Xt]);
              Pd(l[Z], l, a, i, !0);
            }
          }
          t = r ? t.projectionNext : t.next;
        }
        return i;
      }
      function Dp(n, e, t, i = !0) {
        const r = e[Fo].rendererFactory;
        r.begin && r.begin();
        try {
          HI(n, e, n.template, t);
        } catch (o) {
          throw (i && VI(e, o), o);
        } finally {
          r.end && r.end(), e[Fo].effectManager?.flush();
        }
      }
      function HI(n, e, t, i) {
        const r = e[Ce];
        if (256 != (256 & r)) {
          e[Fo].effectManager?.flush(), gv(e);
          try {
            mD(e),
              (function CD(n) {
                return (fe.lFrame.bindingIndex = n);
              })(n.bindingStartIndex),
              null !== t && AI(n, e, t, 2, i);
            const o = 3 == (3 & r);
            if (o) {
              const c = n.preOrderCheckHooks;
              null !== c && Gf(e, c, null);
            } else {
              const c = n.preOrderHooks;
              null !== c && qf(e, c, 0, null), bv(e, 0);
            }
            if (
              ((function N4(n) {
                for (let e = pT(n); null !== e; e = mT(e)) {
                  if (!e[eD]) continue;
                  const t = e[el];
                  for (let i = 0; i < t.length; i++) {
                    hU(t[i]);
                  }
                }
              })(e),
              WI(e, 2),
              null !== n.contentQueries && FI(n, e),
              o)
            ) {
              const c = n.contentCheckHooks;
              null !== c && Gf(e, c);
            } else {
              const c = n.contentHooks;
              null !== c && qf(e, c, 1), bv(e, 1);
            }
            !(function o4(n, e) {
              const t = n.hostBindingOpCodes;
              if (null === t) return;
              const i = _I(e, Nf);
              try {
                for (let r = 0; r < t.length; r++) {
                  const s = t[r];
                  if (s < 0) No(~s);
                  else {
                    const o = s,
                      a = t[++r],
                      l = t[++r];
                    xU(a, o), i.runInContext(l, 2, e[o]);
                  }
                }
              } finally {
                null === e[Nf] && bI(e, Nf), No(-1);
              }
            })(n, e);
            const a = n.components;
            null !== a && zI(e, a, 0);
            const l = n.viewQuery;
            if ((null !== l && Ay(2, l, i), o)) {
              const c = n.viewCheckHooks;
              null !== c && Gf(e, c);
            } else {
              const c = n.viewHooks;
              null !== c && qf(e, c, 2), bv(e, 2);
            }
            !0 === n.firstUpdatePass && (n.firstUpdatePass = !1),
              (e[Ce] &= -73),
              gD(e);
          } finally {
            _v();
          }
        }
      }
      function WI(n, e) {
        for (let t = pT(n); null !== t; t = mT(t))
          for (let i = Dn; i < t.length; i++) jI(t[i], e);
      }
      function V4(n, e, t) {
        jI(Mi(e, n), t);
      }
      function jI(n, e) {
        if (
          !(function dU(n) {
            return 128 == (128 & n[Ce]);
          })(n)
        )
          return;
        const t = n[Z];
        if ((80 & n[Ce] && 0 === e) || 1024 & n[Ce] || 2 === e)
          HI(t, n, t.template, n[qt]);
        else if (n[sd] > 0) {
          WI(n, 1);
          const r = n[Z].components;
          null !== r && zI(n, r, 1);
        }
      }
      function zI(n, e, t) {
        for (let i = 0; i < e.length; i++) V4(n, e[i], t);
      }
      class Rd {
        get rootNodes() {
          const e = this._lView,
            t = e[Z];
          return Pd(t, e, t.firstChild, []);
        }
        constructor(e, t) {
          (this._lView = e),
            (this._cdRefInjectingView = t),
            (this._appRef = null),
            (this._attachedToViewContainer = !1);
        }
        get context() {
          return this._lView[qt];
        }
        set context(e) {
          this._lView[qt] = e;
        }
        get destroyed() {
          return 256 == (256 & this._lView[Ce]);
        }
        destroy() {
          if (this._appRef) this._appRef.detachView(this);
          else if (this._attachedToViewContainer) {
            const e = this._lView[It];
            if (ii(e)) {
              const t = e[8],
                i = t ? t.indexOf(this) : -1;
              i > -1 && (Vv(e, i), Jf(t, i));
            }
            this._attachedToViewContainer = !1;
          }
          vT(this._lView[Z], this._lView);
        }
        onDestroy(e) {
          !(function bD(n, e) {
            if (256 == (256 & n[Ce])) throw new N(911, !1);
            null === n[Ws] && (n[Ws] = []), n[Ws].push(e);
          })(this._lView, e);
        }
        markForCheck() {
          Id(this._cdRefInjectingView || this._lView);
        }
        detach() {
          this._lView[Ce] &= -129;
        }
        reattach() {
          this._lView[Ce] |= 128;
        }
        detectChanges() {
          Dp(this._lView[Z], this._lView, this.context);
        }
        checkNoChanges() {}
        attachToViewContainerRef() {
          if (this._appRef) throw new N(902, !1);
          this._attachedToViewContainer = !0;
        }
        detachFromAppRef() {
          (this._appRef = null),
            (function R3(n, e) {
              yd(n, e, e[xe], 2, null, null);
            })(this._lView[Z], this._lView);
        }
        attachToAppRef(e) {
          if (this._attachedToViewContainer) throw new N(902, !1);
          this._appRef = e;
        }
      }
      class B4 extends Rd {
        constructor(e) {
          super(e), (this._view = e);
        }
        detectChanges() {
          const e = this._view;
          Dp(e[Z], e, e[qt], !1);
        }
        checkNoChanges() {}
        get context() {
          return null;
        }
      }
      class UI extends Dd {
        constructor(e) {
          super(), (this.ngModule = e);
        }
        resolveComponentFactory(e) {
          const t = it(e);
          return new Fd(t, this.ngModule);
        }
      }
      function $I(n) {
        const e = [];
        for (let t in n)
          n.hasOwnProperty(t) && e.push({ propName: n[t], templateName: t });
        return e;
      }
      class W4 {
        constructor(e, t) {
          (this.injector = e), (this.parentInjector = t);
        }
        get(e, t, i) {
          i = Rf(i);
          const r = this.injector.get(e, my, i);
          return r !== my || t === my ? r : this.parentInjector.get(e, t, i);
        }
      }
      class Fd extends sI {
        get inputs() {
          return $I(this.componentDef.inputs);
        }
        get outputs() {
          return $I(this.componentDef.outputs);
        }
        constructor(e, t) {
          super(),
            (this.componentDef = e),
            (this.ngModule = t),
            (this.componentType = e.type),
            (this.selector = (function Lz(n) {
              return n.map(Oz).join(',');
            })(e.selectors)),
            (this.ngContentSelectors = e.ngContentSelectors
              ? e.ngContentSelectors
              : []),
            (this.isBoundToModule = !!t);
        }
        create(e, t, i, r) {
          let s = (r = r || this.ngModule) instanceof gl ? r : r?.injector;
          s &&
            null !== this.componentDef.getStandaloneInjector &&
            (s = this.componentDef.getStandaloneInjector(s) || s);
          const o = s ? new W4(e, s) : e,
            a = o.get(Td, null);
          if (null === a) throw new N(407, !1);
          const u = {
              rendererFactory: a,
              sanitizer: o.get(G$, null),
              effectManager: o.get(BI, null),
            },
            h = a.createRenderer(null, this.componentDef),
            f = this.componentDef.selectors[0][0] || 'div',
            p = i
              ? (function l4(n, e, t, i) {
                  const s = i.get(cI, !1) || t === ei.ShadowDom,
                    o = n.selectRootElement(e, s);
                  return (
                    (function c4(n) {
                      MI(n);
                    })(o),
                    o
                  );
                })(h, i, this.componentDef.encapsulation, o)
              : lp(
                  h,
                  f,
                  (function H4(n) {
                    const e = n.toLowerCase();
                    return 'svg' === e ? hD : 'math' === e ? 'math' : null;
                  })(f)
                ),
            w = this.componentDef.signals
              ? 4608
              : this.componentDef.onPush
              ? 576
              : 528,
            y = wy(0, null, null, 1, 0, null, null, null, null, null, null),
            E = Ap(null, y, null, w, null, null, u, h, o, null, null);
          let A, M;
          gv(E);
          try {
            const T = this.componentDef;
            let k,
              P = null;
            T.findHostDirectiveDefs
              ? ((k = []),
                (P = new Map()),
                T.findHostDirectiveDefs(T, k, P),
                k.push(T))
              : (k = [T]);
            const O = (function z4(n, e) {
                const t = n[Z],
                  i = ze;
                return (n[i] = e), El(t, i, 2, '#host', null);
              })(E, p),
              I = (function U4(n, e, t, i, r, s, o) {
                const a = r[Z];
                !(function $4(n, e, t, i) {
                  for (const r of n)
                    e.mergedAttrs = id(e.mergedAttrs, r.hostAttrs);
                  null !== e.mergedAttrs &&
                    (Mp(e, e.mergedAttrs, !0), null !== t && kT(i, t, e));
                })(i, n, e, o);
                let l = null;
                null !== e && (l = nI(e, r[Za]));
                const c = s.rendererFactory.createRenderer(e, t);
                let u = 16;
                t.signals ? (u = 4096) : t.onPush && (u = 64);
                const h = Ap(
                  r,
                  SI(t),
                  null,
                  u,
                  r[n.index],
                  n,
                  s,
                  c,
                  null,
                  null,
                  l
                );
                return (
                  a.firstCreatePass && Cy(a, n, i.length - 1),
                  Sp(r, h),
                  (r[n.index] = h)
                );
              })(O, p, T, k, E, u, h);
            (M = pD(y, ze)),
              p &&
                (function q4(n, e, t, i) {
                  if (i) nv(n, t, ['ng-version', q$.full]);
                  else {
                    const { attrs: r, classes: s } = (function Nz(n) {
                      const e = [],
                        t = [];
                      let i = 1,
                        r = 2;
                      for (; i < n.length; ) {
                        let s = n[i];
                        if ('string' == typeof s)
                          2 === r
                            ? '' !== s && e.push(s, n[++i])
                            : 8 === r && t.push(s);
                        else {
                          if (!Qi(r)) break;
                          r = s;
                        }
                        i++;
                      }
                      return { attrs: e, classes: t };
                    })(e.selectors[0]);
                    r && nv(n, t, r),
                      s && s.length > 0 && IT(n, t, s.join(' '));
                  }
                })(h, T, p, i),
              void 0 !== t &&
                (function X4(n, e, t) {
                  const i = (n.projection = []);
                  for (let r = 0; r < e.length; r++) {
                    const s = t[r];
                    i.push(null != s ? Array.from(s) : null);
                  }
                })(M, this.ngContentSelectors, t),
              (A = (function G4(n, e, t, i, r, s) {
                const o = bn(),
                  a = r[Z],
                  l = si(o, r);
                II(a, r, o, t, null, i);
                for (let u = 0; u < t.length; u++)
                  Tn(Vo(r, a, o.directiveStart + u, o), r);
                kI(a, r, o), l && Tn(l, r);
                const c = Vo(r, a, o.directiveStart + o.componentOffset, o);
                if (((n[qt] = r[qt] = c), null !== s))
                  for (const u of s) u(c, e);
                return by(a, o, n), c;
              })(I, T, k, P, E, [Y4])),
              My(y, E, null);
          } finally {
            _v();
          }
          return new j4(this.componentType, A, bl(M, E), E, M);
        }
      }
      class j4 extends H$ {
        constructor(e, t, i, r, s) {
          super(),
            (this.location = i),
            (this._rootLView = r),
            (this._tNode = s),
            (this.previousInputValues = null),
            (this.instance = t),
            (this.hostView = this.changeDetectorRef = new B4(r)),
            (this.componentType = e);
        }
        setInput(e, t) {
          const i = this._tNode.inputs;
          let r;
          if (null !== i && (r = i[e])) {
            if (
              ((this.previousInputValues ??= new Map()),
              this.previousInputValues.has(e) &&
                Object.is(this.previousInputValues.get(e), t))
            )
              return;
            const s = this._rootLView;
            Sy(s[Z], s, r, e, t),
              this.previousInputValues.set(e, t),
              Id(Mi(this._tNode.index, s));
          }
        }
        get injector() {
          return new sl(this._tNode, this._rootLView);
        }
        destroy() {
          this.hostView.destroy();
        }
        onDestroy(e) {
          this.hostView.onDestroy(e);
        }
      }
      function Y4() {
        const n = bn();
        $f(H()[Z], n);
      }
      function ye(n) {
        let e = (function GI(n) {
            return Object.getPrototypeOf(n.prototype).constructor;
          })(n.type),
          t = !0;
        const i = [n];
        for (; e; ) {
          let r;
          if (er(n)) r = e.ɵcmp || e.ɵdir;
          else {
            if (e.ɵcmp) throw new N(903, !1);
            r = e.ɵdir;
          }
          if (r) {
            if (t) {
              i.push(r);
              const o = n;
              (o.inputs = Tp(n.inputs)),
                (o.inputTransforms = Tp(n.inputTransforms)),
                (o.declaredInputs = Tp(n.declaredInputs)),
                (o.outputs = Tp(n.outputs));
              const a = r.hostBindings;
              a && J4(n, a);
              const l = r.viewQuery,
                c = r.contentQueries;
              if (
                (l && Z4(n, l),
                c && Q4(n, c),
                Mf(n.inputs, r.inputs),
                Mf(n.declaredInputs, r.declaredInputs),
                Mf(n.outputs, r.outputs),
                null !== r.inputTransforms &&
                  (null === o.inputTransforms && (o.inputTransforms = {}),
                  Mf(o.inputTransforms, r.inputTransforms)),
                er(r) && r.data.animation)
              ) {
                const u = n.data;
                u.animation = (u.animation || []).concat(r.data.animation);
              }
            }
            const s = r.features;
            if (s)
              for (let o = 0; o < s.length; o++) {
                const a = s[o];
                a && a.ngInherit && a(n), a === ye && (t = !1);
              }
          }
          e = Object.getPrototypeOf(e);
        }
        !(function K4(n) {
          let e = 0,
            t = null;
          for (let i = n.length - 1; i >= 0; i--) {
            const r = n[i];
            (r.hostVars = e += r.hostVars),
              (r.hostAttrs = id(r.hostAttrs, (t = id(t, r.hostAttrs))));
          }
        })(i);
      }
      function Tp(n) {
        return n === xr ? {} : n === et ? [] : n;
      }
      function Z4(n, e) {
        const t = n.viewQuery;
        n.viewQuery = t
          ? (i, r) => {
              e(i, r), t(i, r);
            }
          : e;
      }
      function Q4(n, e) {
        const t = n.contentQueries;
        n.contentQueries = t
          ? (i, r, s) => {
              e(i, r, s), t(i, r, s);
            }
          : e;
      }
      function J4(n, e) {
        const t = n.hostBindings;
        n.hostBindings = t
          ? (i, r) => {
              e(i, r), t(i, r);
            }
          : e;
      }
      function Ip(n) {
        return (
          !!Dy(n) &&
          (Array.isArray(n) || (!(n instanceof Map) && Symbol.iterator in n))
        );
      }
      function Dy(n) {
        return null !== n && ('function' == typeof n || 'object' == typeof n);
      }
      function In(n, e, t) {
        return !Object.is(n[e], t) && ((n[e] = t), !0);
      }
      function Dt(n, e, t, i) {
        const r = H();
        return In(r, il(), e) && (Xe(), Rr(kt(), r, n, e, t, i)), Dt;
      }
      function xl(n, e, t, i) {
        return In(n, il(), t) ? e + ve(t) + i : Ae;
      }
      function Ie(n, e, t, i, r, s, o, a) {
        const l = H(),
          c = Xe(),
          u = n + ze,
          h = c.firstCreatePass
            ? (function S5(n, e, t, i, r, s, o, a, l) {
                const c = e.consts,
                  u = El(e, n, 4, o || null, js(c, a));
                Ey(e, t, u, js(c, l)), $f(e, u);
                const h = (u.tView = wy(
                  2,
                  u,
                  i,
                  r,
                  s,
                  e.directiveRegistry,
                  e.pipeRegistry,
                  null,
                  e.schemas,
                  c,
                  null
                ));
                return (
                  null !== e.queries &&
                    (e.queries.template(e, u),
                    (h.queries = e.queries.embeddedTView(u))),
                  u
                );
              })(u, c, l, e, t, i, r, s, o)
            : c.data[u];
        Tr(h, !1);
        const f = lk(c, l, h, n);
        Uf() && dp(c, l, f, h),
          Tn(f, l),
          Sp(l, (l[u] = RI(f, l, f, h))),
          Bf(h) && vy(c, l, h),
          null != o && yy(l, h, a);
      }
      let lk = function ck(n, e, t, i) {
        return zs(!0), e[xe].createComment('');
      };
      function Go(n) {
        return tl(
          (function EU() {
            return fe.lFrame.contextLView;
          })(),
          ze + n
        );
      }
      function X(n, e, t) {
        const i = H();
        return In(i, il(), e) && ki(Xe(), kt(), i, n, e, i[xe], t, !1), X;
      }
      function Fy(n, e, t, i, r) {
        const o = r ? 'class' : 'style';
        Sy(n, t, e.inputs[o], o, i);
      }
      function z(n, e, t, i) {
        const r = H(),
          s = Xe(),
          o = ze + n,
          a = r[xe],
          l = s.firstCreatePass
            ? (function I5(n, e, t, i, r, s) {
                const o = e.consts,
                  l = El(e, n, 2, i, js(o, r));
                return (
                  Ey(e, t, l, js(o, s)),
                  null !== l.attrs && Mp(l, l.attrs, !1),
                  null !== l.mergedAttrs && Mp(l, l.mergedAttrs, !0),
                  null !== e.queries && e.queries.elementStart(e, l),
                  l
                );
              })(o, s, r, e, t, i)
            : s.data[o],
          c = dk(s, r, l, a, e, n);
        r[o] = c;
        const u = Bf(l);
        return (
          Tr(l, !0),
          kT(a, c, l),
          32 != (32 & l.flags) && Uf() && dp(s, r, c, l),
          0 ===
            (function pU() {
              return fe.lFrame.elementDepthCount;
            })() && Tn(c, r),
          (function mU() {
            fe.lFrame.elementDepthCount++;
          })(),
          u && (vy(s, r, l), by(s, l, r)),
          null !== i && yy(r, l),
          z
        );
      }
      function G() {
        let n = bn();
        uv() ? hv() : ((n = n.parent), Tr(n, !1));
        const e = n;
        (function _U(n) {
          return fe.skipHydrationRootTNode === n;
        })(e) &&
          (function wU() {
            fe.skipHydrationRootTNode = null;
          })(),
          (function gU() {
            fe.lFrame.elementDepthCount--;
          })();
        const t = Xe();
        return (
          t.firstCreatePass && ($f(t, n), rv(n) && t.queries.elementEnd(n)),
          null != e.classesWithoutHost &&
            (function FU(n) {
              return 0 != (8 & n.flags);
            })(e) &&
            Fy(t, e, H(), e.classesWithoutHost, !0),
          null != e.stylesWithoutHost &&
            (function OU(n) {
              return 0 != (16 & n.flags);
            })(e) &&
            Fy(t, e, H(), e.stylesWithoutHost, !1),
          G
        );
      }
      function ct(n, e, t, i) {
        return z(n, e, t, i), G(), ct;
      }
      let dk = (n, e, t, i, r, s) => (
        zs(!0),
        lp(
          i,
          r,
          (function kD() {
            return fe.lFrame.currentNamespace;
          })()
        )
      );
      function Ui() {
        return H();
      }
      function Op(n) {
        return !!n && 'function' == typeof n.then;
      }
      function fk(n) {
        return !!n && 'function' == typeof n.subscribe;
      }
      function pe(n, e, t, i) {
        const r = H(),
          s = Xe(),
          o = bn();
        return pk(s, r, r[xe], o, n, e, i), pe;
      }
      function Ny(n, e) {
        const t = bn(),
          i = H(),
          r = Xe();
        return pk(r, i, NI(pv(r.data), t, i), t, n, e), Ny;
      }
      function pk(n, e, t, i, r, s, o) {
        const a = Bf(i),
          c = n.firstCreatePass && LI(n),
          u = e[qt],
          h = OI(e);
        let f = !0;
        if (3 & i.type || o) {
          const g = si(i, e),
            w = o ? o(g) : g,
            y = h.length,
            E = o ? (M) => o(At(M[i.index])) : i.index;
          let A = null;
          if (
            (!o &&
              a &&
              (A = (function L5(n, e, t, i) {
                const r = n.cleanup;
                if (null != r)
                  for (let s = 0; s < r.length - 1; s += 2) {
                    const o = r[s];
                    if (o === t && r[s + 1] === i) {
                      const a = e[Ka],
                        l = r[s + 2];
                      return a.length > l ? a[l] : null;
                    }
                    'string' == typeof o && (s += 2);
                  }
                return null;
              })(n, e, r, i.index)),
            null !== A)
          )
            ((A.__ngLastListenerFn__ || A).__ngNextListenerFn__ = s),
              (A.__ngLastListenerFn__ = s),
              (f = !1);
          else {
            s = gk(i, e, u, s, !1);
            const M = t.listen(w, r, s);
            h.push(s, M), c && c.push(r, E, y, y + 1);
          }
        } else s = gk(i, e, u, s, !1);
        const p = i.outputs;
        let m;
        if (f && null !== p && (m = p[r])) {
          const g = m.length;
          if (g)
            for (let w = 0; w < g; w += 2) {
              const T = e[m[w]][m[w + 1]].subscribe(s),
                k = h.length;
              h.push(s, T), c && c.push(r, i.index, k, -(k + 1));
            }
        }
      }
      function mk(n, e, t, i) {
        try {
          return Dr(6, e, t), !1 !== t(i);
        } catch (r) {
          return VI(n, r), !1;
        } finally {
          Dr(7, e, t);
        }
      }
      function gk(n, e, t, i, r) {
        return function s(o) {
          if (o === Function) return i;
          Id(n.componentOffset > -1 ? Mi(n.index, e) : e);
          let l = mk(e, t, i, o),
            c = s.__ngNextListenerFn__;
          for (; c; ) (l = mk(e, t, c, o) && l), (c = c.__ngNextListenerFn__);
          return r && !1 === l && o.preventDefault(), l;
        };
      }
      function Be(n = 1) {
        return (function MU(n) {
          return (fe.lFrame.contextLView = (function DU(n, e) {
            for (; n > 0; ) (e = e[Qa]), n--;
            return e;
          })(n, fe.lFrame.contextLView))[qt];
        })(n);
      }
      function N5(n, e) {
        let t = null;
        const i = (function kz(n) {
          const e = n.attrs;
          if (null != e) {
            const t = e.indexOf(5);
            if (!(1 & t)) return e[t + 1];
          }
          return null;
        })(n);
        for (let r = 0; r < e.length; r++) {
          const s = e[r];
          if ('*' !== s) {
            if (null === i ? qM(n, s, !0) : Fz(i, s)) return r;
          } else t = r;
        }
        return t;
      }
      function Pi(n) {
        const e = H()[Xt][Mn];
        if (!e.projection) {
          const i = (e.projection = md(n ? n.length : 1, null)),
            r = i.slice();
          let s = e.child;
          for (; null !== s; ) {
            const o = n ? N5(s, n) : 0;
            null !== o &&
              (r[o] ? (r[o].projectionNext = s) : (i[o] = s), (r[o] = s)),
              (s = s.next);
          }
        }
      }
      function dt(n, e = 0, t) {
        const i = H(),
          r = Xe(),
          s = El(r, ze + n, 16, null, t || null);
        null === s.projection && (s.projection = e),
          hv(),
          (!i[rs] || nl()) &&
            32 != (32 & s.flags) &&
            (function W3(n, e, t) {
              TT(e[xe], 0, e, t, Hv(n, t, e), CT(t.parent || e[Mn], t, e));
            })(r, i, s);
      }
      function Lp(n, e) {
        return (n << 17) | (e << 2);
      }
      function Us(n) {
        return (n >> 17) & 32767;
      }
      function By(n) {
        return 2 | n;
      }
      function qo(n) {
        return (131068 & n) >> 2;
      }
      function Hy(n, e) {
        return (-131069 & n) | (e << 2);
      }
      function Wy(n) {
        return 1 | n;
      }
      function Sk(n, e, t, i, r) {
        const s = n[t + 1],
          o = null === e;
        let a = i ? Us(s) : qo(s),
          l = !1;
        for (; 0 !== a && (!1 === l || o); ) {
          const u = n[a + 1];
          z5(n[a], e) && ((l = !0), (n[a + 1] = i ? Wy(u) : By(u))),
            (a = i ? Us(u) : qo(u));
        }
        l && (n[t + 1] = i ? By(s) : Wy(s));
      }
      function z5(n, e) {
        return (
          null === n ||
          null == e ||
          (Array.isArray(n) ? n[1] : n) === e ||
          (!(!Array.isArray(n) || 'string' != typeof e) && dl(n, e) >= 0)
        );
      }
      const on = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 };
      function Mk(n) {
        return n.substring(on.key, on.keyEnd);
      }
      function Dk(n, e) {
        const t = on.textEnd;
        return t === e
          ? -1
          : ((e = on.keyEnd =
              (function q5(n, e, t) {
                for (; e < t && n.charCodeAt(e) > 32; ) e++;
                return e;
              })(n, (on.key = e), t)),
            Pl(n, e, t));
      }
      function Pl(n, e, t) {
        for (; e < t && n.charCodeAt(e) <= 32; ) e++;
        return e;
      }
      function Rl(n, e, t) {
        return ir(n, e, t, !1), Rl;
      }
      function _t(n, e) {
        return ir(n, e, null, !0), _t;
      }
      function Lr(n, e) {
        for (
          let t = (function $5(n) {
            return (
              (function Ik(n) {
                (on.key = 0),
                  (on.keyEnd = 0),
                  (on.value = 0),
                  (on.valueEnd = 0),
                  (on.textEnd = n.length);
              })(n),
              Dk(n, Pl(n, 0, on.textEnd))
            );
          })(e);
          t >= 0;
          t = Dk(e, t)
        )
          Di(n, Mk(e), !0);
      }
      function ir(n, e, t, i) {
        const r = H(),
          s = Xe(),
          o = os(2);
        s.firstUpdatePass && Fk(s, n, o, i),
          e !== Ae &&
            In(r, o, e) &&
            Lk(
              s,
              s.data[zn()],
              r,
              r[xe],
              n,
              (r[o + 1] = (function sG(n, e) {
                return (
                  null == n ||
                    '' === n ||
                    ('string' == typeof e
                      ? (n += e)
                      : 'object' == typeof n && (n = nn(Ti(n)))),
                  n
                );
              })(e, t)),
              i,
              o
            );
      }
      function Rk(n, e) {
        return e >= n.expandoStartIndex;
      }
      function Fk(n, e, t, i) {
        const r = n.data;
        if (null === r[t + 1]) {
          const s = r[zn()],
            o = Rk(n, t);
          Vk(s, i) && null === e && !o && (e = !1),
            (e = (function Q5(n, e, t, i) {
              const r = pv(n);
              let s = i ? e.residualClasses : e.residualStyles;
              if (null === r)
                0 === (i ? e.classBindings : e.styleBindings) &&
                  ((t = Bd((t = jy(null, n, e, t, i)), e.attrs, i)),
                  (s = null));
              else {
                const o = e.directiveStylingLast;
                if (-1 === o || n[o] !== r)
                  if (((t = jy(r, n, e, t, i)), null === s)) {
                    let l = (function J5(n, e, t) {
                      const i = t ? e.classBindings : e.styleBindings;
                      if (0 !== qo(i)) return n[Us(i)];
                    })(n, e, i);
                    void 0 !== l &&
                      Array.isArray(l) &&
                      ((l = jy(null, n, e, l[1], i)),
                      (l = Bd(l, e.attrs, i)),
                      (function eG(n, e, t, i) {
                        n[Us(t ? e.classBindings : e.styleBindings)] = i;
                      })(n, e, i, l));
                  } else
                    s = (function tG(n, e, t) {
                      let i;
                      const r = e.directiveEnd;
                      for (let s = 1 + e.directiveStylingLast; s < r; s++)
                        i = Bd(i, n[s].hostAttrs, t);
                      return Bd(i, e.attrs, t);
                    })(n, e, i);
              }
              return (
                void 0 !== s &&
                  (i ? (e.residualClasses = s) : (e.residualStyles = s)),
                t
              );
            })(r, s, e, i)),
            (function W5(n, e, t, i, r, s) {
              let o = s ? e.classBindings : e.styleBindings,
                a = Us(o),
                l = qo(o);
              n[i] = t;
              let u,
                c = !1;
              if (
                (Array.isArray(t)
                  ? ((u = t[1]), (null === u || dl(t, u) > 0) && (c = !0))
                  : (u = t),
                r)
              )
                if (0 !== l) {
                  const f = Us(n[a + 1]);
                  (n[i + 1] = Lp(f, a)),
                    0 !== f && (n[f + 1] = Hy(n[f + 1], i)),
                    (n[a + 1] = (function B5(n, e) {
                      return (131071 & n) | (e << 17);
                    })(n[a + 1], i));
                } else
                  (n[i + 1] = Lp(a, 0)),
                    0 !== a && (n[a + 1] = Hy(n[a + 1], i)),
                    (a = i);
              else
                (n[i + 1] = Lp(l, 0)),
                  0 === a ? (a = i) : (n[l + 1] = Hy(n[l + 1], i)),
                  (l = i);
              c && (n[i + 1] = By(n[i + 1])),
                Sk(n, u, i, !0),
                Sk(n, u, i, !1),
                (function j5(n, e, t, i, r) {
                  const s = r ? n.residualClasses : n.residualStyles;
                  null != s &&
                    'string' == typeof e &&
                    dl(s, e) >= 0 &&
                    (t[i + 1] = Wy(t[i + 1]));
                })(e, u, n, i, s),
                (o = Lp(a, l)),
                s ? (e.classBindings = o) : (e.styleBindings = o);
            })(r, s, e, t, o, i);
        }
      }
      function jy(n, e, t, i, r) {
        let s = null;
        const o = t.directiveEnd;
        let a = t.directiveStylingLast;
        for (
          -1 === a ? (a = t.directiveStart) : a++;
          a < o && ((s = e[a]), (i = Bd(i, s.hostAttrs, r)), s !== n);

        )
          a++;
        return null !== n && (t.directiveStylingLast = a), i;
      }
      function Bd(n, e, t) {
        const i = t ? 1 : 2;
        let r = -1;
        if (null !== e)
          for (let s = 0; s < e.length; s++) {
            const o = e[s];
            'number' == typeof o
              ? (r = o)
              : r === i &&
                (Array.isArray(n) || (n = void 0 === n ? [] : ['', n]),
                Di(n, o, !!t || e[++s]));
          }
        return void 0 === n ? null : n;
      }
      function Lk(n, e, t, i, r, s, o, a) {
        if (!(3 & e.type)) return;
        const l = n.data,
          c = l[a + 1],
          u = (function H5(n) {
            return 1 == (1 & n);
          })(c)
            ? Nk(l, e, t, r, qo(c), o)
            : void 0;
        Np(u) ||
          (Np(s) ||
            ((function V5(n) {
              return 2 == (2 & n);
            })(c) &&
              (s = Nk(l, null, t, r, a, o))),
          (function z3(n, e, t, i, r) {
            if (e) r ? n.addClass(t, i) : n.removeClass(t, i);
            else {
              let s = -1 === i.indexOf('-') ? void 0 : oi.DashCase;
              null == r
                ? n.removeStyle(t, i, s)
                : ('string' == typeof r &&
                    r.endsWith('!important') &&
                    ((r = r.slice(0, -10)), (s |= oi.Important)),
                  n.setStyle(t, i, r, s));
            }
          })(i, o, zf(zn(), t), r, s));
      }
      function Nk(n, e, t, i, r, s) {
        const o = null === e;
        let a;
        for (; r > 0; ) {
          const l = n[r],
            c = Array.isArray(l),
            u = c ? l[1] : l,
            h = null === u;
          let f = t[r + 1];
          f === Ae && (f = h ? et : void 0);
          let p = h ? Sv(f, i) : u === i ? f : void 0;
          if ((c && !Np(p) && (p = Sv(l, i)), Np(p) && ((a = p), o))) return a;
          const m = n[r + 1];
          r = o ? Us(m) : qo(m);
        }
        if (null !== e) {
          let l = s ? e.residualClasses : e.residualStyles;
          null != l && (a = Sv(l, i));
        }
        return a;
      }
      function Np(n) {
        return void 0 !== n;
      }
      function Vk(n, e) {
        return 0 != (n.flags & (e ? 8 : 16));
      }
      function Ue(n, e = '') {
        const t = H(),
          i = Xe(),
          r = n + ze,
          s = i.firstCreatePass ? El(i, r, 1, e, null) : i.data[r],
          o = Bk(i, t, s, e, n);
        (t[r] = o), Uf() && dp(i, t, o, s), Tr(s, !1);
      }
      let Bk = (n, e, t, i, r) => (
        zs(!0),
        (function ap(n, e) {
          return n.createText(e);
        })(e[xe], i)
      );
      function Fl(n) {
        return ds('', n, ''), Fl;
      }
      function ds(n, e, t) {
        const i = H(),
          r = xl(i, n, e, t);
        return (
          r !== Ae &&
            (function cs(n, e, t) {
              const i = zf(e, n);
              !(function _T(n, e, t) {
                n.setValue(e, t);
              })(n[xe], i, t);
            })(i, zn(), r),
          ds
        );
      }
      function zy(n, e, t) {
        !(function rr(n, e, t, i) {
          const r = Xe(),
            s = os(2);
          r.firstUpdatePass && Fk(r, null, s, i);
          const o = H();
          if (t !== Ae && In(o, s, t)) {
            const a = r.data[zn()];
            if (Vk(a, i) && !Rk(r, s)) {
              let l = i ? a.classesWithoutHost : a.stylesWithoutHost;
              null !== l && (t = qb(l, t || '')), Fy(r, a, o, t, i);
            } else
              !(function rG(n, e, t, i, r, s, o, a) {
                r === Ae && (r = et);
                let l = 0,
                  c = 0,
                  u = 0 < r.length ? r[0] : null,
                  h = 0 < s.length ? s[0] : null;
                for (; null !== u || null !== h; ) {
                  const f = l < r.length ? r[l + 1] : void 0,
                    p = c < s.length ? s[c + 1] : void 0;
                  let g,
                    m = null;
                  u === h
                    ? ((l += 2), (c += 2), f !== p && ((m = h), (g = p)))
                    : null === h || (null !== u && u < h)
                    ? ((l += 2), (m = u))
                    : ((c += 2), (m = h), (g = p)),
                    null !== m && Lk(n, e, t, i, m, g, o, a),
                    (u = l < r.length ? r[l] : null),
                    (h = c < s.length ? s[c] : null);
                }
              })(
                r,
                a,
                o,
                o[xe],
                o[s + 1],
                (o[s + 1] = (function nG(n, e, t) {
                  if (null == t || '' === t) return et;
                  const i = [],
                    r = Ti(t);
                  if (Array.isArray(r))
                    for (let s = 0; s < r.length; s++) n(i, r[s], !0);
                  else if ('object' == typeof r)
                    for (const s in r) r.hasOwnProperty(s) && n(i, s, r[s]);
                  else 'string' == typeof r && e(i, r);
                  return i;
                })(n, e, t)),
                i,
                s
              );
          }
        })(Di, Lr, xl(H(), n, e, t), !0);
      }
      function Xo(n, e, t) {
        const i = H();
        return In(i, il(), e) && ki(Xe(), kt(), i, n, e, i[xe], t, !0), Xo;
      }
      function Uy(n, e, t) {
        const i = H();
        if (In(i, il(), e)) {
          const s = Xe(),
            o = kt();
          ki(s, o, i, n, e, NI(pv(s.data), o, i), t, !0);
        }
        return Uy;
      }
      const Ll = 'en-US';
      let sP = Ll;
      function qy(n, e, t, i, r) {
        if (((n = be(n)), Array.isArray(n)))
          for (let s = 0; s < n.length; s++) qy(n[s], e, t, i, r);
        else {
          const s = Xe(),
            o = H();
          let a = jo(n) ? n : be(n.provide),
            l = QT(n);
          const c = bn(),
            u = 1048575 & c.providerIndexes,
            h = c.directiveStart,
            f = c.providerIndexes >> 20;
          if (jo(n) || !n.multi) {
            const p = new ud(l, r, D),
              m = Yy(a, e, r ? u : u + f, h);
            -1 === m
              ? (Cv(Zf(c, o), s, a),
                Xy(s, n, e.length),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                t.push(p),
                o.push(p))
              : ((t[m] = p), (o[m] = p));
          } else {
            const p = Yy(a, e, u + f, h),
              m = Yy(a, e, u, u + f),
              w = m >= 0 && t[m];
            if ((r && !w) || (!r && !(p >= 0 && t[p]))) {
              Cv(Zf(c, o), s, a);
              const y = (function x8(n, e, t, i, r) {
                const s = new ud(n, t, D);
                return (
                  (s.multi = []),
                  (s.index = e),
                  (s.componentProviders = 0),
                  IP(s, r, i && !t),
                  s
                );
              })(r ? C8 : E8, t.length, r, i, l);
              !r && w && (t[m].providerFactory = y),
                Xy(s, n, e.length, 0),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                t.push(y),
                o.push(y);
            } else Xy(s, n, p > -1 ? p : m, IP(t[r ? m : p], l, !r && i));
            !r && i && w && t[m].componentProviders++;
          }
        }
      }
      function Xy(n, e, t, i) {
        const r = jo(e),
          s = (function x$(n) {
            return !!n.useClass;
          })(e);
        if (r || s) {
          const l = (s ? be(e.useClass) : e).prototype.ngOnDestroy;
          if (l) {
            const c = n.destroyHooks || (n.destroyHooks = []);
            if (!r && e.multi) {
              const u = c.indexOf(t);
              -1 === u ? c.push(t, [i, l]) : c[u + 1].push(i, l);
            } else c.push(t, l);
          }
        }
      }
      function IP(n, e, t) {
        return t && n.componentProviders++, n.multi.push(e) - 1;
      }
      function Yy(n, e, t, i) {
        for (let r = t; r < i; r++) if (e[r] === n) return r;
        return -1;
      }
      function E8(n, e, t, i) {
        return Ky(this.multi, []);
      }
      function C8(n, e, t, i) {
        const r = this.multi;
        let s;
        if (this.providerFactory) {
          const o = this.providerFactory.componentProviders,
            a = Vo(t, t[Z], this.providerFactory.index, i);
          (s = a.slice(0, o)), Ky(r, s);
          for (let l = o; l < a.length; l++) s.push(a[l]);
        } else (s = []), Ky(r, s);
        return s;
      }
      function Ky(n, e) {
        for (let t = 0; t < n.length; t++) e.push((0, n[t])());
        return e;
      }
      function tt(n, e = []) {
        return (t) => {
          t.providersResolver = (i, r) =>
            (function w8(n, e, t) {
              const i = Xe();
              if (i.firstCreatePass) {
                const r = er(n);
                qy(t, i.data, i.blueprint, r, !0),
                  qy(e, i.data, i.blueprint, r, !1);
              }
            })(i, r ? r(n) : n, e);
        };
      }
      class Nl {}
      class A8 {}
      class Zy extends Nl {
        constructor(e, t, i) {
          super(),
            (this._parent = t),
            (this._bootstrapComponents = []),
            (this.destroyCbs = []),
            (this.componentFactoryResolver = new UI(this));
          const r = (function Ai(n, e) {
            const t = n[BM] || null;
            if (!t && !0 === e)
              throw new Error(
                `Type ${nn(n)} does not have '\u0275mod' property.`
              );
            return t;
          })(e);
          (this._bootstrapComponents = (function ls(n) {
            return n instanceof Function ? n() : n;
          })(r.bootstrap)),
            (this._r3Injector = xI(
              e,
              t,
              [
                { provide: Nl, useValue: this },
                { provide: Dd, useValue: this.componentFactoryResolver },
                ...i,
              ],
              nn(e),
              new Set(['environment'])
            )),
            this._r3Injector.resolveInjectorInitializers(),
            (this.instance = this._r3Injector.get(e));
        }
        get injector() {
          return this._r3Injector;
        }
        destroy() {
          const e = this._r3Injector;
          !e.destroyed && e.destroy(),
            this.destroyCbs.forEach((t) => t()),
            (this.destroyCbs = null);
        }
        onDestroy(e) {
          this.destroyCbs.push(e);
        }
      }
      class Qy extends A8 {
        constructor(e) {
          super(), (this.moduleType = e);
        }
        create(e) {
          return new Zy(this.moduleType, e, []);
        }
      }
      function VP(n, e, t, i, r, s) {
        const o = e + t;
        return In(n, o, r)
          ? (function Fr(n, e, t) {
              return (n[e] = t);
            })(n, o + 1, s ? i.call(s, r) : i(r))
          : (function $d(n, e) {
              const t = n[e];
              return t === Ae ? void 0 : t;
            })(n, o + 1);
      }
      function UP(n, e, t) {
        const i = n + ze,
          r = H(),
          s = tl(r, i);
        return (function Gd(n, e) {
          return n[Z].data[e].pure;
        })(r, i)
          ? VP(
              r,
              (function jn() {
                const n = fe.lFrame;
                let e = n.bindingRootIndex;
                return (
                  -1 === e &&
                    (e = n.bindingRootIndex = n.tView.bindingStartIndex),
                  e
                );
              })(),
              e,
              s.transform,
              t,
              s
            )
          : s.transform(t);
      }
      function ew(n) {
        return (e) => {
          setTimeout(n, void 0, e);
        };
      }
      const ke = class eq extends Le {
        constructor(e = !1) {
          super(), (this.__isAsync = e);
        }
        emit(e) {
          super.next(e);
        }
        subscribe(e, t, i) {
          let r = e,
            s = t || (() => null),
            o = i;
          if (e && 'object' == typeof e) {
            const l = e;
            (r = l.next?.bind(l)),
              (s = l.error?.bind(l)),
              (o = l.complete?.bind(l));
          }
          this.__isAsync && ((s = ew(s)), r && (r = ew(r)), o && (o = ew(o)));
          const a = super.subscribe({ next: r, error: s, complete: o });
          return e instanceof $t && e.add(a), a;
        }
      };
      function tq() {
        return this._results[Symbol.iterator]();
      }
      class Vl {
        get changes() {
          return this._changes || (this._changes = new ke());
        }
        constructor(e = !1) {
          (this._emitDistinctChangesOnly = e),
            (this.dirty = !0),
            (this._results = []),
            (this._changesDetected = !1),
            (this._changes = null),
            (this.length = 0),
            (this.first = void 0),
            (this.last = void 0);
          const t = Vl.prototype;
          t[Symbol.iterator] || (t[Symbol.iterator] = tq);
        }
        get(e) {
          return this._results[e];
        }
        map(e) {
          return this._results.map(e);
        }
        filter(e) {
          return this._results.filter(e);
        }
        find(e) {
          return this._results.find(e);
        }
        reduce(e, t) {
          return this._results.reduce(e, t);
        }
        forEach(e) {
          this._results.forEach(e);
        }
        some(e) {
          return this._results.some(e);
        }
        toArray() {
          return this._results.slice();
        }
        toString() {
          return this._results.toString();
        }
        reset(e, t) {
          const i = this;
          i.dirty = !1;
          const r = (function ji(n) {
            return n.flat(Number.POSITIVE_INFINITY);
          })(e);
          (this._changesDetected = !(function GU(n, e, t) {
            if (n.length !== e.length) return !1;
            for (let i = 0; i < n.length; i++) {
              let r = n[i],
                s = e[i];
              if ((t && ((r = t(r)), (s = t(s))), s !== r)) return !1;
            }
            return !0;
          })(i._results, r, t)) &&
            ((i._results = r),
            (i.length = r.length),
            (i.last = r[this.length - 1]),
            (i.first = r[0]));
        }
        notifyOnChanges() {
          this._changes &&
            (this._changesDetected || !this._emitDistinctChangesOnly) &&
            this._changes.emit(this);
        }
        setDirty() {
          this.dirty = !0;
        }
        destroy() {
          this.changes.complete(), this.changes.unsubscribe();
        }
      }
      let Nr = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = rq), n;
      })();
      const nq = Nr,
        iq = class extends nq {
          constructor(e, t, i) {
            super(),
              (this._declarationLView = e),
              (this._declarationTContainer = t),
              (this.elementRef = i);
          }
          get ssrId() {
            return this._declarationTContainer.tView?.ssrId || null;
          }
          createEmbeddedView(e, t) {
            return this.createEmbeddedViewImpl(e, t, null);
          }
          createEmbeddedViewImpl(e, t, i) {
            const o = this._declarationTContainer.tView,
              a = Ap(
                this._declarationLView,
                o,
                e,
                4096 & this._declarationLView[Ce] ? 4096 : 16,
                null,
                o.declTNode,
                null,
                null,
                null,
                t || null,
                i || null
              );
            a[ad] = this._declarationLView[this._declarationTContainer.index];
            const c = this._declarationLView[Ar];
            return (
              null !== c && (a[Ar] = c.createEmbeddedView(o)),
              My(o, a, e),
              new Rd(a)
            );
          }
        };
      function rq() {
        return jp(bn(), H());
      }
      function jp(n, e) {
        return 4 & n.type ? new iq(e, n, bl(n, e)) : null;
      }
      let $i = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = uq), n;
      })();
      function uq() {
        return KP(bn(), H());
      }
      const hq = $i,
        XP = class extends hq {
          constructor(e, t, i) {
            super(),
              (this._lContainer = e),
              (this._hostTNode = t),
              (this._hostLView = i);
          }
          get element() {
            return bl(this._hostTNode, this._hostLView);
          }
          get injector() {
            return new sl(this._hostTNode, this._hostLView);
          }
          get parentInjector() {
            const e = Ev(this._hostTNode, this._hostLView);
            if (OD(e)) {
              const t = Yf(e, this._hostLView),
                i = Xf(e);
              return new sl(t[Z].data[i + 8], t);
            }
            return new sl(null, this._hostLView);
          }
          clear() {
            for (; this.length > 0; ) this.remove(this.length - 1);
          }
          get(e) {
            const t = YP(this._lContainer);
            return (null !== t && t[e]) || null;
          }
          get length() {
            return this._lContainer.length - Dn;
          }
          createEmbeddedView(e, t, i) {
            let r, s;
            'number' == typeof i
              ? (r = i)
              : null != i && ((r = i.index), (s = i.injector));
            const a = e.createEmbeddedViewImpl(t || {}, s, null);
            return this.insertImpl(a, r, false), a;
          }
          createComponent(e, t, i, r, s) {
            const o =
              e &&
              !(function fd(n) {
                return 'function' == typeof n;
              })(e);
            let a;
            if (o) a = t;
            else {
              const g = t || {};
              (a = g.index),
                (i = g.injector),
                (r = g.projectableNodes),
                (s = g.environmentInjector || g.ngModuleRef);
            }
            const l = o ? e : new Fd(it(e)),
              c = i || this.parentInjector;
            if (!s && null == l.ngModule) {
              const w = (o ? c : this.parentInjector).get(gl, null);
              w && (s = w);
            }
            it(l.componentType ?? {});
            const p = l.create(c, r, null, s);
            return this.insertImpl(p.hostView, a, false), p;
          }
          insert(e, t) {
            return this.insertImpl(e, t, !1);
          }
          insertImpl(e, t, i) {
            const r = e._lView,
              s = r[Z];
            if (
              (function uU(n) {
                return ii(n[It]);
              })(r)
            ) {
              const l = this.indexOf(e);
              if (-1 !== l) this.detach(l);
              else {
                const c = r[It],
                  u = new XP(c, c[Mn], c[It]);
                u.detach(u.indexOf(e));
              }
            }
            const o = this._adjustIndex(t),
              a = this._lContainer;
            if (
              ((function O3(n, e, t, i) {
                const r = Dn + i,
                  s = t.length;
                i > 0 && (t[r - 1][Ji] = e),
                  i < s - Dn
                    ? ((e[Ji] = t[r]), qD(t, Dn + i, e))
                    : (t.push(e), (e[Ji] = null)),
                  (e[It] = t);
                const o = e[ad];
                null !== o &&
                  t !== o &&
                  (function L3(n, e) {
                    const t = n[el];
                    e[Xt] !== e[It][It][Xt] && (n[eD] = !0),
                      null === t ? (n[el] = [e]) : t.push(e);
                  })(o, e);
                const a = e[Ar];
                null !== a && a.insertView(n), (e[Ce] |= 128);
              })(s, r, a, o),
              !i)
            ) {
              const l = jv(o, a),
                c = r[xe],
                u = cp(c, a[Sr]);
              null !== u &&
                (function P3(n, e, t, i, r, s) {
                  (i[rn] = r), (i[Mn] = e), yd(n, i, t, 1, r, s);
                })(s, a[Mn], c, r, u, l);
            }
            return e.attachToViewContainerRef(), qD(nw(a), o, e), e;
          }
          move(e, t) {
            return this.insert(e, t);
          }
          indexOf(e) {
            const t = YP(this._lContainer);
            return null !== t ? t.indexOf(e) : -1;
          }
          remove(e) {
            const t = this._adjustIndex(e, -1),
              i = Vv(this._lContainer, t);
            i && (Jf(nw(this._lContainer), t), vT(i[Z], i));
          }
          detach(e) {
            const t = this._adjustIndex(e, -1),
              i = Vv(this._lContainer, t);
            return i && null != Jf(nw(this._lContainer), t) ? new Rd(i) : null;
          }
          _adjustIndex(e, t = 0) {
            return e ?? this.length + t;
          }
        };
      function YP(n) {
        return n[8];
      }
      function nw(n) {
        return n[8] || (n[8] = []);
      }
      function KP(n, e) {
        let t;
        const i = e[n.index];
        return (
          ii(i)
            ? (t = i)
            : ((t = RI(i, e, null, n)), (e[n.index] = t), Sp(e, t)),
          ZP(t, e, n, i),
          new XP(t, n, e)
        );
      }
      let ZP = function QP(n, e, t, i) {
        if (n[Sr]) return;
        let r;
        (r =
          8 & t.type
            ? At(i)
            : (function fq(n, e) {
                const t = n[xe],
                  i = t.createComment(''),
                  r = si(e, n);
                return (
                  Ho(
                    t,
                    cp(t, r),
                    i,
                    (function H3(n, e) {
                      return n.nextSibling(e);
                    })(t, r),
                    !1
                  ),
                  i
                );
              })(e, t)),
          (n[Sr] = r);
      };
      class iw {
        constructor(e) {
          (this.queryList = e), (this.matches = null);
        }
        clone() {
          return new iw(this.queryList);
        }
        setDirty() {
          this.queryList.setDirty();
        }
      }
      class rw {
        constructor(e = []) {
          this.queries = e;
        }
        createEmbeddedView(e) {
          const t = e.queries;
          if (null !== t) {
            const i =
                null !== e.contentQueries ? e.contentQueries[0] : t.length,
              r = [];
            for (let s = 0; s < i; s++) {
              const o = t.getByIndex(s);
              r.push(this.queries[o.indexInDeclarationView].clone());
            }
            return new rw(r);
          }
          return null;
        }
        insertView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        detachView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        dirtyQueriesWithMatches(e) {
          for (let t = 0; t < this.queries.length; t++)
            null !== r1(e, t).matches && this.queries[t].setDirty();
        }
      }
      class JP {
        constructor(e, t, i = null) {
          (this.predicate = e), (this.flags = t), (this.read = i);
        }
      }
      class sw {
        constructor(e = []) {
          this.queries = e;
        }
        elementStart(e, t) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].elementStart(e, t);
        }
        elementEnd(e) {
          for (let t = 0; t < this.queries.length; t++)
            this.queries[t].elementEnd(e);
        }
        embeddedTView(e) {
          let t = null;
          for (let i = 0; i < this.length; i++) {
            const r = null !== t ? t.length : 0,
              s = this.getByIndex(i).embeddedTView(e, r);
            s &&
              ((s.indexInDeclarationView = i),
              null !== t ? t.push(s) : (t = [s]));
          }
          return null !== t ? new sw(t) : null;
        }
        template(e, t) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].template(e, t);
        }
        getByIndex(e) {
          return this.queries[e];
        }
        get length() {
          return this.queries.length;
        }
        track(e) {
          this.queries.push(e);
        }
      }
      class ow {
        constructor(e, t = -1) {
          (this.metadata = e),
            (this.matches = null),
            (this.indexInDeclarationView = -1),
            (this.crossesNgTemplate = !1),
            (this._appliesToNextNode = !0),
            (this._declarationNodeIndex = t);
        }
        elementStart(e, t) {
          this.isApplyingToNode(t) && this.matchTNode(e, t);
        }
        elementEnd(e) {
          this._declarationNodeIndex === e.index &&
            (this._appliesToNextNode = !1);
        }
        template(e, t) {
          this.elementStart(e, t);
        }
        embeddedTView(e, t) {
          return this.isApplyingToNode(e)
            ? ((this.crossesNgTemplate = !0),
              this.addMatch(-e.index, t),
              new ow(this.metadata))
            : null;
        }
        isApplyingToNode(e) {
          if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
            const t = this._declarationNodeIndex;
            let i = e.parent;
            for (; null !== i && 8 & i.type && i.index !== t; ) i = i.parent;
            return t === (null !== i ? i.index : -1);
          }
          return this._appliesToNextNode;
        }
        matchTNode(e, t) {
          const i = this.metadata.predicate;
          if (Array.isArray(i))
            for (let r = 0; r < i.length; r++) {
              const s = i[r];
              this.matchTNodeWithReadOption(e, t, gq(t, s)),
                this.matchTNodeWithReadOption(e, t, Qf(t, e, s, !1, !1));
            }
          else
            i === Nr
              ? 4 & t.type && this.matchTNodeWithReadOption(e, t, -1)
              : this.matchTNodeWithReadOption(e, t, Qf(t, e, i, !1, !1));
        }
        matchTNodeWithReadOption(e, t, i) {
          if (null !== i) {
            const r = this.metadata.read;
            if (null !== r)
              if (r === Ne || r === $i || (r === Nr && 4 & t.type))
                this.addMatch(t.index, -2);
              else {
                const s = Qf(t, e, r, !1, !1);
                null !== s && this.addMatch(t.index, s);
              }
            else this.addMatch(t.index, i);
          }
        }
        addMatch(e, t) {
          null === this.matches
            ? (this.matches = [e, t])
            : this.matches.push(e, t);
        }
      }
      function gq(n, e) {
        const t = n.localNames;
        if (null !== t)
          for (let i = 0; i < t.length; i += 2) if (t[i] === e) return t[i + 1];
        return null;
      }
      function bq(n, e, t, i) {
        return -1 === t
          ? (function _q(n, e) {
              return 11 & n.type ? bl(n, e) : 4 & n.type ? jp(n, e) : null;
            })(e, n)
          : -2 === t
          ? (function vq(n, e, t) {
              return t === Ne
                ? bl(e, n)
                : t === Nr
                ? jp(e, n)
                : t === $i
                ? KP(e, n)
                : void 0;
            })(n, e, i)
          : Vo(n, n[Z], t, e);
      }
      function e1(n, e, t, i) {
        const r = e[Ar].queries[i];
        if (null === r.matches) {
          const s = n.data,
            o = t.matches,
            a = [];
          for (let l = 0; l < o.length; l += 2) {
            const c = o[l];
            a.push(c < 0 ? null : bq(e, s[c], o[l + 1], t.metadata.read));
          }
          r.matches = a;
        }
        return r.matches;
      }
      function aw(n, e, t, i) {
        const r = n.queries.getByIndex(t),
          s = r.matches;
        if (null !== s) {
          const o = e1(n, e, r, t);
          for (let a = 0; a < s.length; a += 2) {
            const l = s[a];
            if (l > 0) i.push(o[a / 2]);
            else {
              const c = s[a + 1],
                u = e[-l];
              for (let h = Dn; h < u.length; h++) {
                const f = u[h];
                f[ad] === f[It] && aw(f[Z], f, c, i);
              }
              if (null !== u[el]) {
                const h = u[el];
                for (let f = 0; f < h.length; f++) {
                  const p = h[f];
                  aw(p[Z], p, c, i);
                }
              }
            }
          }
        }
        return i;
      }
      function ut(n) {
        const e = H(),
          t = Xe(),
          i = AD();
        mv(i + 1);
        const r = r1(t, i);
        if (
          n.dirty &&
          (function cU(n) {
            return 4 == (4 & n[Ce]);
          })(e) ===
            (2 == (2 & r.metadata.flags))
        ) {
          if (null === r.matches) n.reset([]);
          else {
            const s = r.crossesNgTemplate ? aw(t, e, i, []) : e1(t, e, r, i);
            n.reset(s, U$), n.notifyOnChanges();
          }
          return !0;
        }
        return !1;
      }
      function vn(n, e, t) {
        const i = Xe();
        i.firstCreatePass &&
          (n1(i, new JP(n, e, t), -1),
          2 == (2 & e) && (i.staticViewQueries = !0)),
          t1(i, H(), e);
      }
      function li(n, e, t, i) {
        const r = Xe();
        if (r.firstCreatePass) {
          const s = bn();
          n1(r, new JP(e, t, i), s.index),
            (function wq(n, e) {
              const t = n.contentQueries || (n.contentQueries = []);
              e !== (t.length ? t[t.length - 1] : -1) &&
                t.push(n.queries.length - 1, e);
            })(r, n),
            2 == (2 & t) && (r.staticContentQueries = !0);
        }
        t1(r, H(), t);
      }
      function ht() {
        return (function yq(n, e) {
          return n[Ar].queries[e].queryList;
        })(H(), AD());
      }
      function t1(n, e, t) {
        const i = new Vl(4 == (4 & t));
        (function h4(n, e, t, i) {
          const r = OI(e);
          r.push(t), n.firstCreatePass && LI(n).push(i, r.length - 1);
        })(n, e, i, i.destroy),
          null === e[Ar] && (e[Ar] = new rw()),
          e[Ar].queries.push(new iw(i));
      }
      function n1(n, e, t) {
        null === n.queries && (n.queries = new sw()),
          n.queries.track(new ow(e, t));
      }
      function r1(n, e) {
        return n.queries.getByIndex(e);
      }
      function s1(n, e) {
        return jp(n, e);
      }
      const jq = new j('Application Initializer');
      let hw = (() => {
        class n {
          constructor() {
            (this.initialized = !1),
              (this.done = !1),
              (this.donePromise = new Promise((t, i) => {
                (this.resolve = t), (this.reject = i);
              })),
              (this.appInits = Te(jq, { optional: !0 }) ?? []);
          }
          runInitializers() {
            if (this.initialized) return;
            const t = [];
            for (const r of this.appInits) {
              const s = r();
              if (Op(s)) t.push(s);
              else if (fk(s)) {
                const o = new Promise((a, l) => {
                  s.subscribe({ complete: a, error: l });
                });
                t.push(o);
              }
            }
            const i = () => {
              (this.done = !0), this.resolve();
            };
            Promise.all(t)
              .then(() => {
                i();
              })
              .catch((r) => {
                this.reject(r);
              }),
              0 === t.length && i(),
              (this.initialized = !0);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      const Vr = new j('LocaleId', {
        providedIn: 'root',
        factory: () =>
          Te(Vr, me.Optional | me.SkipSelf) ||
          (function Uq() {
            return (typeof $localize < 'u' && $localize.locale) || Ll;
          })(),
      });
      let Gq = (() => {
        class n {
          constructor() {
            (this.taskId = 0),
              (this.pendingTasks = new Set()),
              (this.hasPendingTasks = new uM(!1));
          }
          add() {
            this.hasPendingTasks.next(!0);
            const t = this.taskId++;
            return this.pendingTasks.add(t), t;
          }
          remove(t) {
            this.pendingTasks.delete(t),
              0 === this.pendingTasks.size && this.hasPendingTasks.next(!1);
          }
          ngOnDestroy() {
            this.pendingTasks.clear(), this.hasPendingTasks.next(!1);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      const Kq = (() => Promise.resolve(0))();
      function fw(n) {
        typeof Zone > 'u'
          ? Kq.then(() => {
              n && n.apply(null, null);
            })
          : Zone.current.scheduleMicroTask('scheduleMicrotask', n);
      }
      function A1(...n) {}
      class ue {
        constructor({
          enableLongStackTrace: e = !1,
          shouldCoalesceEventChangeDetection: t = !1,
          shouldCoalesceRunChangeDetection: i = !1,
        }) {
          if (
            ((this.hasPendingMacrotasks = !1),
            (this.hasPendingMicrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new ke(!1)),
            (this.onMicrotaskEmpty = new ke(!1)),
            (this.onStable = new ke(!1)),
            (this.onError = new ke(!1)),
            typeof Zone > 'u')
          )
            throw new N(908, !1);
          Zone.assertZonePatched();
          const r = this;
          (r._nesting = 0),
            (r._outer = r._inner = Zone.current),
            Zone.TaskTrackingZoneSpec &&
              (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec())),
            e &&
              Zone.longStackTraceZoneSpec &&
              (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)),
            (r.shouldCoalesceEventChangeDetection = !i && t),
            (r.shouldCoalesceRunChangeDetection = i),
            (r.lastRequestAnimationFrameId = -1),
            (r.nativeRequestAnimationFrame = (function Zq() {
              let n = yt.requestAnimationFrame,
                e = yt.cancelAnimationFrame;
              if (typeof Zone < 'u' && n && e) {
                const t = n[Zone.__symbol__('OriginalDelegate')];
                t && (n = t);
                const i = e[Zone.__symbol__('OriginalDelegate')];
                i && (e = i);
              }
              return {
                nativeRequestAnimationFrame: n,
                nativeCancelAnimationFrame: e,
              };
            })().nativeRequestAnimationFrame),
            (function e6(n) {
              const e = () => {
                !(function Jq(n) {
                  n.isCheckStableRunning ||
                    -1 !== n.lastRequestAnimationFrameId ||
                    ((n.lastRequestAnimationFrameId =
                      n.nativeRequestAnimationFrame.call(yt, () => {
                        n.fakeTopEventTask ||
                          (n.fakeTopEventTask = Zone.root.scheduleEventTask(
                            'fakeTopEventTask',
                            () => {
                              (n.lastRequestAnimationFrameId = -1),
                                mw(n),
                                (n.isCheckStableRunning = !0),
                                pw(n),
                                (n.isCheckStableRunning = !1);
                            },
                            void 0,
                            () => {},
                            () => {}
                          )),
                          n.fakeTopEventTask.invoke();
                      })),
                    mw(n));
                })(n);
              };
              n._inner = n._inner.fork({
                name: 'angular',
                properties: { isAngularZone: !0 },
                onInvokeTask: (t, i, r, s, o, a) => {
                  try {
                    return S1(n), t.invokeTask(r, s, o, a);
                  } finally {
                    ((n.shouldCoalesceEventChangeDetection &&
                      'eventTask' === s.type) ||
                      n.shouldCoalesceRunChangeDetection) &&
                      e(),
                      M1(n);
                  }
                },
                onInvoke: (t, i, r, s, o, a, l) => {
                  try {
                    return S1(n), t.invoke(r, s, o, a, l);
                  } finally {
                    n.shouldCoalesceRunChangeDetection && e(), M1(n);
                  }
                },
                onHasTask: (t, i, r, s) => {
                  t.hasTask(r, s),
                    i === r &&
                      ('microTask' == s.change
                        ? ((n._hasPendingMicrotasks = s.microTask),
                          mw(n),
                          pw(n))
                        : 'macroTask' == s.change &&
                          (n.hasPendingMacrotasks = s.macroTask));
                },
                onHandleError: (t, i, r, s) => (
                  t.handleError(r, s),
                  n.runOutsideAngular(() => n.onError.emit(s)),
                  !1
                ),
              });
            })(r);
        }
        static isInAngularZone() {
          return typeof Zone < 'u' && !0 === Zone.current.get('isAngularZone');
        }
        static assertInAngularZone() {
          if (!ue.isInAngularZone()) throw new N(909, !1);
        }
        static assertNotInAngularZone() {
          if (ue.isInAngularZone()) throw new N(909, !1);
        }
        run(e, t, i) {
          return this._inner.run(e, t, i);
        }
        runTask(e, t, i, r) {
          const s = this._inner,
            o = s.scheduleEventTask('NgZoneEvent: ' + r, e, Qq, A1, A1);
          try {
            return s.runTask(o, t, i);
          } finally {
            s.cancelTask(o);
          }
        }
        runGuarded(e, t, i) {
          return this._inner.runGuarded(e, t, i);
        }
        runOutsideAngular(e) {
          return this._outer.run(e);
        }
      }
      const Qq = {};
      function pw(n) {
        if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable)
          try {
            n._nesting++, n.onMicrotaskEmpty.emit(null);
          } finally {
            if ((n._nesting--, !n.hasPendingMicrotasks))
              try {
                n.runOutsideAngular(() => n.onStable.emit(null));
              } finally {
                n.isStable = !0;
              }
          }
      }
      function mw(n) {
        n.hasPendingMicrotasks = !!(
          n._hasPendingMicrotasks ||
          ((n.shouldCoalesceEventChangeDetection ||
            n.shouldCoalesceRunChangeDetection) &&
            -1 !== n.lastRequestAnimationFrameId)
        );
      }
      function S1(n) {
        n._nesting++,
          n.isStable && ((n.isStable = !1), n.onUnstable.emit(null));
      }
      function M1(n) {
        n._nesting--, pw(n);
      }
      class t6 {
        constructor() {
          (this.hasPendingMicrotasks = !1),
            (this.hasPendingMacrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new ke()),
            (this.onMicrotaskEmpty = new ke()),
            (this.onStable = new ke()),
            (this.onError = new ke());
        }
        run(e, t, i) {
          return e.apply(t, i);
        }
        runGuarded(e, t, i) {
          return e.apply(t, i);
        }
        runOutsideAngular(e) {
          return e();
        }
        runTask(e, t, i, r) {
          return e.apply(t, i);
        }
      }
      const D1 = new j('', { providedIn: 'root', factory: T1 });
      function T1() {
        const n = Te(ue);
        let e = !0;
        return Ro(
          new Mt((r) => {
            (e =
              n.isStable && !n.hasPendingMacrotasks && !n.hasPendingMicrotasks),
              n.runOutsideAngular(() => {
                r.next(e), r.complete();
              });
          }),
          new Mt((r) => {
            let s;
            n.runOutsideAngular(() => {
              s = n.onStable.subscribe(() => {
                ue.assertNotInAngularZone(),
                  fw(() => {
                    !e &&
                      !n.hasPendingMacrotasks &&
                      !n.hasPendingMicrotasks &&
                      ((e = !0), r.next(!0));
                  });
              });
            });
            const o = n.onUnstable.subscribe(() => {
              ue.assertInAngularZone(),
                e &&
                  ((e = !1),
                  n.runOutsideAngular(() => {
                    r.next(!1);
                  }));
            });
            return () => {
              s.unsubscribe(), o.unsubscribe();
            };
          }).pipe(Ub())
        );
      }
      const I1 = new j(''),
        Up = new j('');
      let bw,
        gw = (() => {
          class n {
            constructor(t, i, r) {
              (this._ngZone = t),
                (this.registry = i),
                (this._pendingCount = 0),
                (this._isZoneStable = !0),
                (this._didWork = !1),
                (this._callbacks = []),
                (this.taskTrackingZone = null),
                bw ||
                  ((function n6(n) {
                    bw = n;
                  })(r),
                  r.addToWindow(i)),
                this._watchAngularEvents(),
                t.run(() => {
                  this.taskTrackingZone =
                    typeof Zone > 'u'
                      ? null
                      : Zone.current.get('TaskTrackingZone');
                });
            }
            _watchAngularEvents() {
              this._ngZone.onUnstable.subscribe({
                next: () => {
                  (this._didWork = !0), (this._isZoneStable = !1);
                },
              }),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable.subscribe({
                    next: () => {
                      ue.assertNotInAngularZone(),
                        fw(() => {
                          (this._isZoneStable = !0),
                            this._runCallbacksIfReady();
                        });
                    },
                  });
                });
            }
            increasePendingRequestCount() {
              return (
                (this._pendingCount += 1),
                (this._didWork = !0),
                this._pendingCount
              );
            }
            decreasePendingRequestCount() {
              if (((this._pendingCount -= 1), this._pendingCount < 0))
                throw new Error('pending async requests below zero');
              return this._runCallbacksIfReady(), this._pendingCount;
            }
            isStable() {
              return (
                this._isZoneStable &&
                0 === this._pendingCount &&
                !this._ngZone.hasPendingMacrotasks
              );
            }
            _runCallbacksIfReady() {
              if (this.isStable())
                fw(() => {
                  for (; 0 !== this._callbacks.length; ) {
                    let t = this._callbacks.pop();
                    clearTimeout(t.timeoutId), t.doneCb(this._didWork);
                  }
                  this._didWork = !1;
                });
              else {
                let t = this.getPendingTasks();
                (this._callbacks = this._callbacks.filter(
                  (i) =>
                    !i.updateCb ||
                    !i.updateCb(t) ||
                    (clearTimeout(i.timeoutId), !1)
                )),
                  (this._didWork = !0);
              }
            }
            getPendingTasks() {
              return this.taskTrackingZone
                ? this.taskTrackingZone.macroTasks.map((t) => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data,
                  }))
                : [];
            }
            addCallback(t, i, r) {
              let s = -1;
              i &&
                i > 0 &&
                (s = setTimeout(() => {
                  (this._callbacks = this._callbacks.filter(
                    (o) => o.timeoutId !== s
                  )),
                    t(this._didWork, this.getPendingTasks());
                }, i)),
                this._callbacks.push({ doneCb: t, timeoutId: s, updateCb: r });
            }
            whenStable(t, i, r) {
              if (r && !this.taskTrackingZone)
                throw new Error(
                  'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'
                );
              this.addCallback(t, i, r), this._runCallbacksIfReady();
            }
            getPendingRequestCount() {
              return this._pendingCount;
            }
            registerApplication(t) {
              this.registry.registerApplication(t, this);
            }
            unregisterApplication(t) {
              this.registry.unregisterApplication(t);
            }
            findProviders(t, i, r) {
              return [];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(ue), L(_w), L(Up));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        _w = (() => {
          class n {
            constructor() {
              this._applications = new Map();
            }
            registerApplication(t, i) {
              this._applications.set(t, i);
            }
            unregisterApplication(t) {
              this._applications.delete(t);
            }
            unregisterAllApplications() {
              this._applications.clear();
            }
            getTestability(t) {
              return this._applications.get(t) || null;
            }
            getAllTestabilities() {
              return Array.from(this._applications.values());
            }
            getAllRootElements() {
              return Array.from(this._applications.keys());
            }
            findTestabilityInTree(t, i = !0) {
              return bw?.findTestabilityInTree(this, t, i) ?? null;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = ee({
              token: n,
              factory: n.ɵfac,
              providedIn: 'platform',
            })),
            n
          );
        })(),
        $s = null;
      const k1 = new j('AllowMultipleToken'),
        vw = new j('PlatformDestroyListeners'),
        P1 = new j('appBootstrapListener');
      function O1(n, e, t = []) {
        const i = `Platform: ${e}`,
          r = new j(i);
        return (s = []) => {
          let o = yw();
          if (!o || o.injector.get(k1, !1)) {
            const a = [...t, ...s, { provide: r, useValue: !0 }];
            n
              ? n(a)
              : (function s6(n) {
                  if ($s && !$s.get(k1, !1)) throw new N(400, !1);
                  (function R1() {
                    !(function Jz(n) {
                      oD = n;
                    })(() => {
                      throw new N(600, !1);
                    });
                  })(),
                    ($s = n);
                  const e = n.get(N1);
                  (function F1(n) {
                    n.get(JT, null)?.forEach((t) => t());
                  })(n);
                })(
                  (function L1(n = [], e) {
                    return nr.create({
                      name: e,
                      providers: [
                        { provide: Jv, useValue: 'platform' },
                        { provide: vw, useValue: new Set([() => ($s = null)]) },
                        ...n,
                      ],
                    });
                  })(a, i)
                );
          }
          return (function a6(n) {
            const e = yw();
            if (!e) throw new N(401, !1);
            return e;
          })();
        };
      }
      function yw() {
        return $s?.get(N1) ?? null;
      }
      let N1 = (() => {
        class n {
          constructor(t) {
            (this._injector = t),
              (this._modules = []),
              (this._destroyListeners = []),
              (this._destroyed = !1);
          }
          bootstrapModuleFactory(t, i) {
            const r = (function l6(n = 'zone.js', e) {
              return 'noop' === n ? new t6() : 'zone.js' === n ? new ue(e) : n;
            })(
              i?.ngZone,
              (function V1(n) {
                return {
                  enableLongStackTrace: !1,
                  shouldCoalesceEventChangeDetection: n?.eventCoalescing ?? !1,
                  shouldCoalesceRunChangeDetection: n?.runCoalescing ?? !1,
                };
              })({
                eventCoalescing: i?.ngZoneEventCoalescing,
                runCoalescing: i?.ngZoneRunCoalescing,
              })
            );
            return r.run(() => {
              const s = (function M8(n, e, t) {
                  return new Zy(n, e, t);
                })(
                  t.moduleType,
                  this.injector,
                  (function z1(n) {
                    return [
                      { provide: ue, useFactory: n },
                      {
                        provide: gp,
                        multi: !0,
                        useFactory: () => {
                          const e = Te(d6, { optional: !0 });
                          return () => e.initialize();
                        },
                      },
                      { provide: j1, useFactory: c6 },
                      { provide: D1, useFactory: T1 },
                    ];
                  })(() => r)
                ),
                o = s.injector.get(Pr, null);
              return (
                r.runOutsideAngular(() => {
                  const a = r.onError.subscribe({
                    next: (l) => {
                      o.handleError(l);
                    },
                  });
                  s.onDestroy(() => {
                    $p(this._modules, s), a.unsubscribe();
                  });
                }),
                (function B1(n, e, t) {
                  try {
                    const i = t();
                    return Op(i)
                      ? i.catch((r) => {
                          throw (
                            (e.runOutsideAngular(() => n.handleError(r)), r)
                          );
                        })
                      : i;
                  } catch (i) {
                    throw (e.runOutsideAngular(() => n.handleError(i)), i);
                  }
                })(o, r, () => {
                  const a = s.injector.get(hw);
                  return (
                    a.runInitializers(),
                    a.donePromise.then(
                      () => (
                        (function oP(n) {
                          Hi(n, 'Expected localeId to be defined'),
                            'string' == typeof n &&
                              (sP = n.toLowerCase().replace(/_/g, '-'));
                        })(s.injector.get(Vr, Ll) || Ll),
                        this._moduleDoBootstrap(s),
                        s
                      )
                    )
                  );
                })
              );
            });
          }
          bootstrapModule(t, i = []) {
            const r = H1({}, i);
            return (function i6(n, e, t) {
              const i = new Qy(t);
              return Promise.resolve(i);
            })(0, 0, t).then((s) => this.bootstrapModuleFactory(s, r));
          }
          _moduleDoBootstrap(t) {
            const i = t.injector.get(Ko);
            if (t._bootstrapComponents.length > 0)
              t._bootstrapComponents.forEach((r) => i.bootstrap(r));
            else {
              if (!t.instance.ngDoBootstrap) throw new N(-403, !1);
              t.instance.ngDoBootstrap(i);
            }
            this._modules.push(t);
          }
          onDestroy(t) {
            this._destroyListeners.push(t);
          }
          get injector() {
            return this._injector;
          }
          destroy() {
            if (this._destroyed) throw new N(404, !1);
            this._modules.slice().forEach((i) => i.destroy()),
              this._destroyListeners.forEach((i) => i());
            const t = this._injector.get(vw, null);
            t && (t.forEach((i) => i()), t.clear()), (this._destroyed = !0);
          }
          get destroyed() {
            return this._destroyed;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(nr));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'platform' })),
          n
        );
      })();
      function H1(n, e) {
        return Array.isArray(e) ? e.reduce(H1, n) : { ...n, ...e };
      }
      let Ko = (() => {
        class n {
          constructor() {
            (this._bootstrapListeners = []),
              (this._runningTick = !1),
              (this._destroyed = !1),
              (this._destroyListeners = []),
              (this._views = []),
              (this.internalErrorHandler = Te(j1)),
              (this.zoneIsStable = Te(D1)),
              (this.componentTypes = []),
              (this.components = []),
              (this.isStable = Te(Gq).hasPendingTasks.pipe(
                Gb((t) => (t ? ts(!1) : this.zoneIsStable)),
                Sf(),
                Ub()
              )),
              (this._injector = Te(gl));
          }
          get destroyed() {
            return this._destroyed;
          }
          get injector() {
            return this._injector;
          }
          bootstrap(t, i) {
            const r = t instanceof sI;
            if (!this._injector.get(hw).done)
              throw (
                (!r &&
                  (function rd(n) {
                    const e = it(n) || Sn(n) || ni(n);
                    return null !== e && e.standalone;
                  })(t),
                new N(405, !1))
              );
            let o;
            (o = r ? t : this._injector.get(Dd).resolveComponentFactory(t)),
              this.componentTypes.push(o.componentType);
            const a = (function r6(n) {
                return n.isBoundToModule;
              })(o)
                ? void 0
                : this._injector.get(Nl),
              c = o.create(nr.NULL, [], i || o.selector, a),
              u = c.location.nativeElement,
              h = c.injector.get(I1, null);
            return (
              h?.registerApplication(u),
              c.onDestroy(() => {
                this.detachView(c.hostView),
                  $p(this.components, c),
                  h?.unregisterApplication(u);
              }),
              this._loadComponent(c),
              c
            );
          }
          tick() {
            if (this._runningTick) throw new N(101, !1);
            try {
              this._runningTick = !0;
              for (let t of this._views) t.detectChanges();
            } catch (t) {
              this.internalErrorHandler(t);
            } finally {
              this._runningTick = !1;
            }
          }
          attachView(t) {
            const i = t;
            this._views.push(i), i.attachToAppRef(this);
          }
          detachView(t) {
            const i = t;
            $p(this._views, i), i.detachFromAppRef();
          }
          _loadComponent(t) {
            this.attachView(t.hostView), this.tick(), this.components.push(t);
            const i = this._injector.get(P1, []);
            i.push(...this._bootstrapListeners), i.forEach((r) => r(t));
          }
          ngOnDestroy() {
            if (!this._destroyed)
              try {
                this._destroyListeners.forEach((t) => t()),
                  this._views.slice().forEach((t) => t.destroy());
              } finally {
                (this._destroyed = !0),
                  (this._views = []),
                  (this._bootstrapListeners = []),
                  (this._destroyListeners = []);
              }
          }
          onDestroy(t) {
            return (
              this._destroyListeners.push(t),
              () => $p(this._destroyListeners, t)
            );
          }
          destroy() {
            if (this._destroyed) throw new N(406, !1);
            const t = this._injector;
            t.destroy && !t.destroyed && t.destroy();
          }
          get viewCount() {
            return this._views.length;
          }
          warnIfDestroyed() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      function $p(n, e) {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1);
      }
      const j1 = new j('', {
        providedIn: 'root',
        factory: () => Te(Pr).handleError.bind(void 0),
      });
      function c6() {
        const n = Te(ue),
          e = Te(Pr);
        return (t) => n.runOutsideAngular(() => e.handleError(t));
      }
      let d6 = (() => {
        class n {
          constructor() {
            (this.zone = Te(ue)), (this.applicationRef = Te(Ko));
          }
          initialize() {
            this._onMicrotaskEmptySubscription ||
              (this._onMicrotaskEmptySubscription =
                this.zone.onMicrotaskEmpty.subscribe({
                  next: () => {
                    this.zone.run(() => {
                      this.applicationRef.tick();
                    });
                  },
                }));
          }
          ngOnDestroy() {
            this._onMicrotaskEmptySubscription?.unsubscribe();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      let Br = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = h6), n;
      })();
      function h6(n) {
        return (function f6(n, e, t) {
          if (Oo(n) && !t) {
            const i = Mi(n.index, e);
            return new Rd(i, i);
          }
          return 47 & n.type ? new Rd(e[Xt], e) : null;
        })(bn(), H(), 16 == (16 & n));
      }
      class q1 {
        constructor() {}
        supports(e) {
          return Ip(e);
        }
        create(e) {
          return new v6(e);
        }
      }
      const b6 = (n, e) => e;
      class v6 {
        constructor(e) {
          (this.length = 0),
            (this._linkedRecords = null),
            (this._unlinkedRecords = null),
            (this._previousItHead = null),
            (this._itHead = null),
            (this._itTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._movesHead = null),
            (this._movesTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null),
            (this._identityChangesHead = null),
            (this._identityChangesTail = null),
            (this._trackByFn = e || b6);
        }
        forEachItem(e) {
          let t;
          for (t = this._itHead; null !== t; t = t._next) e(t);
        }
        forEachOperation(e) {
          let t = this._itHead,
            i = this._removalsHead,
            r = 0,
            s = null;
          for (; t || i; ) {
            const o = !i || (t && t.currentIndex < Y1(i, r, s)) ? t : i,
              a = Y1(o, r, s),
              l = o.currentIndex;
            if (o === i) r--, (i = i._nextRemoved);
            else if (((t = t._next), null == o.previousIndex)) r++;
            else {
              s || (s = []);
              const c = a - r,
                u = l - r;
              if (c != u) {
                for (let f = 0; f < c; f++) {
                  const p = f < s.length ? s[f] : (s[f] = 0),
                    m = p + f;
                  u <= m && m < c && (s[f] = p + 1);
                }
                s[o.previousIndex] = u - c;
              }
            }
            a !== l && e(o, a, l);
          }
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousItHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachMovedItem(e) {
          let t;
          for (t = this._movesHead; null !== t; t = t._nextMoved) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        forEachIdentityChange(e) {
          let t;
          for (
            t = this._identityChangesHead;
            null !== t;
            t = t._nextIdentityChange
          )
            e(t);
        }
        diff(e) {
          if ((null == e && (e = []), !Ip(e))) throw new N(900, !1);
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let r,
            s,
            o,
            t = this._itHead,
            i = !1;
          if (Array.isArray(e)) {
            this.length = e.length;
            for (let a = 0; a < this.length; a++)
              (s = e[a]),
                (o = this._trackByFn(a, s)),
                null !== t && Object.is(t.trackById, o)
                  ? (i && (t = this._verifyReinsertion(t, s, o, a)),
                    Object.is(t.item, s) || this._addIdentityChange(t, s))
                  : ((t = this._mismatch(t, s, o, a)), (i = !0)),
                (t = t._next);
          } else
            (r = 0),
              (function l5(n, e) {
                if (Array.isArray(n))
                  for (let t = 0; t < n.length; t++) e(n[t]);
                else {
                  const t = n[Symbol.iterator]();
                  let i;
                  for (; !(i = t.next()).done; ) e(i.value);
                }
              })(e, (a) => {
                (o = this._trackByFn(r, a)),
                  null !== t && Object.is(t.trackById, o)
                    ? (i && (t = this._verifyReinsertion(t, a, o, r)),
                      Object.is(t.item, a) || this._addIdentityChange(t, a))
                    : ((t = this._mismatch(t, a, o, r)), (i = !0)),
                  (t = t._next),
                  r++;
              }),
              (this.length = r);
          return this._truncate(t), (this.collection = e), this.isDirty;
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._movesHead ||
            null !== this._removalsHead ||
            null !== this._identityChangesHead
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              e = this._previousItHead = this._itHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._additionsHead; null !== e; e = e._nextAdded)
              e.previousIndex = e.currentIndex;
            for (
              this._additionsHead = this._additionsTail = null,
                e = this._movesHead;
              null !== e;
              e = e._nextMoved
            )
              e.previousIndex = e.currentIndex;
            (this._movesHead = this._movesTail = null),
              (this._removalsHead = this._removalsTail = null),
              (this._identityChangesHead = this._identityChangesTail = null);
          }
        }
        _mismatch(e, t, i, r) {
          let s;
          return (
            null === e ? (s = this._itTail) : ((s = e._prev), this._remove(e)),
            null !==
            (e =
              null === this._unlinkedRecords
                ? null
                : this._unlinkedRecords.get(i, null))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._reinsertAfter(e, s, r))
              : null !==
                (e =
                  null === this._linkedRecords
                    ? null
                    : this._linkedRecords.get(i, r))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._moveAfter(e, s, r))
              : (e = this._addAfter(new y6(t, i), s, r)),
            e
          );
        }
        _verifyReinsertion(e, t, i, r) {
          let s =
            null === this._unlinkedRecords
              ? null
              : this._unlinkedRecords.get(i, null);
          return (
            null !== s
              ? (e = this._reinsertAfter(s, e._prev, r))
              : e.currentIndex != r &&
                ((e.currentIndex = r), this._addToMoves(e, r)),
            e
          );
        }
        _truncate(e) {
          for (; null !== e; ) {
            const t = e._next;
            this._addToRemovals(this._unlink(e)), (e = t);
          }
          null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
            null !== this._additionsTail &&
              (this._additionsTail._nextAdded = null),
            null !== this._movesTail && (this._movesTail._nextMoved = null),
            null !== this._itTail && (this._itTail._next = null),
            null !== this._removalsTail &&
              (this._removalsTail._nextRemoved = null),
            null !== this._identityChangesTail &&
              (this._identityChangesTail._nextIdentityChange = null);
        }
        _reinsertAfter(e, t, i) {
          null !== this._unlinkedRecords && this._unlinkedRecords.remove(e);
          const r = e._prevRemoved,
            s = e._nextRemoved;
          return (
            null === r ? (this._removalsHead = s) : (r._nextRemoved = s),
            null === s ? (this._removalsTail = r) : (s._prevRemoved = r),
            this._insertAfter(e, t, i),
            this._addToMoves(e, i),
            e
          );
        }
        _moveAfter(e, t, i) {
          return (
            this._unlink(e),
            this._insertAfter(e, t, i),
            this._addToMoves(e, i),
            e
          );
        }
        _addAfter(e, t, i) {
          return (
            this._insertAfter(e, t, i),
            (this._additionsTail =
              null === this._additionsTail
                ? (this._additionsHead = e)
                : (this._additionsTail._nextAdded = e)),
            e
          );
        }
        _insertAfter(e, t, i) {
          const r = null === t ? this._itHead : t._next;
          return (
            (e._next = r),
            (e._prev = t),
            null === r ? (this._itTail = e) : (r._prev = e),
            null === t ? (this._itHead = e) : (t._next = e),
            null === this._linkedRecords && (this._linkedRecords = new X1()),
            this._linkedRecords.put(e),
            (e.currentIndex = i),
            e
          );
        }
        _remove(e) {
          return this._addToRemovals(this._unlink(e));
        }
        _unlink(e) {
          null !== this._linkedRecords && this._linkedRecords.remove(e);
          const t = e._prev,
            i = e._next;
          return (
            null === t ? (this._itHead = i) : (t._next = i),
            null === i ? (this._itTail = t) : (i._prev = t),
            e
          );
        }
        _addToMoves(e, t) {
          return (
            e.previousIndex === t ||
              (this._movesTail =
                null === this._movesTail
                  ? (this._movesHead = e)
                  : (this._movesTail._nextMoved = e)),
            e
          );
        }
        _addToRemovals(e) {
          return (
            null === this._unlinkedRecords &&
              (this._unlinkedRecords = new X1()),
            this._unlinkedRecords.put(e),
            (e.currentIndex = null),
            (e._nextRemoved = null),
            null === this._removalsTail
              ? ((this._removalsTail = this._removalsHead = e),
                (e._prevRemoved = null))
              : ((e._prevRemoved = this._removalsTail),
                (this._removalsTail = this._removalsTail._nextRemoved = e)),
            e
          );
        }
        _addIdentityChange(e, t) {
          return (
            (e.item = t),
            (this._identityChangesTail =
              null === this._identityChangesTail
                ? (this._identityChangesHead = e)
                : (this._identityChangesTail._nextIdentityChange = e)),
            e
          );
        }
      }
      class y6 {
        constructor(e, t) {
          (this.item = e),
            (this.trackById = t),
            (this.currentIndex = null),
            (this.previousIndex = null),
            (this._nextPrevious = null),
            (this._prev = null),
            (this._next = null),
            (this._prevDup = null),
            (this._nextDup = null),
            (this._prevRemoved = null),
            (this._nextRemoved = null),
            (this._nextAdded = null),
            (this._nextMoved = null),
            (this._nextIdentityChange = null);
        }
      }
      class w6 {
        constructor() {
          (this._head = null), (this._tail = null);
        }
        add(e) {
          null === this._head
            ? ((this._head = this._tail = e),
              (e._nextDup = null),
              (e._prevDup = null))
            : ((this._tail._nextDup = e),
              (e._prevDup = this._tail),
              (e._nextDup = null),
              (this._tail = e));
        }
        get(e, t) {
          let i;
          for (i = this._head; null !== i; i = i._nextDup)
            if (
              (null === t || t <= i.currentIndex) &&
              Object.is(i.trackById, e)
            )
              return i;
          return null;
        }
        remove(e) {
          const t = e._prevDup,
            i = e._nextDup;
          return (
            null === t ? (this._head = i) : (t._nextDup = i),
            null === i ? (this._tail = t) : (i._prevDup = t),
            null === this._head
          );
        }
      }
      class X1 {
        constructor() {
          this.map = new Map();
        }
        put(e) {
          const t = e.trackById;
          let i = this.map.get(t);
          i || ((i = new w6()), this.map.set(t, i)), i.add(e);
        }
        get(e, t) {
          const r = this.map.get(e);
          return r ? r.get(e, t) : null;
        }
        remove(e) {
          const t = e.trackById;
          return this.map.get(t).remove(e) && this.map.delete(t), e;
        }
        get isEmpty() {
          return 0 === this.map.size;
        }
        clear() {
          this.map.clear();
        }
      }
      function Y1(n, e, t) {
        const i = n.previousIndex;
        if (null === i) return i;
        let r = 0;
        return t && i < t.length && (r = t[i]), i + e + r;
      }
      class K1 {
        constructor() {}
        supports(e) {
          return e instanceof Map || Dy(e);
        }
        create() {
          return new E6();
        }
      }
      class E6 {
        constructor() {
          (this._records = new Map()),
            (this._mapHead = null),
            (this._appendAfter = null),
            (this._previousMapHead = null),
            (this._changesHead = null),
            (this._changesTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null);
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._changesHead ||
            null !== this._removalsHead
          );
        }
        forEachItem(e) {
          let t;
          for (t = this._mapHead; null !== t; t = t._next) e(t);
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousMapHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachChangedItem(e) {
          let t;
          for (t = this._changesHead; null !== t; t = t._nextChanged) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        diff(e) {
          if (e) {
            if (!(e instanceof Map || Dy(e))) throw new N(900, !1);
          } else e = new Map();
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let t = this._mapHead;
          if (
            ((this._appendAfter = null),
            this._forEach(e, (i, r) => {
              if (t && t.key === r)
                this._maybeAddToChanges(t, i),
                  (this._appendAfter = t),
                  (t = t._next);
              else {
                const s = this._getOrCreateRecordForKey(r, i);
                t = this._insertBeforeOrAppend(t, s);
              }
            }),
            t)
          ) {
            t._prev && (t._prev._next = null), (this._removalsHead = t);
            for (let i = t; null !== i; i = i._nextRemoved)
              i === this._mapHead && (this._mapHead = null),
                this._records.delete(i.key),
                (i._nextRemoved = i._next),
                (i.previousValue = i.currentValue),
                (i.currentValue = null),
                (i._prev = null),
                (i._next = null);
          }
          return (
            this._changesTail && (this._changesTail._nextChanged = null),
            this._additionsTail && (this._additionsTail._nextAdded = null),
            this.isDirty
          );
        }
        _insertBeforeOrAppend(e, t) {
          if (e) {
            const i = e._prev;
            return (
              (t._next = e),
              (t._prev = i),
              (e._prev = t),
              i && (i._next = t),
              e === this._mapHead && (this._mapHead = t),
              (this._appendAfter = e),
              e
            );
          }
          return (
            this._appendAfter
              ? ((this._appendAfter._next = t), (t._prev = this._appendAfter))
              : (this._mapHead = t),
            (this._appendAfter = t),
            null
          );
        }
        _getOrCreateRecordForKey(e, t) {
          if (this._records.has(e)) {
            const r = this._records.get(e);
            this._maybeAddToChanges(r, t);
            const s = r._prev,
              o = r._next;
            return (
              s && (s._next = o),
              o && (o._prev = s),
              (r._next = null),
              (r._prev = null),
              r
            );
          }
          const i = new C6(e);
          return (
            this._records.set(e, i),
            (i.currentValue = t),
            this._addToAdditions(i),
            i
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              this._previousMapHead = this._mapHead, e = this._previousMapHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._changesHead; null !== e; e = e._nextChanged)
              e.previousValue = e.currentValue;
            for (e = this._additionsHead; null != e; e = e._nextAdded)
              e.previousValue = e.currentValue;
            (this._changesHead = this._changesTail = null),
              (this._additionsHead = this._additionsTail = null),
              (this._removalsHead = null);
          }
        }
        _maybeAddToChanges(e, t) {
          Object.is(t, e.currentValue) ||
            ((e.previousValue = e.currentValue),
            (e.currentValue = t),
            this._addToChanges(e));
        }
        _addToAdditions(e) {
          null === this._additionsHead
            ? (this._additionsHead = this._additionsTail = e)
            : ((this._additionsTail._nextAdded = e), (this._additionsTail = e));
        }
        _addToChanges(e) {
          null === this._changesHead
            ? (this._changesHead = this._changesTail = e)
            : ((this._changesTail._nextChanged = e), (this._changesTail = e));
        }
        _forEach(e, t) {
          e instanceof Map
            ? e.forEach(t)
            : Object.keys(e).forEach((i) => t(e[i], i));
        }
      }
      class C6 {
        constructor(e) {
          (this.key = e),
            (this.previousValue = null),
            (this.currentValue = null),
            (this._nextPrevious = null),
            (this._next = null),
            (this._prev = null),
            (this._nextAdded = null),
            (this._nextRemoved = null),
            (this._nextChanged = null);
        }
      }
      function Z1() {
        return new Xp([new q1()]);
      }
      let Xp = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, i) {
            if (null != i) {
              const r = i.factories.slice();
              t = t.concat(r);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (i) => n.create(t, i || Z1()),
              deps: [[n, new tp(), new ul()]],
            };
          }
          find(t) {
            const i = this.factories.find((r) => r.supports(t));
            if (null != i) return i;
            throw new N(901, !1);
          }
        }
        return (n.ɵprov = ee({ token: n, providedIn: 'root', factory: Z1 })), n;
      })();
      function Q1() {
        return new Xd([new K1()]);
      }
      let Xd = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, i) {
            if (i) {
              const r = i.factories.slice();
              t = t.concat(r);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (i) => n.create(t, i || Q1()),
              deps: [[n, new tp(), new ul()]],
            };
          }
          find(t) {
            const i = this.factories.find((r) => r.supports(t));
            if (i) return i;
            throw new N(901, !1);
          }
        }
        return (n.ɵprov = ee({ token: n, providedIn: 'root', factory: Q1 })), n;
      })();
      const S6 = O1(null, 'core', []);
      let M6 = (() => {
        class n {
          constructor(t) {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(Ko));
          }),
          (n.ɵmod = Ze({ type: n })),
          (n.ɵinj = qe({})),
          n
        );
      })();
      let Dw = null;
      function Gs() {
        return Dw;
      }
      class V6 {}
      const He = new j('DocumentToken');
      let sR = (() => {
          class n {
            historyGo(t) {
              throw new Error('Not implemented');
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = ee({
              token: n,
              factory: function () {
                return Te(B6);
              },
              providedIn: 'platform',
            })),
            n
          );
        })(),
        B6 = (() => {
          class n extends sR {
            constructor() {
              super(),
                (this._doc = Te(He)),
                (this._location = window.location),
                (this._history = window.history);
            }
            getBaseHrefFromDOM() {
              return Gs().getBaseHref(this._doc);
            }
            onPopState(t) {
              const i = Gs().getGlobalEventTarget(this._doc, 'window');
              return (
                i.addEventListener('popstate', t, !1),
                () => i.removeEventListener('popstate', t)
              );
            }
            onHashChange(t) {
              const i = Gs().getGlobalEventTarget(this._doc, 'window');
              return (
                i.addEventListener('hashchange', t, !1),
                () => i.removeEventListener('hashchange', t)
              );
            }
            get href() {
              return this._location.href;
            }
            get protocol() {
              return this._location.protocol;
            }
            get hostname() {
              return this._location.hostname;
            }
            get port() {
              return this._location.port;
            }
            get pathname() {
              return this._location.pathname;
            }
            get search() {
              return this._location.search;
            }
            get hash() {
              return this._location.hash;
            }
            set pathname(t) {
              this._location.pathname = t;
            }
            pushState(t, i, r) {
              this._history.pushState(t, i, r);
            }
            replaceState(t, i, r) {
              this._history.replaceState(t, i, r);
            }
            forward() {
              this._history.forward();
            }
            back() {
              this._history.back();
            }
            historyGo(t = 0) {
              this._history.go(t);
            }
            getState() {
              return this._history.state;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = ee({
              token: n,
              factory: function () {
                return new n();
              },
              providedIn: 'platform',
            })),
            n
          );
        })();
      function oR(n, e) {
        if (0 == n.length) return e;
        if (0 == e.length) return n;
        let t = 0;
        return (
          n.endsWith('/') && t++,
          e.startsWith('/') && t++,
          2 == t ? n + e.substring(1) : 1 == t ? n + e : n + '/' + e
        );
      }
      function aR(n) {
        const e = n.match(/#|\?|$/),
          t = (e && e.index) || n.length;
        return n.slice(0, t - ('/' === n[t - 1] ? 1 : 0)) + n.slice(t);
      }
      function Qo(n) {
        return n && '?' !== n[0] ? '?' + n : n;
      }
      let Tw = (() => {
        class n {
          historyGo(t) {
            throw new Error('Not implemented');
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = ee({
            token: n,
            factory: function () {
              return Te(W6);
            },
            providedIn: 'root',
          })),
          n
        );
      })();
      const H6 = new j('appBaseHref');
      let W6 = (() => {
          class n extends Tw {
            constructor(t, i) {
              super(),
                (this._platformLocation = t),
                (this._removeListenerFns = []),
                (this._baseHref =
                  i ??
                  this._platformLocation.getBaseHrefFromDOM() ??
                  Te(He).location?.origin ??
                  '');
            }
            ngOnDestroy() {
              for (; this._removeListenerFns.length; )
                this._removeListenerFns.pop()();
            }
            onPopState(t) {
              this._removeListenerFns.push(
                this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t)
              );
            }
            getBaseHref() {
              return this._baseHref;
            }
            prepareExternalUrl(t) {
              return oR(this._baseHref, t);
            }
            path(t = !1) {
              const i =
                  this._platformLocation.pathname +
                  Qo(this._platformLocation.search),
                r = this._platformLocation.hash;
              return r && t ? `${i}${r}` : i;
            }
            pushState(t, i, r, s) {
              const o = this.prepareExternalUrl(r + Qo(s));
              this._platformLocation.pushState(t, i, o);
            }
            replaceState(t, i, r, s) {
              const o = this.prepareExternalUrl(r + Qo(s));
              this._platformLocation.replaceState(t, i, o);
            }
            forward() {
              this._platformLocation.forward();
            }
            back() {
              this._platformLocation.back();
            }
            getState() {
              return this._platformLocation.getState();
            }
            historyGo(t = 0) {
              this._platformLocation.historyGo?.(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(sR), L(H6, 8));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        lR = (() => {
          class n {
            constructor(t) {
              (this._subject = new ke()),
                (this._urlChangeListeners = []),
                (this._urlChangeSubscription = null),
                (this._locationStrategy = t);
              const i = this._locationStrategy.getBaseHref();
              (this._basePath = (function U6(n) {
                if (new RegExp('^(https?:)?//').test(n)) {
                  const [, t] = n.split(/\/\/[^\/]+/);
                  return t;
                }
                return n;
              })(aR(cR(i)))),
                this._locationStrategy.onPopState((r) => {
                  this._subject.emit({
                    url: this.path(!0),
                    pop: !0,
                    state: r.state,
                    type: r.type,
                  });
                });
            }
            ngOnDestroy() {
              this._urlChangeSubscription?.unsubscribe(),
                (this._urlChangeListeners = []);
            }
            path(t = !1) {
              return this.normalize(this._locationStrategy.path(t));
            }
            getState() {
              return this._locationStrategy.getState();
            }
            isCurrentPathEqualTo(t, i = '') {
              return this.path() == this.normalize(t + Qo(i));
            }
            normalize(t) {
              return n.stripTrailingSlash(
                (function z6(n, e) {
                  if (!n || !e.startsWith(n)) return e;
                  const t = e.substring(n.length);
                  return '' === t || ['/', ';', '?', '#'].includes(t[0])
                    ? t
                    : e;
                })(this._basePath, cR(t))
              );
            }
            prepareExternalUrl(t) {
              return (
                t && '/' !== t[0] && (t = '/' + t),
                this._locationStrategy.prepareExternalUrl(t)
              );
            }
            go(t, i = '', r = null) {
              this._locationStrategy.pushState(r, '', t, i),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + Qo(i)),
                  r
                );
            }
            replaceState(t, i = '', r = null) {
              this._locationStrategy.replaceState(r, '', t, i),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + Qo(i)),
                  r
                );
            }
            forward() {
              this._locationStrategy.forward();
            }
            back() {
              this._locationStrategy.back();
            }
            historyGo(t = 0) {
              this._locationStrategy.historyGo?.(t);
            }
            onUrlChange(t) {
              return (
                this._urlChangeListeners.push(t),
                this._urlChangeSubscription ||
                  (this._urlChangeSubscription = this.subscribe((i) => {
                    this._notifyUrlChangeListeners(i.url, i.state);
                  })),
                () => {
                  const i = this._urlChangeListeners.indexOf(t);
                  this._urlChangeListeners.splice(i, 1),
                    0 === this._urlChangeListeners.length &&
                      (this._urlChangeSubscription?.unsubscribe(),
                      (this._urlChangeSubscription = null));
                }
              );
            }
            _notifyUrlChangeListeners(t = '', i) {
              this._urlChangeListeners.forEach((r) => r(t, i));
            }
            subscribe(t, i, r) {
              return this._subject.subscribe({
                next: t,
                error: i,
                complete: r,
              });
            }
          }
          return (
            (n.normalizeQueryParams = Qo),
            (n.joinWithSlash = oR),
            (n.stripTrailingSlash = aR),
            (n.ɵfac = function (t) {
              return new (t || n)(L(Tw));
            }),
            (n.ɵprov = ee({
              token: n,
              factory: function () {
                return (function j6() {
                  return new lR(L(Tw));
                })();
              },
              providedIn: 'root',
            })),
            n
          );
        })();
      function cR(n) {
        return n.replace(/\/index.html$/, '');
      }
      const Bw = /\s+/,
        bR = [];
      let Hw = (() => {
        class n {
          constructor(t, i, r, s) {
            (this._iterableDiffers = t),
              (this._keyValueDiffers = i),
              (this._ngEl = r),
              (this._renderer = s),
              (this.initialClasses = bR),
              (this.stateMap = new Map());
          }
          set klass(t) {
            this.initialClasses = null != t ? t.trim().split(Bw) : bR;
          }
          set ngClass(t) {
            this.rawClass = 'string' == typeof t ? t.trim().split(Bw) : t;
          }
          ngDoCheck() {
            for (const i of this.initialClasses) this._updateState(i, !0);
            const t = this.rawClass;
            if (Array.isArray(t) || t instanceof Set)
              for (const i of t) this._updateState(i, !0);
            else if (null != t)
              for (const i of Object.keys(t)) this._updateState(i, !!t[i]);
            this._applyStateDiff();
          }
          _updateState(t, i) {
            const r = this.stateMap.get(t);
            void 0 !== r
              ? (r.enabled !== i && ((r.changed = !0), (r.enabled = i)),
                (r.touched = !0))
              : this.stateMap.set(t, { enabled: i, changed: !0, touched: !0 });
          }
          _applyStateDiff() {
            for (const t of this.stateMap) {
              const i = t[0],
                r = t[1];
              r.changed
                ? (this._toggleClass(i, r.enabled), (r.changed = !1))
                : r.touched ||
                  (r.enabled && this._toggleClass(i, !1),
                  this.stateMap.delete(i)),
                (r.touched = !1);
            }
          }
          _toggleClass(t, i) {
            (t = t.trim()).length > 0 &&
              t.split(Bw).forEach((r) => {
                i
                  ? this._renderer.addClass(this._ngEl.nativeElement, r)
                  : this._renderer.removeClass(this._ngEl.nativeElement, r);
              });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(D(Xp), D(Xd), D(Ne), D(Uo));
          }),
          (n.ɵdir = J({
            type: n,
            selectors: [['', 'ngClass', '']],
            inputs: { klass: ['class', 'klass'], ngClass: 'ngClass' },
            standalone: !0,
          })),
          n
        );
      })();
      class TX {
        constructor(e, t, i, r) {
          (this.$implicit = e),
            (this.ngForOf = t),
            (this.index = i),
            (this.count = r);
        }
        get first() {
          return 0 === this.index;
        }
        get last() {
          return this.index === this.count - 1;
        }
        get even() {
          return this.index % 2 == 0;
        }
        get odd() {
          return !this.even;
        }
      }
      let yR = (() => {
        class n {
          set ngForOf(t) {
            (this._ngForOf = t), (this._ngForOfDirty = !0);
          }
          set ngForTrackBy(t) {
            this._trackByFn = t;
          }
          get ngForTrackBy() {
            return this._trackByFn;
          }
          constructor(t, i, r) {
            (this._viewContainer = t),
              (this._template = i),
              (this._differs = r),
              (this._ngForOf = null),
              (this._ngForOfDirty = !0),
              (this._differ = null);
          }
          set ngForTemplate(t) {
            t && (this._template = t);
          }
          ngDoCheck() {
            if (this._ngForOfDirty) {
              this._ngForOfDirty = !1;
              const t = this._ngForOf;
              !this._differ &&
                t &&
                (this._differ = this._differs
                  .find(t)
                  .create(this.ngForTrackBy));
            }
            if (this._differ) {
              const t = this._differ.diff(this._ngForOf);
              t && this._applyChanges(t);
            }
          }
          _applyChanges(t) {
            const i = this._viewContainer;
            t.forEachOperation((r, s, o) => {
              if (null == r.previousIndex)
                i.createEmbeddedView(
                  this._template,
                  new TX(r.item, this._ngForOf, -1, -1),
                  null === o ? void 0 : o
                );
              else if (null == o) i.remove(null === s ? void 0 : s);
              else if (null !== s) {
                const a = i.get(s);
                i.move(a, o), wR(a, r);
              }
            });
            for (let r = 0, s = i.length; r < s; r++) {
              const a = i.get(r).context;
              (a.index = r), (a.count = s), (a.ngForOf = this._ngForOf);
            }
            t.forEachIdentityChange((r) => {
              wR(i.get(r.currentIndex), r);
            });
          }
          static ngTemplateContextGuard(t, i) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(D($i), D(Nr), D(Xp));
          }),
          (n.ɵdir = J({
            type: n,
            selectors: [['', 'ngFor', '', 'ngForOf', '']],
            inputs: {
              ngForOf: 'ngForOf',
              ngForTrackBy: 'ngForTrackBy',
              ngForTemplate: 'ngForTemplate',
            },
            standalone: !0,
          })),
          n
        );
      })();
      function wR(n, e) {
        n.context.$implicit = e.item;
      }
      let Zd = (() => {
        class n {
          constructor(t, i) {
            (this._viewContainer = t),
              (this._context = new IX()),
              (this._thenTemplateRef = null),
              (this._elseTemplateRef = null),
              (this._thenViewRef = null),
              (this._elseViewRef = null),
              (this._thenTemplateRef = i);
          }
          set ngIf(t) {
            (this._context.$implicit = this._context.ngIf = t),
              this._updateView();
          }
          set ngIfThen(t) {
            ER('ngIfThen', t),
              (this._thenTemplateRef = t),
              (this._thenViewRef = null),
              this._updateView();
          }
          set ngIfElse(t) {
            ER('ngIfElse', t),
              (this._elseTemplateRef = t),
              (this._elseViewRef = null),
              this._updateView();
          }
          _updateView() {
            this._context.$implicit
              ? this._thenViewRef ||
                (this._viewContainer.clear(),
                (this._elseViewRef = null),
                this._thenTemplateRef &&
                  (this._thenViewRef = this._viewContainer.createEmbeddedView(
                    this._thenTemplateRef,
                    this._context
                  )))
              : this._elseViewRef ||
                (this._viewContainer.clear(),
                (this._thenViewRef = null),
                this._elseTemplateRef &&
                  (this._elseViewRef = this._viewContainer.createEmbeddedView(
                    this._elseTemplateRef,
                    this._context
                  )));
          }
          static ngTemplateContextGuard(t, i) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(D($i), D(Nr));
          }),
          (n.ɵdir = J({
            type: n,
            selectors: [['', 'ngIf', '']],
            inputs: {
              ngIf: 'ngIf',
              ngIfThen: 'ngIfThen',
              ngIfElse: 'ngIfElse',
            },
            standalone: !0,
          })),
          n
        );
      })();
      class IX {
        constructor() {
          (this.$implicit = null), (this.ngIf = null);
        }
      }
      function ER(n, e) {
        if (e && !e.createEmbeddedView)
          throw new Error(
            `${n} must be a TemplateRef, but received '${nn(e)}'.`
          );
      }
      class Ww {
        constructor(e, t) {
          (this._viewContainerRef = e),
            (this._templateRef = t),
            (this._created = !1);
        }
        create() {
          (this._created = !0),
            this._viewContainerRef.createEmbeddedView(this._templateRef);
        }
        destroy() {
          (this._created = !1), this._viewContainerRef.clear();
        }
        enforceState(e) {
          e && !this._created
            ? this.create()
            : !e && this._created && this.destroy();
        }
      }
      let Qd = (() => {
          class n {
            constructor() {
              (this._defaultViews = []),
                (this._defaultUsed = !1),
                (this._caseCount = 0),
                (this._lastCaseCheckIndex = 0),
                (this._lastCasesMatched = !1);
            }
            set ngSwitch(t) {
              (this._ngSwitch = t),
                0 === this._caseCount && this._updateDefaultCases(!0);
            }
            _addCase() {
              return this._caseCount++;
            }
            _addDefault(t) {
              this._defaultViews.push(t);
            }
            _matchCase(t) {
              const i = t == this._ngSwitch;
              return (
                (this._lastCasesMatched = this._lastCasesMatched || i),
                this._lastCaseCheckIndex++,
                this._lastCaseCheckIndex === this._caseCount &&
                  (this._updateDefaultCases(!this._lastCasesMatched),
                  (this._lastCaseCheckIndex = 0),
                  (this._lastCasesMatched = !1)),
                i
              );
            }
            _updateDefaultCases(t) {
              if (this._defaultViews.length > 0 && t !== this._defaultUsed) {
                this._defaultUsed = t;
                for (const i of this._defaultViews) i.enforceState(t);
              }
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['', 'ngSwitch', '']],
              inputs: { ngSwitch: 'ngSwitch' },
              standalone: !0,
            })),
            n
          );
        })(),
        jw = (() => {
          class n {
            constructor(t, i, r) {
              (this.ngSwitch = r), r._addCase(), (this._view = new Ww(t, i));
            }
            ngDoCheck() {
              this._view.enforceState(
                this.ngSwitch._matchCase(this.ngSwitchCase)
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D($i), D(Nr), D(Qd, 9));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['', 'ngSwitchCase', '']],
              inputs: { ngSwitchCase: 'ngSwitchCase' },
              standalone: !0,
            })),
            n
          );
        })(),
        CR = (() => {
          class n {
            constructor(t, i, r) {
              r._addDefault(new Ww(t, i));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D($i), D(Nr), D(Qd, 9));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['', 'ngSwitchDefault', '']],
              standalone: !0,
            })),
            n
          );
        })(),
        AR = (() => {
          class n {
            constructor(t) {
              (this._viewContainerRef = t),
                (this._viewRef = null),
                (this.ngTemplateOutletContext = null),
                (this.ngTemplateOutlet = null),
                (this.ngTemplateOutletInjector = null);
            }
            ngOnChanges(t) {
              if (t.ngTemplateOutlet || t.ngTemplateOutletInjector) {
                const i = this._viewContainerRef;
                if (
                  (this._viewRef && i.remove(i.indexOf(this._viewRef)),
                  this.ngTemplateOutlet)
                ) {
                  const {
                    ngTemplateOutlet: r,
                    ngTemplateOutletContext: s,
                    ngTemplateOutletInjector: o,
                  } = this;
                  this._viewRef = i.createEmbeddedView(
                    r,
                    s,
                    o ? { injector: o } : void 0
                  );
                } else this._viewRef = null;
              } else
                this._viewRef &&
                  t.ngTemplateOutletContext &&
                  this.ngTemplateOutletContext &&
                  (this._viewRef.context = this.ngTemplateOutletContext);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D($i));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['', 'ngTemplateOutlet', '']],
              inputs: {
                ngTemplateOutletContext: 'ngTemplateOutletContext',
                ngTemplateOutlet: 'ngTemplateOutlet',
                ngTemplateOutletInjector: 'ngTemplateOutletInjector',
              },
              standalone: !0,
              features: [ri],
            })),
            n
          );
        })(),
        SR = (() => {
          class n {
            transform(t) {
              return JSON.stringify(t, null, 2);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵpipe = ti({ name: 'json', type: n, pure: !1, standalone: !0 })),
            n
          );
        })(),
        Jo = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({})),
            n
          );
        })();
      const DR = 'browser';
      function TR(n) {
        return 'server' === n;
      }
      class DY extends V6 {
        constructor() {
          super(...arguments), (this.supportsDOMEvents = !0);
        }
      }
      class qw extends DY {
        static makeCurrent() {
          !(function N6(n) {
            Dw || (Dw = n);
          })(new qw());
        }
        onAndCancel(e, t, i) {
          return (
            e.addEventListener(t, i),
            () => {
              e.removeEventListener(t, i);
            }
          );
        }
        dispatchEvent(e, t) {
          e.dispatchEvent(t);
        }
        remove(e) {
          e.parentNode && e.parentNode.removeChild(e);
        }
        createElement(e, t) {
          return (t = t || this.getDefaultDocument()).createElement(e);
        }
        createHtmlDocument() {
          return document.implementation.createHTMLDocument('fakeTitle');
        }
        getDefaultDocument() {
          return document;
        }
        isElementNode(e) {
          return e.nodeType === Node.ELEMENT_NODE;
        }
        isShadowRoot(e) {
          return e instanceof DocumentFragment;
        }
        getGlobalEventTarget(e, t) {
          return 'window' === t
            ? window
            : 'document' === t
            ? e
            : 'body' === t
            ? e.body
            : null;
        }
        getBaseHref(e) {
          const t = (function TY() {
            return (
              (eu = eu || document.querySelector('base')),
              eu ? eu.getAttribute('href') : null
            );
          })();
          return null == t
            ? null
            : (function IY(n) {
                (am = am || document.createElement('a')),
                  am.setAttribute('href', n);
                const e = am.pathname;
                return '/' === e.charAt(0) ? e : `/${e}`;
              })(t);
        }
        resetBaseElement() {
          eu = null;
        }
        getUserAgent() {
          return window.navigator.userAgent;
        }
        getCookie(e) {
          return (function MX(n, e) {
            e = encodeURIComponent(e);
            for (const t of n.split(';')) {
              const i = t.indexOf('='),
                [r, s] = -1 == i ? [t, ''] : [t.slice(0, i), t.slice(i + 1)];
              if (r.trim() === e) return decodeURIComponent(s);
            }
            return null;
          })(document.cookie, e);
        }
      }
      let am,
        eu = null,
        PY = (() => {
          class n {
            build() {
              return new XMLHttpRequest();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
            n
          );
        })();
      const Xw = new j('EventManagerPlugins');
      let OR = (() => {
        class n {
          constructor(t, i) {
            (this._zone = i),
              (this._eventNameToPlugin = new Map()),
              t.forEach((r) => {
                r.manager = this;
              }),
              (this._plugins = t.slice().reverse());
          }
          addEventListener(t, i, r) {
            return this._findPluginFor(i).addEventListener(t, i, r);
          }
          getZone() {
            return this._zone;
          }
          _findPluginFor(t) {
            let i = this._eventNameToPlugin.get(t);
            if (i) return i;
            if (((i = this._plugins.find((s) => s.supports(t))), !i))
              throw new N(5101, !1);
            return this._eventNameToPlugin.set(t, i), i;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(Xw), L(ue));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class LR {
        constructor(e) {
          this._doc = e;
        }
      }
      const Yw = 'ng-app-id';
      let NR = (() => {
        class n {
          constructor(t, i, r, s = {}) {
            (this.doc = t),
              (this.appId = i),
              (this.nonce = r),
              (this.platformId = s),
              (this.styleRef = new Map()),
              (this.hostNodes = new Set()),
              (this.styleNodesInDOM = this.collectServerRenderedStyles()),
              (this.platformIsServer = TR(s)),
              this.resetHostNodes();
          }
          addStyles(t) {
            for (const i of t)
              1 === this.changeUsageCount(i, 1) && this.onStyleAdded(i);
          }
          removeStyles(t) {
            for (const i of t)
              this.changeUsageCount(i, -1) <= 0 && this.onStyleRemoved(i);
          }
          ngOnDestroy() {
            const t = this.styleNodesInDOM;
            t && (t.forEach((i) => i.remove()), t.clear());
            for (const i of this.getAllStyles()) this.onStyleRemoved(i);
            this.resetHostNodes();
          }
          addHost(t) {
            this.hostNodes.add(t);
            for (const i of this.getAllStyles()) this.addStyleToHost(t, i);
          }
          removeHost(t) {
            this.hostNodes.delete(t);
          }
          getAllStyles() {
            return this.styleRef.keys();
          }
          onStyleAdded(t) {
            for (const i of this.hostNodes) this.addStyleToHost(i, t);
          }
          onStyleRemoved(t) {
            const i = this.styleRef;
            i.get(t)?.elements?.forEach((r) => r.remove()), i.delete(t);
          }
          collectServerRenderedStyles() {
            const t = this.doc.head?.querySelectorAll(
              `style[${Yw}="${this.appId}"]`
            );
            if (t?.length) {
              const i = new Map();
              return (
                t.forEach((r) => {
                  null != r.textContent && i.set(r.textContent, r);
                }),
                i
              );
            }
            return null;
          }
          changeUsageCount(t, i) {
            const r = this.styleRef;
            if (r.has(t)) {
              const s = r.get(t);
              return (s.usage += i), s.usage;
            }
            return r.set(t, { usage: i, elements: [] }), i;
          }
          getStyleElement(t, i) {
            const r = this.styleNodesInDOM,
              s = r?.get(i);
            if (s?.parentNode === t)
              return r.delete(i), s.removeAttribute(Yw), s;
            {
              const o = this.doc.createElement('style');
              return (
                this.nonce && o.setAttribute('nonce', this.nonce),
                (o.textContent = i),
                this.platformIsServer && o.setAttribute(Yw, this.appId),
                o
              );
            }
          }
          addStyleToHost(t, i) {
            const r = this.getStyleElement(t, i);
            t.appendChild(r);
            const s = this.styleRef,
              o = s.get(i)?.elements;
            o ? o.push(r) : s.set(i, { elements: [r], usage: 1 });
          }
          resetHostNodes() {
            const t = this.hostNodes;
            t.clear(), t.add(this.doc.head);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(He), L(xd), L(ry, 8), L(zo));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const Kw = {
          svg: 'http://www.w3.org/2000/svg',
          xhtml: 'http://www.w3.org/1999/xhtml',
          xlink: 'http://www.w3.org/1999/xlink',
          xml: 'http://www.w3.org/XML/1998/namespace',
          xmlns: 'http://www.w3.org/2000/xmlns/',
          math: 'http://www.w3.org/1998/MathML/',
        },
        Zw = /%COMP%/g,
        LY = new j('RemoveStylesOnCompDestory', {
          providedIn: 'root',
          factory: () => !1,
        });
      function BR(n, e) {
        return e.map((t) => t.replace(Zw, n));
      }
      let Qw = (() => {
        class n {
          constructor(t, i, r, s, o, a, l, c = null) {
            (this.eventManager = t),
              (this.sharedStylesHost = i),
              (this.appId = r),
              (this.removeStylesOnCompDestory = s),
              (this.doc = o),
              (this.platformId = a),
              (this.ngZone = l),
              (this.nonce = c),
              (this.rendererByCompId = new Map()),
              (this.platformIsServer = TR(a)),
              (this.defaultRenderer = new Jw(t, o, l, this.platformIsServer));
          }
          createRenderer(t, i) {
            if (!t || !i) return this.defaultRenderer;
            this.platformIsServer &&
              i.encapsulation === ei.ShadowDom &&
              (i = { ...i, encapsulation: ei.Emulated });
            const r = this.getOrCreateRenderer(t, i);
            return (
              r instanceof WR
                ? r.applyToHost(t)
                : r instanceof e0 && r.applyStyles(),
              r
            );
          }
          getOrCreateRenderer(t, i) {
            const r = this.rendererByCompId;
            let s = r.get(i.id);
            if (!s) {
              const o = this.doc,
                a = this.ngZone,
                l = this.eventManager,
                c = this.sharedStylesHost,
                u = this.removeStylesOnCompDestory,
                h = this.platformIsServer;
              switch (i.encapsulation) {
                case ei.Emulated:
                  s = new WR(l, c, i, this.appId, u, o, a, h);
                  break;
                case ei.ShadowDom:
                  return new HY(l, c, t, i, o, a, this.nonce, h);
                default:
                  s = new e0(l, c, i, u, o, a, h);
              }
              (s.onDestroy = () => r.delete(i.id)), r.set(i.id, s);
            }
            return s;
          }
          ngOnDestroy() {
            this.rendererByCompId.clear();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(
              L(OR),
              L(NR),
              L(xd),
              L(LY),
              L(He),
              L(zo),
              L(ue),
              L(ry)
            );
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class Jw {
        constructor(e, t, i, r) {
          (this.eventManager = e),
            (this.doc = t),
            (this.ngZone = i),
            (this.platformIsServer = r),
            (this.data = Object.create(null)),
            (this.destroyNode = null);
        }
        destroy() {}
        createElement(e, t) {
          return t
            ? this.doc.createElementNS(Kw[t] || t, e)
            : this.doc.createElement(e);
        }
        createComment(e) {
          return this.doc.createComment(e);
        }
        createText(e) {
          return this.doc.createTextNode(e);
        }
        appendChild(e, t) {
          (HR(e) ? e.content : e).appendChild(t);
        }
        insertBefore(e, t, i) {
          e && (HR(e) ? e.content : e).insertBefore(t, i);
        }
        removeChild(e, t) {
          e && e.removeChild(t);
        }
        selectRootElement(e, t) {
          let i = 'string' == typeof e ? this.doc.querySelector(e) : e;
          if (!i) throw new N(5104, !1);
          return t || (i.textContent = ''), i;
        }
        parentNode(e) {
          return e.parentNode;
        }
        nextSibling(e) {
          return e.nextSibling;
        }
        setAttribute(e, t, i, r) {
          if (r) {
            t = r + ':' + t;
            const s = Kw[r];
            s ? e.setAttributeNS(s, t, i) : e.setAttribute(t, i);
          } else e.setAttribute(t, i);
        }
        removeAttribute(e, t, i) {
          if (i) {
            const r = Kw[i];
            r ? e.removeAttributeNS(r, t) : e.removeAttribute(`${i}:${t}`);
          } else e.removeAttribute(t);
        }
        addClass(e, t) {
          e.classList.add(t);
        }
        removeClass(e, t) {
          e.classList.remove(t);
        }
        setStyle(e, t, i, r) {
          r & (oi.DashCase | oi.Important)
            ? e.style.setProperty(t, i, r & oi.Important ? 'important' : '')
            : (e.style[t] = i);
        }
        removeStyle(e, t, i) {
          i & oi.DashCase ? e.style.removeProperty(t) : (e.style[t] = '');
        }
        setProperty(e, t, i) {
          e[t] = i;
        }
        setValue(e, t) {
          e.nodeValue = t;
        }
        listen(e, t, i) {
          if (
            'string' == typeof e &&
            !(e = Gs().getGlobalEventTarget(this.doc, e))
          )
            throw new Error(`Unsupported event target ${e} for event ${t}`);
          return this.eventManager.addEventListener(
            e,
            t,
            this.decoratePreventDefault(i)
          );
        }
        decoratePreventDefault(e) {
          return (t) => {
            if ('__ngUnwrap__' === t) return e;
            !1 ===
              (this.platformIsServer
                ? this.ngZone.runGuarded(() => e(t))
                : e(t)) && t.preventDefault();
          };
        }
      }
      function HR(n) {
        return 'TEMPLATE' === n.tagName && void 0 !== n.content;
      }
      class HY extends Jw {
        constructor(e, t, i, r, s, o, a, l) {
          super(e, s, o, l),
            (this.sharedStylesHost = t),
            (this.hostEl = i),
            (this.shadowRoot = i.attachShadow({ mode: 'open' })),
            this.sharedStylesHost.addHost(this.shadowRoot);
          const c = BR(r.id, r.styles);
          for (const u of c) {
            const h = document.createElement('style');
            a && h.setAttribute('nonce', a),
              (h.textContent = u),
              this.shadowRoot.appendChild(h);
          }
        }
        nodeOrShadowRoot(e) {
          return e === this.hostEl ? this.shadowRoot : e;
        }
        appendChild(e, t) {
          return super.appendChild(this.nodeOrShadowRoot(e), t);
        }
        insertBefore(e, t, i) {
          return super.insertBefore(this.nodeOrShadowRoot(e), t, i);
        }
        removeChild(e, t) {
          return super.removeChild(this.nodeOrShadowRoot(e), t);
        }
        parentNode(e) {
          return this.nodeOrShadowRoot(
            super.parentNode(this.nodeOrShadowRoot(e))
          );
        }
        destroy() {
          this.sharedStylesHost.removeHost(this.shadowRoot);
        }
      }
      class e0 extends Jw {
        constructor(e, t, i, r, s, o, a, l) {
          super(e, s, o, a),
            (this.sharedStylesHost = t),
            (this.removeStylesOnCompDestory = r),
            (this.rendererUsageCount = 0),
            (this.styles = l ? BR(l, i.styles) : i.styles);
        }
        applyStyles() {
          this.sharedStylesHost.addStyles(this.styles),
            this.rendererUsageCount++;
        }
        destroy() {
          this.removeStylesOnCompDestory &&
            (this.sharedStylesHost.removeStyles(this.styles),
            this.rendererUsageCount--,
            0 === this.rendererUsageCount && this.onDestroy?.());
        }
      }
      class WR extends e0 {
        constructor(e, t, i, r, s, o, a, l) {
          const c = r + '-' + i.id;
          super(e, t, i, s, o, a, l, c),
            (this.contentAttr = (function NY(n) {
              return '_ngcontent-%COMP%'.replace(Zw, n);
            })(c)),
            (this.hostAttr = (function VY(n) {
              return '_nghost-%COMP%'.replace(Zw, n);
            })(c));
        }
        applyToHost(e) {
          this.applyStyles(), this.setAttribute(e, this.hostAttr, '');
        }
        createElement(e, t) {
          const i = super.createElement(e, t);
          return super.setAttribute(i, this.contentAttr, ''), i;
        }
      }
      let WY = (() => {
        class n extends LR {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return !0;
          }
          addEventListener(t, i, r) {
            return (
              t.addEventListener(i, r, !1),
              () => this.removeEventListener(t, i, r)
            );
          }
          removeEventListener(t, i, r) {
            return t.removeEventListener(i, r);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(He));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const jR = ['alt', 'control', 'meta', 'shift'],
        jY = {
          '\b': 'Backspace',
          '\t': 'Tab',
          '\x7f': 'Delete',
          '\x1b': 'Escape',
          Del: 'Delete',
          Esc: 'Escape',
          Left: 'ArrowLeft',
          Right: 'ArrowRight',
          Up: 'ArrowUp',
          Down: 'ArrowDown',
          Menu: 'ContextMenu',
          Scroll: 'ScrollLock',
          Win: 'OS',
        },
        zY = {
          alt: (n) => n.altKey,
          control: (n) => n.ctrlKey,
          meta: (n) => n.metaKey,
          shift: (n) => n.shiftKey,
        };
      let UY = (() => {
        class n extends LR {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return null != n.parseEventName(t);
          }
          addEventListener(t, i, r) {
            const s = n.parseEventName(i),
              o = n.eventCallback(s.fullKey, r, this.manager.getZone());
            return this.manager
              .getZone()
              .runOutsideAngular(() => Gs().onAndCancel(t, s.domEventName, o));
          }
          static parseEventName(t) {
            const i = t.toLowerCase().split('.'),
              r = i.shift();
            if (0 === i.length || ('keydown' !== r && 'keyup' !== r))
              return null;
            const s = n._normalizeKey(i.pop());
            let o = '',
              a = i.indexOf('code');
            if (
              (a > -1 && (i.splice(a, 1), (o = 'code.')),
              jR.forEach((c) => {
                const u = i.indexOf(c);
                u > -1 && (i.splice(u, 1), (o += c + '.'));
              }),
              (o += s),
              0 != i.length || 0 === s.length)
            )
              return null;
            const l = {};
            return (l.domEventName = r), (l.fullKey = o), l;
          }
          static matchEventFullKeyCode(t, i) {
            let r = jY[t.key] || t.key,
              s = '';
            return (
              i.indexOf('code.') > -1 && ((r = t.code), (s = 'code.')),
              !(null == r || !r) &&
                ((r = r.toLowerCase()),
                ' ' === r ? (r = 'space') : '.' === r && (r = 'dot'),
                jR.forEach((o) => {
                  o !== r && (0, zY[o])(t) && (s += o + '.');
                }),
                (s += r),
                s === i)
            );
          }
          static eventCallback(t, i, r) {
            return (s) => {
              n.matchEventFullKeyCode(s, t) && r.runGuarded(() => i(s));
            };
          }
          static _normalizeKey(t) {
            return 'esc' === t ? 'escape' : t;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(He));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const XY = O1(S6, 'browser', [
          { provide: zo, useValue: DR },
          {
            provide: JT,
            useValue: function $Y() {
              qw.makeCurrent();
            },
            multi: !0,
          },
          {
            provide: He,
            useFactory: function qY() {
              return (
                (function X3(n) {
                  $v = n;
                })(document),
                document
              );
            },
            deps: [],
          },
        ]),
        YY = new j(''),
        $R = [
          {
            provide: Up,
            useClass: class kY {
              addToWindow(e) {
                (yt.getAngularTestability = (i, r = !0) => {
                  const s = e.findTestabilityInTree(i, r);
                  if (null == s) throw new N(5103, !1);
                  return s;
                }),
                  (yt.getAllAngularTestabilities = () =>
                    e.getAllTestabilities()),
                  (yt.getAllAngularRootElements = () => e.getAllRootElements()),
                  yt.frameworkStabilizers || (yt.frameworkStabilizers = []),
                  yt.frameworkStabilizers.push((i) => {
                    const r = yt.getAllAngularTestabilities();
                    let s = r.length,
                      o = !1;
                    const a = function (l) {
                      (o = o || l), s--, 0 == s && i(o);
                    };
                    r.forEach(function (l) {
                      l.whenStable(a);
                    });
                  });
              }
              findTestabilityInTree(e, t, i) {
                return null == t
                  ? null
                  : e.getTestability(t) ??
                      (i
                        ? Gs().isShadowRoot(t)
                          ? this.findTestabilityInTree(e, t.host, !0)
                          : this.findTestabilityInTree(e, t.parentElement, !0)
                        : null);
              }
            },
            deps: [],
          },
          { provide: I1, useClass: gw, deps: [ue, _w, Up] },
          { provide: gw, useClass: gw, deps: [ue, _w, Up] },
        ],
        GR = [
          { provide: Jv, useValue: 'root' },
          {
            provide: Pr,
            useFactory: function GY() {
              return new Pr();
            },
            deps: [],
          },
          { provide: Xw, useClass: WY, multi: !0, deps: [He, ue, zo] },
          { provide: Xw, useClass: UY, multi: !0, deps: [He] },
          Qw,
          NR,
          OR,
          { provide: Td, useExisting: Qw },
          { provide: class sY {}, useClass: PY, deps: [] },
          [],
        ];
      let qR = (() => {
        class n {
          constructor(t) {}
          static withServerTransition(t) {
            return {
              ngModule: n,
              providers: [{ provide: xd, useValue: t.appId }],
            };
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(YY, 12));
          }),
          (n.ɵmod = Ze({ type: n })),
          (n.ɵinj = qe({ providers: [...GR, ...$R], imports: [Jo, M6] })),
          n
        );
      })();
      typeof window < 'u' && window;
      let n0 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = ee({
              token: n,
              factory: function (t) {
                let i = null;
                return (i = t ? new (t || n)() : L(KR)), i;
              },
              providedIn: 'root',
            })),
            n
          );
        })(),
        KR = (() => {
          class n extends n0 {
            constructor(t) {
              super(), (this._doc = t);
            }
            sanitize(t, i) {
              if (null == i) return null;
              switch (t) {
                case rt.NONE:
                  return i;
                case rt.HTML:
                  return kr(i, 'HTML')
                    ? Ti(i)
                    : WT(this._doc, String(i)).toString();
                case rt.STYLE:
                  return kr(i, 'Style') ? Ti(i) : i;
                case rt.SCRIPT:
                  if (kr(i, 'Script')) return Ti(i);
                  throw new N(5200, !1);
                case rt.URL:
                  return kr(i, 'URL') ? Ti(i) : pp(String(i));
                case rt.RESOURCE_URL:
                  if (kr(i, 'ResourceURL')) return Ti(i);
                  throw new N(5201, !1);
                default:
                  throw new N(5202, !1);
              }
            }
            bypassSecurityTrustHtml(t) {
              return (function t$(n) {
                return new Y3(n);
              })(t);
            }
            bypassSecurityTrustStyle(t) {
              return (function n$(n) {
                return new K3(n);
              })(t);
            }
            bypassSecurityTrustScript(t) {
              return (function i$(n) {
                return new Z3(n);
              })(t);
            }
            bypassSecurityTrustUrl(t) {
              return (function r$(n) {
                return new Q3(n);
              })(t);
            }
            bypassSecurityTrustResourceUrl(t) {
              return (function s$(n) {
                return new J3(n);
              })(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(He));
            }),
            (n.ɵprov = ee({
              token: n,
              factory: function (t) {
                let i = null;
                return (
                  (i = t
                    ? new t()
                    : (function tK(n) {
                        return new KR(n.get(He));
                      })(L(nr))),
                  i
                );
              },
              providedIn: 'root',
            })),
            n
          );
        })();
      const { isArray: nK } = Array,
        { getPrototypeOf: iK, prototype: rK, keys: sK } = Object;
      function QR(n) {
        if (1 === n.length) {
          const e = n[0];
          if (nK(e)) return { args: e, keys: null };
          if (
            (function oK(n) {
              return n && 'object' == typeof n && iK(n) === rK;
            })(e)
          ) {
            const t = sK(e);
            return { args: t.map((i) => e[i]), keys: t };
          }
        }
        return { args: n, keys: null };
      }
      const { isArray: aK } = Array;
      function r0(n) {
        return Gt((e) =>
          (function lK(n, e) {
            return aK(e) ? n(...e) : n(e);
          })(n, e)
        );
      }
      function JR(n, e) {
        return n.reduce((t, i, r) => ((t[i] = e[r]), t), {});
      }
      function eF(...n) {
        const e = MM(n),
          { args: t, keys: i } = QR(n),
          r = new Mt((s) => {
            const { length: o } = t;
            if (!o) return void s.complete();
            const a = new Array(o);
            let l = o,
              c = o;
            for (let u = 0; u < o; u++) {
              let h = !1;
              Bn(t[u]).subscribe(
                hn(
                  s,
                  (f) => {
                    h || ((h = !0), c--), (a[u] = f);
                  },
                  () => l--,
                  void 0,
                  () => {
                    (!l || !h) && (c || s.next(i ? JR(i, a) : a), s.complete());
                  }
                )
              );
            }
          });
        return e ? r.pipe(r0(e)) : r;
      }
      let tF = (() => {
          class n {
            constructor(t, i) {
              (this._renderer = t),
                (this._elementRef = i),
                (this.onChange = (r) => {}),
                (this.onTouched = () => {});
            }
            setProperty(t, i) {
              this._renderer.setProperty(this._elementRef.nativeElement, t, i);
            }
            registerOnTouched(t) {
              this.onTouched = t;
            }
            registerOnChange(t) {
              this.onChange = t;
            }
            setDisabledState(t) {
              this.setProperty('disabled', t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Uo), D(Ne));
            }),
            (n.ɵdir = J({ type: n })),
            n
          );
        })(),
        ea = (() => {
          class n extends tF {}
          return (
            (n.ɵfac = (function () {
              let e;
              return function (i) {
                return (e || (e = pn(n)))(i || n);
              };
            })()),
            (n.ɵdir = J({ type: n, features: [ye] })),
            n
          );
        })();
      const lr = new j('NgValueAccessor'),
        dK = { provide: lr, useExisting: mt(() => lm), multi: !0 },
        hK = new j('CompositionEventMode');
      let lm = (() => {
        class n extends tF {
          constructor(t, i, r) {
            super(t, i),
              (this._compositionMode = r),
              (this._composing = !1),
              null == this._compositionMode &&
                (this._compositionMode = !(function uK() {
                  const n = Gs() ? Gs().getUserAgent() : '';
                  return /android (\d+)/.test(n.toLowerCase());
                })());
          }
          writeValue(t) {
            this.setProperty('value', t ?? '');
          }
          _handleInput(t) {
            (!this._compositionMode ||
              (this._compositionMode && !this._composing)) &&
              this.onChange(t);
          }
          _compositionStart() {
            this._composing = !0;
          }
          _compositionEnd(t) {
            (this._composing = !1), this._compositionMode && this.onChange(t);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(D(Uo), D(Ne), D(hK, 8));
          }),
          (n.ɵdir = J({
            type: n,
            selectors: [
              ['input', 'formControlName', '', 3, 'type', 'checkbox'],
              ['textarea', 'formControlName', ''],
              ['input', 'formControl', '', 3, 'type', 'checkbox'],
              ['textarea', 'formControl', ''],
              ['input', 'ngModel', '', 3, 'type', 'checkbox'],
              ['textarea', 'ngModel', ''],
              ['', 'ngDefaultControl', ''],
            ],
            hostBindings: function (t, i) {
              1 & t &&
                pe('input', function (s) {
                  return i._handleInput(s.target.value);
                })('blur', function () {
                  return i.onTouched();
                })('compositionstart', function () {
                  return i._compositionStart();
                })('compositionend', function (s) {
                  return i._compositionEnd(s.target.value);
                });
            },
            features: [tt([dK]), ye],
          })),
          n
        );
      })();
      function Xs(n) {
        return (
          null == n ||
          (('string' == typeof n || Array.isArray(n)) && 0 === n.length)
        );
      }
      function iF(n) {
        return null != n && 'number' == typeof n.length;
      }
      const yn = new j('NgValidators'),
        Ys = new j('NgAsyncValidators'),
        fK =
          /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
      class rF {
        static min(e) {
          return (function sF(n) {
            return (e) => {
              if (Xs(e.value) || Xs(n)) return null;
              const t = parseFloat(e.value);
              return !isNaN(t) && t < n
                ? { min: { min: n, actual: e.value } }
                : null;
            };
          })(e);
        }
        static max(e) {
          return (function oF(n) {
            return (e) => {
              if (Xs(e.value) || Xs(n)) return null;
              const t = parseFloat(e.value);
              return !isNaN(t) && t > n
                ? { max: { max: n, actual: e.value } }
                : null;
            };
          })(e);
        }
        static required(e) {
          return (function aF(n) {
            return Xs(n.value) ? { required: !0 } : null;
          })(e);
        }
        static requiredTrue(e) {
          return (function lF(n) {
            return !0 === n.value ? null : { required: !0 };
          })(e);
        }
        static email(e) {
          return (function cF(n) {
            return Xs(n.value) || fK.test(n.value) ? null : { email: !0 };
          })(e);
        }
        static minLength(e) {
          return (function dF(n) {
            return (e) =>
              Xs(e.value) || !iF(e.value)
                ? null
                : e.value.length < n
                ? {
                    minlength: {
                      requiredLength: n,
                      actualLength: e.value.length,
                    },
                  }
                : null;
          })(e);
        }
        static maxLength(e) {
          return (function uF(n) {
            return (e) =>
              iF(e.value) && e.value.length > n
                ? {
                    maxlength: {
                      requiredLength: n,
                      actualLength: e.value.length,
                    },
                  }
                : null;
          })(e);
        }
        static pattern(e) {
          return hF(e);
        }
        static nullValidator(e) {
          return null;
        }
        static compose(e) {
          return bF(e);
        }
        static composeAsync(e) {
          return vF(e);
        }
      }
      function hF(n) {
        if (!n) return cm;
        let e, t;
        return (
          'string' == typeof n
            ? ((t = ''),
              '^' !== n.charAt(0) && (t += '^'),
              (t += n),
              '$' !== n.charAt(n.length - 1) && (t += '$'),
              (e = new RegExp(t)))
            : ((t = n.toString()), (e = n)),
          (i) => {
            if (Xs(i.value)) return null;
            const r = i.value;
            return e.test(r)
              ? null
              : { pattern: { requiredPattern: t, actualValue: r } };
          }
        );
      }
      function cm(n) {
        return null;
      }
      function fF(n) {
        return null != n;
      }
      function pF(n) {
        return Op(n) ? Vs(n) : n;
      }
      function mF(n) {
        let e = {};
        return (
          n.forEach((t) => {
            e = null != t ? { ...e, ...t } : e;
          }),
          0 === Object.keys(e).length ? null : e
        );
      }
      function gF(n, e) {
        return e.map((t) => t(n));
      }
      function _F(n) {
        return n.map((e) =>
          (function pK(n) {
            return !n.validate;
          })(e)
            ? e
            : (t) => e.validate(t)
        );
      }
      function bF(n) {
        if (!n) return null;
        const e = n.filter(fF);
        return 0 == e.length
          ? null
          : function (t) {
              return mF(gF(t, e));
            };
      }
      function s0(n) {
        return null != n ? bF(_F(n)) : null;
      }
      function vF(n) {
        if (!n) return null;
        const e = n.filter(fF);
        return 0 == e.length
          ? null
          : function (t) {
              return eF(gF(t, e).map(pF)).pipe(Gt(mF));
            };
      }
      function o0(n) {
        return null != n ? vF(_F(n)) : null;
      }
      function yF(n, e) {
        return null === n ? [e] : Array.isArray(n) ? [...n, e] : [n, e];
      }
      function wF(n) {
        return n._rawValidators;
      }
      function EF(n) {
        return n._rawAsyncValidators;
      }
      function a0(n) {
        return n ? (Array.isArray(n) ? n : [n]) : [];
      }
      function dm(n, e) {
        return Array.isArray(n) ? n.includes(e) : n === e;
      }
      function CF(n, e) {
        const t = a0(e);
        return (
          a0(n).forEach((r) => {
            dm(t, r) || t.push(r);
          }),
          t
        );
      }
      function xF(n, e) {
        return a0(e).filter((t) => !dm(n, t));
      }
      class AF {
        constructor() {
          (this._rawValidators = []),
            (this._rawAsyncValidators = []),
            (this._onDestroyCallbacks = []);
        }
        get value() {
          return this.control ? this.control.value : null;
        }
        get valid() {
          return this.control ? this.control.valid : null;
        }
        get invalid() {
          return this.control ? this.control.invalid : null;
        }
        get pending() {
          return this.control ? this.control.pending : null;
        }
        get disabled() {
          return this.control ? this.control.disabled : null;
        }
        get enabled() {
          return this.control ? this.control.enabled : null;
        }
        get errors() {
          return this.control ? this.control.errors : null;
        }
        get pristine() {
          return this.control ? this.control.pristine : null;
        }
        get dirty() {
          return this.control ? this.control.dirty : null;
        }
        get touched() {
          return this.control ? this.control.touched : null;
        }
        get status() {
          return this.control ? this.control.status : null;
        }
        get untouched() {
          return this.control ? this.control.untouched : null;
        }
        get statusChanges() {
          return this.control ? this.control.statusChanges : null;
        }
        get valueChanges() {
          return this.control ? this.control.valueChanges : null;
        }
        get path() {
          return null;
        }
        _setValidators(e) {
          (this._rawValidators = e || []),
            (this._composedValidatorFn = s0(this._rawValidators));
        }
        _setAsyncValidators(e) {
          (this._rawAsyncValidators = e || []),
            (this._composedAsyncValidatorFn = o0(this._rawAsyncValidators));
        }
        get validator() {
          return this._composedValidatorFn || null;
        }
        get asyncValidator() {
          return this._composedAsyncValidatorFn || null;
        }
        _registerOnDestroy(e) {
          this._onDestroyCallbacks.push(e);
        }
        _invokeOnDestroyCallbacks() {
          this._onDestroyCallbacks.forEach((e) => e()),
            (this._onDestroyCallbacks = []);
        }
        reset(e = void 0) {
          this.control && this.control.reset(e);
        }
        hasError(e, t) {
          return !!this.control && this.control.hasError(e, t);
        }
        getError(e, t) {
          return this.control ? this.control.getError(e, t) : null;
        }
      }
      class Gn extends AF {
        get formDirective() {
          return null;
        }
        get path() {
          return null;
        }
      }
      class Hr extends AF {
        constructor() {
          super(...arguments),
            (this._parent = null),
            (this.name = null),
            (this.valueAccessor = null);
        }
      }
      class SF {
        constructor(e) {
          this._cd = e;
        }
        get isTouched() {
          return !!this._cd?.control?.touched;
        }
        get isUntouched() {
          return !!this._cd?.control?.untouched;
        }
        get isPristine() {
          return !!this._cd?.control?.pristine;
        }
        get isDirty() {
          return !!this._cd?.control?.dirty;
        }
        get isValid() {
          return !!this._cd?.control?.valid;
        }
        get isInvalid() {
          return !!this._cd?.control?.invalid;
        }
        get isPending() {
          return !!this._cd?.control?.pending;
        }
        get isSubmitted() {
          return !!this._cd?.submitted;
        }
      }
      let MF = (() => {
        class n extends SF {
          constructor(t) {
            super(t);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(D(Hr, 2));
          }),
          (n.ɵdir = J({
            type: n,
            selectors: [
              ['', 'formControlName', ''],
              ['', 'ngModel', ''],
              ['', 'formControl', ''],
            ],
            hostVars: 14,
            hostBindings: function (t, i) {
              2 & t &&
                _t('ng-untouched', i.isUntouched)('ng-touched', i.isTouched)(
                  'ng-pristine',
                  i.isPristine
                )('ng-dirty', i.isDirty)('ng-valid', i.isValid)(
                  'ng-invalid',
                  i.isInvalid
                )('ng-pending', i.isPending);
            },
            features: [ye],
          })),
          n
        );
      })();
      const tu = 'VALID',
        hm = 'INVALID',
        Wl = 'PENDING',
        nu = 'DISABLED';
      function d0(n) {
        return (fm(n) ? n.validators : n) || null;
      }
      function u0(n, e) {
        return (fm(e) ? e.asyncValidators : n) || null;
      }
      function fm(n) {
        return null != n && !Array.isArray(n) && 'object' == typeof n;
      }
      class kF {
        constructor(e, t) {
          (this._pendingDirty = !1),
            (this._hasOwnPendingAsyncValidator = !1),
            (this._pendingTouched = !1),
            (this._onCollectionChange = () => {}),
            (this._parent = null),
            (this.pristine = !0),
            (this.touched = !1),
            (this._onDisabledChange = []),
            this._assignValidators(e),
            this._assignAsyncValidators(t);
        }
        get validator() {
          return this._composedValidatorFn;
        }
        set validator(e) {
          this._rawValidators = this._composedValidatorFn = e;
        }
        get asyncValidator() {
          return this._composedAsyncValidatorFn;
        }
        set asyncValidator(e) {
          this._rawAsyncValidators = this._composedAsyncValidatorFn = e;
        }
        get parent() {
          return this._parent;
        }
        get valid() {
          return this.status === tu;
        }
        get invalid() {
          return this.status === hm;
        }
        get pending() {
          return this.status == Wl;
        }
        get disabled() {
          return this.status === nu;
        }
        get enabled() {
          return this.status !== nu;
        }
        get dirty() {
          return !this.pristine;
        }
        get untouched() {
          return !this.touched;
        }
        get updateOn() {
          return this._updateOn
            ? this._updateOn
            : this.parent
            ? this.parent.updateOn
            : 'change';
        }
        setValidators(e) {
          this._assignValidators(e);
        }
        setAsyncValidators(e) {
          this._assignAsyncValidators(e);
        }
        addValidators(e) {
          this.setValidators(CF(e, this._rawValidators));
        }
        addAsyncValidators(e) {
          this.setAsyncValidators(CF(e, this._rawAsyncValidators));
        }
        removeValidators(e) {
          this.setValidators(xF(e, this._rawValidators));
        }
        removeAsyncValidators(e) {
          this.setAsyncValidators(xF(e, this._rawAsyncValidators));
        }
        hasValidator(e) {
          return dm(this._rawValidators, e);
        }
        hasAsyncValidator(e) {
          return dm(this._rawAsyncValidators, e);
        }
        clearValidators() {
          this.validator = null;
        }
        clearAsyncValidators() {
          this.asyncValidator = null;
        }
        markAsTouched(e = {}) {
          (this.touched = !0),
            this._parent && !e.onlySelf && this._parent.markAsTouched(e);
        }
        markAllAsTouched() {
          this.markAsTouched({ onlySelf: !0 }),
            this._forEachChild((e) => e.markAllAsTouched());
        }
        markAsUntouched(e = {}) {
          (this.touched = !1),
            (this._pendingTouched = !1),
            this._forEachChild((t) => {
              t.markAsUntouched({ onlySelf: !0 });
            }),
            this._parent && !e.onlySelf && this._parent._updateTouched(e);
        }
        markAsDirty(e = {}) {
          (this.pristine = !1),
            this._parent && !e.onlySelf && this._parent.markAsDirty(e);
        }
        markAsPristine(e = {}) {
          (this.pristine = !0),
            (this._pendingDirty = !1),
            this._forEachChild((t) => {
              t.markAsPristine({ onlySelf: !0 });
            }),
            this._parent && !e.onlySelf && this._parent._updatePristine(e);
        }
        markAsPending(e = {}) {
          (this.status = Wl),
            !1 !== e.emitEvent && this.statusChanges.emit(this.status),
            this._parent && !e.onlySelf && this._parent.markAsPending(e);
        }
        disable(e = {}) {
          const t = this._parentMarkedDirty(e.onlySelf);
          (this.status = nu),
            (this.errors = null),
            this._forEachChild((i) => {
              i.disable({ ...e, onlySelf: !0 });
            }),
            this._updateValue(),
            !1 !== e.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._updateAncestors({ ...e, skipPristineCheck: t }),
            this._onDisabledChange.forEach((i) => i(!0));
        }
        enable(e = {}) {
          const t = this._parentMarkedDirty(e.onlySelf);
          (this.status = tu),
            this._forEachChild((i) => {
              i.enable({ ...e, onlySelf: !0 });
            }),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: e.emitEvent,
            }),
            this._updateAncestors({ ...e, skipPristineCheck: t }),
            this._onDisabledChange.forEach((i) => i(!1));
        }
        _updateAncestors(e) {
          this._parent &&
            !e.onlySelf &&
            (this._parent.updateValueAndValidity(e),
            e.skipPristineCheck || this._parent._updatePristine(),
            this._parent._updateTouched());
        }
        setParent(e) {
          this._parent = e;
        }
        getRawValue() {
          return this.value;
        }
        updateValueAndValidity(e = {}) {
          this._setInitialStatus(),
            this._updateValue(),
            this.enabled &&
              (this._cancelExistingSubscription(),
              (this.errors = this._runValidator()),
              (this.status = this._calculateStatus()),
              (this.status === tu || this.status === Wl) &&
                this._runAsyncValidator(e.emitEvent)),
            !1 !== e.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._parent &&
              !e.onlySelf &&
              this._parent.updateValueAndValidity(e);
        }
        _updateTreeValidity(e = { emitEvent: !0 }) {
          this._forEachChild((t) => t._updateTreeValidity(e)),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: e.emitEvent,
            });
        }
        _setInitialStatus() {
          this.status = this._allControlsDisabled() ? nu : tu;
        }
        _runValidator() {
          return this.validator ? this.validator(this) : null;
        }
        _runAsyncValidator(e) {
          if (this.asyncValidator) {
            (this.status = Wl), (this._hasOwnPendingAsyncValidator = !0);
            const t = pF(this.asyncValidator(this));
            this._asyncValidationSubscription = t.subscribe((i) => {
              (this._hasOwnPendingAsyncValidator = !1),
                this.setErrors(i, { emitEvent: e });
            });
          }
        }
        _cancelExistingSubscription() {
          this._asyncValidationSubscription &&
            (this._asyncValidationSubscription.unsubscribe(),
            (this._hasOwnPendingAsyncValidator = !1));
        }
        setErrors(e, t = {}) {
          (this.errors = e), this._updateControlsErrors(!1 !== t.emitEvent);
        }
        get(e) {
          let t = e;
          return null == t ||
            (Array.isArray(t) || (t = t.split('.')), 0 === t.length)
            ? null
            : t.reduce((i, r) => i && i._find(r), this);
        }
        getError(e, t) {
          const i = t ? this.get(t) : this;
          return i && i.errors ? i.errors[e] : null;
        }
        hasError(e, t) {
          return !!this.getError(e, t);
        }
        get root() {
          let e = this;
          for (; e._parent; ) e = e._parent;
          return e;
        }
        _updateControlsErrors(e) {
          (this.status = this._calculateStatus()),
            e && this.statusChanges.emit(this.status),
            this._parent && this._parent._updateControlsErrors(e);
        }
        _initObservables() {
          (this.valueChanges = new ke()), (this.statusChanges = new ke());
        }
        _calculateStatus() {
          return this._allControlsDisabled()
            ? nu
            : this.errors
            ? hm
            : this._hasOwnPendingAsyncValidator ||
              this._anyControlsHaveStatus(Wl)
            ? Wl
            : this._anyControlsHaveStatus(hm)
            ? hm
            : tu;
        }
        _anyControlsHaveStatus(e) {
          return this._anyControls((t) => t.status === e);
        }
        _anyControlsDirty() {
          return this._anyControls((e) => e.dirty);
        }
        _anyControlsTouched() {
          return this._anyControls((e) => e.touched);
        }
        _updatePristine(e = {}) {
          (this.pristine = !this._anyControlsDirty()),
            this._parent && !e.onlySelf && this._parent._updatePristine(e);
        }
        _updateTouched(e = {}) {
          (this.touched = this._anyControlsTouched()),
            this._parent && !e.onlySelf && this._parent._updateTouched(e);
        }
        _registerOnCollectionChange(e) {
          this._onCollectionChange = e;
        }
        _setUpdateStrategy(e) {
          fm(e) && null != e.updateOn && (this._updateOn = e.updateOn);
        }
        _parentMarkedDirty(e) {
          return (
            !e &&
            !(!this._parent || !this._parent.dirty) &&
            !this._parent._anyControlsDirty()
          );
        }
        _find(e) {
          return null;
        }
        _assignValidators(e) {
          (this._rawValidators = Array.isArray(e) ? e.slice() : e),
            (this._composedValidatorFn = (function vK(n) {
              return Array.isArray(n) ? s0(n) : n || null;
            })(this._rawValidators));
        }
        _assignAsyncValidators(e) {
          (this._rawAsyncValidators = Array.isArray(e) ? e.slice() : e),
            (this._composedAsyncValidatorFn = (function yK(n) {
              return Array.isArray(n) ? o0(n) : n || null;
            })(this._rawAsyncValidators));
        }
      }
      class h0 extends kF {
        constructor(e, t, i) {
          super(d0(t), u0(i, t)),
            (this.controls = e),
            this._initObservables(),
            this._setUpdateStrategy(t),
            this._setUpControls(),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: !!this.asyncValidator,
            });
        }
        registerControl(e, t) {
          return this.controls[e]
            ? this.controls[e]
            : ((this.controls[e] = t),
              t.setParent(this),
              t._registerOnCollectionChange(this._onCollectionChange),
              t);
        }
        addControl(e, t, i = {}) {
          this.registerControl(e, t),
            this.updateValueAndValidity({ emitEvent: i.emitEvent }),
            this._onCollectionChange();
        }
        removeControl(e, t = {}) {
          this.controls[e] &&
            this.controls[e]._registerOnCollectionChange(() => {}),
            delete this.controls[e],
            this.updateValueAndValidity({ emitEvent: t.emitEvent }),
            this._onCollectionChange();
        }
        setControl(e, t, i = {}) {
          this.controls[e] &&
            this.controls[e]._registerOnCollectionChange(() => {}),
            delete this.controls[e],
            t && this.registerControl(e, t),
            this.updateValueAndValidity({ emitEvent: i.emitEvent }),
            this._onCollectionChange();
        }
        contains(e) {
          return this.controls.hasOwnProperty(e) && this.controls[e].enabled;
        }
        setValue(e, t = {}) {
          (function IF(n, e, t) {
            n._forEachChild((i, r) => {
              if (void 0 === t[r]) throw new N(1002, '');
            });
          })(this, 0, e),
            Object.keys(e).forEach((i) => {
              (function TF(n, e, t) {
                const i = n.controls;
                if (!(e ? Object.keys(i) : i).length) throw new N(1e3, '');
                if (!i[t]) throw new N(1001, '');
              })(this, !0, i),
                this.controls[i].setValue(e[i], {
                  onlySelf: !0,
                  emitEvent: t.emitEvent,
                });
            }),
            this.updateValueAndValidity(t);
        }
        patchValue(e, t = {}) {
          null != e &&
            (Object.keys(e).forEach((i) => {
              const r = this.controls[i];
              r && r.patchValue(e[i], { onlySelf: !0, emitEvent: t.emitEvent });
            }),
            this.updateValueAndValidity(t));
        }
        reset(e = {}, t = {}) {
          this._forEachChild((i, r) => {
            i.reset(e[r], { onlySelf: !0, emitEvent: t.emitEvent });
          }),
            this._updatePristine(t),
            this._updateTouched(t),
            this.updateValueAndValidity(t);
        }
        getRawValue() {
          return this._reduceChildren(
            {},
            (e, t, i) => ((e[i] = t.getRawValue()), e)
          );
        }
        _syncPendingControls() {
          let e = this._reduceChildren(
            !1,
            (t, i) => !!i._syncPendingControls() || t
          );
          return e && this.updateValueAndValidity({ onlySelf: !0 }), e;
        }
        _forEachChild(e) {
          Object.keys(this.controls).forEach((t) => {
            const i = this.controls[t];
            i && e(i, t);
          });
        }
        _setUpControls() {
          this._forEachChild((e) => {
            e.setParent(this),
              e._registerOnCollectionChange(this._onCollectionChange);
          });
        }
        _updateValue() {
          this.value = this._reduceValue();
        }
        _anyControls(e) {
          for (const [t, i] of Object.entries(this.controls))
            if (this.contains(t) && e(i)) return !0;
          return !1;
        }
        _reduceValue() {
          return this._reduceChildren(
            {},
            (t, i, r) => ((i.enabled || this.disabled) && (t[r] = i.value), t)
          );
        }
        _reduceChildren(e, t) {
          let i = e;
          return (
            this._forEachChild((r, s) => {
              i = t(i, r, s);
            }),
            i
          );
        }
        _allControlsDisabled() {
          for (const e of Object.keys(this.controls))
            if (this.controls[e].enabled) return !1;
          return Object.keys(this.controls).length > 0 || this.disabled;
        }
        _find(e) {
          return this.controls.hasOwnProperty(e) ? this.controls[e] : null;
        }
      }
      const jl = new j('CallSetDisabledState', {
          providedIn: 'root',
          factory: () => pm,
        }),
        pm = 'always';
      function iu(n, e, t = pm) {
        f0(n, e),
          e.valueAccessor.writeValue(n.value),
          (n.disabled || 'always' === t) &&
            e.valueAccessor.setDisabledState?.(n.disabled),
          (function CK(n, e) {
            e.valueAccessor.registerOnChange((t) => {
              (n._pendingValue = t),
                (n._pendingChange = !0),
                (n._pendingDirty = !0),
                'change' === n.updateOn && PF(n, e);
            });
          })(n, e),
          (function AK(n, e) {
            const t = (i, r) => {
              e.valueAccessor.writeValue(i), r && e.viewToModelUpdate(i);
            };
            n.registerOnChange(t),
              e._registerOnDestroy(() => {
                n._unregisterOnChange(t);
              });
          })(n, e),
          (function xK(n, e) {
            e.valueAccessor.registerOnTouched(() => {
              (n._pendingTouched = !0),
                'blur' === n.updateOn && n._pendingChange && PF(n, e),
                'submit' !== n.updateOn && n.markAsTouched();
            });
          })(n, e),
          (function EK(n, e) {
            if (e.valueAccessor.setDisabledState) {
              const t = (i) => {
                e.valueAccessor.setDisabledState(i);
              };
              n.registerOnDisabledChange(t),
                e._registerOnDestroy(() => {
                  n._unregisterOnDisabledChange(t);
                });
            }
          })(n, e);
      }
      function gm(n, e, t = !0) {
        const i = () => {};
        e.valueAccessor &&
          (e.valueAccessor.registerOnChange(i),
          e.valueAccessor.registerOnTouched(i)),
          bm(n, e),
          n &&
            (e._invokeOnDestroyCallbacks(),
            n._registerOnCollectionChange(() => {}));
      }
      function _m(n, e) {
        n.forEach((t) => {
          t.registerOnValidatorChange && t.registerOnValidatorChange(e);
        });
      }
      function f0(n, e) {
        const t = wF(n);
        null !== e.validator
          ? n.setValidators(yF(t, e.validator))
          : 'function' == typeof t && n.setValidators([t]);
        const i = EF(n);
        null !== e.asyncValidator
          ? n.setAsyncValidators(yF(i, e.asyncValidator))
          : 'function' == typeof i && n.setAsyncValidators([i]);
        const r = () => n.updateValueAndValidity();
        _m(e._rawValidators, r), _m(e._rawAsyncValidators, r);
      }
      function bm(n, e) {
        let t = !1;
        if (null !== n) {
          if (null !== e.validator) {
            const r = wF(n);
            if (Array.isArray(r) && r.length > 0) {
              const s = r.filter((o) => o !== e.validator);
              s.length !== r.length && ((t = !0), n.setValidators(s));
            }
          }
          if (null !== e.asyncValidator) {
            const r = EF(n);
            if (Array.isArray(r) && r.length > 0) {
              const s = r.filter((o) => o !== e.asyncValidator);
              s.length !== r.length && ((t = !0), n.setAsyncValidators(s));
            }
          }
        }
        const i = () => {};
        return _m(e._rawValidators, i), _m(e._rawAsyncValidators, i), t;
      }
      function PF(n, e) {
        n._pendingDirty && n.markAsDirty(),
          n.setValue(n._pendingValue, { emitModelToViewChange: !1 }),
          e.viewToModelUpdate(n._pendingValue),
          (n._pendingChange = !1);
      }
      function RF(n, e) {
        f0(n, e);
      }
      function FF(n, e) {
        n._syncPendingControls(),
          e.forEach((t) => {
            const i = t.control;
            'submit' === i.updateOn &&
              i._pendingChange &&
              (t.viewToModelUpdate(i._pendingValue), (i._pendingChange = !1));
          });
      }
      const IK = { provide: Gn, useExisting: mt(() => su) },
        ru = (() => Promise.resolve())();
      let su = (() => {
        class n extends Gn {
          constructor(t, i, r) {
            super(),
              (this.callSetDisabledState = r),
              (this.submitted = !1),
              (this._directives = new Set()),
              (this.ngSubmit = new ke()),
              (this.form = new h0({}, s0(t), o0(i)));
          }
          ngAfterViewInit() {
            this._setUpdateStrategy();
          }
          get formDirective() {
            return this;
          }
          get control() {
            return this.form;
          }
          get path() {
            return [];
          }
          get controls() {
            return this.form.controls;
          }
          addControl(t) {
            ru.then(() => {
              const i = this._findContainer(t.path);
              (t.control = i.registerControl(t.name, t.control)),
                iu(t.control, t, this.callSetDisabledState),
                t.control.updateValueAndValidity({ emitEvent: !1 }),
                this._directives.add(t);
            });
          }
          getControl(t) {
            return this.form.get(t.path);
          }
          removeControl(t) {
            ru.then(() => {
              const i = this._findContainer(t.path);
              i && i.removeControl(t.name), this._directives.delete(t);
            });
          }
          addFormGroup(t) {
            ru.then(() => {
              const i = this._findContainer(t.path),
                r = new h0({});
              RF(r, t),
                i.registerControl(t.name, r),
                r.updateValueAndValidity({ emitEvent: !1 });
            });
          }
          removeFormGroup(t) {
            ru.then(() => {
              const i = this._findContainer(t.path);
              i && i.removeControl(t.name);
            });
          }
          getFormGroup(t) {
            return this.form.get(t.path);
          }
          updateModel(t, i) {
            ru.then(() => {
              this.form.get(t.path).setValue(i);
            });
          }
          setValue(t) {
            this.control.setValue(t);
          }
          onSubmit(t) {
            return (
              (this.submitted = !0),
              FF(this.form, this._directives),
              this.ngSubmit.emit(t),
              'dialog' === t?.target?.method
            );
          }
          onReset() {
            this.resetForm();
          }
          resetForm(t = void 0) {
            this.form.reset(t), (this.submitted = !1);
          }
          _setUpdateStrategy() {
            this.options &&
              null != this.options.updateOn &&
              (this.form._updateOn = this.options.updateOn);
          }
          _findContainer(t) {
            return t.pop(), t.length ? this.form.get(t) : this.form;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(D(yn, 10), D(Ys, 10), D(jl, 8));
          }),
          (n.ɵdir = J({
            type: n,
            selectors: [
              ['form', 3, 'ngNoForm', '', 3, 'formGroup', ''],
              ['ng-form'],
              ['', 'ngForm', ''],
            ],
            hostBindings: function (t, i) {
              1 & t &&
                pe('submit', function (s) {
                  return i.onSubmit(s);
                })('reset', function () {
                  return i.onReset();
                });
            },
            inputs: { options: ['ngFormOptions', 'options'] },
            outputs: { ngSubmit: 'ngSubmit' },
            exportAs: ['ngForm'],
            features: [tt([IK]), ye],
          })),
          n
        );
      })();
      function OF(n, e) {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1);
      }
      function LF(n) {
        return (
          'object' == typeof n &&
          null !== n &&
          2 === Object.keys(n).length &&
          'value' in n &&
          'disabled' in n
        );
      }
      const NF = class extends kF {
          constructor(e = null, t, i) {
            super(d0(t), u0(i, t)),
              (this.defaultValue = null),
              (this._onChange = []),
              (this._pendingChange = !1),
              this._applyFormState(e),
              this._setUpdateStrategy(t),
              this._initObservables(),
              this.updateValueAndValidity({
                onlySelf: !0,
                emitEvent: !!this.asyncValidator,
              }),
              fm(t) &&
                (t.nonNullable || t.initialValueIsDefault) &&
                (this.defaultValue = LF(e) ? e.value : e);
          }
          setValue(e, t = {}) {
            (this.value = this._pendingValue = e),
              this._onChange.length &&
                !1 !== t.emitModelToViewChange &&
                this._onChange.forEach((i) =>
                  i(this.value, !1 !== t.emitViewToModelChange)
                ),
              this.updateValueAndValidity(t);
          }
          patchValue(e, t = {}) {
            this.setValue(e, t);
          }
          reset(e = this.defaultValue, t = {}) {
            this._applyFormState(e),
              this.markAsPristine(t),
              this.markAsUntouched(t),
              this.setValue(this.value, t),
              (this._pendingChange = !1);
          }
          _updateValue() {}
          _anyControls(e) {
            return !1;
          }
          _allControlsDisabled() {
            return this.disabled;
          }
          registerOnChange(e) {
            this._onChange.push(e);
          }
          _unregisterOnChange(e) {
            OF(this._onChange, e);
          }
          registerOnDisabledChange(e) {
            this._onDisabledChange.push(e);
          }
          _unregisterOnDisabledChange(e) {
            OF(this._onDisabledChange, e);
          }
          _forEachChild(e) {}
          _syncPendingControls() {
            return !(
              'submit' !== this.updateOn ||
              (this._pendingDirty && this.markAsDirty(),
              this._pendingTouched && this.markAsTouched(),
              !this._pendingChange) ||
              (this.setValue(this._pendingValue, {
                onlySelf: !0,
                emitModelToViewChange: !1,
              }),
              0)
            );
          }
          _applyFormState(e) {
            LF(e)
              ? ((this.value = this._pendingValue = e.value),
                e.disabled
                  ? this.disable({ onlySelf: !0, emitEvent: !1 })
                  : this.enable({ onlySelf: !0, emitEvent: !1 }))
              : (this.value = this._pendingValue = e);
          }
        },
        RK = { provide: Hr, useExisting: mt(() => _0) },
        HF = (() => Promise.resolve())();
      let _0 = (() => {
        class n extends Hr {
          constructor(t, i, r, s, o, a) {
            super(),
              (this._changeDetectorRef = o),
              (this.callSetDisabledState = a),
              (this.control = new NF()),
              (this._registered = !1),
              (this.name = ''),
              (this.update = new ke()),
              (this._parent = t),
              this._setValidators(i),
              this._setAsyncValidators(r),
              (this.valueAccessor = (function g0(n, e) {
                if (!e) return null;
                let t, i, r;
                return (
                  Array.isArray(e),
                  e.forEach((s) => {
                    s.constructor === lm
                      ? (t = s)
                      : (function DK(n) {
                          return Object.getPrototypeOf(n.constructor) === ea;
                        })(s)
                      ? (i = s)
                      : (r = s);
                  }),
                  r || i || t || null
                );
              })(0, s));
          }
          ngOnChanges(t) {
            if ((this._checkForErrors(), !this._registered || 'name' in t)) {
              if (this._registered && (this._checkName(), this.formDirective)) {
                const i = t.name.previousValue;
                this.formDirective.removeControl({
                  name: i,
                  path: this._getPath(i),
                });
              }
              this._setUpControl();
            }
            'isDisabled' in t && this._updateDisabled(t),
              (function m0(n, e) {
                if (!n.hasOwnProperty('model')) return !1;
                const t = n.model;
                return !!t.isFirstChange() || !Object.is(e, t.currentValue);
              })(t, this.viewModel) &&
                (this._updateValue(this.model), (this.viewModel = this.model));
          }
          ngOnDestroy() {
            this.formDirective && this.formDirective.removeControl(this);
          }
          get path() {
            return this._getPath(this.name);
          }
          get formDirective() {
            return this._parent ? this._parent.formDirective : null;
          }
          viewToModelUpdate(t) {
            (this.viewModel = t), this.update.emit(t);
          }
          _setUpControl() {
            this._setUpdateStrategy(),
              this._isStandalone()
                ? this._setUpStandalone()
                : this.formDirective.addControl(this),
              (this._registered = !0);
          }
          _setUpdateStrategy() {
            this.options &&
              null != this.options.updateOn &&
              (this.control._updateOn = this.options.updateOn);
          }
          _isStandalone() {
            return (
              !this._parent || !(!this.options || !this.options.standalone)
            );
          }
          _setUpStandalone() {
            iu(this.control, this, this.callSetDisabledState),
              this.control.updateValueAndValidity({ emitEvent: !1 });
          }
          _checkForErrors() {
            this._isStandalone() || this._checkParentType(), this._checkName();
          }
          _checkParentType() {}
          _checkName() {
            this.options &&
              this.options.name &&
              (this.name = this.options.name),
              this._isStandalone();
          }
          _updateValue(t) {
            HF.then(() => {
              this.control.setValue(t, { emitViewToModelChange: !1 }),
                this._changeDetectorRef?.markForCheck();
            });
          }
          _updateDisabled(t) {
            const i = t.isDisabled.currentValue,
              r =
                0 !== i &&
                (function Mw(n) {
                  return 'boolean' == typeof n ? n : null != n && 'false' !== n;
                })(i);
            HF.then(() => {
              r && !this.control.disabled
                ? this.control.disable()
                : !r && this.control.disabled && this.control.enable(),
                this._changeDetectorRef?.markForCheck();
            });
          }
          _getPath(t) {
            return this._parent
              ? (function mm(n, e) {
                  return [...e.path, n];
                })(t, this._parent)
              : [t];
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(
              D(Gn, 9),
              D(yn, 10),
              D(Ys, 10),
              D(lr, 10),
              D(Br, 8),
              D(jl, 8)
            );
          }),
          (n.ɵdir = J({
            type: n,
            selectors: [
              [
                '',
                'ngModel',
                '',
                3,
                'formControlName',
                '',
                3,
                'formControl',
                '',
              ],
            ],
            inputs: {
              name: 'name',
              isDisabled: ['disabled', 'isDisabled'],
              model: ['ngModel', 'model'],
              options: ['ngModelOptions', 'options'],
            },
            outputs: { update: 'ngModelChange' },
            exportAs: ['ngModel'],
            features: [tt([RK]), ye, ri],
          })),
          n
        );
      })();
      const OK = { provide: lr, useExisting: mt(() => b0), multi: !0 };
      let b0 = (() => {
          class n extends ea {
            writeValue(t) {
              this.setProperty('value', t ?? '');
            }
            registerOnChange(t) {
              this.onChange = (i) => {
                t('' == i ? null : parseFloat(i));
              };
            }
          }
          return (
            (n.ɵfac = (function () {
              let e;
              return function (i) {
                return (e || (e = pn(n)))(i || n);
              };
            })()),
            (n.ɵdir = J({
              type: n,
              selectors: [
                ['input', 'type', 'number', 'formControlName', ''],
                ['input', 'type', 'number', 'formControl', ''],
                ['input', 'type', 'number', 'ngModel', ''],
              ],
              hostBindings: function (t, i) {
                1 & t &&
                  pe('input', function (s) {
                    return i.onChange(s.target.value);
                  })('blur', function () {
                    return i.onTouched();
                  });
              },
              features: [tt([OK]), ye],
            })),
            n
          );
        })(),
        WF = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({})),
            n
          );
        })();
      const HK = { provide: Gn, useExisting: mt(() => ou) };
      let ou = (() => {
          class n extends Gn {
            constructor(t, i, r) {
              super(),
                (this.callSetDisabledState = r),
                (this.submitted = !1),
                (this._onCollectionChange = () => this._updateDomValue()),
                (this.directives = []),
                (this.form = null),
                (this.ngSubmit = new ke()),
                this._setValidators(t),
                this._setAsyncValidators(i);
            }
            ngOnChanges(t) {
              this._checkFormPresent(),
                t.hasOwnProperty('form') &&
                  (this._updateValidators(),
                  this._updateDomValue(),
                  this._updateRegistrations(),
                  (this._oldForm = this.form));
            }
            ngOnDestroy() {
              this.form &&
                (bm(this.form, this),
                this.form._onCollectionChange === this._onCollectionChange &&
                  this.form._registerOnCollectionChange(() => {}));
            }
            get formDirective() {
              return this;
            }
            get control() {
              return this.form;
            }
            get path() {
              return [];
            }
            addControl(t) {
              const i = this.form.get(t.path);
              return (
                iu(i, t, this.callSetDisabledState),
                i.updateValueAndValidity({ emitEvent: !1 }),
                this.directives.push(t),
                i
              );
            }
            getControl(t) {
              return this.form.get(t.path);
            }
            removeControl(t) {
              gm(t.control || null, t, !1),
                (function TK(n, e) {
                  const t = n.indexOf(e);
                  t > -1 && n.splice(t, 1);
                })(this.directives, t);
            }
            addFormGroup(t) {
              this._setUpFormContainer(t);
            }
            removeFormGroup(t) {
              this._cleanUpFormContainer(t);
            }
            getFormGroup(t) {
              return this.form.get(t.path);
            }
            addFormArray(t) {
              this._setUpFormContainer(t);
            }
            removeFormArray(t) {
              this._cleanUpFormContainer(t);
            }
            getFormArray(t) {
              return this.form.get(t.path);
            }
            updateModel(t, i) {
              this.form.get(t.path).setValue(i);
            }
            onSubmit(t) {
              return (
                (this.submitted = !0),
                FF(this.form, this.directives),
                this.ngSubmit.emit(t),
                'dialog' === t?.target?.method
              );
            }
            onReset() {
              this.resetForm();
            }
            resetForm(t = void 0) {
              this.form.reset(t), (this.submitted = !1);
            }
            _updateDomValue() {
              this.directives.forEach((t) => {
                const i = t.control,
                  r = this.form.get(t.path);
                i !== r &&
                  (gm(i || null, t),
                  ((n) => n instanceof NF)(r) &&
                    (iu(r, t, this.callSetDisabledState), (t.control = r)));
              }),
                this.form._updateTreeValidity({ emitEvent: !1 });
            }
            _setUpFormContainer(t) {
              const i = this.form.get(t.path);
              RF(i, t), i.updateValueAndValidity({ emitEvent: !1 });
            }
            _cleanUpFormContainer(t) {
              if (this.form) {
                const i = this.form.get(t.path);
                i &&
                  (function SK(n, e) {
                    return bm(n, e);
                  })(i, t) &&
                  i.updateValueAndValidity({ emitEvent: !1 });
              }
            }
            _updateRegistrations() {
              this.form._registerOnCollectionChange(this._onCollectionChange),
                this._oldForm &&
                  this._oldForm._registerOnCollectionChange(() => {});
            }
            _updateValidators() {
              f0(this.form, this), this._oldForm && bm(this._oldForm, this);
            }
            _checkFormPresent() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(yn, 10), D(Ys, 10), D(jl, 8));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['', 'formGroup', '']],
              hostBindings: function (t, i) {
                1 & t &&
                  pe('submit', function (s) {
                    return i.onSubmit(s);
                  })('reset', function () {
                    return i.onReset();
                  });
              },
              inputs: { form: ['formGroup', 'form'] },
              outputs: { ngSubmit: 'ngSubmit' },
              exportAs: ['ngForm'],
              features: [tt([HK]), ye, ri],
            })),
            n
          );
        })(),
        ta = (() => {
          class n {
            constructor() {
              this._validator = cm;
            }
            ngOnChanges(t) {
              if (this.inputName in t) {
                const i = this.normalizeInput(t[this.inputName].currentValue);
                (this._enabled = this.enabled(i)),
                  (this._validator = this._enabled
                    ? this.createValidator(i)
                    : cm),
                  this._onChange && this._onChange();
              }
            }
            validate(t) {
              return this._validator(t);
            }
            registerOnValidatorChange(t) {
              this._onChange = t;
            }
            enabled(t) {
              return null != t;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵdir = J({ type: n, features: [ri] })),
            n
          );
        })();
      const i9 = { provide: yn, useExisting: mt(() => A0), multi: !0 };
      let A0 = (() => {
          class n extends ta {
            constructor() {
              super(...arguments),
                (this.inputName = 'pattern'),
                (this.normalizeInput = (t) => t),
                (this.createValidator = (t) => hF(t));
            }
          }
          return (
            (n.ɵfac = (function () {
              let e;
              return function (i) {
                return (e || (e = pn(n)))(i || n);
              };
            })()),
            (n.ɵdir = J({
              type: n,
              selectors: [
                ['', 'pattern', '', 'formControlName', ''],
                ['', 'pattern', '', 'formControl', ''],
                ['', 'pattern', '', 'ngModel', ''],
              ],
              hostVars: 1,
              hostBindings: function (t, i) {
                2 & t && Dt('pattern', i._enabled ? i.pattern : null);
              },
              inputs: { pattern: 'pattern' },
              features: [tt([i9]), ye],
            })),
            n
          );
        })(),
        r9 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [WF] })),
            n
          );
        })(),
        o9 = (() => {
          class n {
            static withConfig(t) {
              return {
                ngModule: n,
                providers: [
                  { provide: jl, useValue: t.callSetDisabledState ?? pm },
                ],
              };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [r9] })),
            n
          );
        })();
      class iO {}
      class a9 {}
      const hs = '*';
      function au(n, e) {
        return { type: 7, name: n, definitions: e, options: {} };
      }
      function na(n, e = null) {
        return { type: 4, styles: e, timings: n };
      }
      function rO(n, e = null) {
        return { type: 2, steps: n, options: e };
      }
      function cr(n) {
        return { type: 6, styles: n, offset: null };
      }
      function zl(n, e, t) {
        return { type: 0, name: n, styles: e, options: t };
      }
      function Ks(n, e, t = null) {
        return { type: 1, expr: n, animation: e, options: t };
      }
      function l9(n = null) {
        return { type: 9, options: n };
      }
      function c9(n, e, t = null) {
        return { type: 11, selector: n, animation: e, options: t };
      }
      function sO(n) {
        Promise.resolve().then(n);
      }
      class lu {
        constructor(e = 0, t = 0) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._originalOnDoneFns = []),
            (this._originalOnStartFns = []),
            (this._started = !1),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._position = 0),
            (this.parentPlayer = null),
            (this.totalTime = e + t);
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        onStart(e) {
          this._originalOnStartFns.push(e), this._onStartFns.push(e);
        }
        onDone(e) {
          this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        init() {}
        play() {
          this.hasStarted() || (this._onStart(), this.triggerMicrotask()),
            (this._started = !0);
        }
        triggerMicrotask() {
          sO(() => this._onFinish());
        }
        _onStart() {
          this._onStartFns.forEach((e) => e()), (this._onStartFns = []);
        }
        pause() {}
        restart() {}
        finish() {
          this._onFinish();
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this.hasStarted() || this._onStart(),
            this.finish(),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          (this._started = !1),
            (this._finished = !1),
            (this._onStartFns = this._originalOnStartFns),
            (this._onDoneFns = this._originalOnDoneFns);
        }
        setPosition(e) {
          this._position = this.totalTime ? e * this.totalTime : 1;
        }
        getPosition() {
          return this.totalTime ? this._position / this.totalTime : 1;
        }
        triggerCallback(e) {
          const t = 'start' == e ? this._onStartFns : this._onDoneFns;
          t.forEach((i) => i()), (t.length = 0);
        }
      }
      class oO {
        constructor(e) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._onDestroyFns = []),
            (this.parentPlayer = null),
            (this.totalTime = 0),
            (this.players = e);
          let t = 0,
            i = 0,
            r = 0;
          const s = this.players.length;
          0 == s
            ? sO(() => this._onFinish())
            : this.players.forEach((o) => {
                o.onDone(() => {
                  ++t == s && this._onFinish();
                }),
                  o.onDestroy(() => {
                    ++i == s && this._onDestroy();
                  }),
                  o.onStart(() => {
                    ++r == s && this._onStart();
                  });
              }),
            (this.totalTime = this.players.reduce(
              (o, a) => Math.max(o, a.totalTime),
              0
            ));
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        init() {
          this.players.forEach((e) => e.init());
        }
        onStart(e) {
          this._onStartFns.push(e);
        }
        _onStart() {
          this.hasStarted() ||
            ((this._started = !0),
            this._onStartFns.forEach((e) => e()),
            (this._onStartFns = []));
        }
        onDone(e) {
          this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this.parentPlayer || this.init(),
            this._onStart(),
            this.players.forEach((e) => e.play());
        }
        pause() {
          this.players.forEach((e) => e.pause());
        }
        restart() {
          this.players.forEach((e) => e.restart());
        }
        finish() {
          this._onFinish(), this.players.forEach((e) => e.finish());
        }
        destroy() {
          this._onDestroy();
        }
        _onDestroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._onFinish(),
            this.players.forEach((e) => e.destroy()),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          this.players.forEach((e) => e.reset()),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1);
        }
        setPosition(e) {
          const t = e * this.totalTime;
          this.players.forEach((i) => {
            const r = i.totalTime ? Math.min(1, t / i.totalTime) : 1;
            i.setPosition(r);
          });
        }
        getPosition() {
          const e = this.players.reduce(
            (t, i) => (null === t || i.totalTime > t.totalTime ? i : t),
            null
          );
          return null != e ? e.getPosition() : 0;
        }
        beforeDestroy() {
          this.players.forEach((e) => {
            e.beforeDestroy && e.beforeDestroy();
          });
        }
        triggerCallback(e) {
          const t = 'start' == e ? this._onStartFns : this._onDoneFns;
          t.forEach((i) => i()), (t.length = 0);
        }
      }
      function aO(n) {
        return new N(3e3, !1);
      }
      function Zs(n) {
        switch (n.length) {
          case 0:
            return new lu();
          case 1:
            return n[0];
          default:
            return new oO(n);
        }
      }
      function lO(n, e, t = new Map(), i = new Map()) {
        const r = [],
          s = [];
        let o = -1,
          a = null;
        if (
          (e.forEach((l) => {
            const c = l.get('offset'),
              u = c == o,
              h = (u && a) || new Map();
            l.forEach((f, p) => {
              let m = p,
                g = f;
              if ('offset' !== p)
                switch (((m = n.normalizePropertyName(m, r)), g)) {
                  case '!':
                    g = t.get(p);
                    break;
                  case hs:
                    g = i.get(p);
                    break;
                  default:
                    g = n.normalizeStyleValue(p, m, g, r);
                }
              h.set(m, g);
            }),
              u || s.push(h),
              (a = h),
              (o = c);
          }),
          r.length)
        )
          throw (function P9(n) {
            return new N(3502, !1);
          })();
        return s;
      }
      function M0(n, e, t, i) {
        switch (e) {
          case 'start':
            n.onStart(() => i(t && D0(t, 'start', n)));
            break;
          case 'done':
            n.onDone(() => i(t && D0(t, 'done', n)));
            break;
          case 'destroy':
            n.onDestroy(() => i(t && D0(t, 'destroy', n)));
        }
      }
      function D0(n, e, t) {
        const s = T0(
            n.element,
            n.triggerName,
            n.fromState,
            n.toState,
            e || n.phaseName,
            t.totalTime ?? n.totalTime,
            !!t.disabled
          ),
          o = n._data;
        return null != o && (s._data = o), s;
      }
      function T0(n, e, t, i, r = '', s = 0, o) {
        return {
          element: n,
          triggerName: e,
          fromState: t,
          toState: i,
          phaseName: r,
          totalTime: s,
          disabled: !!o,
        };
      }
      function Ri(n, e, t) {
        let i = n.get(e);
        return i || n.set(e, (i = t)), i;
      }
      function cO(n) {
        const e = n.indexOf(':');
        return [n.substring(1, e), n.slice(e + 1)];
      }
      const U9 = (() =>
        typeof document > 'u' ? null : document.documentElement)();
      function I0(n) {
        const e = n.parentNode || n.host || null;
        return e === U9 ? null : e;
      }
      let ia = null,
        dO = !1;
      function uO(n, e) {
        for (; e; ) {
          if (e === n) return !0;
          e = I0(e);
        }
        return !1;
      }
      function hO(n, e, t) {
        if (t) return Array.from(n.querySelectorAll(e));
        const i = n.querySelector(e);
        return i ? [i] : [];
      }
      let fO = (() => {
          class n {
            validateStyleProperty(t) {
              return (function G9(n) {
                ia ||
                  ((ia =
                    (function q9() {
                      return typeof document < 'u' ? document.body : null;
                    })() || {}),
                  (dO = !!ia.style && 'WebkitAppearance' in ia.style));
                let e = !0;
                return (
                  ia.style &&
                    !(function $9(n) {
                      return 'ebkit' == n.substring(1, 6);
                    })(n) &&
                    ((e = n in ia.style),
                    !e &&
                      dO &&
                      (e =
                        'Webkit' + n.charAt(0).toUpperCase() + n.slice(1) in
                        ia.style)),
                  e
                );
              })(t);
            }
            matchesElement(t, i) {
              return !1;
            }
            containsElement(t, i) {
              return uO(t, i);
            }
            getParentElement(t) {
              return I0(t);
            }
            query(t, i, r) {
              return hO(t, i, r);
            }
            computeStyle(t, i, r) {
              return r || '';
            }
            animate(t, i, r, s, o, a = [], l) {
              return new lu(r, s);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        k0 = (() => {
          class n {}
          return (n.NOOP = new fO()), n;
        })();
      const X9 = 1e3,
        P0 = 'ng-enter',
        vm = 'ng-leave',
        ym = 'ng-trigger',
        wm = '.ng-trigger',
        mO = 'ng-animating',
        R0 = '.ng-animating';
      function fs(n) {
        if ('number' == typeof n) return n;
        const e = n.match(/^(-?[\.\d]+)(m?s)/);
        return !e || e.length < 2 ? 0 : F0(parseFloat(e[1]), e[2]);
      }
      function F0(n, e) {
        return 's' === e ? n * X9 : n;
      }
      function Em(n, e, t) {
        return n.hasOwnProperty('duration')
          ? n
          : (function K9(n, e, t) {
              let r,
                s = 0,
                o = '';
              if ('string' == typeof n) {
                const a = n.match(
                  /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i
                );
                if (null === a)
                  return e.push(aO()), { duration: 0, delay: 0, easing: '' };
                r = F0(parseFloat(a[1]), a[2]);
                const l = a[3];
                null != l && (s = F0(parseFloat(l), a[4]));
                const c = a[5];
                c && (o = c);
              } else r = n;
              if (!t) {
                let a = !1,
                  l = e.length;
                r < 0 &&
                  (e.push(
                    (function d9() {
                      return new N(3100, !1);
                    })()
                  ),
                  (a = !0)),
                  s < 0 &&
                    (e.push(
                      (function u9() {
                        return new N(3101, !1);
                      })()
                    ),
                    (a = !0)),
                  a && e.splice(l, 0, aO());
              }
              return { duration: r, delay: s, easing: o };
            })(n, e, t);
      }
      function cu(n, e = {}) {
        return (
          Object.keys(n).forEach((t) => {
            e[t] = n[t];
          }),
          e
        );
      }
      function gO(n) {
        const e = new Map();
        return (
          Object.keys(n).forEach((t) => {
            e.set(t, n[t]);
          }),
          e
        );
      }
      function Qs(n, e = new Map(), t) {
        if (t) for (let [i, r] of t) e.set(i, r);
        for (let [i, r] of n) e.set(i, r);
        return e;
      }
      function Wr(n, e, t) {
        e.forEach((i, r) => {
          const s = L0(r);
          t && !t.has(r) && t.set(r, n.style[s]), (n.style[s] = i);
        });
      }
      function ra(n, e) {
        e.forEach((t, i) => {
          const r = L0(i);
          n.style[r] = '';
        });
      }
      function du(n) {
        return Array.isArray(n) ? (1 == n.length ? n[0] : rO(n)) : n;
      }
      const O0 = new RegExp('{{\\s*(.+?)\\s*}}', 'g');
      function bO(n) {
        let e = [];
        if ('string' == typeof n) {
          let t;
          for (; (t = O0.exec(n)); ) e.push(t[1]);
          O0.lastIndex = 0;
        }
        return e;
      }
      function uu(n, e, t) {
        const i = n.toString(),
          r = i.replace(O0, (s, o) => {
            let a = e[o];
            return (
              null == a &&
                (t.push(
                  (function f9(n) {
                    return new N(3003, !1);
                  })()
                ),
                (a = '')),
              a.toString()
            );
          });
        return r == i ? n : r;
      }
      function Cm(n) {
        const e = [];
        let t = n.next();
        for (; !t.done; ) e.push(t.value), (t = n.next());
        return e;
      }
      const J9 = /-+([a-z0-9])/g;
      function L0(n) {
        return n.replace(J9, (...e) => e[1].toUpperCase());
      }
      function Fi(n, e, t) {
        switch (e.type) {
          case 7:
            return n.visitTrigger(e, t);
          case 0:
            return n.visitState(e, t);
          case 1:
            return n.visitTransition(e, t);
          case 2:
            return n.visitSequence(e, t);
          case 3:
            return n.visitGroup(e, t);
          case 4:
            return n.visitAnimate(e, t);
          case 5:
            return n.visitKeyframes(e, t);
          case 6:
            return n.visitStyle(e, t);
          case 8:
            return n.visitReference(e, t);
          case 9:
            return n.visitAnimateChild(e, t);
          case 10:
            return n.visitAnimateRef(e, t);
          case 11:
            return n.visitQuery(e, t);
          case 12:
            return n.visitStagger(e, t);
          default:
            throw (function p9(n) {
              return new N(3004, !1);
            })();
        }
      }
      const xm = '*';
      function n7(n, e) {
        const t = [];
        return (
          'string' == typeof n
            ? n.split(/\s*,\s*/).forEach((i) =>
                (function i7(n, e, t) {
                  if (':' == n[0]) {
                    const l = (function r7(n, e) {
                      switch (n) {
                        case ':enter':
                          return 'void => *';
                        case ':leave':
                          return '* => void';
                        case ':increment':
                          return (t, i) => parseFloat(i) > parseFloat(t);
                        case ':decrement':
                          return (t, i) => parseFloat(i) < parseFloat(t);
                        default:
                          return (
                            e.push(
                              (function D9(n) {
                                return new N(3016, !1);
                              })()
                            ),
                            '* => *'
                          );
                      }
                    })(n, t);
                    if ('function' == typeof l) return void e.push(l);
                    n = l;
                  }
                  const i = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                  if (null == i || i.length < 4)
                    return (
                      t.push(
                        (function M9(n) {
                          return new N(3015, !1);
                        })()
                      ),
                      e
                    );
                  const r = i[1],
                    s = i[2],
                    o = i[3];
                  e.push(yO(r, o));
                  '<' == s[0] && !(r == xm && o == xm) && e.push(yO(o, r));
                })(i, t, e)
              )
            : t.push(n),
          t
        );
      }
      const Am = new Set(['true', '1']),
        Sm = new Set(['false', '0']);
      function yO(n, e) {
        const t = Am.has(n) || Sm.has(n),
          i = Am.has(e) || Sm.has(e);
        return (r, s) => {
          let o = n == xm || n == r,
            a = e == xm || e == s;
          return (
            !o && t && 'boolean' == typeof r && (o = r ? Am.has(n) : Sm.has(n)),
            !a && i && 'boolean' == typeof s && (a = s ? Am.has(e) : Sm.has(e)),
            o && a
          );
        };
      }
      const s7 = new RegExp('s*:selfs*,?', 'g');
      function N0(n, e, t, i) {
        return new o7(n).build(e, t, i);
      }
      class o7 {
        constructor(e) {
          this._driver = e;
        }
        build(e, t, i) {
          const r = new c7(t);
          return this._resetContextStyleTimingState(r), Fi(this, du(e), r);
        }
        _resetContextStyleTimingState(e) {
          (e.currentQuerySelector = ''),
            (e.collectedStyles = new Map()),
            e.collectedStyles.set('', new Map()),
            (e.currentTime = 0);
        }
        visitTrigger(e, t) {
          let i = (t.queryCount = 0),
            r = (t.depCount = 0);
          const s = [],
            o = [];
          return (
            '@' == e.name.charAt(0) &&
              t.errors.push(
                (function g9() {
                  return new N(3006, !1);
                })()
              ),
            e.definitions.forEach((a) => {
              if ((this._resetContextStyleTimingState(t), 0 == a.type)) {
                const l = a,
                  c = l.name;
                c
                  .toString()
                  .split(/\s*,\s*/)
                  .forEach((u) => {
                    (l.name = u), s.push(this.visitState(l, t));
                  }),
                  (l.name = c);
              } else if (1 == a.type) {
                const l = this.visitTransition(a, t);
                (i += l.queryCount), (r += l.depCount), o.push(l);
              } else
                t.errors.push(
                  (function _9() {
                    return new N(3007, !1);
                  })()
                );
            }),
            {
              type: 7,
              name: e.name,
              states: s,
              transitions: o,
              queryCount: i,
              depCount: r,
              options: null,
            }
          );
        }
        visitState(e, t) {
          const i = this.visitStyle(e.styles, t),
            r = (e.options && e.options.params) || null;
          if (i.containsDynamicStyles) {
            const s = new Set(),
              o = r || {};
            i.styles.forEach((a) => {
              a instanceof Map &&
                a.forEach((l) => {
                  bO(l).forEach((c) => {
                    o.hasOwnProperty(c) || s.add(c);
                  });
                });
            }),
              s.size &&
                (Cm(s.values()),
                t.errors.push(
                  (function b9(n, e) {
                    return new N(3008, !1);
                  })()
                ));
          }
          return {
            type: 0,
            name: e.name,
            style: i,
            options: r ? { params: r } : null,
          };
        }
        visitTransition(e, t) {
          (t.queryCount = 0), (t.depCount = 0);
          const i = Fi(this, du(e.animation), t);
          return {
            type: 1,
            matchers: n7(e.expr, t.errors),
            animation: i,
            queryCount: t.queryCount,
            depCount: t.depCount,
            options: sa(e.options),
          };
        }
        visitSequence(e, t) {
          return {
            type: 2,
            steps: e.steps.map((i) => Fi(this, i, t)),
            options: sa(e.options),
          };
        }
        visitGroup(e, t) {
          const i = t.currentTime;
          let r = 0;
          const s = e.steps.map((o) => {
            t.currentTime = i;
            const a = Fi(this, o, t);
            return (r = Math.max(r, t.currentTime)), a;
          });
          return (
            (t.currentTime = r), { type: 3, steps: s, options: sa(e.options) }
          );
        }
        visitAnimate(e, t) {
          const i = (function u7(n, e) {
            if (n.hasOwnProperty('duration')) return n;
            if ('number' == typeof n) return V0(Em(n, e).duration, 0, '');
            const t = n;
            if (
              t
                .split(/\s+/)
                .some((s) => '{' == s.charAt(0) && '{' == s.charAt(1))
            ) {
              const s = V0(0, 0, '');
              return (s.dynamic = !0), (s.strValue = t), s;
            }
            const r = Em(t, e);
            return V0(r.duration, r.delay, r.easing);
          })(e.timings, t.errors);
          t.currentAnimateTimings = i;
          let r,
            s = e.styles ? e.styles : cr({});
          if (5 == s.type) r = this.visitKeyframes(s, t);
          else {
            let o = e.styles,
              a = !1;
            if (!o) {
              a = !0;
              const c = {};
              i.easing && (c.easing = i.easing), (o = cr(c));
            }
            t.currentTime += i.duration + i.delay;
            const l = this.visitStyle(o, t);
            (l.isEmptyStep = a), (r = l);
          }
          return (
            (t.currentAnimateTimings = null),
            { type: 4, timings: i, style: r, options: null }
          );
        }
        visitStyle(e, t) {
          const i = this._makeStyleAst(e, t);
          return this._validateStyleAst(i, t), i;
        }
        _makeStyleAst(e, t) {
          const i = [],
            r = Array.isArray(e.styles) ? e.styles : [e.styles];
          for (let a of r)
            'string' == typeof a
              ? a === hs
                ? i.push(a)
                : t.errors.push(new N(3002, !1))
              : i.push(gO(a));
          let s = !1,
            o = null;
          return (
            i.forEach((a) => {
              if (
                a instanceof Map &&
                (a.has('easing') && ((o = a.get('easing')), a.delete('easing')),
                !s)
              )
                for (let l of a.values())
                  if (l.toString().indexOf('{{') >= 0) {
                    s = !0;
                    break;
                  }
            }),
            {
              type: 6,
              styles: i,
              easing: o,
              offset: e.offset,
              containsDynamicStyles: s,
              options: null,
            }
          );
        }
        _validateStyleAst(e, t) {
          const i = t.currentAnimateTimings;
          let r = t.currentTime,
            s = t.currentTime;
          i && s > 0 && (s -= i.duration + i.delay),
            e.styles.forEach((o) => {
              'string' != typeof o &&
                o.forEach((a, l) => {
                  const c = t.collectedStyles.get(t.currentQuerySelector),
                    u = c.get(l);
                  let h = !0;
                  u &&
                    (s != r &&
                      s >= u.startTime &&
                      r <= u.endTime &&
                      (t.errors.push(
                        (function y9(n, e, t, i, r) {
                          return new N(3010, !1);
                        })()
                      ),
                      (h = !1)),
                    (s = u.startTime)),
                    h && c.set(l, { startTime: s, endTime: r }),
                    t.options &&
                      (function Q9(n, e, t) {
                        const i = e.params || {},
                          r = bO(n);
                        r.length &&
                          r.forEach((s) => {
                            i.hasOwnProperty(s) ||
                              t.push(
                                (function h9(n) {
                                  return new N(3001, !1);
                                })()
                              );
                          });
                      })(a, t.options, t.errors);
                });
            });
        }
        visitKeyframes(e, t) {
          const i = { type: 5, styles: [], options: null };
          if (!t.currentAnimateTimings)
            return (
              t.errors.push(
                (function w9() {
                  return new N(3011, !1);
                })()
              ),
              i
            );
          let s = 0;
          const o = [];
          let a = !1,
            l = !1,
            c = 0;
          const u = e.steps.map((y) => {
            const E = this._makeStyleAst(y, t);
            let A =
                null != E.offset
                  ? E.offset
                  : (function d7(n) {
                      if ('string' == typeof n) return null;
                      let e = null;
                      if (Array.isArray(n))
                        n.forEach((t) => {
                          if (t instanceof Map && t.has('offset')) {
                            const i = t;
                            (e = parseFloat(i.get('offset'))),
                              i.delete('offset');
                          }
                        });
                      else if (n instanceof Map && n.has('offset')) {
                        const t = n;
                        (e = parseFloat(t.get('offset'))), t.delete('offset');
                      }
                      return e;
                    })(E.styles),
              M = 0;
            return (
              null != A && (s++, (M = E.offset = A)),
              (l = l || M < 0 || M > 1),
              (a = a || M < c),
              (c = M),
              o.push(M),
              E
            );
          });
          l &&
            t.errors.push(
              (function E9() {
                return new N(3012, !1);
              })()
            ),
            a &&
              t.errors.push(
                (function C9() {
                  return new N(3200, !1);
                })()
              );
          const h = e.steps.length;
          let f = 0;
          s > 0 && s < h
            ? t.errors.push(
                (function x9() {
                  return new N(3202, !1);
                })()
              )
            : 0 == s && (f = 1 / (h - 1));
          const p = h - 1,
            m = t.currentTime,
            g = t.currentAnimateTimings,
            w = g.duration;
          return (
            u.forEach((y, E) => {
              const A = f > 0 ? (E == p ? 1 : f * E) : o[E],
                M = A * w;
              (t.currentTime = m + g.delay + M),
                (g.duration = M),
                this._validateStyleAst(y, t),
                (y.offset = A),
                i.styles.push(y);
            }),
            i
          );
        }
        visitReference(e, t) {
          return {
            type: 8,
            animation: Fi(this, du(e.animation), t),
            options: sa(e.options),
          };
        }
        visitAnimateChild(e, t) {
          return t.depCount++, { type: 9, options: sa(e.options) };
        }
        visitAnimateRef(e, t) {
          return {
            type: 10,
            animation: this.visitReference(e.animation, t),
            options: sa(e.options),
          };
        }
        visitQuery(e, t) {
          const i = t.currentQuerySelector,
            r = e.options || {};
          t.queryCount++, (t.currentQuery = e);
          const [s, o] = (function a7(n) {
            const e = !!n.split(/\s*,\s*/).find((t) => ':self' == t);
            return (
              e && (n = n.replace(s7, '')),
              (n = n
                .replace(/@\*/g, wm)
                .replace(/@\w+/g, (t) => wm + '-' + t.slice(1))
                .replace(/:animating/g, R0)),
              [n, e]
            );
          })(e.selector);
          (t.currentQuerySelector = i.length ? i + ' ' + s : s),
            Ri(t.collectedStyles, t.currentQuerySelector, new Map());
          const a = Fi(this, du(e.animation), t);
          return (
            (t.currentQuery = null),
            (t.currentQuerySelector = i),
            {
              type: 11,
              selector: s,
              limit: r.limit || 0,
              optional: !!r.optional,
              includeSelf: o,
              animation: a,
              originalSelector: e.selector,
              options: sa(e.options),
            }
          );
        }
        visitStagger(e, t) {
          t.currentQuery ||
            t.errors.push(
              (function A9() {
                return new N(3013, !1);
              })()
            );
          const i =
            'full' === e.timings
              ? { duration: 0, delay: 0, easing: 'full' }
              : Em(e.timings, t.errors, !0);
          return {
            type: 12,
            animation: Fi(this, du(e.animation), t),
            timings: i,
            options: null,
          };
        }
      }
      class c7 {
        constructor(e) {
          (this.errors = e),
            (this.queryCount = 0),
            (this.depCount = 0),
            (this.currentTransition = null),
            (this.currentQuery = null),
            (this.currentQuerySelector = null),
            (this.currentAnimateTimings = null),
            (this.currentTime = 0),
            (this.collectedStyles = new Map()),
            (this.options = null),
            (this.unsupportedCSSPropertiesFound = new Set());
        }
      }
      function sa(n) {
        return (
          n
            ? (n = cu(n)).params &&
              (n.params = (function l7(n) {
                return n ? cu(n) : null;
              })(n.params))
            : (n = {}),
          n
        );
      }
      function V0(n, e, t) {
        return { duration: n, delay: e, easing: t };
      }
      function B0(n, e, t, i, r, s, o = null, a = !1) {
        return {
          type: 1,
          element: n,
          keyframes: e,
          preStyleProps: t,
          postStyleProps: i,
          duration: r,
          delay: s,
          totalTime: r + s,
          easing: o,
          subTimeline: a,
        };
      }
      class Mm {
        constructor() {
          this._map = new Map();
        }
        get(e) {
          return this._map.get(e) || [];
        }
        append(e, t) {
          let i = this._map.get(e);
          i || this._map.set(e, (i = [])), i.push(...t);
        }
        has(e) {
          return this._map.has(e);
        }
        clear() {
          this._map.clear();
        }
      }
      const p7 = new RegExp(':enter', 'g'),
        g7 = new RegExp(':leave', 'g');
      function H0(n, e, t, i, r, s = new Map(), o = new Map(), a, l, c = []) {
        return new _7().buildKeyframes(n, e, t, i, r, s, o, a, l, c);
      }
      class _7 {
        buildKeyframes(e, t, i, r, s, o, a, l, c, u = []) {
          c = c || new Mm();
          const h = new W0(e, t, c, r, s, u, []);
          h.options = l;
          const f = l.delay ? fs(l.delay) : 0;
          h.currentTimeline.delayNextStep(f),
            h.currentTimeline.setStyles([o], null, h.errors, l),
            Fi(this, i, h);
          const p = h.timelines.filter((m) => m.containsAnimation());
          if (p.length && a.size) {
            let m;
            for (let g = p.length - 1; g >= 0; g--) {
              const w = p[g];
              if (w.element === t) {
                m = w;
                break;
              }
            }
            m &&
              !m.allowOnlyTimelineStyles() &&
              m.setStyles([a], null, h.errors, l);
          }
          return p.length
            ? p.map((m) => m.buildKeyframes())
            : [B0(t, [], [], [], 0, f, '', !1)];
        }
        visitTrigger(e, t) {}
        visitState(e, t) {}
        visitTransition(e, t) {}
        visitAnimateChild(e, t) {
          const i = t.subInstructions.get(t.element);
          if (i) {
            const r = t.createSubContext(e.options),
              s = t.currentTimeline.currentTime,
              o = this._visitSubInstructions(i, r, r.options);
            s != o && t.transformIntoNewTimeline(o);
          }
          t.previousNode = e;
        }
        visitAnimateRef(e, t) {
          const i = t.createSubContext(e.options);
          i.transformIntoNewTimeline(),
            this._applyAnimationRefDelays(
              [e.options, e.animation.options],
              t,
              i
            ),
            this.visitReference(e.animation, i),
            t.transformIntoNewTimeline(i.currentTimeline.currentTime),
            (t.previousNode = e);
        }
        _applyAnimationRefDelays(e, t, i) {
          for (const r of e) {
            const s = r?.delay;
            if (s) {
              const o =
                'number' == typeof s ? s : fs(uu(s, r?.params ?? {}, t.errors));
              i.delayNextStep(o);
            }
          }
        }
        _visitSubInstructions(e, t, i) {
          let s = t.currentTimeline.currentTime;
          const o = null != i.duration ? fs(i.duration) : null,
            a = null != i.delay ? fs(i.delay) : null;
          return (
            0 !== o &&
              e.forEach((l) => {
                const c = t.appendInstructionToTimeline(l, o, a);
                s = Math.max(s, c.duration + c.delay);
              }),
            s
          );
        }
        visitReference(e, t) {
          t.updateOptions(e.options, !0),
            Fi(this, e.animation, t),
            (t.previousNode = e);
        }
        visitSequence(e, t) {
          const i = t.subContextCount;
          let r = t;
          const s = e.options;
          if (
            s &&
            (s.params || s.delay) &&
            ((r = t.createSubContext(s)),
            r.transformIntoNewTimeline(),
            null != s.delay)
          ) {
            6 == r.previousNode.type &&
              (r.currentTimeline.snapshotCurrentStyles(),
              (r.previousNode = Dm));
            const o = fs(s.delay);
            r.delayNextStep(o);
          }
          e.steps.length &&
            (e.steps.forEach((o) => Fi(this, o, r)),
            r.currentTimeline.applyStylesToKeyframe(),
            r.subContextCount > i && r.transformIntoNewTimeline()),
            (t.previousNode = e);
        }
        visitGroup(e, t) {
          const i = [];
          let r = t.currentTimeline.currentTime;
          const s = e.options && e.options.delay ? fs(e.options.delay) : 0;
          e.steps.forEach((o) => {
            const a = t.createSubContext(e.options);
            s && a.delayNextStep(s),
              Fi(this, o, a),
              (r = Math.max(r, a.currentTimeline.currentTime)),
              i.push(a.currentTimeline);
          }),
            i.forEach((o) => t.currentTimeline.mergeTimelineCollectedStyles(o)),
            t.transformIntoNewTimeline(r),
            (t.previousNode = e);
        }
        _visitTiming(e, t) {
          if (e.dynamic) {
            const i = e.strValue;
            return Em(t.params ? uu(i, t.params, t.errors) : i, t.errors);
          }
          return { duration: e.duration, delay: e.delay, easing: e.easing };
        }
        visitAnimate(e, t) {
          const i = (t.currentAnimateTimings = this._visitTiming(e.timings, t)),
            r = t.currentTimeline;
          i.delay && (t.incrementTime(i.delay), r.snapshotCurrentStyles());
          const s = e.style;
          5 == s.type
            ? this.visitKeyframes(s, t)
            : (t.incrementTime(i.duration),
              this.visitStyle(s, t),
              r.applyStylesToKeyframe()),
            (t.currentAnimateTimings = null),
            (t.previousNode = e);
        }
        visitStyle(e, t) {
          const i = t.currentTimeline,
            r = t.currentAnimateTimings;
          !r && i.hasCurrentStyleProperties() && i.forwardFrame();
          const s = (r && r.easing) || e.easing;
          e.isEmptyStep
            ? i.applyEmptyStep(s)
            : i.setStyles(e.styles, s, t.errors, t.options),
            (t.previousNode = e);
        }
        visitKeyframes(e, t) {
          const i = t.currentAnimateTimings,
            r = t.currentTimeline.duration,
            s = i.duration,
            a = t.createSubContext().currentTimeline;
          (a.easing = i.easing),
            e.styles.forEach((l) => {
              a.forwardTime((l.offset || 0) * s),
                a.setStyles(l.styles, l.easing, t.errors, t.options),
                a.applyStylesToKeyframe();
            }),
            t.currentTimeline.mergeTimelineCollectedStyles(a),
            t.transformIntoNewTimeline(r + s),
            (t.previousNode = e);
        }
        visitQuery(e, t) {
          const i = t.currentTimeline.currentTime,
            r = e.options || {},
            s = r.delay ? fs(r.delay) : 0;
          s &&
            (6 === t.previousNode.type ||
              (0 == i && t.currentTimeline.hasCurrentStyleProperties())) &&
            (t.currentTimeline.snapshotCurrentStyles(), (t.previousNode = Dm));
          let o = i;
          const a = t.invokeQuery(
            e.selector,
            e.originalSelector,
            e.limit,
            e.includeSelf,
            !!r.optional,
            t.errors
          );
          t.currentQueryTotal = a.length;
          let l = null;
          a.forEach((c, u) => {
            t.currentQueryIndex = u;
            const h = t.createSubContext(e.options, c);
            s && h.delayNextStep(s),
              c === t.element && (l = h.currentTimeline),
              Fi(this, e.animation, h),
              h.currentTimeline.applyStylesToKeyframe(),
              (o = Math.max(o, h.currentTimeline.currentTime));
          }),
            (t.currentQueryIndex = 0),
            (t.currentQueryTotal = 0),
            t.transformIntoNewTimeline(o),
            l &&
              (t.currentTimeline.mergeTimelineCollectedStyles(l),
              t.currentTimeline.snapshotCurrentStyles()),
            (t.previousNode = e);
        }
        visitStagger(e, t) {
          const i = t.parentContext,
            r = t.currentTimeline,
            s = e.timings,
            o = Math.abs(s.duration),
            a = o * (t.currentQueryTotal - 1);
          let l = o * t.currentQueryIndex;
          switch (s.duration < 0 ? 'reverse' : s.easing) {
            case 'reverse':
              l = a - l;
              break;
            case 'full':
              l = i.currentStaggerTime;
          }
          const u = t.currentTimeline;
          l && u.delayNextStep(l);
          const h = u.currentTime;
          Fi(this, e.animation, t),
            (t.previousNode = e),
            (i.currentStaggerTime =
              r.currentTime - h + (r.startTime - i.currentTimeline.startTime));
        }
      }
      const Dm = {};
      class W0 {
        constructor(e, t, i, r, s, o, a, l) {
          (this._driver = e),
            (this.element = t),
            (this.subInstructions = i),
            (this._enterClassName = r),
            (this._leaveClassName = s),
            (this.errors = o),
            (this.timelines = a),
            (this.parentContext = null),
            (this.currentAnimateTimings = null),
            (this.previousNode = Dm),
            (this.subContextCount = 0),
            (this.options = {}),
            (this.currentQueryIndex = 0),
            (this.currentQueryTotal = 0),
            (this.currentStaggerTime = 0),
            (this.currentTimeline = l || new Tm(this._driver, t, 0)),
            a.push(this.currentTimeline);
        }
        get params() {
          return this.options.params;
        }
        updateOptions(e, t) {
          if (!e) return;
          const i = e;
          let r = this.options;
          null != i.duration && (r.duration = fs(i.duration)),
            null != i.delay && (r.delay = fs(i.delay));
          const s = i.params;
          if (s) {
            let o = r.params;
            o || (o = this.options.params = {}),
              Object.keys(s).forEach((a) => {
                (!t || !o.hasOwnProperty(a)) &&
                  (o[a] = uu(s[a], o, this.errors));
              });
          }
        }
        _copyOptions() {
          const e = {};
          if (this.options) {
            const t = this.options.params;
            if (t) {
              const i = (e.params = {});
              Object.keys(t).forEach((r) => {
                i[r] = t[r];
              });
            }
          }
          return e;
        }
        createSubContext(e = null, t, i) {
          const r = t || this.element,
            s = new W0(
              this._driver,
              r,
              this.subInstructions,
              this._enterClassName,
              this._leaveClassName,
              this.errors,
              this.timelines,
              this.currentTimeline.fork(r, i || 0)
            );
          return (
            (s.previousNode = this.previousNode),
            (s.currentAnimateTimings = this.currentAnimateTimings),
            (s.options = this._copyOptions()),
            s.updateOptions(e),
            (s.currentQueryIndex = this.currentQueryIndex),
            (s.currentQueryTotal = this.currentQueryTotal),
            (s.parentContext = this),
            this.subContextCount++,
            s
          );
        }
        transformIntoNewTimeline(e) {
          return (
            (this.previousNode = Dm),
            (this.currentTimeline = this.currentTimeline.fork(this.element, e)),
            this.timelines.push(this.currentTimeline),
            this.currentTimeline
          );
        }
        appendInstructionToTimeline(e, t, i) {
          const r = {
              duration: t ?? e.duration,
              delay: this.currentTimeline.currentTime + (i ?? 0) + e.delay,
              easing: '',
            },
            s = new b7(
              this._driver,
              e.element,
              e.keyframes,
              e.preStyleProps,
              e.postStyleProps,
              r,
              e.stretchStartingKeyframe
            );
          return this.timelines.push(s), r;
        }
        incrementTime(e) {
          this.currentTimeline.forwardTime(this.currentTimeline.duration + e);
        }
        delayNextStep(e) {
          e > 0 && this.currentTimeline.delayNextStep(e);
        }
        invokeQuery(e, t, i, r, s, o) {
          let a = [];
          if ((r && a.push(this.element), e.length > 0)) {
            e = (e = e.replace(p7, '.' + this._enterClassName)).replace(
              g7,
              '.' + this._leaveClassName
            );
            let c = this._driver.query(this.element, e, 1 != i);
            0 !== i &&
              (c = i < 0 ? c.slice(c.length + i, c.length) : c.slice(0, i)),
              a.push(...c);
          }
          return (
            !s &&
              0 == a.length &&
              o.push(
                (function S9(n) {
                  return new N(3014, !1);
                })()
              ),
            a
          );
        }
      }
      class Tm {
        constructor(e, t, i, r) {
          (this._driver = e),
            (this.element = t),
            (this.startTime = i),
            (this._elementTimelineStylesLookup = r),
            (this.duration = 0),
            (this.easing = null),
            (this._previousKeyframe = new Map()),
            (this._currentKeyframe = new Map()),
            (this._keyframes = new Map()),
            (this._styleSummary = new Map()),
            (this._localTimelineStyles = new Map()),
            (this._pendingStyles = new Map()),
            (this._backFill = new Map()),
            (this._currentEmptyStepKeyframe = null),
            this._elementTimelineStylesLookup ||
              (this._elementTimelineStylesLookup = new Map()),
            (this._globalTimelineStyles =
              this._elementTimelineStylesLookup.get(t)),
            this._globalTimelineStyles ||
              ((this._globalTimelineStyles = this._localTimelineStyles),
              this._elementTimelineStylesLookup.set(
                t,
                this._localTimelineStyles
              )),
            this._loadKeyframe();
        }
        containsAnimation() {
          switch (this._keyframes.size) {
            case 0:
              return !1;
            case 1:
              return this.hasCurrentStyleProperties();
            default:
              return !0;
          }
        }
        hasCurrentStyleProperties() {
          return this._currentKeyframe.size > 0;
        }
        get currentTime() {
          return this.startTime + this.duration;
        }
        delayNextStep(e) {
          const t = 1 === this._keyframes.size && this._pendingStyles.size;
          this.duration || t
            ? (this.forwardTime(this.currentTime + e),
              t && this.snapshotCurrentStyles())
            : (this.startTime += e);
        }
        fork(e, t) {
          return (
            this.applyStylesToKeyframe(),
            new Tm(
              this._driver,
              e,
              t || this.currentTime,
              this._elementTimelineStylesLookup
            )
          );
        }
        _loadKeyframe() {
          this._currentKeyframe &&
            (this._previousKeyframe = this._currentKeyframe),
            (this._currentKeyframe = this._keyframes.get(this.duration)),
            this._currentKeyframe ||
              ((this._currentKeyframe = new Map()),
              this._keyframes.set(this.duration, this._currentKeyframe));
        }
        forwardFrame() {
          (this.duration += 1), this._loadKeyframe();
        }
        forwardTime(e) {
          this.applyStylesToKeyframe(),
            (this.duration = e),
            this._loadKeyframe();
        }
        _updateStyle(e, t) {
          this._localTimelineStyles.set(e, t),
            this._globalTimelineStyles.set(e, t),
            this._styleSummary.set(e, { time: this.currentTime, value: t });
        }
        allowOnlyTimelineStyles() {
          return this._currentEmptyStepKeyframe !== this._currentKeyframe;
        }
        applyEmptyStep(e) {
          e && this._previousKeyframe.set('easing', e);
          for (let [t, i] of this._globalTimelineStyles)
            this._backFill.set(t, i || hs), this._currentKeyframe.set(t, hs);
          this._currentEmptyStepKeyframe = this._currentKeyframe;
        }
        setStyles(e, t, i, r) {
          t && this._previousKeyframe.set('easing', t);
          const s = (r && r.params) || {},
            o = (function v7(n, e) {
              const t = new Map();
              let i;
              return (
                n.forEach((r) => {
                  if ('*' === r) {
                    i = i || e.keys();
                    for (let s of i) t.set(s, hs);
                  } else Qs(r, t);
                }),
                t
              );
            })(e, this._globalTimelineStyles);
          for (let [a, l] of o) {
            const c = uu(l, s, i);
            this._pendingStyles.set(a, c),
              this._localTimelineStyles.has(a) ||
                this._backFill.set(a, this._globalTimelineStyles.get(a) ?? hs),
              this._updateStyle(a, c);
          }
        }
        applyStylesToKeyframe() {
          0 != this._pendingStyles.size &&
            (this._pendingStyles.forEach((e, t) => {
              this._currentKeyframe.set(t, e);
            }),
            this._pendingStyles.clear(),
            this._localTimelineStyles.forEach((e, t) => {
              this._currentKeyframe.has(t) || this._currentKeyframe.set(t, e);
            }));
        }
        snapshotCurrentStyles() {
          for (let [e, t] of this._localTimelineStyles)
            this._pendingStyles.set(e, t), this._updateStyle(e, t);
        }
        getFinalKeyframe() {
          return this._keyframes.get(this.duration);
        }
        get properties() {
          const e = [];
          for (let t in this._currentKeyframe) e.push(t);
          return e;
        }
        mergeTimelineCollectedStyles(e) {
          e._styleSummary.forEach((t, i) => {
            const r = this._styleSummary.get(i);
            (!r || t.time > r.time) && this._updateStyle(i, t.value);
          });
        }
        buildKeyframes() {
          this.applyStylesToKeyframe();
          const e = new Set(),
            t = new Set(),
            i = 1 === this._keyframes.size && 0 === this.duration;
          let r = [];
          this._keyframes.forEach((a, l) => {
            const c = Qs(a, new Map(), this._backFill);
            c.forEach((u, h) => {
              '!' === u ? e.add(h) : u === hs && t.add(h);
            }),
              i || c.set('offset', l / this.duration),
              r.push(c);
          });
          const s = e.size ? Cm(e.values()) : [],
            o = t.size ? Cm(t.values()) : [];
          if (i) {
            const a = r[0],
              l = new Map(a);
            a.set('offset', 0), l.set('offset', 1), (r = [a, l]);
          }
          return B0(
            this.element,
            r,
            s,
            o,
            this.duration,
            this.startTime,
            this.easing,
            !1
          );
        }
      }
      class b7 extends Tm {
        constructor(e, t, i, r, s, o, a = !1) {
          super(e, t, o.delay),
            (this.keyframes = i),
            (this.preStyleProps = r),
            (this.postStyleProps = s),
            (this._stretchStartingKeyframe = a),
            (this.timings = {
              duration: o.duration,
              delay: o.delay,
              easing: o.easing,
            });
        }
        containsAnimation() {
          return this.keyframes.length > 1;
        }
        buildKeyframes() {
          let e = this.keyframes,
            { delay: t, duration: i, easing: r } = this.timings;
          if (this._stretchStartingKeyframe && t) {
            const s = [],
              o = i + t,
              a = t / o,
              l = Qs(e[0]);
            l.set('offset', 0), s.push(l);
            const c = Qs(e[0]);
            c.set('offset', CO(a)), s.push(c);
            const u = e.length - 1;
            for (let h = 1; h <= u; h++) {
              let f = Qs(e[h]);
              const p = f.get('offset');
              f.set('offset', CO((t + p * i) / o)), s.push(f);
            }
            (i = o), (t = 0), (r = ''), (e = s);
          }
          return B0(
            this.element,
            e,
            this.preStyleProps,
            this.postStyleProps,
            i,
            t,
            r,
            !0
          );
        }
      }
      function CO(n, e = 3) {
        const t = Math.pow(10, e - 1);
        return Math.round(n * t) / t;
      }
      class j0 {}
      const y7 = new Set([
        'width',
        'height',
        'minWidth',
        'minHeight',
        'maxWidth',
        'maxHeight',
        'left',
        'top',
        'bottom',
        'right',
        'fontSize',
        'outlineWidth',
        'outlineOffset',
        'paddingTop',
        'paddingLeft',
        'paddingBottom',
        'paddingRight',
        'marginTop',
        'marginLeft',
        'marginBottom',
        'marginRight',
        'borderRadius',
        'borderWidth',
        'borderTopWidth',
        'borderLeftWidth',
        'borderRightWidth',
        'borderBottomWidth',
        'textIndent',
        'perspective',
      ]);
      class w7 extends j0 {
        normalizePropertyName(e, t) {
          return L0(e);
        }
        normalizeStyleValue(e, t, i, r) {
          let s = '';
          const o = i.toString().trim();
          if (y7.has(t) && 0 !== i && '0' !== i)
            if ('number' == typeof i) s = 'px';
            else {
              const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
              a &&
                0 == a[1].length &&
                r.push(
                  (function m9(n, e) {
                    return new N(3005, !1);
                  })()
                );
            }
          return o + s;
        }
      }
      function xO(n, e, t, i, r, s, o, a, l, c, u, h, f) {
        return {
          type: 0,
          element: n,
          triggerName: e,
          isRemovalTransition: r,
          fromState: t,
          fromStyles: s,
          toState: i,
          toStyles: o,
          timelines: a,
          queriedElements: l,
          preStyleProps: c,
          postStyleProps: u,
          totalTime: h,
          errors: f,
        };
      }
      const z0 = {};
      class AO {
        constructor(e, t, i) {
          (this._triggerName = e), (this.ast = t), (this._stateStyles = i);
        }
        match(e, t, i, r) {
          return (function E7(n, e, t, i, r) {
            return n.some((s) => s(e, t, i, r));
          })(this.ast.matchers, e, t, i, r);
        }
        buildStyles(e, t, i) {
          let r = this._stateStyles.get('*');
          return (
            void 0 !== e && (r = this._stateStyles.get(e?.toString()) || r),
            r ? r.buildStyles(t, i) : new Map()
          );
        }
        build(e, t, i, r, s, o, a, l, c, u) {
          const h = [],
            f = (this.ast.options && this.ast.options.params) || z0,
            m = this.buildStyles(i, (a && a.params) || z0, h),
            g = (l && l.params) || z0,
            w = this.buildStyles(r, g, h),
            y = new Set(),
            E = new Map(),
            A = new Map(),
            M = 'void' === r,
            T = { params: C7(g, f), delay: this.ast.options?.delay },
            k = u ? [] : H0(e, t, this.ast.animation, s, o, m, w, T, c, h);
          let P = 0;
          if (
            (k.forEach((I) => {
              P = Math.max(I.duration + I.delay, P);
            }),
            h.length)
          )
            return xO(t, this._triggerName, i, r, M, m, w, [], [], E, A, P, h);
          k.forEach((I) => {
            const C = I.element,
              R = Ri(E, C, new Set());
            I.preStyleProps.forEach((q) => R.add(q));
            const $ = Ri(A, C, new Set());
            I.postStyleProps.forEach((q) => $.add(q)), C !== t && y.add(C);
          });
          const O = Cm(y.values());
          return xO(t, this._triggerName, i, r, M, m, w, k, O, E, A, P);
        }
      }
      function C7(n, e) {
        const t = cu(e);
        for (const i in n) n.hasOwnProperty(i) && null != n[i] && (t[i] = n[i]);
        return t;
      }
      class x7 {
        constructor(e, t, i) {
          (this.styles = e), (this.defaultParams = t), (this.normalizer = i);
        }
        buildStyles(e, t) {
          const i = new Map(),
            r = cu(this.defaultParams);
          return (
            Object.keys(e).forEach((s) => {
              const o = e[s];
              null !== o && (r[s] = o);
            }),
            this.styles.styles.forEach((s) => {
              'string' != typeof s &&
                s.forEach((o, a) => {
                  o && (o = uu(o, r, t));
                  const l = this.normalizer.normalizePropertyName(a, t);
                  (o = this.normalizer.normalizeStyleValue(a, l, o, t)),
                    i.set(a, o);
                });
            }),
            i
          );
        }
      }
      class S7 {
        constructor(e, t, i) {
          (this.name = e),
            (this.ast = t),
            (this._normalizer = i),
            (this.transitionFactories = []),
            (this.states = new Map()),
            t.states.forEach((r) => {
              this.states.set(
                r.name,
                new x7(r.style, (r.options && r.options.params) || {}, i)
              );
            }),
            SO(this.states, 'true', '1'),
            SO(this.states, 'false', '0'),
            t.transitions.forEach((r) => {
              this.transitionFactories.push(new AO(e, r, this.states));
            }),
            (this.fallbackTransition = (function M7(n, e, t) {
              return new AO(
                n,
                {
                  type: 1,
                  animation: { type: 2, steps: [], options: null },
                  matchers: [(o, a) => !0],
                  options: null,
                  queryCount: 0,
                  depCount: 0,
                },
                e
              );
            })(e, this.states));
        }
        get containsQueries() {
          return this.ast.queryCount > 0;
        }
        matchTransition(e, t, i, r) {
          return (
            this.transitionFactories.find((o) => o.match(e, t, i, r)) || null
          );
        }
        matchStyles(e, t, i) {
          return this.fallbackTransition.buildStyles(e, t, i);
        }
      }
      function SO(n, e, t) {
        n.has(e)
          ? n.has(t) || n.set(t, n.get(e))
          : n.has(t) && n.set(e, n.get(t));
      }
      const D7 = new Mm();
      class T7 {
        constructor(e, t, i) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = i),
            (this._animations = new Map()),
            (this._playersById = new Map()),
            (this.players = []);
        }
        register(e, t) {
          const i = [],
            s = N0(this._driver, t, i, []);
          if (i.length)
            throw (function R9(n) {
              return new N(3503, !1);
            })();
          this._animations.set(e, s);
        }
        _buildPlayer(e, t, i) {
          const r = e.element,
            s = lO(this._normalizer, e.keyframes, t, i);
          return this._driver.animate(
            r,
            s,
            e.duration,
            e.delay,
            e.easing,
            [],
            !0
          );
        }
        create(e, t, i = {}) {
          const r = [],
            s = this._animations.get(e);
          let o;
          const a = new Map();
          if (
            (s
              ? ((o = H0(
                  this._driver,
                  t,
                  s,
                  P0,
                  vm,
                  new Map(),
                  new Map(),
                  i,
                  D7,
                  r
                )),
                o.forEach((u) => {
                  const h = Ri(a, u.element, new Map());
                  u.postStyleProps.forEach((f) => h.set(f, null));
                }))
              : (r.push(
                  (function F9() {
                    return new N(3300, !1);
                  })()
                ),
                (o = [])),
            r.length)
          )
            throw (function O9(n) {
              return new N(3504, !1);
            })();
          a.forEach((u, h) => {
            u.forEach((f, p) => {
              u.set(p, this._driver.computeStyle(h, p, hs));
            });
          });
          const c = Zs(
            o.map((u) => {
              const h = a.get(u.element);
              return this._buildPlayer(u, new Map(), h);
            })
          );
          return (
            this._playersById.set(e, c),
            c.onDestroy(() => this.destroy(e)),
            this.players.push(c),
            c
          );
        }
        destroy(e) {
          const t = this._getPlayer(e);
          t.destroy(), this._playersById.delete(e);
          const i = this.players.indexOf(t);
          i >= 0 && this.players.splice(i, 1);
        }
        _getPlayer(e) {
          const t = this._playersById.get(e);
          if (!t)
            throw (function L9(n) {
              return new N(3301, !1);
            })();
          return t;
        }
        listen(e, t, i, r) {
          const s = T0(t, '', '', '');
          return M0(this._getPlayer(e), i, s, r), () => {};
        }
        command(e, t, i, r) {
          if ('register' == i) return void this.register(e, r[0]);
          if ('create' == i) return void this.create(e, t, r[0] || {});
          const s = this._getPlayer(e);
          switch (i) {
            case 'play':
              s.play();
              break;
            case 'pause':
              s.pause();
              break;
            case 'reset':
              s.reset();
              break;
            case 'restart':
              s.restart();
              break;
            case 'finish':
              s.finish();
              break;
            case 'init':
              s.init();
              break;
            case 'setPosition':
              s.setPosition(parseFloat(r[0]));
              break;
            case 'destroy':
              this.destroy(e);
          }
        }
      }
      const MO = 'ng-animate-queued',
        U0 = 'ng-animate-disabled',
        F7 = [],
        DO = {
          namespaceId: '',
          setForRemoval: !1,
          setForMove: !1,
          hasAnimation: !1,
          removedBeforeQueried: !1,
        },
        O7 = {
          namespaceId: '',
          setForMove: !1,
          setForRemoval: !1,
          hasAnimation: !1,
          removedBeforeQueried: !0,
        },
        Xi = '__ng_removed';
      class $0 {
        get params() {
          return this.options.params;
        }
        constructor(e, t = '') {
          this.namespaceId = t;
          const i = e && e.hasOwnProperty('value');
          if (
            ((this.value = (function B7(n) {
              return n ?? null;
            })(i ? e.value : e)),
            i)
          ) {
            const s = cu(e);
            delete s.value, (this.options = s);
          } else this.options = {};
          this.options.params || (this.options.params = {});
        }
        absorbOptions(e) {
          const t = e.params;
          if (t) {
            const i = this.options.params;
            Object.keys(t).forEach((r) => {
              null == i[r] && (i[r] = t[r]);
            });
          }
        }
      }
      const hu = 'void',
        G0 = new $0(hu);
      class L7 {
        constructor(e, t, i) {
          (this.id = e),
            (this.hostElement = t),
            (this._engine = i),
            (this.players = []),
            (this._triggers = new Map()),
            (this._queue = []),
            (this._elementListeners = new Map()),
            (this._hostClassName = 'ng-tns-' + e),
            Yi(t, this._hostClassName);
        }
        listen(e, t, i, r) {
          if (!this._triggers.has(t))
            throw (function N9(n, e) {
              return new N(3302, !1);
            })();
          if (null == i || 0 == i.length)
            throw (function V9(n) {
              return new N(3303, !1);
            })();
          if (
            !(function H7(n) {
              return 'start' == n || 'done' == n;
            })(i)
          )
            throw (function B9(n, e) {
              return new N(3400, !1);
            })();
          const s = Ri(this._elementListeners, e, []),
            o = { name: t, phase: i, callback: r };
          s.push(o);
          const a = Ri(this._engine.statesByElement, e, new Map());
          return (
            a.has(t) || (Yi(e, ym), Yi(e, ym + '-' + t), a.set(t, G0)),
            () => {
              this._engine.afterFlush(() => {
                const l = s.indexOf(o);
                l >= 0 && s.splice(l, 1), this._triggers.has(t) || a.delete(t);
              });
            }
          );
        }
        register(e, t) {
          return !this._triggers.has(e) && (this._triggers.set(e, t), !0);
        }
        _getTrigger(e) {
          const t = this._triggers.get(e);
          if (!t)
            throw (function H9(n) {
              return new N(3401, !1);
            })();
          return t;
        }
        trigger(e, t, i, r = !0) {
          const s = this._getTrigger(t),
            o = new q0(this.id, t, e);
          let a = this._engine.statesByElement.get(e);
          a ||
            (Yi(e, ym),
            Yi(e, ym + '-' + t),
            this._engine.statesByElement.set(e, (a = new Map())));
          let l = a.get(t);
          const c = new $0(i, this.id);
          if (
            (!(i && i.hasOwnProperty('value')) &&
              l &&
              c.absorbOptions(l.options),
            a.set(t, c),
            l || (l = G0),
            c.value !== hu && l.value === c.value)
          ) {
            if (
              !(function z7(n, e) {
                const t = Object.keys(n),
                  i = Object.keys(e);
                if (t.length != i.length) return !1;
                for (let r = 0; r < t.length; r++) {
                  const s = t[r];
                  if (!e.hasOwnProperty(s) || n[s] !== e[s]) return !1;
                }
                return !0;
              })(l.params, c.params)
            ) {
              const g = [],
                w = s.matchStyles(l.value, l.params, g),
                y = s.matchStyles(c.value, c.params, g);
              g.length
                ? this._engine.reportError(g)
                : this._engine.afterFlush(() => {
                    ra(e, w), Wr(e, y);
                  });
            }
            return;
          }
          const f = Ri(this._engine.playersByElement, e, []);
          f.forEach((g) => {
            g.namespaceId == this.id &&
              g.triggerName == t &&
              g.queued &&
              g.destroy();
          });
          let p = s.matchTransition(l.value, c.value, e, c.params),
            m = !1;
          if (!p) {
            if (!r) return;
            (p = s.fallbackTransition), (m = !0);
          }
          return (
            this._engine.totalQueuedPlayers++,
            this._queue.push({
              element: e,
              triggerName: t,
              transition: p,
              fromState: l,
              toState: c,
              player: o,
              isFallbackTransition: m,
            }),
            m ||
              (Yi(e, MO),
              o.onStart(() => {
                Ul(e, MO);
              })),
            o.onDone(() => {
              let g = this.players.indexOf(o);
              g >= 0 && this.players.splice(g, 1);
              const w = this._engine.playersByElement.get(e);
              if (w) {
                let y = w.indexOf(o);
                y >= 0 && w.splice(y, 1);
              }
            }),
            this.players.push(o),
            f.push(o),
            o
          );
        }
        deregister(e) {
          this._triggers.delete(e),
            this._engine.statesByElement.forEach((t) => t.delete(e)),
            this._elementListeners.forEach((t, i) => {
              this._elementListeners.set(
                i,
                t.filter((r) => r.name != e)
              );
            });
        }
        clearElementCache(e) {
          this._engine.statesByElement.delete(e),
            this._elementListeners.delete(e);
          const t = this._engine.playersByElement.get(e);
          t &&
            (t.forEach((i) => i.destroy()),
            this._engine.playersByElement.delete(e));
        }
        _signalRemovalForInnerTriggers(e, t) {
          const i = this._engine.driver.query(e, wm, !0);
          i.forEach((r) => {
            if (r[Xi]) return;
            const s = this._engine.fetchNamespacesByElement(r);
            s.size
              ? s.forEach((o) => o.triggerLeaveAnimation(r, t, !1, !0))
              : this.clearElementCache(r);
          }),
            this._engine.afterFlushAnimationsDone(() =>
              i.forEach((r) => this.clearElementCache(r))
            );
        }
        triggerLeaveAnimation(e, t, i, r) {
          const s = this._engine.statesByElement.get(e),
            o = new Map();
          if (s) {
            const a = [];
            if (
              (s.forEach((l, c) => {
                if ((o.set(c, l.value), this._triggers.has(c))) {
                  const u = this.trigger(e, c, hu, r);
                  u && a.push(u);
                }
              }),
              a.length)
            )
              return (
                this._engine.markElementAsRemoved(this.id, e, !0, t, o),
                i && Zs(a).onDone(() => this._engine.processLeaveNode(e)),
                !0
              );
          }
          return !1;
        }
        prepareLeaveAnimationListeners(e) {
          const t = this._elementListeners.get(e),
            i = this._engine.statesByElement.get(e);
          if (t && i) {
            const r = new Set();
            t.forEach((s) => {
              const o = s.name;
              if (r.has(o)) return;
              r.add(o);
              const l = this._triggers.get(o).fallbackTransition,
                c = i.get(o) || G0,
                u = new $0(hu),
                h = new q0(this.id, o, e);
              this._engine.totalQueuedPlayers++,
                this._queue.push({
                  element: e,
                  triggerName: o,
                  transition: l,
                  fromState: c,
                  toState: u,
                  player: h,
                  isFallbackTransition: !0,
                });
            });
          }
        }
        removeNode(e, t) {
          const i = this._engine;
          if (
            (e.childElementCount && this._signalRemovalForInnerTriggers(e, t),
            this.triggerLeaveAnimation(e, t, !0))
          )
            return;
          let r = !1;
          if (i.totalAnimations) {
            const s = i.players.length ? i.playersByQueriedElement.get(e) : [];
            if (s && s.length) r = !0;
            else {
              let o = e;
              for (; (o = o.parentNode); )
                if (i.statesByElement.get(o)) {
                  r = !0;
                  break;
                }
            }
          }
          if ((this.prepareLeaveAnimationListeners(e), r))
            i.markElementAsRemoved(this.id, e, !1, t);
          else {
            const s = e[Xi];
            (!s || s === DO) &&
              (i.afterFlush(() => this.clearElementCache(e)),
              i.destroyInnerAnimations(e),
              i._onRemovalComplete(e, t));
          }
        }
        insertNode(e, t) {
          Yi(e, this._hostClassName);
        }
        drainQueuedTransitions(e) {
          const t = [];
          return (
            this._queue.forEach((i) => {
              const r = i.player;
              if (r.destroyed) return;
              const s = i.element,
                o = this._elementListeners.get(s);
              o &&
                o.forEach((a) => {
                  if (a.name == i.triggerName) {
                    const l = T0(
                      s,
                      i.triggerName,
                      i.fromState.value,
                      i.toState.value
                    );
                    (l._data = e), M0(i.player, a.phase, l, a.callback);
                  }
                }),
                r.markedForDestroy
                  ? this._engine.afterFlush(() => {
                      r.destroy();
                    })
                  : t.push(i);
            }),
            (this._queue = []),
            t.sort((i, r) => {
              const s = i.transition.ast.depCount,
                o = r.transition.ast.depCount;
              return 0 == s || 0 == o
                ? s - o
                : this._engine.driver.containsElement(i.element, r.element)
                ? 1
                : -1;
            })
          );
        }
        destroy(e) {
          this.players.forEach((t) => t.destroy()),
            this._signalRemovalForInnerTriggers(this.hostElement, e);
        }
        elementContainsData(e) {
          let t = !1;
          return (
            this._elementListeners.has(e) && (t = !0),
            (t = !!this._queue.find((i) => i.element === e) || t),
            t
          );
        }
      }
      class N7 {
        _onRemovalComplete(e, t) {
          this.onRemovalComplete(e, t);
        }
        constructor(e, t, i) {
          (this.bodyNode = e),
            (this.driver = t),
            (this._normalizer = i),
            (this.players = []),
            (this.newHostElements = new Map()),
            (this.playersByElement = new Map()),
            (this.playersByQueriedElement = new Map()),
            (this.statesByElement = new Map()),
            (this.disabledNodes = new Set()),
            (this.totalAnimations = 0),
            (this.totalQueuedPlayers = 0),
            (this._namespaceLookup = {}),
            (this._namespaceList = []),
            (this._flushFns = []),
            (this._whenQuietFns = []),
            (this.namespacesByHostElement = new Map()),
            (this.collectedEnterElements = []),
            (this.collectedLeaveElements = []),
            (this.onRemovalComplete = (r, s) => {});
        }
        get queuedPlayers() {
          const e = [];
          return (
            this._namespaceList.forEach((t) => {
              t.players.forEach((i) => {
                i.queued && e.push(i);
              });
            }),
            e
          );
        }
        createNamespace(e, t) {
          const i = new L7(e, t, this);
          return (
            this.bodyNode && this.driver.containsElement(this.bodyNode, t)
              ? this._balanceNamespaceList(i, t)
              : (this.newHostElements.set(t, i), this.collectEnterElement(t)),
            (this._namespaceLookup[e] = i)
          );
        }
        _balanceNamespaceList(e, t) {
          const i = this._namespaceList,
            r = this.namespacesByHostElement;
          if (i.length - 1 >= 0) {
            let o = !1,
              a = this.driver.getParentElement(t);
            for (; a; ) {
              const l = r.get(a);
              if (l) {
                const c = i.indexOf(l);
                i.splice(c + 1, 0, e), (o = !0);
                break;
              }
              a = this.driver.getParentElement(a);
            }
            o || i.unshift(e);
          } else i.push(e);
          return r.set(t, e), e;
        }
        register(e, t) {
          let i = this._namespaceLookup[e];
          return i || (i = this.createNamespace(e, t)), i;
        }
        registerTrigger(e, t, i) {
          let r = this._namespaceLookup[e];
          r && r.register(t, i) && this.totalAnimations++;
        }
        destroy(e, t) {
          if (!e) return;
          const i = this._fetchNamespace(e);
          this.afterFlush(() => {
            this.namespacesByHostElement.delete(i.hostElement),
              delete this._namespaceLookup[e];
            const r = this._namespaceList.indexOf(i);
            r >= 0 && this._namespaceList.splice(r, 1);
          }),
            this.afterFlushAnimationsDone(() => i.destroy(t));
        }
        _fetchNamespace(e) {
          return this._namespaceLookup[e];
        }
        fetchNamespacesByElement(e) {
          const t = new Set(),
            i = this.statesByElement.get(e);
          if (i)
            for (let r of i.values())
              if (r.namespaceId) {
                const s = this._fetchNamespace(r.namespaceId);
                s && t.add(s);
              }
          return t;
        }
        trigger(e, t, i, r) {
          if (Im(t)) {
            const s = this._fetchNamespace(e);
            if (s) return s.trigger(t, i, r), !0;
          }
          return !1;
        }
        insertNode(e, t, i, r) {
          if (!Im(t)) return;
          const s = t[Xi];
          if (s && s.setForRemoval) {
            (s.setForRemoval = !1), (s.setForMove = !0);
            const o = this.collectedLeaveElements.indexOf(t);
            o >= 0 && this.collectedLeaveElements.splice(o, 1);
          }
          if (e) {
            const o = this._fetchNamespace(e);
            o && o.insertNode(t, i);
          }
          r && this.collectEnterElement(t);
        }
        collectEnterElement(e) {
          this.collectedEnterElements.push(e);
        }
        markElementAsDisabled(e, t) {
          t
            ? this.disabledNodes.has(e) ||
              (this.disabledNodes.add(e), Yi(e, U0))
            : this.disabledNodes.has(e) &&
              (this.disabledNodes.delete(e), Ul(e, U0));
        }
        removeNode(e, t, i) {
          if (Im(t)) {
            const r = e ? this._fetchNamespace(e) : null;
            r ? r.removeNode(t, i) : this.markElementAsRemoved(e, t, !1, i);
            const s = this.namespacesByHostElement.get(t);
            s && s.id !== e && s.removeNode(t, i);
          } else this._onRemovalComplete(t, i);
        }
        markElementAsRemoved(e, t, i, r, s) {
          this.collectedLeaveElements.push(t),
            (t[Xi] = {
              namespaceId: e,
              setForRemoval: r,
              hasAnimation: i,
              removedBeforeQueried: !1,
              previousTriggersValues: s,
            });
        }
        listen(e, t, i, r, s) {
          return Im(t) ? this._fetchNamespace(e).listen(t, i, r, s) : () => {};
        }
        _buildInstruction(e, t, i, r, s) {
          return e.transition.build(
            this.driver,
            e.element,
            e.fromState.value,
            e.toState.value,
            i,
            r,
            e.fromState.options,
            e.toState.options,
            t,
            s
          );
        }
        destroyInnerAnimations(e) {
          let t = this.driver.query(e, wm, !0);
          t.forEach((i) => this.destroyActiveAnimationsForElement(i)),
            0 != this.playersByQueriedElement.size &&
              ((t = this.driver.query(e, R0, !0)),
              t.forEach((i) => this.finishActiveQueriedAnimationOnElement(i)));
        }
        destroyActiveAnimationsForElement(e) {
          const t = this.playersByElement.get(e);
          t &&
            t.forEach((i) => {
              i.queued ? (i.markedForDestroy = !0) : i.destroy();
            });
        }
        finishActiveQueriedAnimationOnElement(e) {
          const t = this.playersByQueriedElement.get(e);
          t && t.forEach((i) => i.finish());
        }
        whenRenderingDone() {
          return new Promise((e) => {
            if (this.players.length) return Zs(this.players).onDone(() => e());
            e();
          });
        }
        processLeaveNode(e) {
          const t = e[Xi];
          if (t && t.setForRemoval) {
            if (((e[Xi] = DO), t.namespaceId)) {
              this.destroyInnerAnimations(e);
              const i = this._fetchNamespace(t.namespaceId);
              i && i.clearElementCache(e);
            }
            this._onRemovalComplete(e, t.setForRemoval);
          }
          e.classList?.contains(U0) && this.markElementAsDisabled(e, !1),
            this.driver.query(e, '.ng-animate-disabled', !0).forEach((i) => {
              this.markElementAsDisabled(i, !1);
            });
        }
        flush(e = -1) {
          let t = [];
          if (
            (this.newHostElements.size &&
              (this.newHostElements.forEach((i, r) =>
                this._balanceNamespaceList(i, r)
              ),
              this.newHostElements.clear()),
            this.totalAnimations && this.collectedEnterElements.length)
          )
            for (let i = 0; i < this.collectedEnterElements.length; i++)
              Yi(this.collectedEnterElements[i], 'ng-star-inserted');
          if (
            this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)
          ) {
            const i = [];
            try {
              t = this._flushAnimations(i, e);
            } finally {
              for (let r = 0; r < i.length; r++) i[r]();
            }
          } else
            for (let i = 0; i < this.collectedLeaveElements.length; i++)
              this.processLeaveNode(this.collectedLeaveElements[i]);
          if (
            ((this.totalQueuedPlayers = 0),
            (this.collectedEnterElements.length = 0),
            (this.collectedLeaveElements.length = 0),
            this._flushFns.forEach((i) => i()),
            (this._flushFns = []),
            this._whenQuietFns.length)
          ) {
            const i = this._whenQuietFns;
            (this._whenQuietFns = []),
              t.length
                ? Zs(t).onDone(() => {
                    i.forEach((r) => r());
                  })
                : i.forEach((r) => r());
          }
        }
        reportError(e) {
          throw (function W9(n) {
            return new N(3402, !1);
          })();
        }
        _flushAnimations(e, t) {
          const i = new Mm(),
            r = [],
            s = new Map(),
            o = [],
            a = new Map(),
            l = new Map(),
            c = new Map(),
            u = new Set();
          this.disabledNodes.forEach((F) => {
            u.add(F);
            const W = this.driver.query(F, '.ng-animate-queued', !0);
            for (let Q = 0; Q < W.length; Q++) u.add(W[Q]);
          });
          const h = this.bodyNode,
            f = Array.from(this.statesByElement.keys()),
            p = kO(f, this.collectedEnterElements),
            m = new Map();
          let g = 0;
          p.forEach((F, W) => {
            const Q = P0 + g++;
            m.set(W, Q), F.forEach((ge) => Yi(ge, Q));
          });
          const w = [],
            y = new Set(),
            E = new Set();
          for (let F = 0; F < this.collectedLeaveElements.length; F++) {
            const W = this.collectedLeaveElements[F],
              Q = W[Xi];
            Q &&
              Q.setForRemoval &&
              (w.push(W),
              y.add(W),
              Q.hasAnimation
                ? this.driver
                    .query(W, '.ng-star-inserted', !0)
                    .forEach((ge) => y.add(ge))
                : E.add(W));
          }
          const A = new Map(),
            M = kO(f, Array.from(y));
          M.forEach((F, W) => {
            const Q = vm + g++;
            A.set(W, Q), F.forEach((ge) => Yi(ge, Q));
          }),
            e.push(() => {
              p.forEach((F, W) => {
                const Q = m.get(W);
                F.forEach((ge) => Ul(ge, Q));
              }),
                M.forEach((F, W) => {
                  const Q = A.get(W);
                  F.forEach((ge) => Ul(ge, Q));
                }),
                w.forEach((F) => {
                  this.processLeaveNode(F);
                });
            });
          const T = [],
            k = [];
          for (let F = this._namespaceList.length - 1; F >= 0; F--)
            this._namespaceList[F].drainQueuedTransitions(t).forEach((Q) => {
              const ge = Q.player,
                st = Q.element;
              if ((T.push(ge), this.collectedEnterElements.length)) {
                const De = st[Xi];
                if (De && De.setForMove) {
                  if (
                    De.previousTriggersValues &&
                    De.previousTriggersValues.has(Q.triggerName)
                  ) {
                    const Ct = De.previousTriggersValues.get(Q.triggerName),
                      Ot = this.statesByElement.get(Q.element);
                    if (Ot && Ot.has(Q.triggerName)) {
                      const Do = Ot.get(Q.triggerName);
                      (Do.value = Ct), Ot.set(Q.triggerName, Do);
                    }
                  }
                  return void ge.destroy();
                }
              }
              const un = !h || !this.driver.containsElement(h, st),
                Je = A.get(st),
                ft = m.get(st),
                nt = this._buildInstruction(Q, i, ft, Je, un);
              if (nt.errors && nt.errors.length) return void k.push(nt);
              if (un)
                return (
                  ge.onStart(() => ra(st, nt.fromStyles)),
                  ge.onDestroy(() => Wr(st, nt.toStyles)),
                  void r.push(ge)
                );
              if (Q.isFallbackTransition)
                return (
                  ge.onStart(() => ra(st, nt.fromStyles)),
                  ge.onDestroy(() => Wr(st, nt.toStyles)),
                  void r.push(ge)
                );
              const vi = [];
              nt.timelines.forEach((De) => {
                (De.stretchStartingKeyframe = !0),
                  this.disabledNodes.has(De.element) || vi.push(De);
              }),
                (nt.timelines = vi),
                i.append(st, nt.timelines),
                o.push({ instruction: nt, player: ge, element: st }),
                nt.queriedElements.forEach((De) => Ri(a, De, []).push(ge)),
                nt.preStyleProps.forEach((De, Ct) => {
                  if (De.size) {
                    let Ot = l.get(Ct);
                    Ot || l.set(Ct, (Ot = new Set())),
                      De.forEach((Do, To) => Ot.add(To));
                  }
                }),
                nt.postStyleProps.forEach((De, Ct) => {
                  let Ot = c.get(Ct);
                  Ot || c.set(Ct, (Ot = new Set())),
                    De.forEach((Do, To) => Ot.add(To));
                });
            });
          if (k.length) {
            const F = [];
            k.forEach((W) => {
              F.push(
                (function j9(n, e) {
                  return new N(3505, !1);
                })()
              );
            }),
              T.forEach((W) => W.destroy()),
              this.reportError(F);
          }
          const P = new Map(),
            O = new Map();
          o.forEach((F) => {
            const W = F.element;
            i.has(W) &&
              (O.set(W, W),
              this._beforeAnimationBuild(
                F.player.namespaceId,
                F.instruction,
                P
              ));
          }),
            r.forEach((F) => {
              const W = F.element;
              this._getPreviousPlayers(
                W,
                !1,
                F.namespaceId,
                F.triggerName,
                null
              ).forEach((ge) => {
                Ri(P, W, []).push(ge), ge.destroy();
              });
            });
          const I = w.filter((F) => RO(F, l, c)),
            C = new Map();
          IO(C, this.driver, E, c, hs).forEach((F) => {
            RO(F, l, c) && I.push(F);
          });
          const $ = new Map();
          p.forEach((F, W) => {
            IO($, this.driver, new Set(F), l, '!');
          }),
            I.forEach((F) => {
              const W = C.get(F),
                Q = $.get(F);
              C.set(
                F,
                new Map([...(W?.entries() ?? []), ...(Q?.entries() ?? [])])
              );
            });
          const q = [],
            oe = [],
            Oe = {};
          o.forEach((F) => {
            const { element: W, player: Q, instruction: ge } = F;
            if (i.has(W)) {
              if (u.has(W))
                return (
                  Q.onDestroy(() => Wr(W, ge.toStyles)),
                  (Q.disabled = !0),
                  Q.overrideTotalTime(ge.totalTime),
                  void r.push(Q)
                );
              let st = Oe;
              if (O.size > 1) {
                let Je = W;
                const ft = [];
                for (; (Je = Je.parentNode); ) {
                  const nt = O.get(Je);
                  if (nt) {
                    st = nt;
                    break;
                  }
                  ft.push(Je);
                }
                ft.forEach((nt) => O.set(nt, st));
              }
              const un = this._buildAnimation(Q.namespaceId, ge, P, s, $, C);
              if ((Q.setRealPlayer(un), st === Oe)) q.push(Q);
              else {
                const Je = this.playersByElement.get(st);
                Je && Je.length && (Q.parentPlayer = Zs(Je)), r.push(Q);
              }
            } else
              ra(W, ge.fromStyles),
                Q.onDestroy(() => Wr(W, ge.toStyles)),
                oe.push(Q),
                u.has(W) && r.push(Q);
          }),
            oe.forEach((F) => {
              const W = s.get(F.element);
              if (W && W.length) {
                const Q = Zs(W);
                F.setRealPlayer(Q);
              }
            }),
            r.forEach((F) => {
              F.parentPlayer ? F.syncPlayerEvents(F.parentPlayer) : F.destroy();
            });
          for (let F = 0; F < w.length; F++) {
            const W = w[F],
              Q = W[Xi];
            if ((Ul(W, vm), Q && Q.hasAnimation)) continue;
            let ge = [];
            if (a.size) {
              let un = a.get(W);
              un && un.length && ge.push(...un);
              let Je = this.driver.query(W, R0, !0);
              for (let ft = 0; ft < Je.length; ft++) {
                let nt = a.get(Je[ft]);
                nt && nt.length && ge.push(...nt);
              }
            }
            const st = ge.filter((un) => !un.destroyed);
            st.length ? W7(this, W, st) : this.processLeaveNode(W);
          }
          return (
            (w.length = 0),
            q.forEach((F) => {
              this.players.push(F),
                F.onDone(() => {
                  F.destroy();
                  const W = this.players.indexOf(F);
                  this.players.splice(W, 1);
                }),
                F.play();
            }),
            q
          );
        }
        elementContainsData(e, t) {
          let i = !1;
          const r = t[Xi];
          return (
            r && r.setForRemoval && (i = !0),
            this.playersByElement.has(t) && (i = !0),
            this.playersByQueriedElement.has(t) && (i = !0),
            this.statesByElement.has(t) && (i = !0),
            this._fetchNamespace(e).elementContainsData(t) || i
          );
        }
        afterFlush(e) {
          this._flushFns.push(e);
        }
        afterFlushAnimationsDone(e) {
          this._whenQuietFns.push(e);
        }
        _getPreviousPlayers(e, t, i, r, s) {
          let o = [];
          if (t) {
            const a = this.playersByQueriedElement.get(e);
            a && (o = a);
          } else {
            const a = this.playersByElement.get(e);
            if (a) {
              const l = !s || s == hu;
              a.forEach((c) => {
                c.queued || (!l && c.triggerName != r) || o.push(c);
              });
            }
          }
          return (
            (i || r) &&
              (o = o.filter(
                (a) => !((i && i != a.namespaceId) || (r && r != a.triggerName))
              )),
            o
          );
        }
        _beforeAnimationBuild(e, t, i) {
          const s = t.element,
            o = t.isRemovalTransition ? void 0 : e,
            a = t.isRemovalTransition ? void 0 : t.triggerName;
          for (const l of t.timelines) {
            const c = l.element,
              u = c !== s,
              h = Ri(i, c, []);
            this._getPreviousPlayers(c, u, o, a, t.toState).forEach((p) => {
              const m = p.getRealPlayer();
              m.beforeDestroy && m.beforeDestroy(), p.destroy(), h.push(p);
            });
          }
          ra(s, t.fromStyles);
        }
        _buildAnimation(e, t, i, r, s, o) {
          const a = t.triggerName,
            l = t.element,
            c = [],
            u = new Set(),
            h = new Set(),
            f = t.timelines.map((m) => {
              const g = m.element;
              u.add(g);
              const w = g[Xi];
              if (w && w.removedBeforeQueried)
                return new lu(m.duration, m.delay);
              const y = g !== l,
                E = (function j7(n) {
                  const e = [];
                  return PO(n, e), e;
                })((i.get(g) || F7).map((P) => P.getRealPlayer())).filter(
                  (P) => !!P.element && P.element === g
                ),
                A = s.get(g),
                M = o.get(g),
                T = lO(this._normalizer, m.keyframes, A, M),
                k = this._buildPlayer(m, T, E);
              if ((m.subTimeline && r && h.add(g), y)) {
                const P = new q0(e, a, g);
                P.setRealPlayer(k), c.push(P);
              }
              return k;
            });
          c.forEach((m) => {
            Ri(this.playersByQueriedElement, m.element, []).push(m),
              m.onDone(() =>
                (function V7(n, e, t) {
                  let i = n.get(e);
                  if (i) {
                    if (i.length) {
                      const r = i.indexOf(t);
                      i.splice(r, 1);
                    }
                    0 == i.length && n.delete(e);
                  }
                  return i;
                })(this.playersByQueriedElement, m.element, m)
              );
          }),
            u.forEach((m) => Yi(m, mO));
          const p = Zs(f);
          return (
            p.onDestroy(() => {
              u.forEach((m) => Ul(m, mO)), Wr(l, t.toStyles);
            }),
            h.forEach((m) => {
              Ri(r, m, []).push(p);
            }),
            p
          );
        }
        _buildPlayer(e, t, i) {
          return t.length > 0
            ? this.driver.animate(
                e.element,
                t,
                e.duration,
                e.delay,
                e.easing,
                i
              )
            : new lu(e.duration, e.delay);
        }
      }
      class q0 {
        constructor(e, t, i) {
          (this.namespaceId = e),
            (this.triggerName = t),
            (this.element = i),
            (this._player = new lu()),
            (this._containsRealPlayer = !1),
            (this._queuedCallbacks = new Map()),
            (this.destroyed = !1),
            (this.parentPlayer = null),
            (this.markedForDestroy = !1),
            (this.disabled = !1),
            (this.queued = !0),
            (this.totalTime = 0);
        }
        setRealPlayer(e) {
          this._containsRealPlayer ||
            ((this._player = e),
            this._queuedCallbacks.forEach((t, i) => {
              t.forEach((r) => M0(e, i, void 0, r));
            }),
            this._queuedCallbacks.clear(),
            (this._containsRealPlayer = !0),
            this.overrideTotalTime(e.totalTime),
            (this.queued = !1));
        }
        getRealPlayer() {
          return this._player;
        }
        overrideTotalTime(e) {
          this.totalTime = e;
        }
        syncPlayerEvents(e) {
          const t = this._player;
          t.triggerCallback && e.onStart(() => t.triggerCallback('start')),
            e.onDone(() => this.finish()),
            e.onDestroy(() => this.destroy());
        }
        _queueEvent(e, t) {
          Ri(this._queuedCallbacks, e, []).push(t);
        }
        onDone(e) {
          this.queued && this._queueEvent('done', e), this._player.onDone(e);
        }
        onStart(e) {
          this.queued && this._queueEvent('start', e), this._player.onStart(e);
        }
        onDestroy(e) {
          this.queued && this._queueEvent('destroy', e),
            this._player.onDestroy(e);
        }
        init() {
          this._player.init();
        }
        hasStarted() {
          return !this.queued && this._player.hasStarted();
        }
        play() {
          !this.queued && this._player.play();
        }
        pause() {
          !this.queued && this._player.pause();
        }
        restart() {
          !this.queued && this._player.restart();
        }
        finish() {
          this._player.finish();
        }
        destroy() {
          (this.destroyed = !0), this._player.destroy();
        }
        reset() {
          !this.queued && this._player.reset();
        }
        setPosition(e) {
          this.queued || this._player.setPosition(e);
        }
        getPosition() {
          return this.queued ? 0 : this._player.getPosition();
        }
        triggerCallback(e) {
          const t = this._player;
          t.triggerCallback && t.triggerCallback(e);
        }
      }
      function Im(n) {
        return n && 1 === n.nodeType;
      }
      function TO(n, e) {
        const t = n.style.display;
        return (n.style.display = e ?? 'none'), t;
      }
      function IO(n, e, t, i, r) {
        const s = [];
        t.forEach((l) => s.push(TO(l)));
        const o = [];
        i.forEach((l, c) => {
          const u = new Map();
          l.forEach((h) => {
            const f = e.computeStyle(c, h, r);
            u.set(h, f), (!f || 0 == f.length) && ((c[Xi] = O7), o.push(c));
          }),
            n.set(c, u);
        });
        let a = 0;
        return t.forEach((l) => TO(l, s[a++])), o;
      }
      function kO(n, e) {
        const t = new Map();
        if ((n.forEach((a) => t.set(a, [])), 0 == e.length)) return t;
        const r = new Set(e),
          s = new Map();
        function o(a) {
          if (!a) return 1;
          let l = s.get(a);
          if (l) return l;
          const c = a.parentNode;
          return (l = t.has(c) ? c : r.has(c) ? 1 : o(c)), s.set(a, l), l;
        }
        return (
          e.forEach((a) => {
            const l = o(a);
            1 !== l && t.get(l).push(a);
          }),
          t
        );
      }
      function Yi(n, e) {
        n.classList?.add(e);
      }
      function Ul(n, e) {
        n.classList?.remove(e);
      }
      function W7(n, e, t) {
        Zs(t).onDone(() => n.processLeaveNode(e));
      }
      function PO(n, e) {
        for (let t = 0; t < n.length; t++) {
          const i = n[t];
          i instanceof oO ? PO(i.players, e) : e.push(i);
        }
      }
      function RO(n, e, t) {
        const i = t.get(n);
        if (!i) return !1;
        let r = e.get(n);
        return r ? i.forEach((s) => r.add(s)) : e.set(n, i), t.delete(n), !0;
      }
      class km {
        constructor(e, t, i) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = i),
            (this._triggerCache = {}),
            (this.onRemovalComplete = (r, s) => {}),
            (this._transitionEngine = new N7(e, t, i)),
            (this._timelineEngine = new T7(e, t, i)),
            (this._transitionEngine.onRemovalComplete = (r, s) =>
              this.onRemovalComplete(r, s));
        }
        registerTrigger(e, t, i, r, s) {
          const o = e + '-' + r;
          let a = this._triggerCache[o];
          if (!a) {
            const l = [],
              u = N0(this._driver, s, l, []);
            if (l.length)
              throw (function k9(n, e) {
                return new N(3404, !1);
              })();
            (a = (function A7(n, e, t) {
              return new S7(n, e, t);
            })(r, u, this._normalizer)),
              (this._triggerCache[o] = a);
          }
          this._transitionEngine.registerTrigger(t, r, a);
        }
        register(e, t) {
          this._transitionEngine.register(e, t);
        }
        destroy(e, t) {
          this._transitionEngine.destroy(e, t);
        }
        onInsert(e, t, i, r) {
          this._transitionEngine.insertNode(e, t, i, r);
        }
        onRemove(e, t, i) {
          this._transitionEngine.removeNode(e, t, i);
        }
        disableAnimations(e, t) {
          this._transitionEngine.markElementAsDisabled(e, t);
        }
        process(e, t, i, r) {
          if ('@' == i.charAt(0)) {
            const [s, o] = cO(i);
            this._timelineEngine.command(s, t, o, r);
          } else this._transitionEngine.trigger(e, t, i, r);
        }
        listen(e, t, i, r, s) {
          if ('@' == i.charAt(0)) {
            const [o, a] = cO(i);
            return this._timelineEngine.listen(o, t, a, s);
          }
          return this._transitionEngine.listen(e, t, i, r, s);
        }
        flush(e = -1) {
          this._transitionEngine.flush(e);
        }
        get players() {
          return this._transitionEngine.players.concat(
            this._timelineEngine.players
          );
        }
        whenRenderingDone() {
          return this._transitionEngine.whenRenderingDone();
        }
      }
      let X7 = (() => {
        class n extends iO {
          constructor(t, i) {
            super(),
              (this._nextAnimationId = 0),
              (this._renderer = t.createRenderer(i.body, {
                id: '0',
                encapsulation: ei.None,
                styles: [],
                data: { animation: [] },
              }));
          }
          build(t) {
            const i = this._nextAnimationId.toString();
            this._nextAnimationId++;
            const r = Array.isArray(t) ? rO(t) : t;
            return (
              OO(this._renderer, null, i, 'register', [r]),
              new Y7(i, this._renderer)
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(Td), L(He));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class Y7 extends a9 {
        constructor(e, t) {
          super(), (this._id = e), (this._renderer = t);
        }
        create(e, t) {
          return new K7(this._id, e, t || {}, this._renderer);
        }
      }
      class K7 {
        constructor(e, t, i, r) {
          (this.id = e),
            (this.element = t),
            (this._renderer = r),
            (this.parentPlayer = null),
            (this._started = !1),
            (this.totalTime = 0),
            this._command('create', i);
        }
        _listen(e, t) {
          return this._renderer.listen(this.element, `@@${this.id}:${e}`, t);
        }
        _command(e, ...t) {
          return OO(this._renderer, this.element, this.id, e, t);
        }
        onDone(e) {
          this._listen('done', e);
        }
        onStart(e) {
          this._listen('start', e);
        }
        onDestroy(e) {
          this._listen('destroy', e);
        }
        init() {
          this._command('init');
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this._command('play'), (this._started = !0);
        }
        pause() {
          this._command('pause');
        }
        restart() {
          this._command('restart');
        }
        finish() {
          this._command('finish');
        }
        destroy() {
          this._command('destroy');
        }
        reset() {
          this._command('reset'), (this._started = !1);
        }
        setPosition(e) {
          this._command('setPosition', e);
        }
        getPosition() {
          return this._renderer.engine.players[+this.id]?.getPosition() ?? 0;
        }
      }
      function OO(n, e, t, i, r) {
        return n.setProperty(e, `@@${t}:${i}`, r);
      }
      const LO = '@.disabled';
      let Z7 = (() => {
        class n {
          constructor(t, i, r) {
            (this.delegate = t),
              (this.engine = i),
              (this._zone = r),
              (this._currentId = 0),
              (this._microtaskId = 1),
              (this._animationCallbacksBuffer = []),
              (this._rendererCache = new Map()),
              (this._cdRecurDepth = 0),
              (this.promise = Promise.resolve(0)),
              (i.onRemovalComplete = (s, o) => {
                const a = o?.parentNode(s);
                a && o.removeChild(a, s);
              });
          }
          createRenderer(t, i) {
            const s = this.delegate.createRenderer(t, i);
            if (!(t && i && i.data && i.data.animation)) {
              let u = this._rendererCache.get(s);
              return (
                u ||
                  ((u = new NO('', s, this.engine, () =>
                    this._rendererCache.delete(s)
                  )),
                  this._rendererCache.set(s, u)),
                u
              );
            }
            const o = i.id,
              a = i.id + '-' + this._currentId;
            this._currentId++, this.engine.register(a, t);
            const l = (u) => {
              Array.isArray(u)
                ? u.forEach(l)
                : this.engine.registerTrigger(o, a, t, u.name, u);
            };
            return i.data.animation.forEach(l), new Q7(this, a, s, this.engine);
          }
          begin() {
            this._cdRecurDepth++, this.delegate.begin && this.delegate.begin();
          }
          _scheduleCountTask() {
            this.promise.then(() => {
              this._microtaskId++;
            });
          }
          scheduleListenerCallback(t, i, r) {
            t >= 0 && t < this._microtaskId
              ? this._zone.run(() => i(r))
              : (0 == this._animationCallbacksBuffer.length &&
                  Promise.resolve(null).then(() => {
                    this._zone.run(() => {
                      this._animationCallbacksBuffer.forEach((s) => {
                        const [o, a] = s;
                        o(a);
                      }),
                        (this._animationCallbacksBuffer = []);
                    });
                  }),
                this._animationCallbacksBuffer.push([i, r]));
          }
          end() {
            this._cdRecurDepth--,
              0 == this._cdRecurDepth &&
                this._zone.runOutsideAngular(() => {
                  this._scheduleCountTask(),
                    this.engine.flush(this._microtaskId);
                }),
              this.delegate.end && this.delegate.end();
          }
          whenRenderingDone() {
            return this.engine.whenRenderingDone();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(Td), L(km), L(ue));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class NO {
        constructor(e, t, i, r) {
          (this.namespaceId = e),
            (this.delegate = t),
            (this.engine = i),
            (this._onDestroy = r),
            (this.destroyNode = this.delegate.destroyNode
              ? (s) => t.destroyNode(s)
              : null);
        }
        get data() {
          return this.delegate.data;
        }
        destroy() {
          this.engine.destroy(this.namespaceId, this.delegate),
            this.delegate.destroy(),
            this._onDestroy?.();
        }
        createElement(e, t) {
          return this.delegate.createElement(e, t);
        }
        createComment(e) {
          return this.delegate.createComment(e);
        }
        createText(e) {
          return this.delegate.createText(e);
        }
        appendChild(e, t) {
          this.delegate.appendChild(e, t),
            this.engine.onInsert(this.namespaceId, t, e, !1);
        }
        insertBefore(e, t, i, r = !0) {
          this.delegate.insertBefore(e, t, i),
            this.engine.onInsert(this.namespaceId, t, e, r);
        }
        removeChild(e, t, i) {
          this.engine.onRemove(this.namespaceId, t, this.delegate);
        }
        selectRootElement(e, t) {
          return this.delegate.selectRootElement(e, t);
        }
        parentNode(e) {
          return this.delegate.parentNode(e);
        }
        nextSibling(e) {
          return this.delegate.nextSibling(e);
        }
        setAttribute(e, t, i, r) {
          this.delegate.setAttribute(e, t, i, r);
        }
        removeAttribute(e, t, i) {
          this.delegate.removeAttribute(e, t, i);
        }
        addClass(e, t) {
          this.delegate.addClass(e, t);
        }
        removeClass(e, t) {
          this.delegate.removeClass(e, t);
        }
        setStyle(e, t, i, r) {
          this.delegate.setStyle(e, t, i, r);
        }
        removeStyle(e, t, i) {
          this.delegate.removeStyle(e, t, i);
        }
        setProperty(e, t, i) {
          '@' == t.charAt(0) && t == LO
            ? this.disableAnimations(e, !!i)
            : this.delegate.setProperty(e, t, i);
        }
        setValue(e, t) {
          this.delegate.setValue(e, t);
        }
        listen(e, t, i) {
          return this.delegate.listen(e, t, i);
        }
        disableAnimations(e, t) {
          this.engine.disableAnimations(e, t);
        }
      }
      class Q7 extends NO {
        constructor(e, t, i, r, s) {
          super(t, i, r, s), (this.factory = e), (this.namespaceId = t);
        }
        setProperty(e, t, i) {
          '@' == t.charAt(0)
            ? '.' == t.charAt(1) && t == LO
              ? this.disableAnimations(e, (i = void 0 === i || !!i))
              : this.engine.process(this.namespaceId, e, t.slice(1), i)
            : this.delegate.setProperty(e, t, i);
        }
        listen(e, t, i) {
          if ('@' == t.charAt(0)) {
            const r = (function J7(n) {
              switch (n) {
                case 'body':
                  return document.body;
                case 'document':
                  return document;
                case 'window':
                  return window;
                default:
                  return n;
              }
            })(e);
            let s = t.slice(1),
              o = '';
            return (
              '@' != s.charAt(0) &&
                ([s, o] = (function eZ(n) {
                  const e = n.indexOf('.');
                  return [n.substring(0, e), n.slice(e + 1)];
                })(s)),
              this.engine.listen(this.namespaceId, r, s, o, (a) => {
                this.factory.scheduleListenerCallback(a._data || -1, i, a);
              })
            );
          }
          return this.delegate.listen(e, t, i);
        }
      }
      const BO = [
        { provide: k0, useClass: fO },
        { provide: Ii, useValue: 'NoopAnimations' },
        ...[
          { provide: iO, useClass: X7 },
          {
            provide: j0,
            useFactory: function nZ() {
              return new w7();
            },
          },
          {
            provide: km,
            useClass: (() => {
              class n extends km {
                constructor(t, i, r, s) {
                  super(t.body, i, r);
                }
                ngOnDestroy() {
                  this.flush();
                }
              }
              return (
                (n.ɵfac = function (t) {
                  return new (t || n)(L(He), L(k0), L(j0), L(Ko));
                }),
                (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
                n
              );
            })(),
          },
          {
            provide: Td,
            useFactory: function iZ(n, e, t) {
              return new Z7(n, e, t);
            },
            deps: [Qw, km, ue],
          },
        ],
      ];
      let Y0,
        sZ = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ providers: BO, imports: [qR] })),
            n
          );
        })();
      try {
        Y0 = typeof Intl < 'u' && Intl.v8BreakIterator;
      } catch {
        Y0 = !1;
      }
      let $l,
        jt = (() => {
          class n {
            constructor(t) {
              (this._platformId = t),
                (this.isBrowser = this._platformId
                  ? (function iY(n) {
                      return n === DR;
                    })(this._platformId)
                  : 'object' == typeof document && !!document),
                (this.EDGE =
                  this.isBrowser && /(edge)/i.test(navigator.userAgent)),
                (this.TRIDENT =
                  this.isBrowser &&
                  /(msie|trident)/i.test(navigator.userAgent)),
                (this.BLINK =
                  this.isBrowser &&
                  !(!window.chrome && !Y0) &&
                  typeof CSS < 'u' &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.WEBKIT =
                  this.isBrowser &&
                  /AppleWebKit/i.test(navigator.userAgent) &&
                  !this.BLINK &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.IOS =
                  this.isBrowser &&
                  /iPad|iPhone|iPod/.test(navigator.userAgent) &&
                  !('MSStream' in window)),
                (this.FIREFOX =
                  this.isBrowser &&
                  /(firefox|minefield)/i.test(navigator.userAgent)),
                (this.ANDROID =
                  this.isBrowser &&
                  /android/i.test(navigator.userAgent) &&
                  !this.TRIDENT),
                (this.SAFARI =
                  this.isBrowser &&
                  /safari/i.test(navigator.userAgent) &&
                  this.WEBKIT);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(zo));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })();
      const HO = [
        'color',
        'button',
        'checkbox',
        'date',
        'datetime-local',
        'email',
        'file',
        'hidden',
        'image',
        'month',
        'number',
        'password',
        'radio',
        'range',
        'reset',
        'search',
        'submit',
        'tel',
        'text',
        'time',
        'url',
        'week',
      ];
      function WO() {
        if ($l) return $l;
        if ('object' != typeof document || !document)
          return ($l = new Set(HO)), $l;
        let n = document.createElement('input');
        return (
          ($l = new Set(
            HO.filter((e) => (n.setAttribute('type', e), n.type === e))
          )),
          $l
        );
      }
      let fu, Rm, oa, K0;
      function Gl(n) {
        return (function oZ() {
          if (null == fu && typeof window < 'u')
            try {
              window.addEventListener(
                'test',
                null,
                Object.defineProperty({}, 'passive', { get: () => (fu = !0) })
              );
            } finally {
              fu = fu || !1;
            }
          return fu;
        })()
          ? n
          : !!n.capture;
      }
      function jO() {
        if (null == oa) {
          if (
            'object' != typeof document ||
            !document ||
            'function' != typeof Element ||
            !Element
          )
            return (oa = !1), oa;
          if ('scrollBehavior' in document.documentElement.style) oa = !0;
          else {
            const n = Element.prototype.scrollTo;
            oa = !!n && !/\{\s*\[native code\]\s*\}/.test(n.toString());
          }
        }
        return oa;
      }
      function pu() {
        if ('object' != typeof document || !document) return 0;
        if (null == Rm) {
          const n = document.createElement('div'),
            e = n.style;
          (n.dir = 'rtl'),
            (e.width = '1px'),
            (e.overflow = 'auto'),
            (e.visibility = 'hidden'),
            (e.pointerEvents = 'none'),
            (e.position = 'absolute');
          const t = document.createElement('div'),
            i = t.style;
          (i.width = '2px'),
            (i.height = '1px'),
            n.appendChild(t),
            document.body.appendChild(n),
            (Rm = 0),
            0 === n.scrollLeft &&
              ((n.scrollLeft = 1), (Rm = 0 === n.scrollLeft ? 1 : 2)),
            n.remove();
        }
        return Rm;
      }
      function Js(n) {
        return n.composedPath ? n.composedPath()[0] : n.target;
      }
      function Z0() {
        return (
          (typeof __karma__ < 'u' && !!__karma__) ||
          (typeof jasmine < 'u' && !!jasmine) ||
          (typeof jest < 'u' && !!jest) ||
          (typeof Mocha < 'u' && !!Mocha)
        );
      }
      function aa(n, ...e) {
        return e.length
          ? e.some((t) => n[t])
          : n.altKey || n.shiftKey || n.ctrlKey || n.metaKey;
      }
      function Fm(n, e, t) {
        const i = ot(n) || e || t ? { next: n, error: e, complete: t } : n;
        return i
          ? gn((r, s) => {
              var o;
              null === (o = i.subscribe) || void 0 === o || o.call(i);
              let a = !0;
              r.subscribe(
                hn(
                  s,
                  (l) => {
                    var c;
                    null === (c = i.next) || void 0 === c || c.call(i, l),
                      s.next(l);
                  },
                  () => {
                    var l;
                    (a = !1),
                      null === (l = i.complete) || void 0 === l || l.call(i),
                      s.complete();
                  },
                  (l) => {
                    var c;
                    (a = !1),
                      null === (c = i.error) || void 0 === c || c.call(i, l),
                      s.error(l);
                  },
                  () => {
                    var l, c;
                    a &&
                      (null === (l = i.unsubscribe) ||
                        void 0 === l ||
                        l.call(i)),
                      null === (c = i.finalize) || void 0 === c || c.call(i);
                  }
                )
              );
            })
          : Xa;
      }
      class EZ extends $t {
        constructor(e, t) {
          super();
        }
        schedule(e, t = 0) {
          return this;
        }
      }
      const Om = {
        setInterval(n, e, ...t) {
          const { delegate: i } = Om;
          return i?.setInterval
            ? i.setInterval(n, e, ...t)
            : setInterval(n, e, ...t);
        },
        clearInterval(n) {
          const { delegate: e } = Om;
          return (e?.clearInterval || clearInterval)(n);
        },
        delegate: void 0,
      };
      class iE extends EZ {
        constructor(e, t) {
          super(e, t),
            (this.scheduler = e),
            (this.work = t),
            (this.pending = !1);
        }
        schedule(e, t = 0) {
          var i;
          if (this.closed) return this;
          this.state = e;
          const r = this.id,
            s = this.scheduler;
          return (
            null != r && (this.id = this.recycleAsyncId(s, r, t)),
            (this.pending = !0),
            (this.delay = t),
            (this.id =
              null !== (i = this.id) && void 0 !== i
                ? i
                : this.requestAsyncId(s, this.id, t)),
            this
          );
        }
        requestAsyncId(e, t, i = 0) {
          return Om.setInterval(e.flush.bind(e, this), i);
        }
        recycleAsyncId(e, t, i = 0) {
          if (null != i && this.delay === i && !1 === this.pending) return t;
          null != t && Om.clearInterval(t);
        }
        execute(e, t) {
          if (this.closed) return new Error('executing a cancelled action');
          this.pending = !1;
          const i = this._execute(e, t);
          if (i) return i;
          !1 === this.pending &&
            null != this.id &&
            (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }
        _execute(e, t) {
          let r,
            i = !1;
          try {
            this.work(e);
          } catch (s) {
            (i = !0),
              (r = s || new Error('Scheduled action threw falsy error'));
          }
          if (i) return this.unsubscribe(), r;
        }
        unsubscribe() {
          if (!this.closed) {
            const { id: e, scheduler: t } = this,
              { actions: i } = t;
            (this.work = this.state = this.scheduler = null),
              (this.pending = !1),
              wf(i, this),
              null != e && (this.id = this.recycleAsyncId(t, e, null)),
              (this.delay = null),
              super.unsubscribe();
          }
        }
      }
      const GO = { now: () => (GO.delegate || Date).now(), delegate: void 0 };
      class mu {
        constructor(e, t = mu.now) {
          (this.schedulerActionCtor = e), (this.now = t);
        }
        schedule(e, t = 0, i) {
          return new this.schedulerActionCtor(this, e).schedule(i, t);
        }
      }
      mu.now = GO.now;
      class rE extends mu {
        constructor(e, t = mu.now) {
          super(e, t), (this.actions = []), (this._active = !1);
        }
        flush(e) {
          const { actions: t } = this;
          if (this._active) return void t.push(e);
          let i;
          this._active = !0;
          do {
            if ((i = e.execute(e.state, e.delay))) break;
          } while ((e = t.shift()));
          if (((this._active = !1), i)) {
            for (; (e = t.shift()); ) e.unsubscribe();
            throw i;
          }
        }
      }
      const sE = new rE(iE),
        CZ = sE;
      function gu(n, e = sE) {
        return gn((t, i) => {
          let r = null,
            s = null,
            o = null;
          const a = () => {
            if (r) {
              r.unsubscribe(), (r = null);
              const c = s;
              (s = null), i.next(c);
            }
          };
          function l() {
            const c = o + n,
              u = e.now();
            if (u < c) return (r = this.schedule(void 0, c - u)), void i.add(r);
            a();
          }
          t.subscribe(
            hn(
              i,
              (c) => {
                (s = c), (o = e.now()), r || ((r = e.schedule(l, n)), i.add(r));
              },
              () => {
                a(), i.complete();
              },
              void 0,
              () => {
                s = r = null;
              }
            )
          );
        });
      }
      function di(n, e) {
        return gn((t, i) => {
          let r = 0;
          t.subscribe(hn(i, (s) => n.call(e, s, r++) && i.next(s)));
        });
      }
      function ps(n) {
        return n <= 0
          ? () => Af
          : gn((e, t) => {
              let i = 0;
              e.subscribe(
                hn(t, (r) => {
                  ++i <= n && (t.next(r), n <= i && t.complete());
                })
              );
            });
      }
      function qO(n) {
        return di((e, t) => n <= t);
      }
      function se(n) {
        return gn((e, t) => {
          Bn(n).subscribe(hn(t, () => t.complete(), Pb)),
            !t.closed && e.subscribe(t);
        });
      }
      function vt(n) {
        return null != n && 'false' != `${n}`;
      }
      function _u(n, e = 0) {
        return (function xZ(n) {
          return !isNaN(parseFloat(n)) && !isNaN(Number(n));
        })(n)
          ? Number(n)
          : e;
      }
      function Lm(n) {
        return Array.isArray(n) ? n : [n];
      }
      function Zt(n) {
        return null == n ? '' : 'string' == typeof n ? n : `${n}px`;
      }
      function ms(n) {
        return n instanceof Ne ? n.nativeElement : n;
      }
      let XO = (() => {
          class n {
            create(t) {
              return typeof MutationObserver > 'u'
                ? null
                : new MutationObserver(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        AZ = (() => {
          class n {
            constructor(t) {
              (this._mutationObserverFactory = t),
                (this._observedElements = new Map());
            }
            ngOnDestroy() {
              this._observedElements.forEach((t, i) =>
                this._cleanupObserver(i)
              );
            }
            observe(t) {
              const i = ms(t);
              return new Mt((r) => {
                const o = this._observeElement(i).subscribe(r);
                return () => {
                  o.unsubscribe(), this._unobserveElement(i);
                };
              });
            }
            _observeElement(t) {
              if (this._observedElements.has(t))
                this._observedElements.get(t).count++;
              else {
                const i = new Le(),
                  r = this._mutationObserverFactory.create((s) => i.next(s));
                r &&
                  r.observe(t, {
                    characterData: !0,
                    childList: !0,
                    subtree: !0,
                  }),
                  this._observedElements.set(t, {
                    observer: r,
                    stream: i,
                    count: 1,
                  });
              }
              return this._observedElements.get(t).stream;
            }
            _unobserveElement(t) {
              this._observedElements.has(t) &&
                (this._observedElements.get(t).count--,
                this._observedElements.get(t).count ||
                  this._cleanupObserver(t));
            }
            _cleanupObserver(t) {
              if (this._observedElements.has(t)) {
                const { observer: i, stream: r } =
                  this._observedElements.get(t);
                i && i.disconnect(),
                  r.complete(),
                  this._observedElements.delete(t);
              }
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(XO));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        SZ = (() => {
          class n {
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              (this._disabled = vt(t)),
                this._disabled ? this._unsubscribe() : this._subscribe();
            }
            get debounce() {
              return this._debounce;
            }
            set debounce(t) {
              (this._debounce = _u(t)), this._subscribe();
            }
            constructor(t, i, r) {
              (this._contentObserver = t),
                (this._elementRef = i),
                (this._ngZone = r),
                (this.event = new ke()),
                (this._disabled = !1),
                (this._currentSubscription = null);
            }
            ngAfterContentInit() {
              !this._currentSubscription && !this.disabled && this._subscribe();
            }
            ngOnDestroy() {
              this._unsubscribe();
            }
            _subscribe() {
              this._unsubscribe();
              const t = this._contentObserver.observe(this._elementRef);
              this._ngZone.runOutsideAngular(() => {
                this._currentSubscription = (
                  this.debounce ? t.pipe(gu(this.debounce)) : t
                ).subscribe(this.event);
              });
            }
            _unsubscribe() {
              this._currentSubscription?.unsubscribe();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(AZ), D(Ne), D(ue));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['', 'cdkObserveContent', '']],
              inputs: {
                disabled: ['cdkObserveContentDisabled', 'disabled'],
                debounce: 'debounce',
              },
              outputs: { event: 'cdkObserveContent' },
              exportAs: ['cdkObserveContent'],
            })),
            n
          );
        })(),
        YO = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ providers: [XO] })),
            n
          );
        })();
      function KO(n, e, t) {
        n ? es(t, n, e) : e();
      }
      function oE(...n) {
        return (function TZ() {
          return AM(1);
        })()(Vs(n, Jc(n)));
      }
      function bu(...n) {
        const e = Jc(n);
        return gn((t, i) => {
          (e ? oE(n, t, e) : oE(n, t)).subscribe(i);
        });
      }
      const ZO = new Set();
      let la,
        IZ = (() => {
          class n {
            constructor(t, i) {
              (this._platform = t),
                (this._nonce = i),
                (this._matchMedia =
                  this._platform.isBrowser && window.matchMedia
                    ? window.matchMedia.bind(window)
                    : PZ);
            }
            matchMedia(t) {
              return (
                (this._platform.WEBKIT || this._platform.BLINK) &&
                  (function kZ(n, e) {
                    if (!ZO.has(n))
                      try {
                        la ||
                          ((la = document.createElement('style')),
                          e && (la.nonce = e),
                          la.setAttribute('type', 'text/css'),
                          document.head.appendChild(la)),
                          la.sheet &&
                            (la.sheet.insertRule(`@media ${n} {body{ }}`, 0),
                            ZO.add(n));
                      } catch (t) {
                        console.error(t);
                      }
                  })(t, this._nonce),
                this._matchMedia(t)
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(jt), L(ry, 8));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })();
      function PZ(n) {
        return {
          matches: 'all' === n || '' === n,
          media: n,
          addListener: () => {},
          removeListener: () => {},
        };
      }
      let RZ = (() => {
        class n {
          constructor(t, i) {
            (this._mediaMatcher = t),
              (this._zone = i),
              (this._queries = new Map()),
              (this._destroySubject = new Le());
          }
          ngOnDestroy() {
            this._destroySubject.next(), this._destroySubject.complete();
          }
          isMatched(t) {
            return QO(Lm(t)).some((r) => this._registerQuery(r).mql.matches);
          }
          observe(t) {
            let s = (function MZ(...n) {
              const e = Jc(n),
                t = MM(n),
                { args: i, keys: r } = QR(n);
              if (0 === i.length) return Vs([], e);
              const s = new Mt(
                (function DZ(n, e, t = Xa) {
                  return (i) => {
                    KO(
                      e,
                      () => {
                        const { length: r } = n,
                          s = new Array(r);
                        let o = r,
                          a = r;
                        for (let l = 0; l < r; l++)
                          KO(
                            e,
                            () => {
                              const c = Vs(n[l], e);
                              let u = !1;
                              c.subscribe(
                                hn(
                                  i,
                                  (h) => {
                                    (s[l] = h),
                                      u || ((u = !0), a--),
                                      a || i.next(t(s.slice()));
                                  },
                                  () => {
                                    --o || i.complete();
                                  }
                                )
                              );
                            },
                            i
                          );
                      },
                      i
                    );
                  };
                })(i, e, r ? (o) => JR(r, o) : Xa)
              );
              return t ? s.pipe(r0(t)) : s;
            })(QO(Lm(t)).map((o) => this._registerQuery(o).observable));
            return (
              (s = oE(s.pipe(ps(1)), s.pipe(qO(1), gu(0)))),
              s.pipe(
                Gt((o) => {
                  const a = { matches: !1, breakpoints: {} };
                  return (
                    o.forEach(({ matches: l, query: c }) => {
                      (a.matches = a.matches || l), (a.breakpoints[c] = l);
                    }),
                    a
                  );
                })
              )
            );
          }
          _registerQuery(t) {
            if (this._queries.has(t)) return this._queries.get(t);
            const i = this._mediaMatcher.matchMedia(t),
              s = {
                observable: new Mt((o) => {
                  const a = (l) => this._zone.run(() => o.next(l));
                  return (
                    i.addListener(a),
                    () => {
                      i.removeListener(a);
                    }
                  );
                }).pipe(
                  bu(i),
                  Gt(({ matches: o }) => ({ query: t, matches: o })),
                  se(this._destroySubject)
                ),
                mql: i,
              };
            return this._queries.set(t, s), s;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(IZ), L(ue));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      function QO(n) {
        return n
          .map((e) => e.split(','))
          .reduce((e, t) => e.concat(t))
          .map((e) => e.trim());
      }
      function Nm(n, e) {
        return (n.getAttribute(e) || '').match(/\S+/g) || [];
      }
      const eL = 'cdk-describedby-message',
        Vm = 'cdk-describedby-host';
      let aE = 0,
        LZ = (() => {
          class n {
            constructor(t, i) {
              (this._platform = i),
                (this._messageRegistry = new Map()),
                (this._messagesContainer = null),
                (this._id = '' + aE++),
                (this._document = t),
                (this._id = Te(xd) + '-' + aE++);
            }
            describe(t, i, r) {
              if (!this._canBeDescribed(t, i)) return;
              const s = lE(i, r);
              'string' != typeof i
                ? (tL(i, this._id),
                  this._messageRegistry.set(s, {
                    messageElement: i,
                    referenceCount: 0,
                  }))
                : this._messageRegistry.has(s) ||
                  this._createMessageElement(i, r),
                this._isElementDescribedByMessage(t, s) ||
                  this._addMessageReference(t, s);
            }
            removeDescription(t, i, r) {
              if (!i || !this._isElementNode(t)) return;
              const s = lE(i, r);
              if (
                (this._isElementDescribedByMessage(t, s) &&
                  this._removeMessageReference(t, s),
                'string' == typeof i)
              ) {
                const o = this._messageRegistry.get(s);
                o && 0 === o.referenceCount && this._deleteMessageElement(s);
              }
              0 === this._messagesContainer?.childNodes.length &&
                (this._messagesContainer.remove(),
                (this._messagesContainer = null));
            }
            ngOnDestroy() {
              const t = this._document.querySelectorAll(
                `[${Vm}="${this._id}"]`
              );
              for (let i = 0; i < t.length; i++)
                this._removeCdkDescribedByReferenceIds(t[i]),
                  t[i].removeAttribute(Vm);
              this._messagesContainer?.remove(),
                (this._messagesContainer = null),
                this._messageRegistry.clear();
            }
            _createMessageElement(t, i) {
              const r = this._document.createElement('div');
              tL(r, this._id),
                (r.textContent = t),
                i && r.setAttribute('role', i),
                this._createMessagesContainer(),
                this._messagesContainer.appendChild(r),
                this._messageRegistry.set(lE(t, i), {
                  messageElement: r,
                  referenceCount: 0,
                });
            }
            _deleteMessageElement(t) {
              this._messageRegistry.get(t)?.messageElement?.remove(),
                this._messageRegistry.delete(t);
            }
            _createMessagesContainer() {
              if (this._messagesContainer) return;
              const t = 'cdk-describedby-message-container',
                i = this._document.querySelectorAll(`.${t}[platform="server"]`);
              for (let s = 0; s < i.length; s++) i[s].remove();
              const r = this._document.createElement('div');
              (r.style.visibility = 'hidden'),
                r.classList.add(t),
                r.classList.add('cdk-visually-hidden'),
                this._platform &&
                  !this._platform.isBrowser &&
                  r.setAttribute('platform', 'server'),
                this._document.body.appendChild(r),
                (this._messagesContainer = r);
            }
            _removeCdkDescribedByReferenceIds(t) {
              const i = Nm(t, 'aria-describedby').filter(
                (r) => 0 != r.indexOf(eL)
              );
              t.setAttribute('aria-describedby', i.join(' '));
            }
            _addMessageReference(t, i) {
              const r = this._messageRegistry.get(i);
              (function FZ(n, e, t) {
                const i = Nm(n, e);
                i.some((r) => r.trim() == t.trim()) ||
                  (i.push(t.trim()), n.setAttribute(e, i.join(' ')));
              })(t, 'aria-describedby', r.messageElement.id),
                t.setAttribute(Vm, this._id),
                r.referenceCount++;
            }
            _removeMessageReference(t, i) {
              const r = this._messageRegistry.get(i);
              r.referenceCount--,
                (function OZ(n, e, t) {
                  const r = Nm(n, e).filter((s) => s != t.trim());
                  r.length
                    ? n.setAttribute(e, r.join(' '))
                    : n.removeAttribute(e);
                })(t, 'aria-describedby', r.messageElement.id),
                t.removeAttribute(Vm);
            }
            _isElementDescribedByMessage(t, i) {
              const r = Nm(t, 'aria-describedby'),
                s = this._messageRegistry.get(i),
                o = s && s.messageElement.id;
              return !!o && -1 != r.indexOf(o);
            }
            _canBeDescribed(t, i) {
              if (!this._isElementNode(t)) return !1;
              if (i && 'object' == typeof i) return !0;
              const r = null == i ? '' : `${i}`.trim(),
                s = t.getAttribute('aria-label');
              return !(!r || (s && s.trim() === r));
            }
            _isElementNode(t) {
              return t.nodeType === this._document.ELEMENT_NODE;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(He), L(jt));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })();
      function lE(n, e) {
        return 'string' == typeof n ? `${e || ''}/${n}` : n;
      }
      function tL(n, e) {
        n.id || (n.id = `${eL}-${e}-${aE++}`);
      }
      class NZ {
        constructor(e) {
          (this._items = e),
            (this._activeItemIndex = -1),
            (this._activeItem = null),
            (this._wrap = !1),
            (this._letterKeyStream = new Le()),
            (this._typeaheadSubscription = $t.EMPTY),
            (this._vertical = !0),
            (this._allowedModifierKeys = []),
            (this._homeAndEnd = !1),
            (this._pageUpAndDown = { enabled: !1, delta: 10 }),
            (this._skipPredicateFn = (t) => t.disabled),
            (this._pressedLetters = []),
            (this.tabOut = new Le()),
            (this.change = new Le()),
            e instanceof Vl &&
              (this._itemChangesSubscription = e.changes.subscribe((t) => {
                if (this._activeItem) {
                  const r = t.toArray().indexOf(this._activeItem);
                  r > -1 &&
                    r !== this._activeItemIndex &&
                    (this._activeItemIndex = r);
                }
              }));
        }
        skipPredicate(e) {
          return (this._skipPredicateFn = e), this;
        }
        withWrap(e = !0) {
          return (this._wrap = e), this;
        }
        withVerticalOrientation(e = !0) {
          return (this._vertical = e), this;
        }
        withHorizontalOrientation(e) {
          return (this._horizontal = e), this;
        }
        withAllowedModifierKeys(e) {
          return (this._allowedModifierKeys = e), this;
        }
        withTypeAhead(e = 200) {
          return (
            this._typeaheadSubscription.unsubscribe(),
            (this._typeaheadSubscription = this._letterKeyStream
              .pipe(
                Fm((t) => this._pressedLetters.push(t)),
                gu(e),
                di(() => this._pressedLetters.length > 0),
                Gt(() => this._pressedLetters.join(''))
              )
              .subscribe((t) => {
                const i = this._getItemsArray();
                for (let r = 1; r < i.length + 1; r++) {
                  const s = (this._activeItemIndex + r) % i.length,
                    o = i[s];
                  if (
                    !this._skipPredicateFn(o) &&
                    0 === o.getLabel().toUpperCase().trim().indexOf(t)
                  ) {
                    this.setActiveItem(s);
                    break;
                  }
                }
                this._pressedLetters = [];
              })),
            this
          );
        }
        cancelTypeahead() {
          return (this._pressedLetters = []), this;
        }
        withHomeAndEnd(e = !0) {
          return (this._homeAndEnd = e), this;
        }
        withPageUpDown(e = !0, t = 10) {
          return (this._pageUpAndDown = { enabled: e, delta: t }), this;
        }
        setActiveItem(e) {
          const t = this._activeItem;
          this.updateActiveItem(e),
            this._activeItem !== t && this.change.next(this._activeItemIndex);
        }
        onKeydown(e) {
          const t = e.keyCode,
            r = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].every(
              (s) => !e[s] || this._allowedModifierKeys.indexOf(s) > -1
            );
          switch (t) {
            case 9:
              return void this.tabOut.next();
            case 40:
              if (this._vertical && r) {
                this.setNextItemActive();
                break;
              }
              return;
            case 38:
              if (this._vertical && r) {
                this.setPreviousItemActive();
                break;
              }
              return;
            case 39:
              if (this._horizontal && r) {
                'rtl' === this._horizontal
                  ? this.setPreviousItemActive()
                  : this.setNextItemActive();
                break;
              }
              return;
            case 37:
              if (this._horizontal && r) {
                'rtl' === this._horizontal
                  ? this.setNextItemActive()
                  : this.setPreviousItemActive();
                break;
              }
              return;
            case 36:
              if (this._homeAndEnd && r) {
                this.setFirstItemActive();
                break;
              }
              return;
            case 35:
              if (this._homeAndEnd && r) {
                this.setLastItemActive();
                break;
              }
              return;
            case 33:
              if (this._pageUpAndDown.enabled && r) {
                const s = this._activeItemIndex - this._pageUpAndDown.delta;
                this._setActiveItemByIndex(s > 0 ? s : 0, 1);
                break;
              }
              return;
            case 34:
              if (this._pageUpAndDown.enabled && r) {
                const s = this._activeItemIndex + this._pageUpAndDown.delta,
                  o = this._getItemsArray().length;
                this._setActiveItemByIndex(s < o ? s : o - 1, -1);
                break;
              }
              return;
            default:
              return void (
                (r || aa(e, 'shiftKey')) &&
                (e.key && 1 === e.key.length
                  ? this._letterKeyStream.next(e.key.toLocaleUpperCase())
                  : ((t >= 65 && t <= 90) || (t >= 48 && t <= 57)) &&
                    this._letterKeyStream.next(String.fromCharCode(t)))
              );
          }
          (this._pressedLetters = []), e.preventDefault();
        }
        get activeItemIndex() {
          return this._activeItemIndex;
        }
        get activeItem() {
          return this._activeItem;
        }
        isTyping() {
          return this._pressedLetters.length > 0;
        }
        setFirstItemActive() {
          this._setActiveItemByIndex(0, 1);
        }
        setLastItemActive() {
          this._setActiveItemByIndex(this._items.length - 1, -1);
        }
        setNextItemActive() {
          this._activeItemIndex < 0
            ? this.setFirstItemActive()
            : this._setActiveItemByDelta(1);
        }
        setPreviousItemActive() {
          this._activeItemIndex < 0 && this._wrap
            ? this.setLastItemActive()
            : this._setActiveItemByDelta(-1);
        }
        updateActiveItem(e) {
          const t = this._getItemsArray(),
            i = 'number' == typeof e ? e : t.indexOf(e);
          (this._activeItem = t[i] ?? null), (this._activeItemIndex = i);
        }
        destroy() {
          this._typeaheadSubscription.unsubscribe(),
            this._itemChangesSubscription?.unsubscribe(),
            this._letterKeyStream.complete(),
            this.tabOut.complete(),
            this.change.complete(),
            (this._pressedLetters = []);
        }
        _setActiveItemByDelta(e) {
          this._wrap
            ? this._setActiveInWrapMode(e)
            : this._setActiveInDefaultMode(e);
        }
        _setActiveInWrapMode(e) {
          const t = this._getItemsArray();
          for (let i = 1; i <= t.length; i++) {
            const r = (this._activeItemIndex + e * i + t.length) % t.length;
            if (!this._skipPredicateFn(t[r])) return void this.setActiveItem(r);
          }
        }
        _setActiveInDefaultMode(e) {
          this._setActiveItemByIndex(this._activeItemIndex + e, e);
        }
        _setActiveItemByIndex(e, t) {
          const i = this._getItemsArray();
          if (i[e]) {
            for (; this._skipPredicateFn(i[e]); ) if (!i[(e += t)]) return;
            this.setActiveItem(e);
          }
        }
        _getItemsArray() {
          return this._items instanceof Vl
            ? this._items.toArray()
            : this._items;
        }
      }
      class VZ extends NZ {
        setActiveItem(e) {
          this.activeItem && this.activeItem.setInactiveStyles(),
            super.setActiveItem(e),
            this.activeItem && this.activeItem.setActiveStyles();
        }
      }
      let nL = (() => {
        class n {
          constructor(t) {
            this._platform = t;
          }
          isDisabled(t) {
            return t.hasAttribute('disabled');
          }
          isVisible(t) {
            return (
              (function HZ(n) {
                return !!(
                  n.offsetWidth ||
                  n.offsetHeight ||
                  ('function' == typeof n.getClientRects &&
                    n.getClientRects().length)
                );
              })(t) && 'visible' === getComputedStyle(t).visibility
            );
          }
          isTabbable(t) {
            if (!this._platform.isBrowser) return !1;
            const i = (function BZ(n) {
              try {
                return n.frameElement;
              } catch {
                return null;
              }
            })(
              (function XZ(n) {
                return (
                  (n.ownerDocument && n.ownerDocument.defaultView) || window
                );
              })(t)
            );
            if (i && (-1 === rL(i) || !this.isVisible(i))) return !1;
            let r = t.nodeName.toLowerCase(),
              s = rL(t);
            return t.hasAttribute('contenteditable')
              ? -1 !== s
              : !(
                  'iframe' === r ||
                  'object' === r ||
                  (this._platform.WEBKIT &&
                    this._platform.IOS &&
                    !(function GZ(n) {
                      let e = n.nodeName.toLowerCase(),
                        t = 'input' === e && n.type;
                      return (
                        'text' === t ||
                        'password' === t ||
                        'select' === e ||
                        'textarea' === e
                      );
                    })(t))
                ) &&
                  ('audio' === r
                    ? !!t.hasAttribute('controls') && -1 !== s
                    : 'video' === r
                    ? -1 !== s &&
                      (null !== s ||
                        this._platform.FIREFOX ||
                        t.hasAttribute('controls'))
                    : t.tabIndex >= 0);
          }
          isFocusable(t, i) {
            return (
              (function qZ(n) {
                return (
                  !(function jZ(n) {
                    return (
                      (function UZ(n) {
                        return 'input' == n.nodeName.toLowerCase();
                      })(n) && 'hidden' == n.type
                    );
                  })(n) &&
                  ((function WZ(n) {
                    let e = n.nodeName.toLowerCase();
                    return (
                      'input' === e ||
                      'select' === e ||
                      'button' === e ||
                      'textarea' === e
                    );
                  })(n) ||
                    (function zZ(n) {
                      return (
                        (function $Z(n) {
                          return 'a' == n.nodeName.toLowerCase();
                        })(n) && n.hasAttribute('href')
                      );
                    })(n) ||
                    n.hasAttribute('contenteditable') ||
                    iL(n))
                );
              })(t) &&
              !this.isDisabled(t) &&
              (i?.ignoreVisibility || this.isVisible(t))
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(jt));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      function iL(n) {
        if (!n.hasAttribute('tabindex') || void 0 === n.tabIndex) return !1;
        let e = n.getAttribute('tabindex');
        return !(!e || isNaN(parseInt(e, 10)));
      }
      function rL(n) {
        if (!iL(n)) return null;
        const e = parseInt(n.getAttribute('tabindex') || '', 10);
        return isNaN(e) ? -1 : e;
      }
      class YZ {
        get enabled() {
          return this._enabled;
        }
        set enabled(e) {
          (this._enabled = e),
            this._startAnchor &&
              this._endAnchor &&
              (this._toggleAnchorTabIndex(e, this._startAnchor),
              this._toggleAnchorTabIndex(e, this._endAnchor));
        }
        constructor(e, t, i, r, s = !1) {
          (this._element = e),
            (this._checker = t),
            (this._ngZone = i),
            (this._document = r),
            (this._hasAttached = !1),
            (this.startAnchorListener = () => this.focusLastTabbableElement()),
            (this.endAnchorListener = () => this.focusFirstTabbableElement()),
            (this._enabled = !0),
            s || this.attachAnchors();
        }
        destroy() {
          const e = this._startAnchor,
            t = this._endAnchor;
          e &&
            (e.removeEventListener('focus', this.startAnchorListener),
            e.remove()),
            t &&
              (t.removeEventListener('focus', this.endAnchorListener),
              t.remove()),
            (this._startAnchor = this._endAnchor = null),
            (this._hasAttached = !1);
        }
        attachAnchors() {
          return (
            !!this._hasAttached ||
            (this._ngZone.runOutsideAngular(() => {
              this._startAnchor ||
                ((this._startAnchor = this._createAnchor()),
                this._startAnchor.addEventListener(
                  'focus',
                  this.startAnchorListener
                )),
                this._endAnchor ||
                  ((this._endAnchor = this._createAnchor()),
                  this._endAnchor.addEventListener(
                    'focus',
                    this.endAnchorListener
                  ));
            }),
            this._element.parentNode &&
              (this._element.parentNode.insertBefore(
                this._startAnchor,
                this._element
              ),
              this._element.parentNode.insertBefore(
                this._endAnchor,
                this._element.nextSibling
              ),
              (this._hasAttached = !0)),
            this._hasAttached)
          );
        }
        focusInitialElementWhenReady(e) {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusInitialElement(e)));
          });
        }
        focusFirstTabbableElementWhenReady(e) {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusFirstTabbableElement(e)));
          });
        }
        focusLastTabbableElementWhenReady(e) {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusLastTabbableElement(e)));
          });
        }
        _getRegionBoundary(e) {
          const t = this._element.querySelectorAll(
            `[cdk-focus-region-${e}], [cdkFocusRegion${e}], [cdk-focus-${e}]`
          );
          return 'start' == e
            ? t.length
              ? t[0]
              : this._getFirstTabbableElement(this._element)
            : t.length
            ? t[t.length - 1]
            : this._getLastTabbableElement(this._element);
        }
        focusInitialElement(e) {
          const t = this._element.querySelector(
            '[cdk-focus-initial], [cdkFocusInitial]'
          );
          if (t) {
            if (!this._checker.isFocusable(t)) {
              const i = this._getFirstTabbableElement(t);
              return i?.focus(e), !!i;
            }
            return t.focus(e), !0;
          }
          return this.focusFirstTabbableElement(e);
        }
        focusFirstTabbableElement(e) {
          const t = this._getRegionBoundary('start');
          return t && t.focus(e), !!t;
        }
        focusLastTabbableElement(e) {
          const t = this._getRegionBoundary('end');
          return t && t.focus(e), !!t;
        }
        hasAttached() {
          return this._hasAttached;
        }
        _getFirstTabbableElement(e) {
          if (this._checker.isFocusable(e) && this._checker.isTabbable(e))
            return e;
          const t = e.children;
          for (let i = 0; i < t.length; i++) {
            const r =
              t[i].nodeType === this._document.ELEMENT_NODE
                ? this._getFirstTabbableElement(t[i])
                : null;
            if (r) return r;
          }
          return null;
        }
        _getLastTabbableElement(e) {
          if (this._checker.isFocusable(e) && this._checker.isTabbable(e))
            return e;
          const t = e.children;
          for (let i = t.length - 1; i >= 0; i--) {
            const r =
              t[i].nodeType === this._document.ELEMENT_NODE
                ? this._getLastTabbableElement(t[i])
                : null;
            if (r) return r;
          }
          return null;
        }
        _createAnchor() {
          const e = this._document.createElement('div');
          return (
            this._toggleAnchorTabIndex(this._enabled, e),
            e.classList.add('cdk-visually-hidden'),
            e.classList.add('cdk-focus-trap-anchor'),
            e.setAttribute('aria-hidden', 'true'),
            e
          );
        }
        _toggleAnchorTabIndex(e, t) {
          e ? t.setAttribute('tabindex', '0') : t.removeAttribute('tabindex');
        }
        toggleAnchors(e) {
          this._startAnchor &&
            this._endAnchor &&
            (this._toggleAnchorTabIndex(e, this._startAnchor),
            this._toggleAnchorTabIndex(e, this._endAnchor));
        }
        _executeOnStable(e) {
          this._ngZone.isStable
            ? e()
            : this._ngZone.onStable.pipe(ps(1)).subscribe(e);
        }
      }
      let KZ = (() => {
        class n {
          constructor(t, i, r) {
            (this._checker = t), (this._ngZone = i), (this._document = r);
          }
          create(t, i = !1) {
            return new YZ(t, this._checker, this._ngZone, this._document, i);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(nL), L(ue), L(He));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      function sL(n) {
        return 0 === n.buttons || (0 === n.offsetX && 0 === n.offsetY);
      }
      function oL(n) {
        const e =
          (n.touches && n.touches[0]) ||
          (n.changedTouches && n.changedTouches[0]);
        return !(
          !e ||
          -1 !== e.identifier ||
          (null != e.radiusX && 1 !== e.radiusX) ||
          (null != e.radiusY && 1 !== e.radiusY)
        );
      }
      const ZZ = new j('cdk-input-modality-detector-options'),
        QZ = { ignoreKeys: [18, 17, 224, 91, 16] },
        ql = Gl({ passive: !0, capture: !0 });
      let JZ = (() => {
        class n {
          get mostRecentModality() {
            return this._modality.value;
          }
          constructor(t, i, r, s) {
            (this._platform = t),
              (this._mostRecentTarget = null),
              (this._modality = new uM(null)),
              (this._lastTouchMs = 0),
              (this._onKeydown = (o) => {
                this._options?.ignoreKeys?.some((a) => a === o.keyCode) ||
                  (this._modality.next('keyboard'),
                  (this._mostRecentTarget = Js(o)));
              }),
              (this._onMousedown = (o) => {
                Date.now() - this._lastTouchMs < 650 ||
                  (this._modality.next(sL(o) ? 'keyboard' : 'mouse'),
                  (this._mostRecentTarget = Js(o)));
              }),
              (this._onTouchstart = (o) => {
                oL(o)
                  ? this._modality.next('keyboard')
                  : ((this._lastTouchMs = Date.now()),
                    this._modality.next('touch'),
                    (this._mostRecentTarget = Js(o)));
              }),
              (this._options = { ...QZ, ...s }),
              (this.modalityDetected = this._modality.pipe(qO(1))),
              (this.modalityChanged = this.modalityDetected.pipe(Sf())),
              t.isBrowser &&
                i.runOutsideAngular(() => {
                  r.addEventListener('keydown', this._onKeydown, ql),
                    r.addEventListener('mousedown', this._onMousedown, ql),
                    r.addEventListener('touchstart', this._onTouchstart, ql);
                });
          }
          ngOnDestroy() {
            this._modality.complete(),
              this._platform.isBrowser &&
                (document.removeEventListener('keydown', this._onKeydown, ql),
                document.removeEventListener(
                  'mousedown',
                  this._onMousedown,
                  ql
                ),
                document.removeEventListener(
                  'touchstart',
                  this._onTouchstart,
                  ql
                ));
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(jt), L(ue), L(He), L(ZZ, 8));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      const eQ = new j('liveAnnouncerElement', {
          providedIn: 'root',
          factory: function tQ() {
            return null;
          },
        }),
        nQ = new j('LIVE_ANNOUNCER_DEFAULT_OPTIONS');
      let iQ = 0,
        rQ = (() => {
          class n {
            constructor(t, i, r, s) {
              (this._ngZone = i),
                (this._defaultOptions = s),
                (this._document = r),
                (this._liveElement = t || this._createLiveElement());
            }
            announce(t, ...i) {
              const r = this._defaultOptions;
              let s, o;
              return (
                1 === i.length && 'number' == typeof i[0]
                  ? (o = i[0])
                  : ([s, o] = i),
                this.clear(),
                clearTimeout(this._previousTimeout),
                s || (s = r && r.politeness ? r.politeness : 'polite'),
                null == o && r && (o = r.duration),
                this._liveElement.setAttribute('aria-live', s),
                this._liveElement.id &&
                  this._exposeAnnouncerToModals(this._liveElement.id),
                this._ngZone.runOutsideAngular(
                  () => (
                    this._currentPromise ||
                      (this._currentPromise = new Promise(
                        (a) => (this._currentResolve = a)
                      )),
                    clearTimeout(this._previousTimeout),
                    (this._previousTimeout = setTimeout(() => {
                      (this._liveElement.textContent = t),
                        'number' == typeof o &&
                          (this._previousTimeout = setTimeout(
                            () => this.clear(),
                            o
                          )),
                        this._currentResolve(),
                        (this._currentPromise = this._currentResolve = void 0);
                    }, 100)),
                    this._currentPromise
                  )
                )
              );
            }
            clear() {
              this._liveElement && (this._liveElement.textContent = '');
            }
            ngOnDestroy() {
              clearTimeout(this._previousTimeout),
                this._liveElement?.remove(),
                (this._liveElement = null),
                this._currentResolve?.(),
                (this._currentPromise = this._currentResolve = void 0);
            }
            _createLiveElement() {
              const t = 'cdk-live-announcer-element',
                i = this._document.getElementsByClassName(t),
                r = this._document.createElement('div');
              for (let s = 0; s < i.length; s++) i[s].remove();
              return (
                r.classList.add(t),
                r.classList.add('cdk-visually-hidden'),
                r.setAttribute('aria-atomic', 'true'),
                r.setAttribute('aria-live', 'polite'),
                (r.id = 'cdk-live-announcer-' + iQ++),
                this._document.body.appendChild(r),
                r
              );
            }
            _exposeAnnouncerToModals(t) {
              const i = this._document.querySelectorAll(
                'body > .cdk-overlay-container [aria-modal="true"]'
              );
              for (let r = 0; r < i.length; r++) {
                const s = i[r],
                  o = s.getAttribute('aria-owns');
                o
                  ? -1 === o.indexOf(t) &&
                    s.setAttribute('aria-owns', o + ' ' + t)
                  : s.setAttribute('aria-owns', t);
              }
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(eQ, 8), L(ue), L(He), L(nQ, 8));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })();
      const sQ = new j('cdk-focus-monitor-default-options'),
        Bm = Gl({ passive: !0, capture: !0 });
      let Hm = (() => {
        class n {
          constructor(t, i, r, s, o) {
            (this._ngZone = t),
              (this._platform = i),
              (this._inputModalityDetector = r),
              (this._origin = null),
              (this._windowFocused = !1),
              (this._originFromTouchInteraction = !1),
              (this._elementInfo = new Map()),
              (this._monitoredElementCount = 0),
              (this._rootNodeFocusListenerCount = new Map()),
              (this._windowFocusListener = () => {
                (this._windowFocused = !0),
                  (this._windowFocusTimeoutId = window.setTimeout(
                    () => (this._windowFocused = !1)
                  ));
              }),
              (this._stopInputModalityDetector = new Le()),
              (this._rootNodeFocusAndBlurListener = (a) => {
                for (let c = Js(a); c; c = c.parentElement)
                  'focus' === a.type ? this._onFocus(a, c) : this._onBlur(a, c);
              }),
              (this._document = s),
              (this._detectionMode = o?.detectionMode || 0);
          }
          monitor(t, i = !1) {
            const r = ms(t);
            if (!this._platform.isBrowser || 1 !== r.nodeType) return ts(null);
            const s =
                (function lZ(n) {
                  if (
                    (function aZ() {
                      if (null == K0) {
                        const n = typeof document < 'u' ? document.head : null;
                        K0 = !(!n || (!n.createShadowRoot && !n.attachShadow));
                      }
                      return K0;
                    })()
                  ) {
                    const e = n.getRootNode ? n.getRootNode() : null;
                    if (
                      typeof ShadowRoot < 'u' &&
                      ShadowRoot &&
                      e instanceof ShadowRoot
                    )
                      return e;
                  }
                  return null;
                })(r) || this._getDocument(),
              o = this._elementInfo.get(r);
            if (o) return i && (o.checkChildren = !0), o.subject;
            const a = { checkChildren: i, subject: new Le(), rootNode: s };
            return (
              this._elementInfo.set(r, a),
              this._registerGlobalListeners(a),
              a.subject
            );
          }
          stopMonitoring(t) {
            const i = ms(t),
              r = this._elementInfo.get(i);
            r &&
              (r.subject.complete(),
              this._setClasses(i),
              this._elementInfo.delete(i),
              this._removeGlobalListeners(r));
          }
          focusVia(t, i, r) {
            const s = ms(t);
            s === this._getDocument().activeElement
              ? this._getClosestElementsInfo(s).forEach(([a, l]) =>
                  this._originChanged(a, i, l)
                )
              : (this._setOrigin(i),
                'function' == typeof s.focus && s.focus(r));
          }
          ngOnDestroy() {
            this._elementInfo.forEach((t, i) => this.stopMonitoring(i));
          }
          _getDocument() {
            return this._document || document;
          }
          _getWindow() {
            return this._getDocument().defaultView || window;
          }
          _getFocusOrigin(t) {
            return this._origin
              ? this._originFromTouchInteraction
                ? this._shouldBeAttributedToTouch(t)
                  ? 'touch'
                  : 'program'
                : this._origin
              : this._windowFocused && this._lastFocusOrigin
              ? this._lastFocusOrigin
              : t && this._isLastInteractionFromInputLabel(t)
              ? 'mouse'
              : 'program';
          }
          _shouldBeAttributedToTouch(t) {
            return (
              1 === this._detectionMode ||
              !!t?.contains(this._inputModalityDetector._mostRecentTarget)
            );
          }
          _setClasses(t, i) {
            t.classList.toggle('cdk-focused', !!i),
              t.classList.toggle('cdk-touch-focused', 'touch' === i),
              t.classList.toggle('cdk-keyboard-focused', 'keyboard' === i),
              t.classList.toggle('cdk-mouse-focused', 'mouse' === i),
              t.classList.toggle('cdk-program-focused', 'program' === i);
          }
          _setOrigin(t, i = !1) {
            this._ngZone.runOutsideAngular(() => {
              (this._origin = t),
                (this._originFromTouchInteraction = 'touch' === t && i),
                0 === this._detectionMode &&
                  (clearTimeout(this._originTimeoutId),
                  (this._originTimeoutId = setTimeout(
                    () => (this._origin = null),
                    this._originFromTouchInteraction ? 650 : 1
                  )));
            });
          }
          _onFocus(t, i) {
            const r = this._elementInfo.get(i),
              s = Js(t);
            !r ||
              (!r.checkChildren && i !== s) ||
              this._originChanged(i, this._getFocusOrigin(s), r);
          }
          _onBlur(t, i) {
            const r = this._elementInfo.get(i);
            !r ||
              (r.checkChildren &&
                t.relatedTarget instanceof Node &&
                i.contains(t.relatedTarget)) ||
              (this._setClasses(i), this._emitOrigin(r, null));
          }
          _emitOrigin(t, i) {
            t.subject.observers.length &&
              this._ngZone.run(() => t.subject.next(i));
          }
          _registerGlobalListeners(t) {
            if (!this._platform.isBrowser) return;
            const i = t.rootNode,
              r = this._rootNodeFocusListenerCount.get(i) || 0;
            r ||
              this._ngZone.runOutsideAngular(() => {
                i.addEventListener(
                  'focus',
                  this._rootNodeFocusAndBlurListener,
                  Bm
                ),
                  i.addEventListener(
                    'blur',
                    this._rootNodeFocusAndBlurListener,
                    Bm
                  );
              }),
              this._rootNodeFocusListenerCount.set(i, r + 1),
              1 == ++this._monitoredElementCount &&
                (this._ngZone.runOutsideAngular(() => {
                  this._getWindow().addEventListener(
                    'focus',
                    this._windowFocusListener
                  );
                }),
                this._inputModalityDetector.modalityDetected
                  .pipe(se(this._stopInputModalityDetector))
                  .subscribe((s) => {
                    this._setOrigin(s, !0);
                  }));
          }
          _removeGlobalListeners(t) {
            const i = t.rootNode;
            if (this._rootNodeFocusListenerCount.has(i)) {
              const r = this._rootNodeFocusListenerCount.get(i);
              r > 1
                ? this._rootNodeFocusListenerCount.set(i, r - 1)
                : (i.removeEventListener(
                    'focus',
                    this._rootNodeFocusAndBlurListener,
                    Bm
                  ),
                  i.removeEventListener(
                    'blur',
                    this._rootNodeFocusAndBlurListener,
                    Bm
                  ),
                  this._rootNodeFocusListenerCount.delete(i));
            }
            --this._monitoredElementCount ||
              (this._getWindow().removeEventListener(
                'focus',
                this._windowFocusListener
              ),
              this._stopInputModalityDetector.next(),
              clearTimeout(this._windowFocusTimeoutId),
              clearTimeout(this._originTimeoutId));
          }
          _originChanged(t, i, r) {
            this._setClasses(t, i),
              this._emitOrigin(r, i),
              (this._lastFocusOrigin = i);
          }
          _getClosestElementsInfo(t) {
            const i = [];
            return (
              this._elementInfo.forEach((r, s) => {
                (s === t || (r.checkChildren && s.contains(t))) &&
                  i.push([s, r]);
              }),
              i
            );
          }
          _isLastInteractionFromInputLabel(t) {
            const { _mostRecentTarget: i, mostRecentModality: r } =
              this._inputModalityDetector;
            if (
              'mouse' !== r ||
              !i ||
              i === t ||
              ('INPUT' !== t.nodeName && 'TEXTAREA' !== t.nodeName) ||
              t.disabled
            )
              return !1;
            const s = t.labels;
            if (s)
              for (let o = 0; o < s.length; o++)
                if (s[o].contains(i)) return !0;
            return !1;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(ue), L(jt), L(JZ), L(He, 8), L(sQ, 8));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      const lL = 'cdk-high-contrast-black-on-white',
        cL = 'cdk-high-contrast-white-on-black',
        cE = 'cdk-high-contrast-active';
      let dL = (() => {
          class n {
            constructor(t, i) {
              (this._platform = t),
                (this._document = i),
                (this._breakpointSubscription = Te(RZ)
                  .observe('(forced-colors: active)')
                  .subscribe(() => {
                    this._hasCheckedHighContrastMode &&
                      ((this._hasCheckedHighContrastMode = !1),
                      this._applyBodyHighContrastModeCssClasses());
                  }));
            }
            getHighContrastMode() {
              if (!this._platform.isBrowser) return 0;
              const t = this._document.createElement('div');
              (t.style.backgroundColor = 'rgb(1,2,3)'),
                (t.style.position = 'absolute'),
                this._document.body.appendChild(t);
              const i = this._document.defaultView || window,
                r = i && i.getComputedStyle ? i.getComputedStyle(t) : null,
                s = ((r && r.backgroundColor) || '').replace(/ /g, '');
              switch ((t.remove(), s)) {
                case 'rgb(0,0,0)':
                case 'rgb(45,50,54)':
                case 'rgb(32,32,32)':
                  return 2;
                case 'rgb(255,255,255)':
                case 'rgb(255,250,239)':
                  return 1;
              }
              return 0;
            }
            ngOnDestroy() {
              this._breakpointSubscription.unsubscribe();
            }
            _applyBodyHighContrastModeCssClasses() {
              if (
                !this._hasCheckedHighContrastMode &&
                this._platform.isBrowser &&
                this._document.body
              ) {
                const t = this._document.body.classList;
                t.remove(cE, lL, cL), (this._hasCheckedHighContrastMode = !0);
                const i = this.getHighContrastMode();
                1 === i ? t.add(cE, lL) : 2 === i && t.add(cE, cL);
              }
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(jt), L(He));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        oQ = (() => {
          class n {
            constructor(t) {
              t._applyBodyHighContrastModeCssClasses();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(dL));
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [YO] })),
            n
          );
        })();
      const aQ = new j('cdk-dir-doc', {
          providedIn: 'root',
          factory: function lQ() {
            return Te(He);
          },
        }),
        cQ =
          /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
      let ca = (() => {
          class n {
            constructor(t) {
              (this.value = 'ltr'),
                (this.change = new ke()),
                t &&
                  (this.value = (function dQ(n) {
                    const e = n?.toLowerCase() || '';
                    return 'auto' === e &&
                      typeof navigator < 'u' &&
                      navigator?.language
                      ? cQ.test(navigator.language)
                        ? 'rtl'
                        : 'ltr'
                      : 'rtl' === e
                      ? 'rtl'
                      : 'ltr';
                  })(
                    (t.body ? t.body.dir : null) ||
                      (t.documentElement ? t.documentElement.dir : null) ||
                      'ltr'
                  ));
            }
            ngOnDestroy() {
              this.change.complete();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(aQ, 8));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        vu = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({})),
            n
          );
        })();
      const uQ = ['text'];
      function hQ(n, e) {
        if ((1 & n && ct(0, 'mat-pseudo-checkbox', 6), 2 & n)) {
          const t = Be();
          X('state', t.selected ? 'checked' : 'unchecked')(
            'disabled',
            t.disabled
          );
        }
      }
      function fQ(n, e) {
        1 & n && ct(0, 'mat-pseudo-checkbox', 7),
          2 & n && X('disabled', Be().disabled);
      }
      function pQ(n, e) {
        if ((1 & n && (z(0, 'span', 8), Ue(1), G()), 2 & n)) {
          const t = Be();
          Y(1), ds('(', t.group.label, ')');
        }
      }
      const mQ = [[['mat-icon']], '*'],
        gQ = ['mat-icon', '*'],
        bQ = new j('mat-sanity-checks', {
          providedIn: 'root',
          factory: function _Q() {
            return !0;
          },
        });
      let Vt = (() => {
        class n {
          constructor(t, i, r) {
            (this._sanityChecks = i),
              (this._document = r),
              (this._hasDoneGlobalChecks = !1),
              t._applyBodyHighContrastModeCssClasses(),
              this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0);
          }
          _checkIsEnabled(t) {
            return (
              !Z0() &&
              ('boolean' == typeof this._sanityChecks
                ? this._sanityChecks
                : !!this._sanityChecks[t])
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(dL), L(bQ, 8), L(He));
          }),
          (n.ɵmod = Ze({ type: n })),
          (n.ɵinj = qe({ imports: [vu, vu] })),
          n
        );
      })();
      function dE(n) {
        return class extends n {
          get disabled() {
            return this._disabled;
          }
          set disabled(e) {
            this._disabled = vt(e);
          }
          constructor(...e) {
            super(...e), (this._disabled = !1);
          }
        };
      }
      function Wm(n, e) {
        return class extends n {
          get color() {
            return this._color;
          }
          set color(t) {
            const i = t || this.defaultColor;
            i !== this._color &&
              (this._color &&
                this._elementRef.nativeElement.classList.remove(
                  `mat-${this._color}`
                ),
              i && this._elementRef.nativeElement.classList.add(`mat-${i}`),
              (this._color = i));
          }
          constructor(...t) {
            super(...t), (this.defaultColor = e), (this.color = e);
          }
        };
      }
      function uE(n) {
        return class extends n {
          get disableRipple() {
            return this._disableRipple;
          }
          set disableRipple(e) {
            this._disableRipple = vt(e);
          }
          constructor(...e) {
            super(...e), (this._disableRipple = !1);
          }
        };
      }
      function fL(n, e = 0) {
        return class extends n {
          get tabIndex() {
            return this.disabled ? -1 : this._tabIndex;
          }
          set tabIndex(t) {
            this._tabIndex = null != t ? _u(t) : this.defaultTabIndex;
          }
          constructor(...t) {
            super(...t), (this._tabIndex = e), (this.defaultTabIndex = e);
          }
        };
      }
      function pL(n) {
        return class extends n {
          updateErrorState() {
            const e = this.errorState,
              s = (
                this.errorStateMatcher || this._defaultErrorStateMatcher
              ).isErrorState(
                this.ngControl ? this.ngControl.control : null,
                this._parentFormGroup || this._parentForm
              );
            s !== e && ((this.errorState = s), this.stateChanges.next());
          }
          constructor(...e) {
            super(...e), (this.errorState = !1);
          }
        };
      }
      let mL = (() => {
        class n {
          isErrorState(t, i) {
            return !!(t && t.invalid && (t.touched || (i && i.submitted)));
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      class yQ {
        constructor(e, t, i, r = !1) {
          (this._renderer = e),
            (this.element = t),
            (this.config = i),
            (this._animationForciblyDisabledThroughCss = r),
            (this.state = 3);
        }
        fadeOut() {
          this._renderer.fadeOutRipple(this);
        }
      }
      const gL = Gl({ passive: !0, capture: !0 });
      class wQ {
        constructor() {
          (this._events = new Map()),
            (this._delegateEventHandler = (e) => {
              const t = Js(e);
              t &&
                this._events.get(e.type)?.forEach((i, r) => {
                  (r === t || r.contains(t)) &&
                    i.forEach((s) => s.handleEvent(e));
                });
            });
        }
        addHandler(e, t, i, r) {
          const s = this._events.get(t);
          if (s) {
            const o = s.get(i);
            o ? o.add(r) : s.set(i, new Set([r]));
          } else
            this._events.set(t, new Map([[i, new Set([r])]])),
              e.runOutsideAngular(() => {
                document.addEventListener(t, this._delegateEventHandler, gL);
              });
        }
        removeHandler(e, t, i) {
          const r = this._events.get(e);
          if (!r) return;
          const s = r.get(t);
          s &&
            (s.delete(i),
            0 === s.size && r.delete(t),
            0 === r.size &&
              (this._events.delete(e),
              document.removeEventListener(e, this._delegateEventHandler, gL)));
        }
      }
      const _L = { enterDuration: 225, exitDuration: 150 },
        bL = Gl({ passive: !0, capture: !0 }),
        vL = ['mousedown', 'touchstart'],
        yL = ['mouseup', 'mouseleave', 'touchend', 'touchcancel'];
      class Xl {
        constructor(e, t, i, r) {
          (this._target = e),
            (this._ngZone = t),
            (this._platform = r),
            (this._isPointerDown = !1),
            (this._activeRipples = new Map()),
            (this._pointerUpEventsRegistered = !1),
            r.isBrowser && (this._containerElement = ms(i));
        }
        fadeInRipple(e, t, i = {}) {
          const r = (this._containerRect =
              this._containerRect ||
              this._containerElement.getBoundingClientRect()),
            s = { ..._L, ...i.animation };
          i.centered &&
            ((e = r.left + r.width / 2), (t = r.top + r.height / 2));
          const o =
              i.radius ||
              (function CQ(n, e, t) {
                const i = Math.max(Math.abs(n - t.left), Math.abs(n - t.right)),
                  r = Math.max(Math.abs(e - t.top), Math.abs(e - t.bottom));
                return Math.sqrt(i * i + r * r);
              })(e, t, r),
            a = e - r.left,
            l = t - r.top,
            c = s.enterDuration,
            u = document.createElement('div');
          u.classList.add('mat-ripple-element'),
            (u.style.left = a - o + 'px'),
            (u.style.top = l - o + 'px'),
            (u.style.height = 2 * o + 'px'),
            (u.style.width = 2 * o + 'px'),
            null != i.color && (u.style.backgroundColor = i.color),
            (u.style.transitionDuration = `${c}ms`),
            this._containerElement.appendChild(u);
          const h = window.getComputedStyle(u),
            p = h.transitionDuration,
            m =
              'none' === h.transitionProperty ||
              '0s' === p ||
              '0s, 0s' === p ||
              (0 === r.width && 0 === r.height),
            g = new yQ(this, u, i, m);
          (u.style.transform = 'scale3d(1, 1, 1)'),
            (g.state = 0),
            i.persistent || (this._mostRecentTransientRipple = g);
          let w = null;
          return (
            !m &&
              (c || s.exitDuration) &&
              this._ngZone.runOutsideAngular(() => {
                const y = () => this._finishRippleTransition(g),
                  E = () => this._destroyRipple(g);
                u.addEventListener('transitionend', y),
                  u.addEventListener('transitioncancel', E),
                  (w = { onTransitionEnd: y, onTransitionCancel: E });
              }),
            this._activeRipples.set(g, w),
            (m || !c) && this._finishRippleTransition(g),
            g
          );
        }
        fadeOutRipple(e) {
          if (2 === e.state || 3 === e.state) return;
          const t = e.element,
            i = { ..._L, ...e.config.animation };
          (t.style.transitionDuration = `${i.exitDuration}ms`),
            (t.style.opacity = '0'),
            (e.state = 2),
            (e._animationForciblyDisabledThroughCss || !i.exitDuration) &&
              this._finishRippleTransition(e);
        }
        fadeOutAll() {
          this._getActiveRipples().forEach((e) => e.fadeOut());
        }
        fadeOutAllNonPersistent() {
          this._getActiveRipples().forEach((e) => {
            e.config.persistent || e.fadeOut();
          });
        }
        setupTriggerEvents(e) {
          const t = ms(e);
          !this._platform.isBrowser ||
            !t ||
            t === this._triggerElement ||
            (this._removeTriggerEvents(),
            (this._triggerElement = t),
            vL.forEach((i) => {
              Xl._eventManager.addHandler(this._ngZone, i, t, this);
            }));
        }
        handleEvent(e) {
          'mousedown' === e.type
            ? this._onMousedown(e)
            : 'touchstart' === e.type
            ? this._onTouchStart(e)
            : this._onPointerUp(),
            this._pointerUpEventsRegistered ||
              (this._ngZone.runOutsideAngular(() => {
                yL.forEach((t) => {
                  this._triggerElement.addEventListener(t, this, bL);
                });
              }),
              (this._pointerUpEventsRegistered = !0));
        }
        _finishRippleTransition(e) {
          0 === e.state
            ? this._startFadeOutTransition(e)
            : 2 === e.state && this._destroyRipple(e);
        }
        _startFadeOutTransition(e) {
          const t = e === this._mostRecentTransientRipple,
            { persistent: i } = e.config;
          (e.state = 1), !i && (!t || !this._isPointerDown) && e.fadeOut();
        }
        _destroyRipple(e) {
          const t = this._activeRipples.get(e) ?? null;
          this._activeRipples.delete(e),
            this._activeRipples.size || (this._containerRect = null),
            e === this._mostRecentTransientRipple &&
              (this._mostRecentTransientRipple = null),
            (e.state = 3),
            null !== t &&
              (e.element.removeEventListener(
                'transitionend',
                t.onTransitionEnd
              ),
              e.element.removeEventListener(
                'transitioncancel',
                t.onTransitionCancel
              )),
            e.element.remove();
        }
        _onMousedown(e) {
          const t = sL(e),
            i =
              this._lastTouchStartEvent &&
              Date.now() < this._lastTouchStartEvent + 800;
          !this._target.rippleDisabled &&
            !t &&
            !i &&
            ((this._isPointerDown = !0),
            this.fadeInRipple(e.clientX, e.clientY, this._target.rippleConfig));
        }
        _onTouchStart(e) {
          if (!this._target.rippleDisabled && !oL(e)) {
            (this._lastTouchStartEvent = Date.now()),
              (this._isPointerDown = !0);
            const t = e.changedTouches;
            for (let i = 0; i < t.length; i++)
              this.fadeInRipple(
                t[i].clientX,
                t[i].clientY,
                this._target.rippleConfig
              );
          }
        }
        _onPointerUp() {
          this._isPointerDown &&
            ((this._isPointerDown = !1),
            this._getActiveRipples().forEach((e) => {
              !e.config.persistent &&
                (1 === e.state ||
                  (e.config.terminateOnPointerUp && 0 === e.state)) &&
                e.fadeOut();
            }));
        }
        _getActiveRipples() {
          return Array.from(this._activeRipples.keys());
        }
        _removeTriggerEvents() {
          const e = this._triggerElement;
          e &&
            (vL.forEach((t) => Xl._eventManager.removeHandler(t, e, this)),
            this._pointerUpEventsRegistered &&
              yL.forEach((t) => e.removeEventListener(t, this, bL)));
        }
      }
      Xl._eventManager = new wQ();
      const wL = new j('mat-ripple-global-options');
      let hE = (() => {
          class n {
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              t && this.fadeOutAllNonPersistent(),
                (this._disabled = t),
                this._setupTriggerEventsIfEnabled();
            }
            get trigger() {
              return this._trigger || this._elementRef.nativeElement;
            }
            set trigger(t) {
              (this._trigger = t), this._setupTriggerEventsIfEnabled();
            }
            constructor(t, i, r, s, o) {
              (this._elementRef = t),
                (this._animationMode = o),
                (this.radius = 0),
                (this._disabled = !1),
                (this._isInitialized = !1),
                (this._globalOptions = s || {}),
                (this._rippleRenderer = new Xl(this, i, t, r));
            }
            ngOnInit() {
              (this._isInitialized = !0), this._setupTriggerEventsIfEnabled();
            }
            ngOnDestroy() {
              this._rippleRenderer._removeTriggerEvents();
            }
            fadeOutAll() {
              this._rippleRenderer.fadeOutAll();
            }
            fadeOutAllNonPersistent() {
              this._rippleRenderer.fadeOutAllNonPersistent();
            }
            get rippleConfig() {
              return {
                centered: this.centered,
                radius: this.radius,
                color: this.color,
                animation: {
                  ...this._globalOptions.animation,
                  ...('NoopAnimations' === this._animationMode
                    ? { enterDuration: 0, exitDuration: 0 }
                    : {}),
                  ...this.animation,
                },
                terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,
              };
            }
            get rippleDisabled() {
              return this.disabled || !!this._globalOptions.disabled;
            }
            _setupTriggerEventsIfEnabled() {
              !this.disabled &&
                this._isInitialized &&
                this._rippleRenderer.setupTriggerEvents(this.trigger);
            }
            launch(t, i = 0, r) {
              return 'number' == typeof t
                ? this._rippleRenderer.fadeInRipple(t, i, {
                    ...this.rippleConfig,
                    ...r,
                  })
                : this._rippleRenderer.fadeInRipple(0, 0, {
                    ...this.rippleConfig,
                    ...t,
                  });
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ne), D(ue), D(jt), D(wL, 8), D(Ii, 8));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [
                ['', 'mat-ripple', ''],
                ['', 'matRipple', ''],
              ],
              hostAttrs: [1, 'mat-ripple'],
              hostVars: 2,
              hostBindings: function (t, i) {
                2 & t && _t('mat-ripple-unbounded', i.unbounded);
              },
              inputs: {
                color: ['matRippleColor', 'color'],
                unbounded: ['matRippleUnbounded', 'unbounded'],
                centered: ['matRippleCentered', 'centered'],
                radius: ['matRippleRadius', 'radius'],
                animation: ['matRippleAnimation', 'animation'],
                disabled: ['matRippleDisabled', 'disabled'],
                trigger: ['matRippleTrigger', 'trigger'],
              },
              exportAs: ['matRipple'],
            })),
            n
          );
        })(),
        fE = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [Vt, Vt] })),
            n
          );
        })(),
        xQ = (() => {
          class n {
            constructor(t) {
              (this._animationMode = t),
                (this.state = 'unchecked'),
                (this.disabled = !1),
                (this.appearance = 'full');
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ii, 8));
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-pseudo-checkbox']],
              hostAttrs: [1, 'mat-pseudo-checkbox'],
              hostVars: 12,
              hostBindings: function (t, i) {
                2 & t &&
                  _t(
                    'mat-pseudo-checkbox-indeterminate',
                    'indeterminate' === i.state
                  )('mat-pseudo-checkbox-checked', 'checked' === i.state)(
                    'mat-pseudo-checkbox-disabled',
                    i.disabled
                  )('mat-pseudo-checkbox-minimal', 'minimal' === i.appearance)(
                    'mat-pseudo-checkbox-full',
                    'full' === i.appearance
                  )(
                    '_mat-animation-noopable',
                    'NoopAnimations' === i._animationMode
                  );
              },
              inputs: {
                state: 'state',
                disabled: 'disabled',
                appearance: 'appearance',
              },
              decls: 0,
              vars: 0,
              template: function (t, i) {},
              styles: [
                '.mat-pseudo-checkbox{border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox-full{border:2px solid}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after{width:14px;height:6px;transform-origin:center;top:-4.2426406871px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{top:8px;width:16px}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after{width:10px;height:4px;transform-origin:center;top:-2.8284271247px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        AQ = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [Vt] })),
            n
          );
        })();
      const EL = new j('MAT_OPTION_PARENT_COMPONENT'),
        CL = new j('MatOptgroup');
      let SQ = 0;
      class MQ {
        constructor(e, t = !1) {
          (this.source = e), (this.isUserInput = t);
        }
      }
      let DQ = (() => {
          class n {
            get multiple() {
              return this._parent && this._parent.multiple;
            }
            get selected() {
              return this._selected;
            }
            get disabled() {
              return (this.group && this.group.disabled) || this._disabled;
            }
            set disabled(t) {
              this._disabled = vt(t);
            }
            get disableRipple() {
              return !(!this._parent || !this._parent.disableRipple);
            }
            get hideSingleSelectionIndicator() {
              return !(
                !this._parent || !this._parent.hideSingleSelectionIndicator
              );
            }
            constructor(t, i, r, s) {
              (this._element = t),
                (this._changeDetectorRef = i),
                (this._parent = r),
                (this.group = s),
                (this._selected = !1),
                (this._active = !1),
                (this._disabled = !1),
                (this._mostRecentViewValue = ''),
                (this.id = 'mat-option-' + SQ++),
                (this.onSelectionChange = new ke()),
                (this._stateChanges = new Le());
            }
            get active() {
              return this._active;
            }
            get viewValue() {
              return (this._text?.nativeElement.textContent || '').trim();
            }
            select() {
              this._selected ||
                ((this._selected = !0),
                this._changeDetectorRef.markForCheck(),
                this._emitSelectionChangeEvent());
            }
            deselect() {
              this._selected &&
                ((this._selected = !1),
                this._changeDetectorRef.markForCheck(),
                this._emitSelectionChangeEvent());
            }
            focus(t, i) {
              const r = this._getHostElement();
              'function' == typeof r.focus && r.focus(i);
            }
            setActiveStyles() {
              this._active ||
                ((this._active = !0), this._changeDetectorRef.markForCheck());
            }
            setInactiveStyles() {
              this._active &&
                ((this._active = !1), this._changeDetectorRef.markForCheck());
            }
            getLabel() {
              return this.viewValue;
            }
            _handleKeydown(t) {
              (13 === t.keyCode || 32 === t.keyCode) &&
                !aa(t) &&
                (this._selectViaInteraction(), t.preventDefault());
            }
            _selectViaInteraction() {
              this.disabled ||
                ((this._selected = !this.multiple || !this._selected),
                this._changeDetectorRef.markForCheck(),
                this._emitSelectionChangeEvent(!0));
            }
            _getTabIndex() {
              return this.disabled ? '-1' : '0';
            }
            _getHostElement() {
              return this._element.nativeElement;
            }
            ngAfterViewChecked() {
              if (this._selected) {
                const t = this.viewValue;
                t !== this._mostRecentViewValue &&
                  (this._mostRecentViewValue && this._stateChanges.next(),
                  (this._mostRecentViewValue = t));
              }
            }
            ngOnDestroy() {
              this._stateChanges.complete();
            }
            _emitSelectionChangeEvent(t = !1) {
              this.onSelectionChange.emit(new MQ(this, t));
            }
          }
          return (
            (n.ɵfac = function (t) {
              wl();
            }),
            (n.ɵdir = J({
              type: n,
              viewQuery: function (t, i) {
                if ((1 & t && vn(uQ, 7), 2 & t)) {
                  let r;
                  ut((r = ht())) && (i._text = r.first);
                }
              },
              inputs: { value: 'value', id: 'id', disabled: 'disabled' },
              outputs: { onSelectionChange: 'onSelectionChange' },
            })),
            n
          );
        })(),
        xL = (() => {
          class n extends DQ {
            constructor(t, i, r, s) {
              super(t, i, r, s);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ne), D(Br), D(EL, 8), D(CL, 8));
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-option']],
              hostAttrs: [
                'role',
                'option',
                1,
                'mat-mdc-option',
                'mdc-list-item',
              ],
              hostVars: 11,
              hostBindings: function (t, i) {
                1 & t &&
                  pe('click', function () {
                    return i._selectViaInteraction();
                  })('keydown', function (s) {
                    return i._handleKeydown(s);
                  }),
                  2 & t &&
                    (Xo('id', i.id),
                    Dt('aria-selected', i.selected)(
                      'aria-disabled',
                      i.disabled.toString()
                    ),
                    _t('mdc-list-item--selected', i.selected)(
                      'mat-mdc-option-multiple',
                      i.multiple
                    )('mat-mdc-option-active', i.active)(
                      'mdc-list-item--disabled',
                      i.disabled
                    ));
              },
              exportAs: ['matOption'],
              features: [ye],
              ngContentSelectors: gQ,
              decls: 8,
              vars: 5,
              consts: [
                [
                  'class',
                  'mat-mdc-option-pseudo-checkbox',
                  3,
                  'state',
                  'disabled',
                  4,
                  'ngIf',
                ],
                [1, 'mdc-list-item__primary-text'],
                ['text', ''],
                [
                  'class',
                  'mat-mdc-option-pseudo-checkbox',
                  'state',
                  'checked',
                  'appearance',
                  'minimal',
                  3,
                  'disabled',
                  4,
                  'ngIf',
                ],
                ['class', 'cdk-visually-hidden', 4, 'ngIf'],
                [
                  'mat-ripple',
                  '',
                  1,
                  'mat-mdc-option-ripple',
                  'mat-mdc-focus-indicator',
                  3,
                  'matRippleTrigger',
                  'matRippleDisabled',
                ],
                [1, 'mat-mdc-option-pseudo-checkbox', 3, 'state', 'disabled'],
                [
                  'state',
                  'checked',
                  'appearance',
                  'minimal',
                  1,
                  'mat-mdc-option-pseudo-checkbox',
                  3,
                  'disabled',
                ],
                [1, 'cdk-visually-hidden'],
              ],
              template: function (t, i) {
                1 & t &&
                  (Pi(mQ),
                  Ie(0, hQ, 1, 2, 'mat-pseudo-checkbox', 0),
                  dt(1),
                  z(2, 'span', 1, 2),
                  dt(4, 1),
                  G(),
                  Ie(5, fQ, 1, 1, 'mat-pseudo-checkbox', 3),
                  Ie(6, pQ, 2, 1, 'span', 4),
                  ct(7, 'div', 5)),
                  2 & t &&
                    (X('ngIf', i.multiple),
                    Y(5),
                    X(
                      'ngIf',
                      !i.multiple &&
                        i.selected &&
                        !i.hideSingleSelectionIndicator
                    ),
                    Y(1),
                    X('ngIf', i.group && i.group._inert),
                    Y(1),
                    X('matRippleTrigger', i._getHostElement())(
                      'matRippleDisabled',
                      i.disabled || i.disableRipple
                    ));
              },
              dependencies: [hE, Zd, xQ],
              styles: [
                '.mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{cursor:default;pointer-events:none}.mat-mdc-option.mdc-list-item--disabled .mat-mdc-option-pseudo-checkbox,.mat-mdc-option.mdc-list-item--disabled .mdc-list-item__primary-text,.mat-mdc-option.mdc-list-item--disabled>mat-icon{opacity:.38}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active .mat-mdc-focus-indicator::before{content:""}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        AL = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [fE, Jo, Vt, AQ] })),
            n
          );
        })();
      const SL = ['mat-button', ''],
        ML = [
          [
            ['', 8, 'material-icons', 3, 'iconPositionEnd', ''],
            ['mat-icon', 3, 'iconPositionEnd', ''],
            ['', 'matButtonIcon', '', 3, 'iconPositionEnd', ''],
          ],
          '*',
          [
            ['', 'iconPositionEnd', '', 8, 'material-icons'],
            ['mat-icon', 'iconPositionEnd', ''],
            ['', 'matButtonIcon', '', 'iconPositionEnd', ''],
          ],
        ],
        DL = [
          '.material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])',
          '*',
          '.material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]',
        ],
        TL = { capture: !0 },
        IL = ['focus', 'click', 'mouseenter', 'touchstart'],
        wu = 'mat-button-ripple-uninitialized';
      let RQ = (() => {
        class n {
          constructor() {
            (this._document = Te(He, { optional: !0 })),
              (this._animationMode = Te(Ii, { optional: !0 })),
              (this._globalRippleOptions = Te(wL, { optional: !0 })),
              (this._platform = Te(jt)),
              (this._ngZone = Te(ue)),
              (this._onInteraction = (t) => {
                if (t.target === this._document) return;
                const r = t.target.closest(`[${wu}]`);
                r && (r.removeAttribute(wu), this._appendRipple(r));
              }),
              this._ngZone.runOutsideAngular(() => {
                for (const t of IL)
                  this._document?.addEventListener(t, this._onInteraction, TL);
              });
          }
          ngOnDestroy() {
            for (const t of IL)
              this._document?.removeEventListener(t, this._onInteraction, TL);
          }
          _appendRipple(t) {
            if (!this._document) return;
            const i = this._document.createElement('span');
            i.classList.add('mat-mdc-button-ripple');
            const r = new FQ(
              t,
              this._globalRippleOptions ? this._globalRippleOptions : void 0,
              this._animationMode ? this._animationMode : void 0
            );
            (r.rippleConfig.centered = t.hasAttribute('mat-icon-button')),
              new Xl(r, this._ngZone, i, this._platform).setupTriggerEvents(t),
              t.append(i);
          }
          _createMatRipple(t) {
            if (!this._document) return;
            t.querySelector('.mat-mdc-button-ripple')?.remove(),
              t.removeAttribute(wu);
            const i = this._document.createElement('span');
            i.classList.add('mat-mdc-button-ripple');
            const r = new hE(
              new Ne(i),
              this._ngZone,
              this._platform,
              this._globalRippleOptions ? this._globalRippleOptions : void 0,
              this._animationMode ? this._animationMode : void 0
            );
            return (r._isInitialized = !0), (r.trigger = t), t.append(i), r;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      class FQ {
        constructor(e, t, i) {
          (this._button = e),
            (this._globalRippleOptions = t),
            this._setRippleConfig(t, i);
        }
        _setRippleConfig(e, t) {
          (this.rippleConfig = e || {}),
            'NoopAnimations' === t &&
              (this.rippleConfig.animation = {
                enterDuration: 0,
                exitDuration: 0,
              });
        }
        get rippleDisabled() {
          return (
            this._button.hasAttribute('disabled') ||
            !!this._globalRippleOptions?.disabled
          );
        }
      }
      const OQ = [
          {
            selector: 'mat-button',
            mdcClasses: ['mdc-button', 'mat-mdc-button'],
          },
          {
            selector: 'mat-flat-button',
            mdcClasses: [
              'mdc-button',
              'mdc-button--unelevated',
              'mat-mdc-unelevated-button',
            ],
          },
          {
            selector: 'mat-raised-button',
            mdcClasses: [
              'mdc-button',
              'mdc-button--raised',
              'mat-mdc-raised-button',
            ],
          },
          {
            selector: 'mat-stroked-button',
            mdcClasses: [
              'mdc-button',
              'mdc-button--outlined',
              'mat-mdc-outlined-button',
            ],
          },
          { selector: 'mat-fab', mdcClasses: ['mdc-fab', 'mat-mdc-fab'] },
          {
            selector: 'mat-mini-fab',
            mdcClasses: ['mdc-fab', 'mdc-fab--mini', 'mat-mdc-mini-fab'],
          },
          {
            selector: 'mat-icon-button',
            mdcClasses: ['mdc-icon-button', 'mat-mdc-icon-button'],
          },
        ],
        LQ = Wm(
          dE(
            uE(
              class {
                constructor(n) {
                  this._elementRef = n;
                }
              }
            )
          )
        );
      let kL = (() => {
          class n extends LQ {
            get ripple() {
              return (
                !this._ripple &&
                  this._rippleLoader &&
                  (this._ripple = this._rippleLoader._createMatRipple(
                    this._elementRef.nativeElement
                  )),
                this._ripple
              );
            }
            set ripple(t) {
              this._ripple = t;
            }
            constructor(t, i, r, s) {
              super(t),
                (this._platform = i),
                (this._ngZone = r),
                (this._animationMode = s),
                (this._focusMonitor = Te(Hm)),
                (this._rippleLoader = Te(RQ)),
                (this._isFab = !1);
              const o = t.nativeElement.classList;
              for (const a of OQ)
                this._hasHostAttributes(a.selector) &&
                  a.mdcClasses.forEach((l) => {
                    o.add(l);
                  });
            }
            ngAfterViewInit() {
              this._focusMonitor.monitor(this._elementRef, !0);
            }
            ngOnChanges() {
              this._ripple &&
                (this._ripple.disabled = this.disableRipple || this.disabled);
            }
            ngOnDestroy() {
              this._focusMonitor.stopMonitoring(this._elementRef);
            }
            focus(t = 'program', i) {
              t
                ? this._focusMonitor.focusVia(
                    this._elementRef.nativeElement,
                    t,
                    i
                  )
                : this._elementRef.nativeElement.focus(i);
            }
            _hasHostAttributes(...t) {
              return t.some((i) =>
                this._elementRef.nativeElement.hasAttribute(i)
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              wl();
            }),
            (n.ɵdir = J({ type: n, features: [ye, ri] })),
            n
          );
        })(),
        VQ = (() => {
          class n extends kL {
            constructor(t, i, r, s) {
              super(t, i, r, s),
                (this._haltDisabledEvents = (o) => {
                  this.disabled &&
                    (o.preventDefault(), o.stopImmediatePropagation());
                });
            }
            ngOnInit() {
              this._ngZone.runOutsideAngular(() => {
                this._elementRef.nativeElement.addEventListener(
                  'click',
                  this._haltDisabledEvents
                );
              });
            }
            ngOnDestroy() {
              super.ngOnDestroy(),
                this._elementRef.nativeElement.removeEventListener(
                  'click',
                  this._haltDisabledEvents
                );
            }
          }
          return (
            (n.ɵfac = function (t) {
              wl();
            }),
            (n.ɵdir = J({ type: n, features: [ye] })),
            n
          );
        })(),
        BQ = (() => {
          class n extends kL {
            constructor(t, i, r, s) {
              super(t, i, r, s);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ne), D(jt), D(ue), D(Ii, 8));
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [
                ['button', 'mat-button', ''],
                ['button', 'mat-raised-button', ''],
                ['button', 'mat-flat-button', ''],
                ['button', 'mat-stroked-button', ''],
              ],
              hostAttrs: ['mat-button-ripple-uninitialized', ''],
              hostVars: 7,
              hostBindings: function (t, i) {
                2 & t &&
                  (Dt('disabled', i.disabled || null),
                  _t(
                    '_mat-animation-noopable',
                    'NoopAnimations' === i._animationMode
                  )('mat-unthemed', !i.color)('mat-mdc-button-base', !0));
              },
              inputs: {
                disabled: 'disabled',
                disableRipple: 'disableRipple',
                color: 'color',
              },
              exportAs: ['matButton'],
              features: [ye],
              attrs: SL,
              ngContentSelectors: DL,
              decls: 7,
              vars: 4,
              consts: [
                [1, 'mat-mdc-button-persistent-ripple'],
                [1, 'mdc-button__label'],
                [1, 'mat-mdc-focus-indicator'],
                [1, 'mat-mdc-button-touch-target'],
              ],
              template: function (t, i) {
                1 & t &&
                  (Pi(ML),
                  ct(0, 'span', 0),
                  dt(1),
                  z(2, 'span', 1),
                  dt(3, 1),
                  G(),
                  dt(4, 2),
                  ct(5, 'span', 2)(6, 'span', 3)),
                  2 & t &&
                    _t('mdc-button__ripple', !i._isFab)(
                      'mdc-fab__ripple',
                      i._isFab
                    );
              },
              styles: [
                '.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0)}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__progress-indicator{font-size:0;position:absolute;transform:translate(-50%, -50%);top:50%;left:50%;line-height:initial}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    );display:none}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring{border-color:CanvasText}}.mdc-button .mdc-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring::after{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{display:block}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button{height:var(--mdc-text-button-container-height, 36px);border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, inherit)}.mat-mdc-button:disabled{color:var(--mdc-text-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button{height:var(--mdc-filled-button-container-height, 36px);border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button:not(:disabled){background-color:var(--mdc-filled-button-container-color, transparent)}.mat-mdc-unelevated-button:disabled{background-color:var(--mdc-filled-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, inherit)}.mat-mdc-unelevated-button:disabled{color:var(--mdc-filled-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button{height:var(--mdc-protected-button-container-height, 36px);border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px));box-shadow:var(--mdc-protected-button-container-elevation, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){background-color:var(--mdc-protected-button-container-color, transparent)}.mat-mdc-raised-button:disabled{background-color:var(--mdc-protected-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, inherit)}.mat-mdc-raised-button:disabled{color:var(--mdc-protected-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button.mdc-ripple-upgraded--background-focused,.mat-mdc-raised-button:not(.mdc-ripple-upgraded):focus{box-shadow:var(--mdc-protected-button-focus-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled):active{box-shadow:var(--mdc-protected-button-pressed-container-elevation, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button{height:var(--mdc-outlined-button-container-height, 36px);border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px));padding:0 15px 0 15px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, inherit)}.mat-mdc-outlined-button:disabled{color:var(--mdc-outlined-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-outlined-button .mdc-button__ripple{border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-outlined-button:not(:disabled){border-color:var(--mdc-outlined-button-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button:disabled{border-color:var(--mdc-outlined-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button.mdc-button--icon-trailing{padding:0 11px 0 15px}.mat-mdc-outlined-button.mdc-button--icon-leading{padding:0 15px 0 11px}.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button .mdc-button__touch{left:calc(-1 * var(--mdc-outlined-button-outline-width, 1px));width:calc(100% + 2 * var(--mdc-outlined-button-outline-width, 1px))}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-button .mat-ripple-element,.mat-mdc-unelevated-button .mat-ripple-element,.mat-mdc-raised-button .mat-ripple-element,.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-button .mdc-button__label,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-outlined-button .mdc-button__label{z-index:1}.mat-mdc-button .mat-mdc-focus-indicator,.mat-mdc-unelevated-button .mat-mdc-focus-indicator,.mat-mdc-raised-button .mat-mdc-focus-indicator,.mat-mdc-outlined-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-unelevated-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-raised-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-outlined-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-button[disabled],.mat-mdc-unelevated-button[disabled],.mat-mdc-raised-button[disabled],.mat-mdc-outlined-button[disabled]{cursor:default;pointer-events:none}.mat-mdc-button .mat-mdc-button-touch-target,.mat-mdc-unelevated-button .mat-mdc-button-touch-target,.mat-mdc-raised-button .mat-mdc-button-touch-target,.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .mat-mdc-button>.mat-icon,.mat-mdc-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}.mat-mdc-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon,.mat-mdc-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem;margin-left:-4px;margin-right:8px}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon,.mat-mdc-raised-button .mdc-button__label+.mat-icon,.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon,.mat-mdc-unelevated-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-raised-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-outlined-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:-1px}.mat-mdc-unelevated-button .mat-mdc-focus-indicator::before,.mat-mdc-raised-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-outlined-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 3px) * -1)}',
                '.cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        HQ = (() => {
          class n extends VQ {
            constructor(t, i, r, s) {
              super(t, i, r, s);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ne), D(jt), D(ue), D(Ii, 8));
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [
                ['a', 'mat-button', ''],
                ['a', 'mat-raised-button', ''],
                ['a', 'mat-flat-button', ''],
                ['a', 'mat-stroked-button', ''],
              ],
              hostAttrs: ['mat-button-ripple-uninitialized', ''],
              hostVars: 9,
              hostBindings: function (t, i) {
                2 & t &&
                  (Dt('disabled', i.disabled || null)(
                    'tabindex',
                    i.disabled ? -1 : i.tabIndex
                  )('aria-disabled', i.disabled.toString()),
                  _t(
                    '_mat-animation-noopable',
                    'NoopAnimations' === i._animationMode
                  )('mat-unthemed', !i.color)('mat-mdc-button-base', !0));
              },
              inputs: {
                disabled: 'disabled',
                disableRipple: 'disableRipple',
                color: 'color',
                tabIndex: 'tabIndex',
              },
              exportAs: ['matButton', 'matAnchor'],
              features: [ye],
              attrs: SL,
              ngContentSelectors: DL,
              decls: 7,
              vars: 4,
              consts: [
                [1, 'mat-mdc-button-persistent-ripple'],
                [1, 'mdc-button__label'],
                [1, 'mat-mdc-focus-indicator'],
                [1, 'mat-mdc-button-touch-target'],
              ],
              template: function (t, i) {
                1 & t &&
                  (Pi(ML),
                  ct(0, 'span', 0),
                  dt(1),
                  z(2, 'span', 1),
                  dt(3, 1),
                  G(),
                  dt(4, 2),
                  ct(5, 'span', 2)(6, 'span', 3)),
                  2 & t &&
                    _t('mdc-button__ripple', !i._isFab)(
                      'mdc-fab__ripple',
                      i._isFab
                    );
              },
              styles: [
                '.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0)}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__progress-indicator{font-size:0;position:absolute;transform:translate(-50%, -50%);top:50%;left:50%;line-height:initial}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    );display:none}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring{border-color:CanvasText}}.mdc-button .mdc-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring::after{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{display:block}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button{height:var(--mdc-text-button-container-height, 36px);border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, inherit)}.mat-mdc-button:disabled{color:var(--mdc-text-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button{height:var(--mdc-filled-button-container-height, 36px);border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button:not(:disabled){background-color:var(--mdc-filled-button-container-color, transparent)}.mat-mdc-unelevated-button:disabled{background-color:var(--mdc-filled-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, inherit)}.mat-mdc-unelevated-button:disabled{color:var(--mdc-filled-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button{height:var(--mdc-protected-button-container-height, 36px);border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px));box-shadow:var(--mdc-protected-button-container-elevation, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){background-color:var(--mdc-protected-button-container-color, transparent)}.mat-mdc-raised-button:disabled{background-color:var(--mdc-protected-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, inherit)}.mat-mdc-raised-button:disabled{color:var(--mdc-protected-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button.mdc-ripple-upgraded--background-focused,.mat-mdc-raised-button:not(.mdc-ripple-upgraded):focus{box-shadow:var(--mdc-protected-button-focus-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled):active{box-shadow:var(--mdc-protected-button-pressed-container-elevation, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button{height:var(--mdc-outlined-button-container-height, 36px);border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px));padding:0 15px 0 15px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, inherit)}.mat-mdc-outlined-button:disabled{color:var(--mdc-outlined-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-outlined-button .mdc-button__ripple{border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-outlined-button:not(:disabled){border-color:var(--mdc-outlined-button-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button:disabled{border-color:var(--mdc-outlined-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button.mdc-button--icon-trailing{padding:0 11px 0 15px}.mat-mdc-outlined-button.mdc-button--icon-leading{padding:0 15px 0 11px}.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button .mdc-button__touch{left:calc(-1 * var(--mdc-outlined-button-outline-width, 1px));width:calc(100% + 2 * var(--mdc-outlined-button-outline-width, 1px))}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-button .mat-ripple-element,.mat-mdc-unelevated-button .mat-ripple-element,.mat-mdc-raised-button .mat-ripple-element,.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-button .mdc-button__label,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-outlined-button .mdc-button__label{z-index:1}.mat-mdc-button .mat-mdc-focus-indicator,.mat-mdc-unelevated-button .mat-mdc-focus-indicator,.mat-mdc-raised-button .mat-mdc-focus-indicator,.mat-mdc-outlined-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-unelevated-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-raised-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-outlined-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-button[disabled],.mat-mdc-unelevated-button[disabled],.mat-mdc-raised-button[disabled],.mat-mdc-outlined-button[disabled]{cursor:default;pointer-events:none}.mat-mdc-button .mat-mdc-button-touch-target,.mat-mdc-unelevated-button .mat-mdc-button-touch-target,.mat-mdc-raised-button .mat-mdc-button-touch-target,.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .mat-mdc-button>.mat-icon,.mat-mdc-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}.mat-mdc-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon,.mat-mdc-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem;margin-left:-4px;margin-right:8px}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon,.mat-mdc-raised-button .mdc-button__label+.mat-icon,.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon,.mat-mdc-unelevated-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-raised-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-outlined-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:-1px}.mat-mdc-unelevated-button .mat-mdc-focus-indicator::before,.mat-mdc-raised-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-outlined-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 3px) * -1)}',
                '.cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        PL = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [Vt, fE, Vt] })),
            n
          );
        })();
      const jQ = ['matFormFieldNotchedOutline', ''],
        zQ = ['*'],
        UQ = ['textField'],
        $Q = ['iconPrefixContainer'],
        GQ = ['textPrefixContainer'];
      function qQ(n, e) {
        1 & n && ct(0, 'span', 19);
      }
      function XQ(n, e) {
        if (1 & n) {
          const t = Ui();
          z(0, 'label', 17),
            pe('cdkObserveContent', function () {
              return Hn(t), Wn(Be(2)._refreshOutlineNotchWidth());
            }),
            dt(1, 1),
            Ie(2, qQ, 1, 0, 'span', 18),
            G();
        }
        if (2 & n) {
          const t = Be(2);
          X('floating', t._shouldLabelFloat())(
            'cdkObserveContentDisabled',
            !t._hasOutline()
          )('id', t._labelId),
            Dt('for', t._control.id)('aria-owns', t._control.id),
            Y(2),
            X('ngIf', !t.hideRequiredMarker && t._control.required);
        }
      }
      function YQ(n, e) {
        1 & n && Ie(0, XQ, 3, 6, 'label', 16),
          2 & n && X('ngIf', Be()._hasFloatingLabel());
      }
      function KQ(n, e) {
        1 & n && ct(0, 'div', 20);
      }
      function ZQ(n, e) {}
      function QQ(n, e) {
        1 & n && Ie(0, ZQ, 0, 0, 'ng-template', 22),
          2 & n && (Be(2), X('ngTemplateOutlet', Go(1)));
      }
      function JQ(n, e) {
        if (
          (1 & n && (z(0, 'div', 21), Ie(1, QQ, 1, 1, 'ng-template', 9), G()),
          2 & n)
        ) {
          const t = Be();
          X('matFormFieldNotchedOutlineOpen', t._shouldLabelFloat())(
            'matFormFieldNotchedOutlineLabelWidth',
            t._labelWidth
          ),
            Y(1),
            X('ngIf', !t._forceDisplayInfixLabel());
        }
      }
      function eJ(n, e) {
        1 & n && (z(0, 'div', 23, 24), dt(2, 2), G());
      }
      function tJ(n, e) {
        1 & n && (z(0, 'div', 25, 26), dt(2, 3), G());
      }
      function nJ(n, e) {}
      function iJ(n, e) {
        1 & n && Ie(0, nJ, 0, 0, 'ng-template', 22),
          2 & n && (Be(), X('ngTemplateOutlet', Go(1)));
      }
      function rJ(n, e) {
        1 & n && (z(0, 'div', 27), dt(1, 4), G());
      }
      function sJ(n, e) {
        1 & n && (z(0, 'div', 28), dt(1, 5), G());
      }
      function oJ(n, e) {
        1 & n && ct(0, 'div', 29);
      }
      function aJ(n, e) {
        1 & n && (z(0, 'div', 30), dt(1, 6), G()),
          2 & n && X('@transitionMessages', Be()._subscriptAnimationState);
      }
      function lJ(n, e) {
        if ((1 & n && (z(0, 'mat-hint', 34), Ue(1), G()), 2 & n)) {
          const t = Be(2);
          X('id', t._hintLabelId), Y(1), Fl(t.hintLabel);
        }
      }
      function cJ(n, e) {
        if (
          (1 & n &&
            (z(0, 'div', 31),
            Ie(1, lJ, 2, 2, 'mat-hint', 32),
            dt(2, 7),
            ct(3, 'div', 33),
            dt(4, 8),
            G()),
          2 & n)
        ) {
          const t = Be();
          X('@transitionMessages', t._subscriptAnimationState),
            Y(1),
            X('ngIf', t.hintLabel);
        }
      }
      const dJ = [
          '*',
          [['mat-label']],
          [
            ['', 'matPrefix', ''],
            ['', 'matIconPrefix', ''],
          ],
          [['', 'matTextPrefix', '']],
          [['', 'matTextSuffix', '']],
          [
            ['', 'matSuffix', ''],
            ['', 'matIconSuffix', ''],
          ],
          [['mat-error'], ['', 'matError', '']],
          [['mat-hint', 3, 'align', 'end']],
          [['mat-hint', 'align', 'end']],
        ],
        uJ = [
          '*',
          'mat-label',
          '[matPrefix], [matIconPrefix]',
          '[matTextPrefix]',
          '[matTextSuffix]',
          '[matSuffix], [matIconSuffix]',
          'mat-error, [matError]',
          "mat-hint:not([align='end'])",
          "mat-hint[align='end']",
        ];
      let pE = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵdir = J({ type: n, selectors: [['mat-label']] })),
            n
          );
        })(),
        hJ = 0;
      const RL = new j('MatError');
      let fJ = (() => {
          class n {
            constructor(t, i) {
              (this.id = 'mat-mdc-error-' + hJ++),
                t || i.nativeElement.setAttribute('aria-live', 'polite');
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Bo('aria-live'), D(Ne));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['mat-error'], ['', 'matError', '']],
              hostAttrs: [
                'aria-atomic',
                'true',
                1,
                'mat-mdc-form-field-error',
                'mat-mdc-form-field-bottom-align',
              ],
              hostVars: 1,
              hostBindings: function (t, i) {
                2 & t && Xo('id', i.id);
              },
              inputs: { id: 'id' },
              features: [tt([{ provide: RL, useExisting: n }])],
            })),
            n
          );
        })(),
        pJ = 0,
        mE = (() => {
          class n {
            constructor() {
              (this.align = 'start'), (this.id = 'mat-mdc-hint-' + pJ++);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['mat-hint']],
              hostAttrs: [
                1,
                'mat-mdc-form-field-hint',
                'mat-mdc-form-field-bottom-align',
              ],
              hostVars: 4,
              hostBindings: function (t, i) {
                2 & t &&
                  (Xo('id', i.id),
                  Dt('align', null),
                  _t('mat-mdc-form-field-hint-end', 'end' === i.align));
              },
              inputs: { align: 'align', id: 'id' },
            })),
            n
          );
        })();
      const mJ = new j('MatPrefix'),
        gJ = new j('MatSuffix');
      let FL = (() => {
        class n {
          constructor(t) {
            (this._elementRef = t), (this.floating = !1);
          }
          getWidth() {
            return (function _J(n) {
              if (null !== n.offsetParent) return n.scrollWidth;
              const t = n.cloneNode(!0);
              t.style.setProperty('position', 'absolute'),
                t.style.setProperty('transform', 'translate(-9999px, -9999px)'),
                document.documentElement.appendChild(t);
              const i = t.scrollWidth;
              return t.remove(), i;
            })(this._elementRef.nativeElement);
          }
          get element() {
            return this._elementRef.nativeElement;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(D(Ne));
          }),
          (n.ɵdir = J({
            type: n,
            selectors: [['label', 'matFormFieldFloatingLabel', '']],
            hostAttrs: [1, 'mdc-floating-label', 'mat-mdc-floating-label'],
            hostVars: 2,
            hostBindings: function (t, i) {
              2 & t && _t('mdc-floating-label--float-above', i.floating);
            },
            inputs: { floating: 'floating' },
          })),
          n
        );
      })();
      const OL = 'mdc-line-ripple--active',
        jm = 'mdc-line-ripple--deactivating';
      let LL = (() => {
          class n {
            constructor(t, i) {
              (this._elementRef = t),
                (this._handleTransitionEnd = (r) => {
                  const s = this._elementRef.nativeElement.classList,
                    o = s.contains(jm);
                  'opacity' === r.propertyName && o && s.remove(OL, jm);
                }),
                i.runOutsideAngular(() => {
                  t.nativeElement.addEventListener(
                    'transitionend',
                    this._handleTransitionEnd
                  );
                });
            }
            activate() {
              const t = this._elementRef.nativeElement.classList;
              t.remove(jm), t.add(OL);
            }
            deactivate() {
              this._elementRef.nativeElement.classList.add(jm);
            }
            ngOnDestroy() {
              this._elementRef.nativeElement.removeEventListener(
                'transitionend',
                this._handleTransitionEnd
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ne), D(ue));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['div', 'matFormFieldLineRipple', '']],
              hostAttrs: [1, 'mdc-line-ripple'],
            })),
            n
          );
        })(),
        NL = (() => {
          class n {
            constructor(t, i) {
              (this._elementRef = t),
                (this._ngZone = i),
                (this.labelWidth = 0),
                (this.open = !1);
            }
            ngAfterViewInit() {
              const t = this._elementRef.nativeElement.querySelector(
                '.mdc-floating-label'
              );
              t
                ? (this._elementRef.nativeElement.classList.add(
                    'mdc-notched-outline--upgraded'
                  ),
                  'function' == typeof requestAnimationFrame &&
                    ((t.style.transitionDuration = '0s'),
                    this._ngZone.runOutsideAngular(() => {
                      requestAnimationFrame(
                        () => (t.style.transitionDuration = '')
                      );
                    })))
                : this._elementRef.nativeElement.classList.add(
                    'mdc-notched-outline--no-label'
                  );
            }
            _getNotchWidth() {
              return this.open
                ? this.labelWidth > 0
                  ? `calc(${this.labelWidth}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + 9px)`
                  : '0px'
                : null;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ne), D(ue));
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['div', 'matFormFieldNotchedOutline', '']],
              hostAttrs: [1, 'mdc-notched-outline'],
              hostVars: 2,
              hostBindings: function (t, i) {
                2 & t && _t('mdc-notched-outline--notched', i.open);
              },
              inputs: {
                labelWidth: [
                  'matFormFieldNotchedOutlineLabelWidth',
                  'labelWidth',
                ],
                open: ['matFormFieldNotchedOutlineOpen', 'open'],
              },
              attrs: jQ,
              ngContentSelectors: zQ,
              decls: 4,
              vars: 2,
              consts: [
                [1, 'mdc-notched-outline__leading'],
                [1, 'mdc-notched-outline__notch'],
                [1, 'mdc-notched-outline__trailing'],
              ],
              template: function (t, i) {
                1 & t &&
                  (Pi(),
                  ct(0, 'div', 0),
                  z(1, 'div', 1),
                  dt(2),
                  G(),
                  ct(3, 'div', 2)),
                  2 & t && (Y(1), Rl('width', i._getNotchWidth()));
              },
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })();
      const bJ = {
        transitionMessages: au('transitionMessages', [
          zl('enter', cr({ opacity: 1, transform: 'translateY(0%)' })),
          Ks('void => enter', [
            cr({ opacity: 0, transform: 'translateY(-5px)' }),
            na('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'),
          ]),
        ]),
      };
      let gE = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵdir = J({ type: n })),
          n
        );
      })();
      const _E = new j('MatFormField'),
        vJ = new j('MAT_FORM_FIELD_DEFAULT_OPTIONS');
      let VL = 0,
        EJ = (() => {
          class n {
            get hideRequiredMarker() {
              return this._hideRequiredMarker;
            }
            set hideRequiredMarker(t) {
              this._hideRequiredMarker = vt(t);
            }
            get floatLabel() {
              return this._floatLabel || this._defaults?.floatLabel || 'auto';
            }
            set floatLabel(t) {
              t !== this._floatLabel &&
                ((this._floatLabel = t),
                this._changeDetectorRef.markForCheck());
            }
            get appearance() {
              return this._appearance;
            }
            set appearance(t) {
              const i = this._appearance;
              (this._appearance = t || this._defaults?.appearance || 'fill'),
                'outline' === this._appearance &&
                  this._appearance !== i &&
                  (this._refreshOutlineNotchWidth(),
                  (this._needsOutlineLabelOffsetUpdateOnStable = !0));
            }
            get subscriptSizing() {
              return (
                this._subscriptSizing ||
                this._defaults?.subscriptSizing ||
                'fixed'
              );
            }
            set subscriptSizing(t) {
              this._subscriptSizing =
                t || this._defaults?.subscriptSizing || 'fixed';
            }
            get hintLabel() {
              return this._hintLabel;
            }
            set hintLabel(t) {
              (this._hintLabel = t), this._processHints();
            }
            get _control() {
              return this._explicitFormFieldControl || this._formFieldControl;
            }
            set _control(t) {
              this._explicitFormFieldControl = t;
            }
            constructor(t, i, r, s, o, a, l, c) {
              (this._elementRef = t),
                (this._changeDetectorRef = i),
                (this._ngZone = r),
                (this._dir = s),
                (this._platform = o),
                (this._defaults = a),
                (this._animationMode = l),
                (this._document = c),
                (this._hideRequiredMarker = !1),
                (this.color = 'primary'),
                (this._appearance = 'fill'),
                (this._subscriptSizing = null),
                (this._hintLabel = ''),
                (this._hasIconPrefix = !1),
                (this._hasTextPrefix = !1),
                (this._hasIconSuffix = !1),
                (this._hasTextSuffix = !1),
                (this._labelId = 'mat-mdc-form-field-label-' + VL++),
                (this._hintLabelId = 'mat-mdc-hint-' + VL++),
                (this._subscriptAnimationState = ''),
                (this._labelWidth = 0),
                (this._destroyed = new Le()),
                (this._isFocused = null),
                (this._needsOutlineLabelOffsetUpdateOnStable = !1),
                a &&
                  (a.appearance && (this.appearance = a.appearance),
                  (this._hideRequiredMarker = !!a?.hideRequiredMarker),
                  a.color && (this.color = a.color));
            }
            ngAfterViewInit() {
              this._updateFocusState(),
                this._refreshOutlineNotchWidth(),
                this._document?.fonts?.ready
                  ? this._document.fonts.ready.then(() => {
                      this._refreshOutlineNotchWidth(),
                        this._changeDetectorRef.markForCheck();
                    })
                  : setTimeout(() => this._refreshOutlineNotchWidth(), 100),
                (this._subscriptAnimationState = 'enter'),
                this._changeDetectorRef.detectChanges();
            }
            ngAfterContentInit() {
              this._assertFormFieldControl(),
                this._initializeControl(),
                this._initializeSubscript(),
                this._initializePrefixAndSuffix(),
                this._initializeOutlineLabelOffsetSubscriptions();
            }
            ngAfterContentChecked() {
              this._assertFormFieldControl();
            }
            ngOnDestroy() {
              this._destroyed.next(), this._destroyed.complete();
            }
            getLabelId() {
              return this._hasFloatingLabel() ? this._labelId : null;
            }
            getConnectedOverlayOrigin() {
              return this._textField || this._elementRef;
            }
            _animateAndLockLabel() {
              this._hasFloatingLabel() && (this.floatLabel = 'always');
            }
            _initializeControl() {
              const t = this._control;
              t.controlType &&
                this._elementRef.nativeElement.classList.add(
                  `mat-mdc-form-field-type-${t.controlType}`
                ),
                t.stateChanges.subscribe(() => {
                  this._updateFocusState(),
                    this._syncDescribedByIds(),
                    this._changeDetectorRef.markForCheck();
                }),
                t.ngControl &&
                  t.ngControl.valueChanges &&
                  t.ngControl.valueChanges
                    .pipe(se(this._destroyed))
                    .subscribe(() => this._changeDetectorRef.markForCheck());
            }
            _checkPrefixAndSuffixTypes() {
              (this._hasIconPrefix = !!this._prefixChildren.find(
                (t) => !t._isText
              )),
                (this._hasTextPrefix = !!this._prefixChildren.find(
                  (t) => t._isText
                )),
                (this._hasIconSuffix = !!this._suffixChildren.find(
                  (t) => !t._isText
                )),
                (this._hasTextSuffix = !!this._suffixChildren.find(
                  (t) => t._isText
                ));
            }
            _initializePrefixAndSuffix() {
              this._checkPrefixAndSuffixTypes(),
                Ro(
                  this._prefixChildren.changes,
                  this._suffixChildren.changes
                ).subscribe(() => {
                  this._checkPrefixAndSuffixTypes(),
                    this._changeDetectorRef.markForCheck();
                });
            }
            _initializeSubscript() {
              this._hintChildren.changes.subscribe(() => {
                this._processHints(), this._changeDetectorRef.markForCheck();
              }),
                this._errorChildren.changes.subscribe(() => {
                  this._syncDescribedByIds(),
                    this._changeDetectorRef.markForCheck();
                }),
                this._validateHints(),
                this._syncDescribedByIds();
            }
            _assertFormFieldControl() {}
            _updateFocusState() {
              this._control.focused && !this._isFocused
                ? ((this._isFocused = !0), this._lineRipple?.activate())
                : !this._control.focused &&
                  (this._isFocused || null === this._isFocused) &&
                  ((this._isFocused = !1), this._lineRipple?.deactivate()),
                this._textField?.nativeElement.classList.toggle(
                  'mdc-text-field--focused',
                  this._control.focused
                );
            }
            _initializeOutlineLabelOffsetSubscriptions() {
              this._prefixChildren.changes.subscribe(
                () => (this._needsOutlineLabelOffsetUpdateOnStable = !0)
              ),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable
                    .pipe(se(this._destroyed))
                    .subscribe(() => {
                      this._needsOutlineLabelOffsetUpdateOnStable &&
                        ((this._needsOutlineLabelOffsetUpdateOnStable = !1),
                        this._updateOutlineLabelOffset());
                    });
                }),
                this._dir.change
                  .pipe(se(this._destroyed))
                  .subscribe(
                    () => (this._needsOutlineLabelOffsetUpdateOnStable = !0)
                  );
            }
            _shouldAlwaysFloat() {
              return 'always' === this.floatLabel;
            }
            _hasOutline() {
              return 'outline' === this.appearance;
            }
            _forceDisplayInfixLabel() {
              return (
                !this._platform.isBrowser &&
                this._prefixChildren.length &&
                !this._shouldLabelFloat()
              );
            }
            _hasFloatingLabel() {
              return !!this._labelChildNonStatic || !!this._labelChildStatic;
            }
            _shouldLabelFloat() {
              return (
                this._control.shouldLabelFloat || this._shouldAlwaysFloat()
              );
            }
            _shouldForward(t) {
              const i = this._control ? this._control.ngControl : null;
              return i && i[t];
            }
            _getDisplayedMessages() {
              return this._errorChildren &&
                this._errorChildren.length > 0 &&
                this._control.errorState
                ? 'error'
                : 'hint';
            }
            _refreshOutlineNotchWidth() {
              !this._hasOutline() ||
                !this._floatingLabel ||
                (this._labelWidth = this._floatingLabel.getWidth());
            }
            _processHints() {
              this._validateHints(), this._syncDescribedByIds();
            }
            _validateHints() {}
            _syncDescribedByIds() {
              if (this._control) {
                let t = [];
                if (
                  (this._control.userAriaDescribedBy &&
                    'string' == typeof this._control.userAriaDescribedBy &&
                    t.push(...this._control.userAriaDescribedBy.split(' ')),
                  'hint' === this._getDisplayedMessages())
                ) {
                  const i = this._hintChildren
                      ? this._hintChildren.find((s) => 'start' === s.align)
                      : null,
                    r = this._hintChildren
                      ? this._hintChildren.find((s) => 'end' === s.align)
                      : null;
                  i
                    ? t.push(i.id)
                    : this._hintLabel && t.push(this._hintLabelId),
                    r && t.push(r.id);
                } else
                  this._errorChildren &&
                    t.push(...this._errorChildren.map((i) => i.id));
                this._control.setDescribedByIds(t);
              }
            }
            _updateOutlineLabelOffset() {
              if (
                !this._platform.isBrowser ||
                !this._hasOutline() ||
                !this._floatingLabel
              )
                return;
              const t = this._floatingLabel.element;
              if (!this._iconPrefixContainer && !this._textPrefixContainer)
                return void (t.style.transform = '');
              if (!this._isAttachedToDom())
                return void (this._needsOutlineLabelOffsetUpdateOnStable = !0);
              const i = this._iconPrefixContainer?.nativeElement,
                r = this._textPrefixContainer?.nativeElement,
                s = i?.getBoundingClientRect().width ?? 0,
                o = r?.getBoundingClientRect().width ?? 0;
              t.style.transform = `var(\n        --mat-mdc-form-field-label-transform,\n        translateY(-50%) translateX(calc(${
                'rtl' === this._dir.value ? '-1' : '1'
              } * (${
                s + o
              }px + var(--mat-mdc-form-field-label-offset-x, 0px))))\n    )`;
            }
            _isAttachedToDom() {
              const t = this._elementRef.nativeElement;
              if (t.getRootNode) {
                const i = t.getRootNode();
                return i && i !== t;
              }
              return document.documentElement.contains(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                D(Ne),
                D(Br),
                D(ue),
                D(ca),
                D(jt),
                D(vJ, 8),
                D(Ii, 8),
                D(He)
              );
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-form-field']],
              contentQueries: function (t, i, r) {
                if (
                  (1 & t &&
                    (li(r, pE, 5),
                    li(r, pE, 7),
                    li(r, gE, 5),
                    li(r, mJ, 5),
                    li(r, gJ, 5),
                    li(r, RL, 5),
                    li(r, mE, 5)),
                  2 & t)
                ) {
                  let s;
                  ut((s = ht())) && (i._labelChildNonStatic = s.first),
                    ut((s = ht())) && (i._labelChildStatic = s.first),
                    ut((s = ht())) && (i._formFieldControl = s.first),
                    ut((s = ht())) && (i._prefixChildren = s),
                    ut((s = ht())) && (i._suffixChildren = s),
                    ut((s = ht())) && (i._errorChildren = s),
                    ut((s = ht())) && (i._hintChildren = s);
                }
              },
              viewQuery: function (t, i) {
                if (
                  (1 & t &&
                    (vn(UQ, 5),
                    vn($Q, 5),
                    vn(GQ, 5),
                    vn(FL, 5),
                    vn(NL, 5),
                    vn(LL, 5)),
                  2 & t)
                ) {
                  let r;
                  ut((r = ht())) && (i._textField = r.first),
                    ut((r = ht())) && (i._iconPrefixContainer = r.first),
                    ut((r = ht())) && (i._textPrefixContainer = r.first),
                    ut((r = ht())) && (i._floatingLabel = r.first),
                    ut((r = ht())) && (i._notchedOutline = r.first),
                    ut((r = ht())) && (i._lineRipple = r.first);
                }
              },
              hostAttrs: [1, 'mat-mdc-form-field'],
              hostVars: 42,
              hostBindings: function (t, i) {
                2 & t &&
                  _t(
                    'mat-mdc-form-field-label-always-float',
                    i._shouldAlwaysFloat()
                  )('mat-mdc-form-field-has-icon-prefix', i._hasIconPrefix)(
                    'mat-mdc-form-field-has-icon-suffix',
                    i._hasIconSuffix
                  )('mat-form-field-invalid', i._control.errorState)(
                    'mat-form-field-disabled',
                    i._control.disabled
                  )('mat-form-field-autofilled', i._control.autofilled)(
                    'mat-form-field-no-animations',
                    'NoopAnimations' === i._animationMode
                  )('mat-form-field-appearance-fill', 'fill' == i.appearance)(
                    'mat-form-field-appearance-outline',
                    'outline' == i.appearance
                  )(
                    'mat-form-field-hide-placeholder',
                    i._hasFloatingLabel() && !i._shouldLabelFloat()
                  )('mat-focused', i._control.focused)(
                    'mat-primary',
                    'accent' !== i.color && 'warn' !== i.color
                  )('mat-accent', 'accent' === i.color)(
                    'mat-warn',
                    'warn' === i.color
                  )('ng-untouched', i._shouldForward('untouched'))(
                    'ng-touched',
                    i._shouldForward('touched')
                  )('ng-pristine', i._shouldForward('pristine'))(
                    'ng-dirty',
                    i._shouldForward('dirty')
                  )('ng-valid', i._shouldForward('valid'))(
                    'ng-invalid',
                    i._shouldForward('invalid')
                  )('ng-pending', i._shouldForward('pending'));
              },
              inputs: {
                hideRequiredMarker: 'hideRequiredMarker',
                color: 'color',
                floatLabel: 'floatLabel',
                appearance: 'appearance',
                subscriptSizing: 'subscriptSizing',
                hintLabel: 'hintLabel',
              },
              exportAs: ['matFormField'],
              features: [tt([{ provide: _E, useExisting: n }])],
              ngContentSelectors: uJ,
              decls: 18,
              vars: 23,
              consts: [
                ['labelTemplate', ''],
                [1, 'mat-mdc-text-field-wrapper', 'mdc-text-field', 3, 'click'],
                ['textField', ''],
                ['class', 'mat-mdc-form-field-focus-overlay', 4, 'ngIf'],
                [1, 'mat-mdc-form-field-flex'],
                [
                  'matFormFieldNotchedOutline',
                  '',
                  3,
                  'matFormFieldNotchedOutlineOpen',
                  'matFormFieldNotchedOutlineLabelWidth',
                  4,
                  'ngIf',
                ],
                ['class', 'mat-mdc-form-field-icon-prefix', 4, 'ngIf'],
                ['class', 'mat-mdc-form-field-text-prefix', 4, 'ngIf'],
                [1, 'mat-mdc-form-field-infix'],
                [3, 'ngIf'],
                ['class', 'mat-mdc-form-field-text-suffix', 4, 'ngIf'],
                ['class', 'mat-mdc-form-field-icon-suffix', 4, 'ngIf'],
                ['matFormFieldLineRipple', '', 4, 'ngIf'],
                [
                  1,
                  'mat-mdc-form-field-subscript-wrapper',
                  'mat-mdc-form-field-bottom-align',
                  3,
                  'ngSwitch',
                ],
                [
                  'class',
                  'mat-mdc-form-field-error-wrapper',
                  4,
                  'ngSwitchCase',
                ],
                ['class', 'mat-mdc-form-field-hint-wrapper', 4, 'ngSwitchCase'],
                [
                  'matFormFieldFloatingLabel',
                  '',
                  3,
                  'floating',
                  'cdkObserveContentDisabled',
                  'id',
                  'cdkObserveContent',
                  4,
                  'ngIf',
                ],
                [
                  'matFormFieldFloatingLabel',
                  '',
                  3,
                  'floating',
                  'cdkObserveContentDisabled',
                  'id',
                  'cdkObserveContent',
                ],
                [
                  'aria-hidden',
                  'true',
                  'class',
                  'mat-mdc-form-field-required-marker mdc-floating-label--required',
                  4,
                  'ngIf',
                ],
                [
                  'aria-hidden',
                  'true',
                  1,
                  'mat-mdc-form-field-required-marker',
                  'mdc-floating-label--required',
                ],
                [1, 'mat-mdc-form-field-focus-overlay'],
                [
                  'matFormFieldNotchedOutline',
                  '',
                  3,
                  'matFormFieldNotchedOutlineOpen',
                  'matFormFieldNotchedOutlineLabelWidth',
                ],
                [3, 'ngTemplateOutlet'],
                [1, 'mat-mdc-form-field-icon-prefix'],
                ['iconPrefixContainer', ''],
                [1, 'mat-mdc-form-field-text-prefix'],
                ['textPrefixContainer', ''],
                [1, 'mat-mdc-form-field-text-suffix'],
                [1, 'mat-mdc-form-field-icon-suffix'],
                ['matFormFieldLineRipple', ''],
                [1, 'mat-mdc-form-field-error-wrapper'],
                [1, 'mat-mdc-form-field-hint-wrapper'],
                [3, 'id', 4, 'ngIf'],
                [1, 'mat-mdc-form-field-hint-spacer'],
                [3, 'id'],
              ],
              template: function (t, i) {
                1 & t &&
                  (Pi(dJ),
                  Ie(0, YQ, 1, 1, 'ng-template', null, 0, s1),
                  z(2, 'div', 1, 2),
                  pe('click', function (s) {
                    return i._control.onContainerClick(s);
                  }),
                  Ie(4, KQ, 1, 0, 'div', 3),
                  z(5, 'div', 4),
                  Ie(6, JQ, 2, 3, 'div', 5),
                  Ie(7, eJ, 3, 0, 'div', 6),
                  Ie(8, tJ, 3, 0, 'div', 7),
                  z(9, 'div', 8),
                  Ie(10, iJ, 1, 1, 'ng-template', 9),
                  dt(11),
                  G(),
                  Ie(12, rJ, 2, 0, 'div', 10),
                  Ie(13, sJ, 2, 0, 'div', 11),
                  G(),
                  Ie(14, oJ, 1, 0, 'div', 12),
                  G(),
                  z(15, 'div', 13),
                  Ie(16, aJ, 2, 1, 'div', 14),
                  Ie(17, cJ, 5, 2, 'div', 15),
                  G()),
                  2 & t &&
                    (Y(2),
                    _t('mdc-text-field--filled', !i._hasOutline())(
                      'mdc-text-field--outlined',
                      i._hasOutline()
                    )('mdc-text-field--no-label', !i._hasFloatingLabel())(
                      'mdc-text-field--disabled',
                      i._control.disabled
                    )('mdc-text-field--invalid', i._control.errorState),
                    Y(2),
                    X('ngIf', !i._hasOutline() && !i._control.disabled),
                    Y(2),
                    X('ngIf', i._hasOutline()),
                    Y(1),
                    X('ngIf', i._hasIconPrefix),
                    Y(1),
                    X('ngIf', i._hasTextPrefix),
                    Y(2),
                    X('ngIf', !i._hasOutline() || i._forceDisplayInfixLabel()),
                    Y(2),
                    X('ngIf', i._hasTextSuffix),
                    Y(1),
                    X('ngIf', i._hasIconSuffix),
                    Y(1),
                    X('ngIf', !i._hasOutline()),
                    Y(1),
                    _t(
                      'mat-mdc-form-field-subscript-dynamic-size',
                      'dynamic' === i.subscriptSizing
                    ),
                    X('ngSwitch', i._getDisplayedMessages()),
                    Y(1),
                    X('ngSwitchCase', 'error'),
                    Y(1),
                    X('ngSwitchCase', 'hint'));
              },
              dependencies: [Zd, AR, Qd, jw, SZ, mE, FL, NL, LL],
              styles: [
                '.mdc-text-field{border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:0;border-bottom-left-radius:0;display:inline-flex;align-items:baseline;padding:0 16px;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color}.mdc-text-field .mdc-floating-label{top:50%;transform:translateY(-50%);pointer-events:none}.mdc-text-field__input{height:28px;width:100%;min-width:0;border:none;border-radius:0;background:none;appearance:none;padding:0}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}@media all{.mdc-text-field__input::placeholder{opacity:0}}@media all{.mdc-text-field__input:-ms-input-placeholder{opacity:0}}@media all{.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{opacity:1}}@media all{.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{opacity:1}}.mdc-text-field__affix{height:28px;opacity:0;white-space:nowrap}.mdc-text-field--label-floating .mdc-text-field__affix,.mdc-text-field--no-label .mdc-text-field__affix{opacity:1}@supports(-webkit-hyphens: none){.mdc-text-field--outlined .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field__affix--prefix,.mdc-text-field__affix--prefix[dir=rtl]{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:0;padding-right:12px}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--end-aligned .mdc-text-field__affix--prefix[dir=rtl]{padding-left:12px;padding-right:0}.mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field__affix--suffix,.mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px;padding-right:0}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--end-aligned .mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:2px}.mdc-text-field--filled{height:56px}.mdc-text-field--filled::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}.mdc-text-field--filled .mdc-floating-label{left:16px;right:initial}[dir=rtl] .mdc-text-field--filled .mdc-floating-label,.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:16px}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label{display:none}.mdc-text-field--filled.mdc-text-field--no-label::before{display:none}@supports(-webkit-hyphens: none){.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--outlined{height:56px;overflow:visible}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined .mdc-text-field__input{height:100%}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-shape-small, 4px)}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-shape-small, 4px))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-shape-small, 4px)}@supports(top: max(0%)){.mdc-text-field--outlined{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined{padding-right:max(16px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px, var(--mdc-shape-small, 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-right:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-right:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined .mdc-text-field__input{display:flex;border:none !important;background-color:rgba(0,0,0,0)}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mdc-text-field--textarea{flex-direction:column;align-items:center;width:auto;height:auto;padding:0}.mdc-text-field--textarea .mdc-floating-label{top:19px}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea .mdc-text-field__input{flex-grow:1;height:auto;min-height:1.5rem;overflow-x:hidden;overflow-y:auto;box-sizing:border-box;resize:none;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--filled::before{display:none}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-10.25px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--filled .mdc-text-field__input{margin-top:23px;margin-bottom:9px}.mdc-text-field--textarea.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-27.25px) scale(1)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-24.75px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label{top:18px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field__input{margin-bottom:2px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter{align-self:flex-end;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::after{display:inline-block;width:0;height:16px;content:"";vertical-align:-16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::before{display:none}.mdc-text-field__resizer{align-self:stretch;display:inline-flex;flex-direction:column;flex-grow:1;max-height:100%;max-width:100%;min-height:56px;min-width:fit-content;min-width:-moz-available;min-width:-webkit-fill-available;overflow:hidden;resize:both}.mdc-text-field--filled .mdc-text-field__resizer{transform:translateY(-1px)}.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(-1px) translateY(-1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer,.mdc-text-field--outlined .mdc-text-field__resizer[dir=rtl]{transform:translateX(1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateX(1px) translateY(1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input[dir=rtl],.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter[dir=rtl]{transform:translateX(-1px) translateY(1px)}.mdc-text-field--with-leading-icon{padding-left:0;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon,.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:16px;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 48px);left:48px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(0.75)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-34.75px) translateX(32px) scale(0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-trailing-icon{padding-left:16px;padding-right:0}[dir=rtl] .mdc-text-field--with-trailing-icon,.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0;padding-right:16px}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 64px)}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-trailing-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 96px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 96px / 0.75)}.mdc-text-field-helper-line{display:flex;justify-content:space-between;box-sizing:border-box}.mdc-text-field+.mdc-text-field-helper-line{padding-right:16px;padding-left:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--focused.mdc-text-field--outlined.mdc-text-field--textarea .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--disabled{pointer-events:none}@media screen and (forced-colors: active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--disabled.mdc-text-field--filled .mdc-text-field__ripple{display:none}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl]{text-align:left}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix{direction:ltr}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--leading,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--leading{order:1}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{order:2}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input{order:3}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{order:4}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--trailing,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--trailing{order:5}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--prefix{padding-right:12px}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--suffix{padding-left:2px}.mdc-floating-label{position:absolute;left:0;-webkit-transform-origin:left top;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform}[dir=rtl] .mdc-floating-label,.mdc-floating-label[dir=rtl]{right:0;left:auto;-webkit-transform-origin:right top;transform-origin:right top;text-align:right}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after{margin-left:1px;margin-right:0px;content:"*"}[dir=rtl] .mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after,.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)[dir=rtl]::after{margin-left:0;margin-right:1px}.mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-notched-outline{display:flex;position:absolute;top:0;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;pointer-events:none}.mdc-notched-outline__trailing{flex-grow:1}.mdc-notched-outline__notch{flex:0 0 auto;width:auto}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:133.3333333333%}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{border-top:1px solid;border-bottom:1px solid}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{max-width:calc(100% - 12px * 2)}.mdc-line-ripple::before,.mdc-line-ripple::after{position:absolute;bottom:0;left:0;width:100%;border-bottom-style:solid;content:""}.mdc-line-ripple::before{z-index:1}.mdc-line-ripple::after{transform:scaleX(0);opacity:0;z-index:2}.mdc-line-ripple--active::after{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating::after{opacity:0}.mdc-line-ripple::before{border-bottom-width:1px}.mdc-line-ripple::after{border-bottom-width:2px}.mat-mdc-form-field-textarea-control{vertical-align:middle;resize:vertical;box-sizing:border-box;height:auto;margin:0;padding:0;border:none;overflow:auto}.mat-mdc-form-field-input-control.mat-mdc-form-field-input-control{font:inherit;letter-spacing:inherit;text-decoration:inherit;text-transform:inherit;border:none}.mat-mdc-form-field .mat-mdc-floating-label.mdc-floating-label{line-height:normal;pointer-events:all}.mdc-text-field--no-label:not(.mdc-text-field--textarea) .mat-mdc-form-field-input-control.mdc-text-field__input,.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control{height:auto}.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control.mdc-text-field__input[type=color]{height:23px}.mat-mdc-text-field-wrapper{height:auto;flex:auto}.mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-left:0;--mat-mdc-form-field-label-offset-x: -16px}.mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-right:0}[dir=rtl] .mat-mdc-text-field-wrapper{padding-left:16px;padding-right:16px}[dir=rtl] .mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-left:0}[dir=rtl] .mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-right:0}.mat-mdc-form-field-label-always-float .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}.mat-mdc-text-field-wrapper .mat-mdc-form-field-infix .mat-mdc-floating-label{left:auto;right:auto}.mat-mdc-text-field-wrapper.mdc-text-field--outlined .mdc-text-field__input{display:inline-block}.mat-mdc-form-field .mat-mdc-text-field-wrapper.mdc-text-field .mdc-notched-outline__notch{padding-top:0}.mat-mdc-text-field-wrapper::before{content:none}.mat-mdc-form-field-subscript-wrapper{box-sizing:border-box;width:100%;position:relative}.mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-error-wrapper{position:absolute;top:0;left:0;right:0;padding:0 16px}.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-error-wrapper{position:static}.mat-mdc-form-field-bottom-align::before{content:"";display:inline-block;height:16px}.mat-mdc-form-field-bottom-align.mat-mdc-form-field-subscript-dynamic-size::before{content:unset}.mat-mdc-form-field-hint-end{order:1}.mat-mdc-form-field-hint-wrapper{display:flex}.mat-mdc-form-field-hint-spacer{flex:1 0 1em}.mat-mdc-form-field-error{display:block}.mat-mdc-form-field-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;opacity:0;pointer-events:none}select.mat-mdc-form-field-input-control{-moz-appearance:none;-webkit-appearance:none;background-color:rgba(0,0,0,0);display:inline-flex;box-sizing:border-box}select.mat-mdc-form-field-input-control:not(:disabled){cursor:pointer}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid rgba(0,0,0,0);border-right:5px solid rgba(0,0,0,0);border-top:5px solid;position:absolute;right:0;top:50%;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{right:auto;left:0}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:15px}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:0;padding-left:15px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-mdc-text-field-wrapper{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-form-field-disabled .mat-mdc-text-field-wrapper{outline-color:GrayText}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-mdc-text-field-wrapper{outline:dashed 3px}.cdk-high-contrast-active .mat-mdc-form-field.mat-focused .mdc-notched-outline{border:dashed 3px}.mat-mdc-form-field-input-control[type=date],.mat-mdc-form-field-input-control[type=datetime],.mat-mdc-form-field-input-control[type=datetime-local],.mat-mdc-form-field-input-control[type=month],.mat-mdc-form-field-input-control[type=week],.mat-mdc-form-field-input-control[type=time]{line-height:1}.mat-mdc-form-field-input-control::-webkit-datetime-edit{line-height:1;padding:0;margin-bottom:-2px}.mat-mdc-form-field{--mat-mdc-form-field-floating-label-scale: 0.75;display:inline-flex;flex-direction:column;min-width:0;text-align:left}[dir=rtl] .mat-mdc-form-field{text-align:right}.mat-mdc-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-mdc-text-field-wrapper{width:100%}.mat-mdc-form-field-icon-prefix,.mat-mdc-form-field-icon-suffix{align-self:center;line-height:0;pointer-events:auto}.mat-mdc-form-field-icon-prefix,[dir=rtl] .mat-mdc-form-field-icon-suffix{padding:0 4px 0 0}.mat-mdc-form-field-icon-suffix,[dir=rtl] .mat-mdc-form-field-icon-prefix{padding:0 0 0 4px}.mat-mdc-form-field-icon-prefix>.mat-icon,.mat-mdc-form-field-icon-suffix>.mat-icon{padding:12px;box-sizing:content-box}.mat-mdc-form-field-subscript-wrapper .mat-icon,.mat-mdc-form-field label .mat-icon{width:1em;height:1em;font-size:inherit}.mat-mdc-form-field-infix{flex:auto;min-width:0;width:180px;position:relative;box-sizing:border-box}.mat-mdc-form-field .mdc-notched-outline__notch{margin-left:-1px;-webkit-clip-path:inset(-9em -999em -9em 1px);clip-path:inset(-9em -999em -9em 1px)}[dir=rtl] .mat-mdc-form-field .mdc-notched-outline__notch{margin-left:0;margin-right:-1px;-webkit-clip-path:inset(-9em 1px -9em -999em);clip-path:inset(-9em 1px -9em -999em)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition-delay:40ms;transition-duration:110ms}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__affix{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled.mdc-ripple-upgraded--background-focused .mdc-text-field__ripple::before,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple::before{transition-duration:75ms}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea{transition:none}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-filled 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-filled{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}[dir=rtl] .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-floating-label{transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard 250ms 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-line-ripple::after{transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}',
              ],
              encapsulation: 2,
              data: { animation: [bJ.transitionMessages] },
              changeDetection: 0,
            })),
            n
          );
        })(),
        Eu = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [Vt, Jo, YO, Vt] })),
            n
          );
        })();
      const WL = Gl({ passive: !0 });
      let CJ = (() => {
          class n {
            constructor(t, i) {
              (this._platform = t),
                (this._ngZone = i),
                (this._monitoredElements = new Map());
            }
            monitor(t) {
              if (!this._platform.isBrowser) return Af;
              const i = ms(t),
                r = this._monitoredElements.get(i);
              if (r) return r.subject;
              const s = new Le(),
                o = 'cdk-text-field-autofilled',
                a = (l) => {
                  'cdk-text-field-autofill-start' !== l.animationName ||
                  i.classList.contains(o)
                    ? 'cdk-text-field-autofill-end' === l.animationName &&
                      i.classList.contains(o) &&
                      (i.classList.remove(o),
                      this._ngZone.run(() =>
                        s.next({ target: l.target, isAutofilled: !1 })
                      ))
                    : (i.classList.add(o),
                      this._ngZone.run(() =>
                        s.next({ target: l.target, isAutofilled: !0 })
                      ));
                };
              return (
                this._ngZone.runOutsideAngular(() => {
                  i.addEventListener('animationstart', a, WL),
                    i.classList.add('cdk-text-field-autofill-monitored');
                }),
                this._monitoredElements.set(i, {
                  subject: s,
                  unlisten: () => {
                    i.removeEventListener('animationstart', a, WL);
                  },
                }),
                s
              );
            }
            stopMonitoring(t) {
              const i = ms(t),
                r = this._monitoredElements.get(i);
              r &&
                (r.unlisten(),
                r.subject.complete(),
                i.classList.remove('cdk-text-field-autofill-monitored'),
                i.classList.remove('cdk-text-field-autofilled'),
                this._monitoredElements.delete(i));
            }
            ngOnDestroy() {
              this._monitoredElements.forEach((t, i) => this.stopMonitoring(i));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(jt), L(ue));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        xJ = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({})),
            n
          );
        })();
      const AJ = new j('MAT_INPUT_VALUE_ACCESSOR'),
        SJ = [
          'button',
          'checkbox',
          'file',
          'hidden',
          'image',
          'radio',
          'range',
          'reset',
          'submit',
        ];
      let MJ = 0;
      const DJ = pL(
        class {
          constructor(n, e, t, i) {
            (this._defaultErrorStateMatcher = n),
              (this._parentForm = e),
              (this._parentFormGroup = t),
              (this.ngControl = i),
              (this.stateChanges = new Le());
          }
        }
      );
      let TJ = (() => {
          class n extends DJ {
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              (this._disabled = vt(t)),
                this.focused && ((this.focused = !1), this.stateChanges.next());
            }
            get id() {
              return this._id;
            }
            set id(t) {
              this._id = t || this._uid;
            }
            get required() {
              return (
                this._required ??
                this.ngControl?.control?.hasValidator(rF.required) ??
                !1
              );
            }
            set required(t) {
              this._required = vt(t);
            }
            get type() {
              return this._type;
            }
            set type(t) {
              (this._type = t || 'text'),
                this._validateType(),
                !this._isTextarea &&
                  WO().has(this._type) &&
                  (this._elementRef.nativeElement.type = this._type);
            }
            get value() {
              return this._inputValueAccessor.value;
            }
            set value(t) {
              t !== this.value &&
                ((this._inputValueAccessor.value = t),
                this.stateChanges.next());
            }
            get readonly() {
              return this._readonly;
            }
            set readonly(t) {
              this._readonly = vt(t);
            }
            constructor(t, i, r, s, o, a, l, c, u, h) {
              super(a, s, o, r),
                (this._elementRef = t),
                (this._platform = i),
                (this._autofillMonitor = c),
                (this._formField = h),
                (this._uid = 'mat-input-' + MJ++),
                (this.focused = !1),
                (this.stateChanges = new Le()),
                (this.controlType = 'mat-input'),
                (this.autofilled = !1),
                (this._disabled = !1),
                (this._type = 'text'),
                (this._readonly = !1),
                (this._neverEmptyInputTypes = [
                  'date',
                  'datetime',
                  'datetime-local',
                  'month',
                  'time',
                  'week',
                ].filter((m) => WO().has(m))),
                (this._iOSKeyupListener = (m) => {
                  const g = m.target;
                  !g.value &&
                    0 === g.selectionStart &&
                    0 === g.selectionEnd &&
                    (g.setSelectionRange(1, 1), g.setSelectionRange(0, 0));
                });
              const f = this._elementRef.nativeElement,
                p = f.nodeName.toLowerCase();
              (this._inputValueAccessor = l || f),
                (this._previousNativeValue = this.value),
                (this.id = this.id),
                i.IOS &&
                  u.runOutsideAngular(() => {
                    t.nativeElement.addEventListener(
                      'keyup',
                      this._iOSKeyupListener
                    );
                  }),
                (this._isServer = !this._platform.isBrowser),
                (this._isNativeSelect = 'select' === p),
                (this._isTextarea = 'textarea' === p),
                (this._isInFormField = !!h),
                this._isNativeSelect &&
                  (this.controlType = f.multiple
                    ? 'mat-native-select-multiple'
                    : 'mat-native-select');
            }
            ngAfterViewInit() {
              this._platform.isBrowser &&
                this._autofillMonitor
                  .monitor(this._elementRef.nativeElement)
                  .subscribe((t) => {
                    (this.autofilled = t.isAutofilled),
                      this.stateChanges.next();
                  });
            }
            ngOnChanges() {
              this.stateChanges.next();
            }
            ngOnDestroy() {
              this.stateChanges.complete(),
                this._platform.isBrowser &&
                  this._autofillMonitor.stopMonitoring(
                    this._elementRef.nativeElement
                  ),
                this._platform.IOS &&
                  this._elementRef.nativeElement.removeEventListener(
                    'keyup',
                    this._iOSKeyupListener
                  );
            }
            ngDoCheck() {
              this.ngControl &&
                (this.updateErrorState(),
                null !== this.ngControl.disabled &&
                  this.ngControl.disabled !== this.disabled &&
                  ((this.disabled = this.ngControl.disabled),
                  this.stateChanges.next())),
                this._dirtyCheckNativeValue(),
                this._dirtyCheckPlaceholder();
            }
            focus(t) {
              this._elementRef.nativeElement.focus(t);
            }
            _focusChanged(t) {
              t !== this.focused &&
                ((this.focused = t), this.stateChanges.next());
            }
            _onInput() {}
            _dirtyCheckNativeValue() {
              const t = this._elementRef.nativeElement.value;
              this._previousNativeValue !== t &&
                ((this._previousNativeValue = t), this.stateChanges.next());
            }
            _dirtyCheckPlaceholder() {
              const t = this._getPlaceholder();
              if (t !== this._previousPlaceholder) {
                const i = this._elementRef.nativeElement;
                (this._previousPlaceholder = t),
                  t
                    ? i.setAttribute('placeholder', t)
                    : i.removeAttribute('placeholder');
              }
            }
            _getPlaceholder() {
              return this.placeholder || null;
            }
            _validateType() {
              SJ.indexOf(this._type);
            }
            _isNeverEmpty() {
              return this._neverEmptyInputTypes.indexOf(this._type) > -1;
            }
            _isBadInput() {
              let t = this._elementRef.nativeElement.validity;
              return t && t.badInput;
            }
            get empty() {
              return !(
                this._isNeverEmpty() ||
                this._elementRef.nativeElement.value ||
                this._isBadInput() ||
                this.autofilled
              );
            }
            get shouldLabelFloat() {
              if (this._isNativeSelect) {
                const t = this._elementRef.nativeElement,
                  i = t.options[0];
                return (
                  this.focused ||
                  t.multiple ||
                  !this.empty ||
                  !!(t.selectedIndex > -1 && i && i.label)
                );
              }
              return this.focused || !this.empty;
            }
            setDescribedByIds(t) {
              t.length
                ? this._elementRef.nativeElement.setAttribute(
                    'aria-describedby',
                    t.join(' ')
                  )
                : this._elementRef.nativeElement.removeAttribute(
                    'aria-describedby'
                  );
            }
            onContainerClick() {
              this.focused || this.focus();
            }
            _isInlineSelect() {
              const t = this._elementRef.nativeElement;
              return this._isNativeSelect && (t.multiple || t.size > 1);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                D(Ne),
                D(jt),
                D(Hr, 10),
                D(su, 8),
                D(ou, 8),
                D(mL),
                D(AJ, 10),
                D(CJ),
                D(ue),
                D(_E, 8)
              );
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [
                ['input', 'matInput', ''],
                ['textarea', 'matInput', ''],
                ['select', 'matNativeControl', ''],
                ['input', 'matNativeControl', ''],
                ['textarea', 'matNativeControl', ''],
              ],
              hostAttrs: [1, 'mat-mdc-input-element'],
              hostVars: 18,
              hostBindings: function (t, i) {
                1 & t &&
                  pe('focus', function () {
                    return i._focusChanged(!0);
                  })('blur', function () {
                    return i._focusChanged(!1);
                  })('input', function () {
                    return i._onInput();
                  }),
                  2 & t &&
                    (Xo('id', i.id)('disabled', i.disabled)(
                      'required',
                      i.required
                    ),
                    Dt('name', i.name || null)(
                      'readonly',
                      (i.readonly && !i._isNativeSelect) || null
                    )(
                      'aria-invalid',
                      i.empty && i.required ? null : i.errorState
                    )('aria-required', i.required)('id', i.id),
                    _t('mat-input-server', i._isServer)(
                      'mat-mdc-form-field-textarea-control',
                      i._isInFormField && i._isTextarea
                    )('mat-mdc-form-field-input-control', i._isInFormField)(
                      'mdc-text-field__input',
                      i._isInFormField
                    )('mat-mdc-native-select-inline', i._isInlineSelect()));
              },
              inputs: {
                disabled: 'disabled',
                id: 'id',
                placeholder: 'placeholder',
                name: 'name',
                required: 'required',
                type: 'type',
                errorStateMatcher: 'errorStateMatcher',
                userAriaDescribedBy: [
                  'aria-describedby',
                  'userAriaDescribedBy',
                ],
                value: 'value',
                readonly: 'readonly',
              },
              exportAs: ['matInput'],
              features: [tt([{ provide: gE, useExisting: n }]), ye, ri],
            })),
            n
          );
        })(),
        jL = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [Vt, Eu, Eu, xJ, Vt] })),
            n
          );
        })();
      const IJ = ['switch'],
        kJ = ['*'],
        PJ = new j('mat-slide-toggle-default-options', {
          providedIn: 'root',
          factory: () => ({ disableToggleValue: !1 }),
        }),
        RJ = { provide: lr, useExisting: mt(() => UL), multi: !0 };
      class zL {
        constructor(e, t) {
          (this.source = e), (this.checked = t);
        }
      }
      let FJ = 0;
      const OJ = fL(
        Wm(
          uE(
            dE(
              class {
                constructor(n) {
                  this._elementRef = n;
                }
              }
            )
          )
        )
      );
      let LJ = (() => {
          class n extends OJ {
            get required() {
              return this._required;
            }
            set required(t) {
              this._required = vt(t);
            }
            get checked() {
              return this._checked;
            }
            set checked(t) {
              (this._checked = vt(t)), this._changeDetectorRef.markForCheck();
            }
            get inputId() {
              return `${this.id || this._uniqueId}-input`;
            }
            constructor(t, i, r, s, o, a, l) {
              super(t),
                (this._focusMonitor = i),
                (this._changeDetectorRef = r),
                (this.defaults = o),
                (this._onChange = (c) => {}),
                (this._onTouched = () => {}),
                (this._required = !1),
                (this._checked = !1),
                (this.name = null),
                (this.labelPosition = 'after'),
                (this.ariaLabel = null),
                (this.ariaLabelledby = null),
                (this.change = new ke()),
                (this.toggleChange = new ke()),
                (this.tabIndex = parseInt(s) || 0),
                (this.color = this.defaultColor = o.color || 'accent'),
                (this._noopAnimations = 'NoopAnimations' === a),
                (this.id = this._uniqueId = `${l}${++FJ}`);
            }
            ngAfterContentInit() {
              this._focusMonitor
                .monitor(this._elementRef, !0)
                .subscribe((t) => {
                  'keyboard' === t || 'program' === t
                    ? ((this._focused = !0),
                      this._changeDetectorRef.markForCheck())
                    : t ||
                      Promise.resolve().then(() => {
                        (this._focused = !1),
                          this._onTouched(),
                          this._changeDetectorRef.markForCheck();
                      });
                });
            }
            ngOnDestroy() {
              this._focusMonitor.stopMonitoring(this._elementRef);
            }
            writeValue(t) {
              this.checked = !!t;
            }
            registerOnChange(t) {
              this._onChange = t;
            }
            registerOnTouched(t) {
              this._onTouched = t;
            }
            setDisabledState(t) {
              (this.disabled = t), this._changeDetectorRef.markForCheck();
            }
            toggle() {
              (this.checked = !this.checked), this._onChange(this.checked);
            }
            _emitChangeEvent() {
              this._onChange(this.checked),
                this.change.emit(this._createChangeEvent(this.checked));
            }
          }
          return (
            (n.ɵfac = function (t) {
              wl();
            }),
            (n.ɵdir = J({
              type: n,
              inputs: {
                name: 'name',
                id: 'id',
                labelPosition: 'labelPosition',
                ariaLabel: ['aria-label', 'ariaLabel'],
                ariaLabelledby: ['aria-labelledby', 'ariaLabelledby'],
                ariaDescribedby: ['aria-describedby', 'ariaDescribedby'],
                required: 'required',
                checked: 'checked',
              },
              outputs: { change: 'change', toggleChange: 'toggleChange' },
              features: [ye],
            })),
            n
          );
        })(),
        UL = (() => {
          class n extends LJ {
            get buttonId() {
              return `${this.id || this._uniqueId}-button`;
            }
            constructor(t, i, r, s, o, a) {
              super(t, i, r, s, o, a, 'mat-mdc-slide-toggle-'),
                (this._labelId = this._uniqueId + '-label');
            }
            _handleClick() {
              this.toggleChange.emit(),
                this.defaults.disableToggleValue ||
                  ((this.checked = !this.checked),
                  this._onChange(this.checked),
                  this.change.emit(new zL(this, this.checked)));
            }
            focus() {
              this._switchElement.nativeElement.focus();
            }
            _createChangeEvent(t) {
              return new zL(this, t);
            }
            _getAriaLabelledBy() {
              return this.ariaLabelledby
                ? this.ariaLabelledby
                : this.ariaLabel
                ? null
                : this._labelId;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                D(Ne),
                D(Hm),
                D(Br),
                Bo('tabindex'),
                D(PJ),
                D(Ii, 8)
              );
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-slide-toggle']],
              viewQuery: function (t, i) {
                if ((1 & t && vn(IJ, 5), 2 & t)) {
                  let r;
                  ut((r = ht())) && (i._switchElement = r.first);
                }
              },
              hostAttrs: [1, 'mat-mdc-slide-toggle'],
              hostVars: 11,
              hostBindings: function (t, i) {
                2 & t &&
                  (Xo('id', i.id),
                  Dt('tabindex', null)('aria-label', null)('name', null)(
                    'aria-labelledby',
                    null
                  ),
                  _t('mat-mdc-slide-toggle-focused', i._focused)(
                    'mat-mdc-slide-toggle-checked',
                    i.checked
                  )('_mat-animation-noopable', i._noopAnimations));
              },
              inputs: {
                disabled: 'disabled',
                disableRipple: 'disableRipple',
                color: 'color',
                tabIndex: 'tabIndex',
              },
              exportAs: ['matSlideToggle'],
              features: [tt([RJ]), ye],
              ngContentSelectors: kJ,
              decls: 17,
              vars: 24,
              consts: [
                [1, 'mdc-form-field'],
                [
                  'role',
                  'switch',
                  'type',
                  'button',
                  1,
                  'mdc-switch',
                  3,
                  'tabIndex',
                  'disabled',
                  'click',
                ],
                ['switch', ''],
                [1, 'mdc-switch__track'],
                [1, 'mdc-switch__handle-track'],
                [1, 'mdc-switch__handle'],
                [1, 'mdc-switch__shadow'],
                [1, 'mdc-elevation-overlay'],
                [1, 'mdc-switch__ripple'],
                [
                  'mat-ripple',
                  '',
                  1,
                  'mat-mdc-slide-toggle-ripple',
                  'mat-mdc-focus-indicator',
                  3,
                  'matRippleTrigger',
                  'matRippleDisabled',
                  'matRippleCentered',
                ],
                [1, 'mdc-switch__icons'],
                [
                  'viewBox',
                  '0 0 24 24',
                  'aria-hidden',
                  'true',
                  1,
                  'mdc-switch__icon',
                  'mdc-switch__icon--on',
                ],
                [
                  'd',
                  'M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z',
                ],
                [
                  'viewBox',
                  '0 0 24 24',
                  'aria-hidden',
                  'true',
                  1,
                  'mdc-switch__icon',
                  'mdc-switch__icon--off',
                ],
                ['d', 'M20 13H4v-2h16v2z'],
                [1, 'mdc-label', 3, 'for', 'click'],
              ],
              template: function (t, i) {
                if (
                  (1 & t &&
                    (Pi(),
                    z(0, 'div', 0)(1, 'button', 1, 2),
                    pe('click', function () {
                      return i._handleClick();
                    }),
                    ct(3, 'div', 3),
                    z(4, 'div', 4)(5, 'div', 5)(6, 'div', 6),
                    ct(7, 'div', 7),
                    G(),
                    z(8, 'div', 8),
                    ct(9, 'div', 9),
                    G(),
                    z(10, 'div', 10),
                    Wi(),
                    z(11, 'svg', 11),
                    ct(12, 'path', 12),
                    G(),
                    z(13, 'svg', 13),
                    ct(14, 'path', 14),
                    G()()()()(),
                    tr(),
                    z(15, 'label', 15),
                    pe('click', function (s) {
                      return s.stopPropagation();
                    }),
                    dt(16),
                    G()()),
                  2 & t)
                ) {
                  const r = Go(2);
                  _t('mdc-form-field--align-end', 'before' == i.labelPosition),
                    Y(1),
                    _t('mdc-switch--selected', i.checked)(
                      'mdc-switch--unselected',
                      !i.checked
                    )('mdc-switch--checked', i.checked)(
                      'mdc-switch--disabled',
                      i.disabled
                    ),
                    X('tabIndex', i.tabIndex)('disabled', i.disabled),
                    Dt('id', i.buttonId)('name', i.name)(
                      'aria-label',
                      i.ariaLabel
                    )('aria-labelledby', i._getAriaLabelledBy())(
                      'aria-describedby',
                      i.ariaDescribedby
                    )('aria-required', i.required || null)(
                      'aria-checked',
                      i.checked
                    ),
                    Y(8),
                    X('matRippleTrigger', r)(
                      'matRippleDisabled',
                      i.disableRipple || i.disabled
                    )('matRippleCentered', !0),
                    Y(6),
                    X('for', i.buttonId),
                    Dt('id', i._labelId);
                }
              },
              dependencies: [hE],
              styles: [
                '.mdc-form-field{display:inline-flex;align-items:center;vertical-align:middle}.mdc-form-field[hidden]{display:none}.mdc-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{margin-left:auto;margin-right:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{padding-left:0;padding-right:4px}.mdc-form-field--nowrap>label{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{margin-left:0;margin-right:auto}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{padding-left:4px;padding-right:0}.mdc-form-field--space-between{justify-content:space-between}.mdc-form-field--space-between>label{margin:0}[dir=rtl] .mdc-form-field--space-between>label,.mdc-form-field--space-between>label[dir=rtl]{margin:0}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:var(--mdc-elevation-overlay-color, #fff)}.mdc-switch{align-items:center;background:none;border:none;cursor:pointer;display:inline-flex;flex-shrink:0;margin:0;outline:none;overflow:visible;padding:0;position:relative}.mdc-switch[hidden]{display:none}.mdc-switch:disabled{cursor:default;pointer-events:none}.mdc-switch__track{overflow:hidden;position:relative;width:100%}.mdc-switch__track::before,.mdc-switch__track::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;position:absolute;width:100%}@media screen and (forced-colors: active){.mdc-switch__track::before,.mdc-switch__track::after{border-color:currentColor}}.mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:translateX(0)}.mdc-switch__track::after{transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);transform:translateX(-100%)}[dir=rtl] .mdc-switch__track::after,.mdc-switch__track[dir=rtl]::after{transform:translateX(100%)}.mdc-switch--selected .mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch__track::before,.mdc-switch--selected .mdc-switch__track[dir=rtl]::before{transform:translateX(-100%)}.mdc-switch--selected .mdc-switch__track::after{transition:transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:translateX(0)}.mdc-switch__handle-track{height:100%;pointer-events:none;position:absolute;top:0;transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);left:0;right:auto;transform:translateX(0)}[dir=rtl] .mdc-switch__handle-track,.mdc-switch__handle-track[dir=rtl]{left:auto;right:0}.mdc-switch--selected .mdc-switch__handle-track{transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch__handle-track,.mdc-switch--selected .mdc-switch__handle-track[dir=rtl]{transform:translateX(-100%)}.mdc-switch__handle{display:flex;pointer-events:auto;position:absolute;top:50%;transform:translateY(-50%);left:0;right:auto}[dir=rtl] .mdc-switch__handle,.mdc-switch__handle[dir=rtl]{left:auto;right:0}.mdc-switch__handle::before,.mdc-switch__handle::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";width:100%;height:100%;left:0;position:absolute;top:0;transition:background-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1),border-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);z-index:-1}@media screen and (forced-colors: active){.mdc-switch__handle::before,.mdc-switch__handle::after{border-color:currentColor}}.mdc-switch__shadow{border-radius:inherit;bottom:0;left:0;position:absolute;right:0;top:0}.mdc-elevation-overlay{bottom:0;left:0;right:0;top:0}.mdc-switch__ripple{left:50%;position:absolute;top:50%;transform:translate(-50%, -50%);z-index:-1}.mdc-switch:disabled .mdc-switch__ripple{display:none}.mdc-switch__icons{height:100%;position:relative;width:100%;z-index:1}.mdc-switch__icon{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0;opacity:0;transition:opacity 30ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-switch--selected .mdc-switch__icon--on,.mdc-switch--unselected .mdc-switch__icon--off{opacity:1;transition:opacity 45ms 30ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle{display:inline-block;-webkit-tap-highlight-color:rgba(0,0,0,0);outline:0}.mat-mdc-slide-toggle .mdc-switch{width:var(--mdc-switch-track-width, 36px)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-selected-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-hover-handle-color, #310077)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-focus-handle-color, #310077)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-selected-pressed-handle-color, #310077)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-selected-handle-color, #424242)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-unselected-handle-color, #616161)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-hover-handle-color, #212121)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-focus-handle-color, #212121)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-unselected-pressed-handle-color, #212121)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-unselected-handle-color, #424242)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle::before{background:var(--mdc-switch-handle-surface-color, var(--mdc-theme-surface, #fff))}.mat-mdc-slide-toggle .mdc-switch:enabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-handle-elevation, 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-disabled-handle-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__focus-ring-wrapper,.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle{height:var(--mdc-switch-handle-height, 20px)}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__handle::after{opacity:var(--mdc-switch-disabled-handle-opacity, 0.38)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle{border-radius:var(--mdc-switch-handle-shape, 10px)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle{width:var(--mdc-switch-handle-width, 20px)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle-track{width:calc(100% - var(--mdc-switch-handle-width, 20px))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled .mdc-switch__icon{fill:var(--mdc-switch-selected-icon-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-selected-icon-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled .mdc-switch__icon{fill:var(--mdc-switch-unselected-icon-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-unselected-icon-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:disabled .mdc-switch__icons{opacity:var(--mdc-switch-disabled-selected-icon-opacity, 0.38)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icons{opacity:var(--mdc-switch-disabled-unselected-icon-opacity, 0.38)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected .mdc-switch__icon{width:var(--mdc-switch-selected-icon-size, 18px);height:var(--mdc-switch-selected-icon-size, 18px)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected .mdc-switch__icon{width:var(--mdc-switch-unselected-icon-size, 18px);height:var(--mdc-switch-unselected-icon-size, 18px)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus) .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background-color:var(--mdc-switch-selected-hover-state-layer-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus .mdc-switch__ripple::after{background-color:var(--mdc-switch-selected-focus-state-layer-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active .mdc-switch__ripple::after{background-color:var(--mdc-switch-selected-pressed-state-layer-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus) .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background-color:var(--mdc-switch-unselected-hover-state-layer-color, #424242)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus .mdc-switch__ripple::after{background-color:var(--mdc-switch-unselected-focus-state-layer-color, #424242)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active .mdc-switch__ripple::after{background-color:var(--mdc-switch-unselected-pressed-state-layer-color, #424242)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus):hover .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus).mdc-ripple-surface--hover .mdc-switch__ripple::before{opacity:var(--mdc-switch-selected-hover-state-layer-opacity, 0.04)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus.mdc-ripple-upgraded--background-focused .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus:not(.mdc-ripple-upgraded):focus .mdc-switch__ripple::before{transition-duration:75ms;opacity:var(--mdc-switch-selected-focus-state-layer-opacity, 0.12)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active:not(.mdc-ripple-upgraded) .mdc-switch__ripple::after{transition:opacity 150ms linear}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active:not(.mdc-ripple-upgraded):active .mdc-switch__ripple::after{transition-duration:75ms;opacity:var(--mdc-switch-selected-pressed-state-layer-opacity, 0.1)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-switch-selected-pressed-state-layer-opacity, 0.1)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus):hover .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus).mdc-ripple-surface--hover .mdc-switch__ripple::before{opacity:var(--mdc-switch-unselected-hover-state-layer-opacity, 0.04)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus.mdc-ripple-upgraded--background-focused .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus:not(.mdc-ripple-upgraded):focus .mdc-switch__ripple::before{transition-duration:75ms;opacity:var(--mdc-switch-unselected-focus-state-layer-opacity, 0.12)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active:not(.mdc-ripple-upgraded) .mdc-switch__ripple::after{transition:opacity 150ms linear}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active:not(.mdc-ripple-upgraded):active .mdc-switch__ripple::after{transition-duration:75ms;opacity:var(--mdc-switch-unselected-pressed-state-layer-opacity, 0.1)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-switch-unselected-pressed-state-layer-opacity, 0.1)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__ripple{height:var(--mdc-switch-state-layer-size, 48px);width:var(--mdc-switch-state-layer-size, 48px)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__track{height:var(--mdc-switch-track-height, 14px)}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__track{opacity:var(--mdc-switch-disabled-track-opacity, 0.12)}.mat-mdc-slide-toggle .mdc-switch:enabled .mdc-switch__track::after{background:var(--mdc-switch-selected-track-color, #d7bbff)}.mat-mdc-slide-toggle .mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-hover-track-color, #d7bbff)}.mat-mdc-slide-toggle .mdc-switch:enabled:focus:not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-focus-track-color, #d7bbff)}.mat-mdc-slide-toggle .mdc-switch:enabled:active .mdc-switch__track::after{background:var(--mdc-switch-selected-pressed-track-color, #d7bbff)}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__track::after{background:var(--mdc-switch-disabled-selected-track-color, #424242)}.mat-mdc-slide-toggle .mdc-switch:enabled .mdc-switch__track::before{background:var(--mdc-switch-unselected-track-color, #e0e0e0)}.mat-mdc-slide-toggle .mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-hover-track-color, #e0e0e0)}.mat-mdc-slide-toggle .mdc-switch:enabled:focus:not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-focus-track-color, #e0e0e0)}.mat-mdc-slide-toggle .mdc-switch:enabled:active .mdc-switch__track::before{background:var(--mdc-switch-unselected-pressed-track-color, #e0e0e0)}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__track::before{background:var(--mdc-switch-disabled-unselected-track-color, #424242)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__track{border-radius:var(--mdc-switch-track-shape, 7px)}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple,.mat-mdc-slide-toggle .mdc-switch__ripple::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple:not(:empty),.mat-mdc-slide-toggle .mdc-switch__ripple::after:not(:empty){transform:translateZ(0)}.mat-mdc-slide-toggle .mdc-switch__ripple::after{content:"";opacity:0}.mat-mdc-slide-toggle .mdc-switch:hover .mdc-switch__ripple::after{opacity:.04;transition:opacity 75ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mdc-switch .mdc-switch__ripple::after{opacity:.12}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mat-mdc-focus-indicator::before{content:""}.mat-mdc-slide-toggle .mat-ripple-element{opacity:.12}.mat-mdc-slide-toggle .mat-mdc-focus-indicator::before{border-radius:50%}.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle-track,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-elevation-overlay,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__icon,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::after,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::after{transition:none}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        $L = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({})),
            n
          );
        })(),
        GL = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [$L, Vt, fE, Jo, $L, Vt] })),
            n
          );
        })();
      const BJ = ['*', [['mat-toolbar-row']]],
        HJ = ['*', 'mat-toolbar-row'],
        WJ = Wm(
          class {
            constructor(n) {
              this._elementRef = n;
            }
          }
        );
      let qL = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['mat-toolbar-row']],
              hostAttrs: [1, 'mat-toolbar-row'],
              exportAs: ['matToolbarRow'],
            })),
            n
          );
        })(),
        jJ = (() => {
          class n extends WJ {
            constructor(t, i, r) {
              super(t), (this._platform = i), (this._document = r);
            }
            ngAfterViewInit() {
              this._platform.isBrowser &&
                (this._checkToolbarMixedModes(),
                this._toolbarRows.changes.subscribe(() =>
                  this._checkToolbarMixedModes()
                ));
            }
            _checkToolbarMixedModes() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ne), D(jt), D(He));
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-toolbar']],
              contentQueries: function (t, i, r) {
                if ((1 & t && li(r, qL, 5), 2 & t)) {
                  let s;
                  ut((s = ht())) && (i._toolbarRows = s);
                }
              },
              hostAttrs: [1, 'mat-toolbar'],
              hostVars: 4,
              hostBindings: function (t, i) {
                2 & t &&
                  _t('mat-toolbar-multiple-rows', i._toolbarRows.length > 0)(
                    'mat-toolbar-single-row',
                    0 === i._toolbarRows.length
                  );
              },
              inputs: { color: 'color' },
              exportAs: ['matToolbar'],
              features: [ye],
              ngContentSelectors: HJ,
              decls: 2,
              vars: 0,
              template: function (t, i) {
                1 & t && (Pi(BJ), dt(0), dt(1, 1));
              },
              styles: [
                '.cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar .mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color: inherit;--mdc-outlined-button-label-text-color: inherit}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        XL = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [Vt, Vt] })),
            n
          );
        })();
      const zJ = ['addListener', 'removeListener'],
        UJ = ['addEventListener', 'removeEventListener'],
        $J = ['on', 'off'];
      function St(n, e, t, i) {
        if ((ot(t) && ((i = t), (t = void 0)), i))
          return St(n, e, t).pipe(r0(i));
        const [r, s] = (function XJ(n) {
          return ot(n.addEventListener) && ot(n.removeEventListener);
        })(n)
          ? UJ.map((o) => (a) => n[o](e, a, t))
          : (function GJ(n) {
              return ot(n.addListener) && ot(n.removeListener);
            })(n)
          ? zJ.map(YL(n, e))
          : (function qJ(n) {
              return ot(n.on) && ot(n.off);
            })(n)
          ? $J.map(YL(n, e))
          : [];
        if (!r && jb(n)) return Qc((o) => St(o, e, t))(Bn(n));
        if (!r) throw new TypeError('Invalid event target');
        return new Mt((o) => {
          const a = (...l) => o.next(1 < l.length ? l : l[0]);
          return r(a), () => s(a);
        });
      }
      function YL(n, e) {
        return (t) => (i) => n[t](e, i);
      }
      const Cu = {
        schedule(n) {
          let e = requestAnimationFrame,
            t = cancelAnimationFrame;
          const { delegate: i } = Cu;
          i && ((e = i.requestAnimationFrame), (t = i.cancelAnimationFrame));
          const r = e((s) => {
            (t = void 0), n(s);
          });
          return new $t(() => t?.(r));
        },
        requestAnimationFrame(...n) {
          const { delegate: e } = Cu;
          return (e?.requestAnimationFrame || requestAnimationFrame)(...n);
        },
        cancelAnimationFrame(...n) {
          const { delegate: e } = Cu;
          return (e?.cancelAnimationFrame || cancelAnimationFrame)(...n);
        },
        delegate: void 0,
      };
      new (class KJ extends rE {
        flush(e) {
          this._active = !0;
          const t = this._scheduled;
          this._scheduled = void 0;
          const { actions: i } = this;
          let r;
          e = e || i.shift();
          do {
            if ((r = e.execute(e.state, e.delay))) break;
          } while ((e = i[0]) && e.id === t && i.shift());
          if (((this._active = !1), r)) {
            for (; (e = i[0]) && e.id === t && i.shift(); ) e.unsubscribe();
            throw r;
          }
        }
      })(
        class YJ extends iE {
          constructor(e, t) {
            super(e, t), (this.scheduler = e), (this.work = t);
          }
          requestAsyncId(e, t, i = 0) {
            return null !== i && i > 0
              ? super.requestAsyncId(e, t, i)
              : (e.actions.push(this),
                e._scheduled ||
                  (e._scheduled = Cu.requestAnimationFrame(() =>
                    e.flush(void 0)
                  )));
          }
          recycleAsyncId(e, t, i = 0) {
            var r;
            if (null != i ? i > 0 : this.delay > 0)
              return super.recycleAsyncId(e, t, i);
            const { actions: s } = e;
            null != t &&
              (null === (r = s[s.length - 1]) || void 0 === r
                ? void 0
                : r.id) !== t &&
              (Cu.cancelAnimationFrame(t), (e._scheduled = void 0));
          }
        }
      );
      let bE,
        QJ = 1;
      const zm = {};
      function KL(n) {
        return n in zm && (delete zm[n], !0);
      }
      const JJ = {
          setImmediate(n) {
            const e = QJ++;
            return (
              (zm[e] = !0),
              bE || (bE = Promise.resolve()),
              bE.then(() => KL(e) && n()),
              e
            );
          },
          clearImmediate(n) {
            KL(n);
          },
        },
        { setImmediate: eee, clearImmediate: tee } = JJ,
        Um = {
          setImmediate(...n) {
            const { delegate: e } = Um;
            return (e?.setImmediate || eee)(...n);
          },
          clearImmediate(n) {
            const { delegate: e } = Um;
            return (e?.clearImmediate || tee)(n);
          },
          delegate: void 0,
        };
      new (class iee extends rE {
        flush(e) {
          this._active = !0;
          const t = this._scheduled;
          this._scheduled = void 0;
          const { actions: i } = this;
          let r;
          e = e || i.shift();
          do {
            if ((r = e.execute(e.state, e.delay))) break;
          } while ((e = i[0]) && e.id === t && i.shift());
          if (((this._active = !1), r)) {
            for (; (e = i[0]) && e.id === t && i.shift(); ) e.unsubscribe();
            throw r;
          }
        }
      })(
        class nee extends iE {
          constructor(e, t) {
            super(e, t), (this.scheduler = e), (this.work = t);
          }
          requestAsyncId(e, t, i = 0) {
            return null !== i && i > 0
              ? super.requestAsyncId(e, t, i)
              : (e.actions.push(this),
                e._scheduled ||
                  (e._scheduled = Um.setImmediate(e.flush.bind(e, void 0))));
          }
          recycleAsyncId(e, t, i = 0) {
            var r;
            if (null != i ? i > 0 : this.delay > 0)
              return super.recycleAsyncId(e, t, i);
            const { actions: s } = e;
            null != t &&
              (null === (r = s[s.length - 1]) || void 0 === r
                ? void 0
                : r.id) !== t &&
              (Um.clearImmediate(t),
              e._scheduled === t && (e._scheduled = void 0));
          }
        }
      );
      function ZL(n, e = sE) {
        return (function see(n) {
          return gn((e, t) => {
            let i = !1,
              r = null,
              s = null,
              o = !1;
            const a = () => {
                if ((s?.unsubscribe(), (s = null), i)) {
                  i = !1;
                  const c = r;
                  (r = null), t.next(c);
                }
                o && t.complete();
              },
              l = () => {
                (s = null), o && t.complete();
              };
            e.subscribe(
              hn(
                t,
                (c) => {
                  (i = !0), (r = c), s || Bn(n(c)).subscribe((s = hn(t, a, l)));
                },
                () => {
                  (o = !0), (!i || !s || s.closed) && t.complete();
                }
              )
            );
          });
        })(() =>
          (function aee(n = 0, e, t = CZ) {
            let i = -1;
            return (
              null != e && (SM(e) ? (t = e) : (i = e)),
              new Mt((r) => {
                let s = (function oee(n) {
                  return n instanceof Date && !isNaN(n);
                })(n)
                  ? +n - t.now()
                  : n;
                s < 0 && (s = 0);
                let o = 0;
                return t.schedule(function () {
                  r.closed ||
                    (r.next(o++),
                    0 <= i ? this.schedule(void 0, i) : r.complete());
                }, s);
              })
            );
          })(n, e)
        );
      }
      let $m = (() => {
          class n {
            constructor(t, i, r) {
              (this._ngZone = t),
                (this._platform = i),
                (this._scrolled = new Le()),
                (this._globalSubscription = null),
                (this._scrolledCount = 0),
                (this.scrollContainers = new Map()),
                (this._document = r);
            }
            register(t) {
              this.scrollContainers.has(t) ||
                this.scrollContainers.set(
                  t,
                  t.elementScrolled().subscribe(() => this._scrolled.next(t))
                );
            }
            deregister(t) {
              const i = this.scrollContainers.get(t);
              i && (i.unsubscribe(), this.scrollContainers.delete(t));
            }
            scrolled(t = 20) {
              return this._platform.isBrowser
                ? new Mt((i) => {
                    this._globalSubscription || this._addGlobalListener();
                    const r =
                      t > 0
                        ? this._scrolled.pipe(ZL(t)).subscribe(i)
                        : this._scrolled.subscribe(i);
                    return (
                      this._scrolledCount++,
                      () => {
                        r.unsubscribe(),
                          this._scrolledCount--,
                          this._scrolledCount || this._removeGlobalListener();
                      }
                    );
                  })
                : ts();
            }
            ngOnDestroy() {
              this._removeGlobalListener(),
                this.scrollContainers.forEach((t, i) => this.deregister(i)),
                this._scrolled.complete();
            }
            ancestorScrolled(t, i) {
              const r = this.getAncestorScrollContainers(t);
              return this.scrolled(i).pipe(di((s) => !s || r.indexOf(s) > -1));
            }
            getAncestorScrollContainers(t) {
              const i = [];
              return (
                this.scrollContainers.forEach((r, s) => {
                  this._scrollableContainsElement(s, t) && i.push(s);
                }),
                i
              );
            }
            _getWindow() {
              return this._document.defaultView || window;
            }
            _scrollableContainsElement(t, i) {
              let r = ms(i),
                s = t.getElementRef().nativeElement;
              do {
                if (r == s) return !0;
              } while ((r = r.parentElement));
              return !1;
            }
            _addGlobalListener() {
              this._globalSubscription = this._ngZone.runOutsideAngular(() =>
                St(this._getWindow().document, 'scroll').subscribe(() =>
                  this._scrolled.next()
                )
              );
            }
            _removeGlobalListener() {
              this._globalSubscription &&
                (this._globalSubscription.unsubscribe(),
                (this._globalSubscription = null));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(ue), L(jt), L(He, 8));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        vE = (() => {
          class n {
            constructor(t, i, r, s) {
              (this.elementRef = t),
                (this.scrollDispatcher = i),
                (this.ngZone = r),
                (this.dir = s),
                (this._destroyed = new Le()),
                (this._elementScrolled = new Mt((o) =>
                  this.ngZone.runOutsideAngular(() =>
                    St(this.elementRef.nativeElement, 'scroll')
                      .pipe(se(this._destroyed))
                      .subscribe(o)
                  )
                ));
            }
            ngOnInit() {
              this.scrollDispatcher.register(this);
            }
            ngOnDestroy() {
              this.scrollDispatcher.deregister(this),
                this._destroyed.next(),
                this._destroyed.complete();
            }
            elementScrolled() {
              return this._elementScrolled;
            }
            getElementRef() {
              return this.elementRef;
            }
            scrollTo(t) {
              const i = this.elementRef.nativeElement,
                r = this.dir && 'rtl' == this.dir.value;
              null == t.left && (t.left = r ? t.end : t.start),
                null == t.right && (t.right = r ? t.start : t.end),
                null != t.bottom &&
                  (t.top = i.scrollHeight - i.clientHeight - t.bottom),
                r && 0 != pu()
                  ? (null != t.left &&
                      (t.right = i.scrollWidth - i.clientWidth - t.left),
                    2 == pu()
                      ? (t.left = t.right)
                      : 1 == pu() && (t.left = t.right ? -t.right : t.right))
                  : null != t.right &&
                    (t.left = i.scrollWidth - i.clientWidth - t.right),
                this._applyScrollToOptions(t);
            }
            _applyScrollToOptions(t) {
              const i = this.elementRef.nativeElement;
              jO()
                ? i.scrollTo(t)
                : (null != t.top && (i.scrollTop = t.top),
                  null != t.left && (i.scrollLeft = t.left));
            }
            measureScrollOffset(t) {
              const i = 'left',
                r = 'right',
                s = this.elementRef.nativeElement;
              if ('top' == t) return s.scrollTop;
              if ('bottom' == t)
                return s.scrollHeight - s.clientHeight - s.scrollTop;
              const o = this.dir && 'rtl' == this.dir.value;
              return (
                'start' == t ? (t = o ? r : i) : 'end' == t && (t = o ? i : r),
                o && 2 == pu()
                  ? t == i
                    ? s.scrollWidth - s.clientWidth - s.scrollLeft
                    : s.scrollLeft
                  : o && 1 == pu()
                  ? t == i
                    ? s.scrollLeft + s.scrollWidth - s.clientWidth
                    : -s.scrollLeft
                  : t == i
                  ? s.scrollLeft
                  : s.scrollWidth - s.clientWidth - s.scrollLeft
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ne), D($m), D(ue), D(ca, 8));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [
                ['', 'cdk-scrollable', ''],
                ['', 'cdkScrollable', ''],
              ],
              standalone: !0,
            })),
            n
          );
        })(),
        Gm = (() => {
          class n {
            constructor(t, i, r) {
              (this._platform = t),
                (this._change = new Le()),
                (this._changeListener = (s) => {
                  this._change.next(s);
                }),
                (this._document = r),
                i.runOutsideAngular(() => {
                  if (t.isBrowser) {
                    const s = this._getWindow();
                    s.addEventListener('resize', this._changeListener),
                      s.addEventListener(
                        'orientationchange',
                        this._changeListener
                      );
                  }
                  this.change().subscribe(() => (this._viewportSize = null));
                });
            }
            ngOnDestroy() {
              if (this._platform.isBrowser) {
                const t = this._getWindow();
                t.removeEventListener('resize', this._changeListener),
                  t.removeEventListener(
                    'orientationchange',
                    this._changeListener
                  );
              }
              this._change.complete();
            }
            getViewportSize() {
              this._viewportSize || this._updateViewportSize();
              const t = {
                width: this._viewportSize.width,
                height: this._viewportSize.height,
              };
              return this._platform.isBrowser || (this._viewportSize = null), t;
            }
            getViewportRect() {
              const t = this.getViewportScrollPosition(),
                { width: i, height: r } = this.getViewportSize();
              return {
                top: t.top,
                left: t.left,
                bottom: t.top + r,
                right: t.left + i,
                height: r,
                width: i,
              };
            }
            getViewportScrollPosition() {
              if (!this._platform.isBrowser) return { top: 0, left: 0 };
              const t = this._document,
                i = this._getWindow(),
                r = t.documentElement,
                s = r.getBoundingClientRect();
              return {
                top:
                  -s.top || t.body.scrollTop || i.scrollY || r.scrollTop || 0,
                left:
                  -s.left ||
                  t.body.scrollLeft ||
                  i.scrollX ||
                  r.scrollLeft ||
                  0,
              };
            }
            change(t = 20) {
              return t > 0 ? this._change.pipe(ZL(t)) : this._change;
            }
            _getWindow() {
              return this._document.defaultView || window;
            }
            _updateViewportSize() {
              const t = this._getWindow();
              this._viewportSize = this._platform.isBrowser
                ? { width: t.innerWidth, height: t.innerHeight }
                : { width: 0, height: 0 };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(jt), L(ue), L(He, 8));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        Yl = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({})),
            n
          );
        })(),
        QL = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [vu, Yl, vu, Yl] })),
            n
          );
        })();
      function JL(n) {
        return Gt(() => n);
      }
      const eN = ['*'],
        dee = ['content'];
      function uee(n, e) {
        if (1 & n) {
          const t = Ui();
          z(0, 'div', 2),
            pe('click', function () {
              return Hn(t), Wn(Be()._onBackdropClicked());
            }),
            G();
        }
        2 & n && _t('mat-drawer-shown', Be()._isShowingBackdrop());
      }
      function hee(n, e) {
        1 & n && (z(0, 'mat-drawer-content'), dt(1, 2), G());
      }
      const fee = [[['mat-drawer']], [['mat-drawer-content']], '*'],
        pee = ['mat-drawer', 'mat-drawer-content', '*'],
        mee = {
          transformDrawer: au('transform', [
            zl(
              'open, open-instant',
              cr({ transform: 'none', visibility: 'visible' })
            ),
            zl('void', cr({ 'box-shadow': 'none', visibility: 'hidden' })),
            Ks('void => open-instant', na('0ms')),
            Ks(
              'void <=> open, open-instant => void',
              na('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')
            ),
          ]),
        },
        gee = new j('MAT_DRAWER_DEFAULT_AUTOSIZE', {
          providedIn: 'root',
          factory: function _ee() {
            return !1;
          },
        }),
        tN = new j('MAT_DRAWER_CONTAINER');
      let qm = (() => {
          class n extends vE {
            constructor(t, i, r, s, o) {
              super(r, s, o),
                (this._changeDetectorRef = t),
                (this._container = i);
            }
            ngAfterContentInit() {
              this._container._contentMarginChanges.subscribe(() => {
                this._changeDetectorRef.markForCheck();
              });
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Br), D(mt(() => iN)), D(Ne), D($m), D(ue));
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-drawer-content']],
              hostAttrs: ['ngSkipHydration', '', 1, 'mat-drawer-content'],
              hostVars: 4,
              hostBindings: function (t, i) {
                2 & t &&
                  Rl('margin-left', i._container._contentMargins.left, 'px')(
                    'margin-right',
                    i._container._contentMargins.right,
                    'px'
                  );
              },
              features: [tt([{ provide: vE, useExisting: n }]), ye],
              ngContentSelectors: eN,
              decls: 1,
              vars: 0,
              template: function (t, i) {
                1 & t && (Pi(), dt(0));
              },
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        nN = (() => {
          class n {
            get position() {
              return this._position;
            }
            set position(t) {
              (t = 'end' === t ? 'end' : 'start') !== this._position &&
                (this._isAttached && this._updatePositionInParent(t),
                (this._position = t),
                this.onPositionChanged.emit());
            }
            get mode() {
              return this._mode;
            }
            set mode(t) {
              (this._mode = t),
                this._updateFocusTrapState(),
                this._modeChanged.next();
            }
            get disableClose() {
              return this._disableClose;
            }
            set disableClose(t) {
              this._disableClose = vt(t);
            }
            get autoFocus() {
              return (
                this._autoFocus ??
                ('side' === this.mode ? 'dialog' : 'first-tabbable')
              );
            }
            set autoFocus(t) {
              ('true' === t || 'false' === t || null == t) && (t = vt(t)),
                (this._autoFocus = t);
            }
            get opened() {
              return this._opened;
            }
            set opened(t) {
              this.toggle(vt(t));
            }
            constructor(t, i, r, s, o, a, l, c) {
              (this._elementRef = t),
                (this._focusTrapFactory = i),
                (this._focusMonitor = r),
                (this._platform = s),
                (this._ngZone = o),
                (this._interactivityChecker = a),
                (this._doc = l),
                (this._container = c),
                (this._elementFocusedBeforeDrawerWasOpened = null),
                (this._enableAnimations = !1),
                (this._position = 'start'),
                (this._mode = 'over'),
                (this._disableClose = !1),
                (this._opened = !1),
                (this._animationStarted = new Le()),
                (this._animationEnd = new Le()),
                (this._animationState = 'void'),
                (this.openedChange = new ke(!0)),
                (this._openedStream = this.openedChange.pipe(
                  di((u) => u),
                  Gt(() => {})
                )),
                (this.openedStart = this._animationStarted.pipe(
                  di(
                    (u) =>
                      u.fromState !== u.toState &&
                      0 === u.toState.indexOf('open')
                  ),
                  JL(void 0)
                )),
                (this._closedStream = this.openedChange.pipe(
                  di((u) => !u),
                  Gt(() => {})
                )),
                (this.closedStart = this._animationStarted.pipe(
                  di((u) => u.fromState !== u.toState && 'void' === u.toState),
                  JL(void 0)
                )),
                (this._destroyed = new Le()),
                (this.onPositionChanged = new ke()),
                (this._modeChanged = new Le()),
                this.openedChange.subscribe((u) => {
                  u
                    ? (this._doc &&
                        (this._elementFocusedBeforeDrawerWasOpened =
                          this._doc.activeElement),
                      this._takeFocus())
                    : this._isFocusWithinDrawer() &&
                      this._restoreFocus(this._openedVia || 'program');
                }),
                this._ngZone.runOutsideAngular(() => {
                  St(this._elementRef.nativeElement, 'keydown')
                    .pipe(
                      di(
                        (u) => 27 === u.keyCode && !this.disableClose && !aa(u)
                      ),
                      se(this._destroyed)
                    )
                    .subscribe((u) =>
                      this._ngZone.run(() => {
                        this.close(), u.stopPropagation(), u.preventDefault();
                      })
                    );
                }),
                this._animationEnd
                  .pipe(
                    Sf(
                      (u, h) =>
                        u.fromState === h.fromState && u.toState === h.toState
                    )
                  )
                  .subscribe((u) => {
                    const { fromState: h, toState: f } = u;
                    ((0 === f.indexOf('open') && 'void' === h) ||
                      ('void' === f && 0 === h.indexOf('open'))) &&
                      this.openedChange.emit(this._opened);
                  });
            }
            _forceFocus(t, i) {
              this._interactivityChecker.isFocusable(t) ||
                ((t.tabIndex = -1),
                this._ngZone.runOutsideAngular(() => {
                  const r = () => {
                    t.removeEventListener('blur', r),
                      t.removeEventListener('mousedown', r),
                      t.removeAttribute('tabindex');
                  };
                  t.addEventListener('blur', r),
                    t.addEventListener('mousedown', r);
                })),
                t.focus(i);
            }
            _focusByCssSelector(t, i) {
              let r = this._elementRef.nativeElement.querySelector(t);
              r && this._forceFocus(r, i);
            }
            _takeFocus() {
              if (!this._focusTrap) return;
              const t = this._elementRef.nativeElement;
              switch (this.autoFocus) {
                case !1:
                case 'dialog':
                  return;
                case !0:
                case 'first-tabbable':
                  this._focusTrap.focusInitialElementWhenReady().then((i) => {
                    !i &&
                      'function' ==
                        typeof this._elementRef.nativeElement.focus &&
                      t.focus();
                  });
                  break;
                case 'first-heading':
                  this._focusByCssSelector(
                    'h1, h2, h3, h4, h5, h6, [role="heading"]'
                  );
                  break;
                default:
                  this._focusByCssSelector(this.autoFocus);
              }
            }
            _restoreFocus(t) {
              'dialog' !== this.autoFocus &&
                (this._elementFocusedBeforeDrawerWasOpened
                  ? this._focusMonitor.focusVia(
                      this._elementFocusedBeforeDrawerWasOpened,
                      t
                    )
                  : this._elementRef.nativeElement.blur(),
                (this._elementFocusedBeforeDrawerWasOpened = null));
            }
            _isFocusWithinDrawer() {
              const t = this._doc.activeElement;
              return !!t && this._elementRef.nativeElement.contains(t);
            }
            ngAfterViewInit() {
              (this._isAttached = !0),
                (this._focusTrap = this._focusTrapFactory.create(
                  this._elementRef.nativeElement
                )),
                this._updateFocusTrapState(),
                'end' === this._position && this._updatePositionInParent('end');
            }
            ngAfterContentChecked() {
              this._platform.isBrowser && (this._enableAnimations = !0);
            }
            ngOnDestroy() {
              this._focusTrap && this._focusTrap.destroy(),
                this._anchor?.remove(),
                (this._anchor = null),
                this._animationStarted.complete(),
                this._animationEnd.complete(),
                this._modeChanged.complete(),
                this._destroyed.next(),
                this._destroyed.complete();
            }
            open(t) {
              return this.toggle(!0, t);
            }
            close() {
              return this.toggle(!1);
            }
            _closeViaBackdropClick() {
              return this._setOpen(!1, !0, 'mouse');
            }
            toggle(t = !this.opened, i) {
              t && i && (this._openedVia = i);
              const r = this._setOpen(
                t,
                !t && this._isFocusWithinDrawer(),
                this._openedVia || 'program'
              );
              return t || (this._openedVia = null), r;
            }
            _setOpen(t, i, r) {
              return (
                (this._opened = t),
                t
                  ? (this._animationState = this._enableAnimations
                      ? 'open'
                      : 'open-instant')
                  : ((this._animationState = 'void'),
                    i && this._restoreFocus(r)),
                this._updateFocusTrapState(),
                new Promise((s) => {
                  this.openedChange
                    .pipe(ps(1))
                    .subscribe((o) => s(o ? 'open' : 'close'));
                })
              );
            }
            _getWidth() {
              return (
                (this._elementRef.nativeElement &&
                  this._elementRef.nativeElement.offsetWidth) ||
                0
              );
            }
            _updateFocusTrapState() {
              this._focusTrap &&
                (this._focusTrap.enabled = this.opened && 'side' !== this.mode);
            }
            _updatePositionInParent(t) {
              const i = this._elementRef.nativeElement,
                r = i.parentNode;
              'end' === t
                ? (this._anchor ||
                    ((this._anchor =
                      this._doc.createComment('mat-drawer-anchor')),
                    r.insertBefore(this._anchor, i)),
                  r.appendChild(i))
                : this._anchor &&
                  this._anchor.parentNode.insertBefore(i, this._anchor);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                D(Ne),
                D(KZ),
                D(Hm),
                D(jt),
                D(ue),
                D(nL),
                D(He, 8),
                D(tN, 8)
              );
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-drawer']],
              viewQuery: function (t, i) {
                if ((1 & t && vn(dee, 5), 2 & t)) {
                  let r;
                  ut((r = ht())) && (i._content = r.first);
                }
              },
              hostAttrs: [
                'tabIndex',
                '-1',
                'ngSkipHydration',
                '',
                1,
                'mat-drawer',
              ],
              hostVars: 12,
              hostBindings: function (t, i) {
                1 & t &&
                  Ny('@transform.start', function (s) {
                    return i._animationStarted.next(s);
                  })('@transform.done', function (s) {
                    return i._animationEnd.next(s);
                  }),
                  2 & t &&
                    (Dt('align', null),
                    Uy('@transform', i._animationState),
                    _t('mat-drawer-end', 'end' === i.position)(
                      'mat-drawer-over',
                      'over' === i.mode
                    )('mat-drawer-push', 'push' === i.mode)(
                      'mat-drawer-side',
                      'side' === i.mode
                    )('mat-drawer-opened', i.opened));
              },
              inputs: {
                position: 'position',
                mode: 'mode',
                disableClose: 'disableClose',
                autoFocus: 'autoFocus',
                opened: 'opened',
              },
              outputs: {
                openedChange: 'openedChange',
                _openedStream: 'opened',
                openedStart: 'openedStart',
                _closedStream: 'closed',
                closedStart: 'closedStart',
                onPositionChanged: 'positionChanged',
              },
              exportAs: ['matDrawer'],
              ngContentSelectors: eN,
              decls: 3,
              vars: 0,
              consts: [
                ['cdkScrollable', '', 1, 'mat-drawer-inner-container'],
                ['content', ''],
              ],
              template: function (t, i) {
                1 & t && (Pi(), z(0, 'div', 0, 1), dt(2), G());
              },
              dependencies: [vE],
              encapsulation: 2,
              data: { animation: [mee.transformDrawer] },
              changeDetection: 0,
            })),
            n
          );
        })(),
        iN = (() => {
          class n {
            get start() {
              return this._start;
            }
            get end() {
              return this._end;
            }
            get autosize() {
              return this._autosize;
            }
            set autosize(t) {
              this._autosize = vt(t);
            }
            get hasBackdrop() {
              return null == this._backdropOverride
                ? !this._start ||
                    'side' !== this._start.mode ||
                    !this._end ||
                    'side' !== this._end.mode
                : this._backdropOverride;
            }
            set hasBackdrop(t) {
              this._backdropOverride = null == t ? null : vt(t);
            }
            get scrollable() {
              return this._userContent || this._content;
            }
            constructor(t, i, r, s, o, a = !1, l) {
              (this._dir = t),
                (this._element = i),
                (this._ngZone = r),
                (this._changeDetectorRef = s),
                (this._animationMode = l),
                (this._drawers = new Vl()),
                (this.backdropClick = new ke()),
                (this._destroyed = new Le()),
                (this._doCheckSubject = new Le()),
                (this._contentMargins = { left: null, right: null }),
                (this._contentMarginChanges = new Le()),
                t &&
                  t.change.pipe(se(this._destroyed)).subscribe(() => {
                    this._validateDrawers(), this.updateContentMargins();
                  }),
                o
                  .change()
                  .pipe(se(this._destroyed))
                  .subscribe(() => this.updateContentMargins()),
                (this._autosize = a);
            }
            ngAfterContentInit() {
              this._allDrawers.changes
                .pipe(bu(this._allDrawers), se(this._destroyed))
                .subscribe((t) => {
                  this._drawers.reset(
                    t.filter((i) => !i._container || i._container === this)
                  ),
                    this._drawers.notifyOnChanges();
                }),
                this._drawers.changes.pipe(bu(null)).subscribe(() => {
                  this._validateDrawers(),
                    this._drawers.forEach((t) => {
                      this._watchDrawerToggle(t),
                        this._watchDrawerPosition(t),
                        this._watchDrawerMode(t);
                    }),
                    (!this._drawers.length ||
                      this._isDrawerOpen(this._start) ||
                      this._isDrawerOpen(this._end)) &&
                      this.updateContentMargins(),
                    this._changeDetectorRef.markForCheck();
                }),
                this._ngZone.runOutsideAngular(() => {
                  this._doCheckSubject
                    .pipe(gu(10), se(this._destroyed))
                    .subscribe(() => this.updateContentMargins());
                });
            }
            ngOnDestroy() {
              this._contentMarginChanges.complete(),
                this._doCheckSubject.complete(),
                this._drawers.destroy(),
                this._destroyed.next(),
                this._destroyed.complete();
            }
            open() {
              this._drawers.forEach((t) => t.open());
            }
            close() {
              this._drawers.forEach((t) => t.close());
            }
            updateContentMargins() {
              let t = 0,
                i = 0;
              if (this._left && this._left.opened)
                if ('side' == this._left.mode) t += this._left._getWidth();
                else if ('push' == this._left.mode) {
                  const r = this._left._getWidth();
                  (t += r), (i -= r);
                }
              if (this._right && this._right.opened)
                if ('side' == this._right.mode) i += this._right._getWidth();
                else if ('push' == this._right.mode) {
                  const r = this._right._getWidth();
                  (i += r), (t -= r);
                }
              (t = t || null),
                (i = i || null),
                (t !== this._contentMargins.left ||
                  i !== this._contentMargins.right) &&
                  ((this._contentMargins = { left: t, right: i }),
                  this._ngZone.run(() =>
                    this._contentMarginChanges.next(this._contentMargins)
                  ));
            }
            ngDoCheck() {
              this._autosize &&
                this._isPushed() &&
                this._ngZone.runOutsideAngular(() =>
                  this._doCheckSubject.next()
                );
            }
            _watchDrawerToggle(t) {
              t._animationStarted
                .pipe(
                  di((i) => i.fromState !== i.toState),
                  se(this._drawers.changes)
                )
                .subscribe((i) => {
                  'open-instant' !== i.toState &&
                    'NoopAnimations' !== this._animationMode &&
                    this._element.nativeElement.classList.add(
                      'mat-drawer-transition'
                    ),
                    this.updateContentMargins(),
                    this._changeDetectorRef.markForCheck();
                }),
                'side' !== t.mode &&
                  t.openedChange
                    .pipe(se(this._drawers.changes))
                    .subscribe(() => this._setContainerClass(t.opened));
            }
            _watchDrawerPosition(t) {
              t &&
                t.onPositionChanged
                  .pipe(se(this._drawers.changes))
                  .subscribe(() => {
                    this._ngZone.onMicrotaskEmpty.pipe(ps(1)).subscribe(() => {
                      this._validateDrawers();
                    });
                  });
            }
            _watchDrawerMode(t) {
              t &&
                t._modeChanged
                  .pipe(se(Ro(this._drawers.changes, this._destroyed)))
                  .subscribe(() => {
                    this.updateContentMargins(),
                      this._changeDetectorRef.markForCheck();
                  });
            }
            _setContainerClass(t) {
              const i = this._element.nativeElement.classList,
                r = 'mat-drawer-container-has-open';
              t ? i.add(r) : i.remove(r);
            }
            _validateDrawers() {
              (this._start = this._end = null),
                this._drawers.forEach((t) => {
                  'end' == t.position ? (this._end = t) : (this._start = t);
                }),
                (this._right = this._left = null),
                this._dir && 'rtl' === this._dir.value
                  ? ((this._left = this._end), (this._right = this._start))
                  : ((this._left = this._start), (this._right = this._end));
            }
            _isPushed() {
              return (
                (this._isDrawerOpen(this._start) &&
                  'over' != this._start.mode) ||
                (this._isDrawerOpen(this._end) && 'over' != this._end.mode)
              );
            }
            _onBackdropClicked() {
              this.backdropClick.emit(), this._closeModalDrawersViaBackdrop();
            }
            _closeModalDrawersViaBackdrop() {
              [this._start, this._end]
                .filter((t) => t && !t.disableClose && this._canHaveBackdrop(t))
                .forEach((t) => t._closeViaBackdropClick());
            }
            _isShowingBackdrop() {
              return (
                (this._isDrawerOpen(this._start) &&
                  this._canHaveBackdrop(this._start)) ||
                (this._isDrawerOpen(this._end) &&
                  this._canHaveBackdrop(this._end))
              );
            }
            _canHaveBackdrop(t) {
              return 'side' !== t.mode || !!this._backdropOverride;
            }
            _isDrawerOpen(t) {
              return null != t && t.opened;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                D(ca, 8),
                D(Ne),
                D(ue),
                D(Br),
                D(Gm),
                D(gee),
                D(Ii, 8)
              );
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-drawer-container']],
              contentQueries: function (t, i, r) {
                if ((1 & t && (li(r, qm, 5), li(r, nN, 5)), 2 & t)) {
                  let s;
                  ut((s = ht())) && (i._content = s.first),
                    ut((s = ht())) && (i._allDrawers = s);
                }
              },
              viewQuery: function (t, i) {
                if ((1 & t && vn(qm, 5), 2 & t)) {
                  let r;
                  ut((r = ht())) && (i._userContent = r.first);
                }
              },
              hostAttrs: ['ngSkipHydration', '', 1, 'mat-drawer-container'],
              hostVars: 2,
              hostBindings: function (t, i) {
                2 & t &&
                  _t(
                    'mat-drawer-container-explicit-backdrop',
                    i._backdropOverride
                  );
              },
              inputs: { autosize: 'autosize', hasBackdrop: 'hasBackdrop' },
              outputs: { backdropClick: 'backdropClick' },
              exportAs: ['matDrawerContainer'],
              features: [tt([{ provide: tN, useExisting: n }])],
              ngContentSelectors: pee,
              decls: 4,
              vars: 2,
              consts: [
                [
                  'class',
                  'mat-drawer-backdrop',
                  3,
                  'mat-drawer-shown',
                  'click',
                  4,
                  'ngIf',
                ],
                [4, 'ngIf'],
                [1, 'mat-drawer-backdrop', 3, 'click'],
              ],
              template: function (t, i) {
                1 & t &&
                  (Pi(fee),
                  Ie(0, uee, 1, 2, 'div', 0),
                  dt(1),
                  dt(2, 1),
                  Ie(3, hee, 2, 0, 'mat-drawer-content', 1)),
                  2 & t &&
                    (X('ngIf', i.hasBackdrop), Y(3), X('ngIf', !i._content));
              },
              dependencies: [Zd, qm],
              styles: [
                '.mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer[style*="visibility: hidden"]{display:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        rN = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [Jo, Vt, Yl, Yl, Vt] })),
            n
          );
        })();
      class yE {
        attach(e) {
          return (this._attachedHost = e), e.attach(this);
        }
        detach() {
          let e = this._attachedHost;
          null != e && ((this._attachedHost = null), e.detach());
        }
        get isAttached() {
          return null != this._attachedHost;
        }
        setAttachedHost(e) {
          this._attachedHost = e;
        }
      }
      class sN extends yE {
        constructor(e, t, i, r, s) {
          super(),
            (this.component = e),
            (this.viewContainerRef = t),
            (this.injector = i),
            (this.componentFactoryResolver = r),
            (this.projectableNodes = s);
        }
      }
      class oN extends yE {
        constructor(e, t, i, r) {
          super(),
            (this.templateRef = e),
            (this.viewContainerRef = t),
            (this.context = i),
            (this.injector = r);
        }
        get origin() {
          return this.templateRef.elementRef;
        }
        attach(e, t = this.context) {
          return (this.context = t), super.attach(e);
        }
        detach() {
          return (this.context = void 0), super.detach();
        }
      }
      class vee extends yE {
        constructor(e) {
          super(), (this.element = e instanceof Ne ? e.nativeElement : e);
        }
      }
      class yee {
        constructor() {
          (this._isDisposed = !1), (this.attachDomPortal = null);
        }
        hasAttached() {
          return !!this._attachedPortal;
        }
        attach(e) {
          return e instanceof sN
            ? ((this._attachedPortal = e), this.attachComponentPortal(e))
            : e instanceof oN
            ? ((this._attachedPortal = e), this.attachTemplatePortal(e))
            : this.attachDomPortal && e instanceof vee
            ? ((this._attachedPortal = e), this.attachDomPortal(e))
            : void 0;
        }
        detach() {
          this._attachedPortal &&
            (this._attachedPortal.setAttachedHost(null),
            (this._attachedPortal = null)),
            this._invokeDisposeFn();
        }
        dispose() {
          this.hasAttached() && this.detach(),
            this._invokeDisposeFn(),
            (this._isDisposed = !0);
        }
        setDisposeFn(e) {
          this._disposeFn = e;
        }
        _invokeDisposeFn() {
          this._disposeFn && (this._disposeFn(), (this._disposeFn = null));
        }
      }
      class wee extends yee {
        constructor(e, t, i, r, s) {
          super(),
            (this.outletElement = e),
            (this._componentFactoryResolver = t),
            (this._appRef = i),
            (this._defaultInjector = r),
            (this.attachDomPortal = (o) => {
              const a = o.element,
                l = this._document.createComment('dom-portal');
              a.parentNode.insertBefore(l, a),
                this.outletElement.appendChild(a),
                (this._attachedPortal = o),
                super.setDisposeFn(() => {
                  l.parentNode && l.parentNode.replaceChild(a, l);
                });
            }),
            (this._document = s);
        }
        attachComponentPortal(e) {
          const i = (
            e.componentFactoryResolver || this._componentFactoryResolver
          ).resolveComponentFactory(e.component);
          let r;
          return (
            e.viewContainerRef
              ? ((r = e.viewContainerRef.createComponent(
                  i,
                  e.viewContainerRef.length,
                  e.injector || e.viewContainerRef.injector,
                  e.projectableNodes || void 0
                )),
                this.setDisposeFn(() => r.destroy()))
              : ((r = i.create(e.injector || this._defaultInjector || nr.NULL)),
                this._appRef.attachView(r.hostView),
                this.setDisposeFn(() => {
                  this._appRef.viewCount > 0 &&
                    this._appRef.detachView(r.hostView),
                    r.destroy();
                })),
            this.outletElement.appendChild(this._getComponentRootNode(r)),
            (this._attachedPortal = e),
            r
          );
        }
        attachTemplatePortal(e) {
          let t = e.viewContainerRef,
            i = t.createEmbeddedView(e.templateRef, e.context, {
              injector: e.injector,
            });
          return (
            i.rootNodes.forEach((r) => this.outletElement.appendChild(r)),
            i.detectChanges(),
            this.setDisposeFn(() => {
              let r = t.indexOf(i);
              -1 !== r && t.remove(r);
            }),
            (this._attachedPortal = e),
            i
          );
        }
        dispose() {
          super.dispose(), this.outletElement.remove();
        }
        _getComponentRootNode(e) {
          return e.hostView.rootNodes[0];
        }
      }
      let Eee = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = Ze({ type: n })),
          (n.ɵinj = qe({})),
          n
        );
      })();
      const aN = jO();
      class Cee {
        constructor(e, t) {
          (this._viewportRuler = e),
            (this._previousHTMLStyles = { top: '', left: '' }),
            (this._isEnabled = !1),
            (this._document = t);
        }
        attach() {}
        enable() {
          if (this._canBeEnabled()) {
            const e = this._document.documentElement;
            (this._previousScrollPosition =
              this._viewportRuler.getViewportScrollPosition()),
              (this._previousHTMLStyles.left = e.style.left || ''),
              (this._previousHTMLStyles.top = e.style.top || ''),
              (e.style.left = Zt(-this._previousScrollPosition.left)),
              (e.style.top = Zt(-this._previousScrollPosition.top)),
              e.classList.add('cdk-global-scrollblock'),
              (this._isEnabled = !0);
          }
        }
        disable() {
          if (this._isEnabled) {
            const e = this._document.documentElement,
              i = e.style,
              r = this._document.body.style,
              s = i.scrollBehavior || '',
              o = r.scrollBehavior || '';
            (this._isEnabled = !1),
              (i.left = this._previousHTMLStyles.left),
              (i.top = this._previousHTMLStyles.top),
              e.classList.remove('cdk-global-scrollblock'),
              aN && (i.scrollBehavior = r.scrollBehavior = 'auto'),
              window.scroll(
                this._previousScrollPosition.left,
                this._previousScrollPosition.top
              ),
              aN && ((i.scrollBehavior = s), (r.scrollBehavior = o));
          }
        }
        _canBeEnabled() {
          if (
            this._document.documentElement.classList.contains(
              'cdk-global-scrollblock'
            ) ||
            this._isEnabled
          )
            return !1;
          const t = this._document.body,
            i = this._viewportRuler.getViewportSize();
          return t.scrollHeight > i.height || t.scrollWidth > i.width;
        }
      }
      class xee {
        constructor(e, t, i, r) {
          (this._scrollDispatcher = e),
            (this._ngZone = t),
            (this._viewportRuler = i),
            (this._config = r),
            (this._scrollSubscription = null),
            (this._detach = () => {
              this.disable(),
                this._overlayRef.hasAttached() &&
                  this._ngZone.run(() => this._overlayRef.detach());
            });
        }
        attach(e) {
          this._overlayRef = e;
        }
        enable() {
          if (this._scrollSubscription) return;
          const e = this._scrollDispatcher
            .scrolled(0)
            .pipe(
              di(
                (t) =>
                  !t ||
                  !this._overlayRef.overlayElement.contains(
                    t.getElementRef().nativeElement
                  )
              )
            );
          this._config && this._config.threshold && this._config.threshold > 1
            ? ((this._initialScrollPosition =
                this._viewportRuler.getViewportScrollPosition().top),
              (this._scrollSubscription = e.subscribe(() => {
                const t = this._viewportRuler.getViewportScrollPosition().top;
                Math.abs(t - this._initialScrollPosition) >
                this._config.threshold
                  ? this._detach()
                  : this._overlayRef.updatePosition();
              })))
            : (this._scrollSubscription = e.subscribe(this._detach));
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null));
        }
        detach() {
          this.disable(), (this._overlayRef = null);
        }
      }
      class lN {
        enable() {}
        disable() {}
        attach() {}
      }
      function wE(n, e) {
        return e.some(
          (t) =>
            n.bottom < t.top ||
            n.top > t.bottom ||
            n.right < t.left ||
            n.left > t.right
        );
      }
      function cN(n, e) {
        return e.some(
          (t) =>
            n.top < t.top ||
            n.bottom > t.bottom ||
            n.left < t.left ||
            n.right > t.right
        );
      }
      class Aee {
        constructor(e, t, i, r) {
          (this._scrollDispatcher = e),
            (this._viewportRuler = t),
            (this._ngZone = i),
            (this._config = r),
            (this._scrollSubscription = null);
        }
        attach(e) {
          this._overlayRef = e;
        }
        enable() {
          this._scrollSubscription ||
            (this._scrollSubscription = this._scrollDispatcher
              .scrolled(this._config ? this._config.scrollThrottle : 0)
              .subscribe(() => {
                if (
                  (this._overlayRef.updatePosition(),
                  this._config && this._config.autoClose)
                ) {
                  const t =
                      this._overlayRef.overlayElement.getBoundingClientRect(),
                    { width: i, height: r } =
                      this._viewportRuler.getViewportSize();
                  wE(t, [
                    {
                      width: i,
                      height: r,
                      bottom: r,
                      right: i,
                      top: 0,
                      left: 0,
                    },
                  ]) &&
                    (this.disable(),
                    this._ngZone.run(() => this._overlayRef.detach()));
                }
              }));
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null));
        }
        detach() {
          this.disable(), (this._overlayRef = null);
        }
      }
      let See = (() => {
        class n {
          constructor(t, i, r, s) {
            (this._scrollDispatcher = t),
              (this._viewportRuler = i),
              (this._ngZone = r),
              (this.noop = () => new lN()),
              (this.close = (o) =>
                new xee(
                  this._scrollDispatcher,
                  this._ngZone,
                  this._viewportRuler,
                  o
                )),
              (this.block = () => new Cee(this._viewportRuler, this._document)),
              (this.reposition = (o) =>
                new Aee(
                  this._scrollDispatcher,
                  this._viewportRuler,
                  this._ngZone,
                  o
                )),
              (this._document = s);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L($m), L(Gm), L(ue), L(He));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      class dN {
        constructor(e) {
          if (
            ((this.scrollStrategy = new lN()),
            (this.panelClass = ''),
            (this.hasBackdrop = !1),
            (this.backdropClass = 'cdk-overlay-dark-backdrop'),
            (this.disposeOnNavigation = !1),
            e)
          ) {
            const t = Object.keys(e);
            for (const i of t) void 0 !== e[i] && (this[i] = e[i]);
          }
        }
      }
      class Mee {
        constructor(e, t) {
          (this.connectionPair = e), (this.scrollableViewProperties = t);
        }
      }
      let uN = (() => {
          class n {
            constructor(t) {
              (this._attachedOverlays = []), (this._document = t);
            }
            ngOnDestroy() {
              this.detach();
            }
            add(t) {
              this.remove(t), this._attachedOverlays.push(t);
            }
            remove(t) {
              const i = this._attachedOverlays.indexOf(t);
              i > -1 && this._attachedOverlays.splice(i, 1),
                0 === this._attachedOverlays.length && this.detach();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(He));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        Dee = (() => {
          class n extends uN {
            constructor(t, i) {
              super(t),
                (this._ngZone = i),
                (this._keydownListener = (r) => {
                  const s = this._attachedOverlays;
                  for (let o = s.length - 1; o > -1; o--)
                    if (s[o]._keydownEvents.observers.length > 0) {
                      const a = s[o]._keydownEvents;
                      this._ngZone
                        ? this._ngZone.run(() => a.next(r))
                        : a.next(r);
                      break;
                    }
                });
            }
            add(t) {
              super.add(t),
                this._isAttached ||
                  (this._ngZone
                    ? this._ngZone.runOutsideAngular(() =>
                        this._document.body.addEventListener(
                          'keydown',
                          this._keydownListener
                        )
                      )
                    : this._document.body.addEventListener(
                        'keydown',
                        this._keydownListener
                      ),
                  (this._isAttached = !0));
            }
            detach() {
              this._isAttached &&
                (this._document.body.removeEventListener(
                  'keydown',
                  this._keydownListener
                ),
                (this._isAttached = !1));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(He), L(ue, 8));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        Tee = (() => {
          class n extends uN {
            constructor(t, i, r) {
              super(t),
                (this._platform = i),
                (this._ngZone = r),
                (this._cursorStyleIsSet = !1),
                (this._pointerDownListener = (s) => {
                  this._pointerDownEventTarget = Js(s);
                }),
                (this._clickListener = (s) => {
                  const o = Js(s),
                    a =
                      'click' === s.type && this._pointerDownEventTarget
                        ? this._pointerDownEventTarget
                        : o;
                  this._pointerDownEventTarget = null;
                  const l = this._attachedOverlays.slice();
                  for (let c = l.length - 1; c > -1; c--) {
                    const u = l[c];
                    if (
                      u._outsidePointerEvents.observers.length < 1 ||
                      !u.hasAttached()
                    )
                      continue;
                    if (
                      u.overlayElement.contains(o) ||
                      u.overlayElement.contains(a)
                    )
                      break;
                    const h = u._outsidePointerEvents;
                    this._ngZone
                      ? this._ngZone.run(() => h.next(s))
                      : h.next(s);
                  }
                });
            }
            add(t) {
              if ((super.add(t), !this._isAttached)) {
                const i = this._document.body;
                this._ngZone
                  ? this._ngZone.runOutsideAngular(() =>
                      this._addEventListeners(i)
                    )
                  : this._addEventListeners(i),
                  this._platform.IOS &&
                    !this._cursorStyleIsSet &&
                    ((this._cursorOriginalValue = i.style.cursor),
                    (i.style.cursor = 'pointer'),
                    (this._cursorStyleIsSet = !0)),
                  (this._isAttached = !0);
              }
            }
            detach() {
              if (this._isAttached) {
                const t = this._document.body;
                t.removeEventListener(
                  'pointerdown',
                  this._pointerDownListener,
                  !0
                ),
                  t.removeEventListener('click', this._clickListener, !0),
                  t.removeEventListener('auxclick', this._clickListener, !0),
                  t.removeEventListener('contextmenu', this._clickListener, !0),
                  this._platform.IOS &&
                    this._cursorStyleIsSet &&
                    ((t.style.cursor = this._cursorOriginalValue),
                    (this._cursorStyleIsSet = !1)),
                  (this._isAttached = !1);
              }
            }
            _addEventListeners(t) {
              t.addEventListener('pointerdown', this._pointerDownListener, !0),
                t.addEventListener('click', this._clickListener, !0),
                t.addEventListener('auxclick', this._clickListener, !0),
                t.addEventListener('contextmenu', this._clickListener, !0);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(He), L(jt), L(ue, 8));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        hN = (() => {
          class n {
            constructor(t, i) {
              (this._platform = i), (this._document = t);
            }
            ngOnDestroy() {
              this._containerElement?.remove();
            }
            getContainerElement() {
              return (
                this._containerElement || this._createContainer(),
                this._containerElement
              );
            }
            _createContainer() {
              const t = 'cdk-overlay-container';
              if (this._platform.isBrowser || Z0()) {
                const r = this._document.querySelectorAll(
                  `.${t}[platform="server"], .${t}[platform="test"]`
                );
                for (let s = 0; s < r.length; s++) r[s].remove();
              }
              const i = this._document.createElement('div');
              i.classList.add(t),
                Z0()
                  ? i.setAttribute('platform', 'test')
                  : this._platform.isBrowser ||
                    i.setAttribute('platform', 'server'),
                this._document.body.appendChild(i),
                (this._containerElement = i);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(He), L(jt));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })();
      class Iee {
        constructor(e, t, i, r, s, o, a, l, c, u = !1) {
          (this._portalOutlet = e),
            (this._host = t),
            (this._pane = i),
            (this._config = r),
            (this._ngZone = s),
            (this._keyboardDispatcher = o),
            (this._document = a),
            (this._location = l),
            (this._outsideClickDispatcher = c),
            (this._animationsDisabled = u),
            (this._backdropElement = null),
            (this._backdropClick = new Le()),
            (this._attachments = new Le()),
            (this._detachments = new Le()),
            (this._locationChanges = $t.EMPTY),
            (this._backdropClickHandler = (h) => this._backdropClick.next(h)),
            (this._backdropTransitionendHandler = (h) => {
              this._disposeBackdrop(h.target);
            }),
            (this._keydownEvents = new Le()),
            (this._outsidePointerEvents = new Le()),
            r.scrollStrategy &&
              ((this._scrollStrategy = r.scrollStrategy),
              this._scrollStrategy.attach(this)),
            (this._positionStrategy = r.positionStrategy);
        }
        get overlayElement() {
          return this._pane;
        }
        get backdropElement() {
          return this._backdropElement;
        }
        get hostElement() {
          return this._host;
        }
        attach(e) {
          !this._host.parentElement &&
            this._previousHostParent &&
            this._previousHostParent.appendChild(this._host);
          const t = this._portalOutlet.attach(e);
          return (
            this._positionStrategy && this._positionStrategy.attach(this),
            this._updateStackingOrder(),
            this._updateElementSize(),
            this._updateElementDirection(),
            this._scrollStrategy && this._scrollStrategy.enable(),
            this._ngZone.onStable.pipe(ps(1)).subscribe(() => {
              this.hasAttached() && this.updatePosition();
            }),
            this._togglePointerEvents(!0),
            this._config.hasBackdrop && this._attachBackdrop(),
            this._config.panelClass &&
              this._toggleClasses(this._pane, this._config.panelClass, !0),
            this._attachments.next(),
            this._keyboardDispatcher.add(this),
            this._config.disposeOnNavigation &&
              (this._locationChanges = this._location.subscribe(() =>
                this.dispose()
              )),
            this._outsideClickDispatcher.add(this),
            'function' == typeof t?.onDestroy &&
              t.onDestroy(() => {
                this.hasAttached() &&
                  this._ngZone.runOutsideAngular(() =>
                    Promise.resolve().then(() => this.detach())
                  );
              }),
            t
          );
        }
        detach() {
          if (!this.hasAttached()) return;
          this.detachBackdrop(),
            this._togglePointerEvents(!1),
            this._positionStrategy &&
              this._positionStrategy.detach &&
              this._positionStrategy.detach(),
            this._scrollStrategy && this._scrollStrategy.disable();
          const e = this._portalOutlet.detach();
          return (
            this._detachments.next(),
            this._keyboardDispatcher.remove(this),
            this._detachContentWhenStable(),
            this._locationChanges.unsubscribe(),
            this._outsideClickDispatcher.remove(this),
            e
          );
        }
        dispose() {
          const e = this.hasAttached();
          this._positionStrategy && this._positionStrategy.dispose(),
            this._disposeScrollStrategy(),
            this._disposeBackdrop(this._backdropElement),
            this._locationChanges.unsubscribe(),
            this._keyboardDispatcher.remove(this),
            this._portalOutlet.dispose(),
            this._attachments.complete(),
            this._backdropClick.complete(),
            this._keydownEvents.complete(),
            this._outsidePointerEvents.complete(),
            this._outsideClickDispatcher.remove(this),
            this._host?.remove(),
            (this._previousHostParent = this._pane = this._host = null),
            e && this._detachments.next(),
            this._detachments.complete();
        }
        hasAttached() {
          return this._portalOutlet.hasAttached();
        }
        backdropClick() {
          return this._backdropClick;
        }
        attachments() {
          return this._attachments;
        }
        detachments() {
          return this._detachments;
        }
        keydownEvents() {
          return this._keydownEvents;
        }
        outsidePointerEvents() {
          return this._outsidePointerEvents;
        }
        getConfig() {
          return this._config;
        }
        updatePosition() {
          this._positionStrategy && this._positionStrategy.apply();
        }
        updatePositionStrategy(e) {
          e !== this._positionStrategy &&
            (this._positionStrategy && this._positionStrategy.dispose(),
            (this._positionStrategy = e),
            this.hasAttached() && (e.attach(this), this.updatePosition()));
        }
        updateSize(e) {
          (this._config = { ...this._config, ...e }), this._updateElementSize();
        }
        setDirection(e) {
          (this._config = { ...this._config, direction: e }),
            this._updateElementDirection();
        }
        addPanelClass(e) {
          this._pane && this._toggleClasses(this._pane, e, !0);
        }
        removePanelClass(e) {
          this._pane && this._toggleClasses(this._pane, e, !1);
        }
        getDirection() {
          const e = this._config.direction;
          return e ? ('string' == typeof e ? e : e.value) : 'ltr';
        }
        updateScrollStrategy(e) {
          e !== this._scrollStrategy &&
            (this._disposeScrollStrategy(),
            (this._scrollStrategy = e),
            this.hasAttached() && (e.attach(this), e.enable()));
        }
        _updateElementDirection() {
          this._host.setAttribute('dir', this.getDirection());
        }
        _updateElementSize() {
          if (!this._pane) return;
          const e = this._pane.style;
          (e.width = Zt(this._config.width)),
            (e.height = Zt(this._config.height)),
            (e.minWidth = Zt(this._config.minWidth)),
            (e.minHeight = Zt(this._config.minHeight)),
            (e.maxWidth = Zt(this._config.maxWidth)),
            (e.maxHeight = Zt(this._config.maxHeight));
        }
        _togglePointerEvents(e) {
          this._pane.style.pointerEvents = e ? '' : 'none';
        }
        _attachBackdrop() {
          const e = 'cdk-overlay-backdrop-showing';
          (this._backdropElement = this._document.createElement('div')),
            this._backdropElement.classList.add('cdk-overlay-backdrop'),
            this._animationsDisabled &&
              this._backdropElement.classList.add(
                'cdk-overlay-backdrop-noop-animation'
              ),
            this._config.backdropClass &&
              this._toggleClasses(
                this._backdropElement,
                this._config.backdropClass,
                !0
              ),
            this._host.parentElement.insertBefore(
              this._backdropElement,
              this._host
            ),
            this._backdropElement.addEventListener(
              'click',
              this._backdropClickHandler
            ),
            !this._animationsDisabled && typeof requestAnimationFrame < 'u'
              ? this._ngZone.runOutsideAngular(() => {
                  requestAnimationFrame(() => {
                    this._backdropElement &&
                      this._backdropElement.classList.add(e);
                  });
                })
              : this._backdropElement.classList.add(e);
        }
        _updateStackingOrder() {
          this._host.nextSibling &&
            this._host.parentNode.appendChild(this._host);
        }
        detachBackdrop() {
          const e = this._backdropElement;
          if (e) {
            if (this._animationsDisabled) return void this._disposeBackdrop(e);
            e.classList.remove('cdk-overlay-backdrop-showing'),
              this._ngZone.runOutsideAngular(() => {
                e.addEventListener(
                  'transitionend',
                  this._backdropTransitionendHandler
                );
              }),
              (e.style.pointerEvents = 'none'),
              (this._backdropTimeout = this._ngZone.runOutsideAngular(() =>
                setTimeout(() => {
                  this._disposeBackdrop(e);
                }, 500)
              ));
          }
        }
        _toggleClasses(e, t, i) {
          const r = Lm(t || []).filter((s) => !!s);
          r.length && (i ? e.classList.add(...r) : e.classList.remove(...r));
        }
        _detachContentWhenStable() {
          this._ngZone.runOutsideAngular(() => {
            const e = this._ngZone.onStable
              .pipe(se(Ro(this._attachments, this._detachments)))
              .subscribe(() => {
                (!this._pane ||
                  !this._host ||
                  0 === this._pane.children.length) &&
                  (this._pane &&
                    this._config.panelClass &&
                    this._toggleClasses(
                      this._pane,
                      this._config.panelClass,
                      !1
                    ),
                  this._host &&
                    this._host.parentElement &&
                    ((this._previousHostParent = this._host.parentElement),
                    this._host.remove()),
                  e.unsubscribe());
              });
          });
        }
        _disposeScrollStrategy() {
          const e = this._scrollStrategy;
          e && (e.disable(), e.detach && e.detach());
        }
        _disposeBackdrop(e) {
          e &&
            (e.removeEventListener('click', this._backdropClickHandler),
            e.removeEventListener(
              'transitionend',
              this._backdropTransitionendHandler
            ),
            e.remove(),
            this._backdropElement === e && (this._backdropElement = null)),
            this._backdropTimeout &&
              (clearTimeout(this._backdropTimeout),
              (this._backdropTimeout = void 0));
        }
      }
      const fN = 'cdk-overlay-connected-position-bounding-box',
        kee = /([A-Za-z%]+)$/;
      class Pee {
        get positions() {
          return this._preferredPositions;
        }
        constructor(e, t, i, r, s) {
          (this._viewportRuler = t),
            (this._document = i),
            (this._platform = r),
            (this._overlayContainer = s),
            (this._lastBoundingBoxSize = { width: 0, height: 0 }),
            (this._isPushed = !1),
            (this._canPush = !0),
            (this._growAfterOpen = !1),
            (this._hasFlexibleDimensions = !0),
            (this._positionLocked = !1),
            (this._viewportMargin = 0),
            (this._scrollables = []),
            (this._preferredPositions = []),
            (this._positionChanges = new Le()),
            (this._resizeSubscription = $t.EMPTY),
            (this._offsetX = 0),
            (this._offsetY = 0),
            (this._appliedPanelClasses = []),
            (this.positionChanges = this._positionChanges),
            this.setOrigin(e);
        }
        attach(e) {
          this._validatePositions(),
            e.hostElement.classList.add(fN),
            (this._overlayRef = e),
            (this._boundingBox = e.hostElement),
            (this._pane = e.overlayElement),
            (this._isDisposed = !1),
            (this._isInitialRender = !0),
            (this._lastPosition = null),
            this._resizeSubscription.unsubscribe(),
            (this._resizeSubscription = this._viewportRuler
              .change()
              .subscribe(() => {
                (this._isInitialRender = !0), this.apply();
              }));
        }
        apply() {
          if (this._isDisposed || !this._platform.isBrowser) return;
          if (
            !this._isInitialRender &&
            this._positionLocked &&
            this._lastPosition
          )
            return void this.reapplyLastPosition();
          this._clearPanelClasses(),
            this._resetOverlayElementStyles(),
            this._resetBoundingBoxStyles(),
            (this._viewportRect = this._getNarrowedViewportRect()),
            (this._originRect = this._getOriginRect()),
            (this._overlayRect = this._pane.getBoundingClientRect()),
            (this._containerRect = this._overlayContainer
              .getContainerElement()
              .getBoundingClientRect());
          const e = this._originRect,
            t = this._overlayRect,
            i = this._viewportRect,
            r = this._containerRect,
            s = [];
          let o;
          for (let a of this._preferredPositions) {
            let l = this._getOriginPoint(e, r, a),
              c = this._getOverlayPoint(l, t, a),
              u = this._getOverlayFit(c, t, i, a);
            if (u.isCompletelyWithinViewport)
              return (this._isPushed = !1), void this._applyPosition(a, l);
            this._canFitWithFlexibleDimensions(u, c, i)
              ? s.push({
                  position: a,
                  origin: l,
                  overlayRect: t,
                  boundingBoxRect: this._calculateBoundingBoxRect(l, a),
                })
              : (!o || o.overlayFit.visibleArea < u.visibleArea) &&
                (o = {
                  overlayFit: u,
                  overlayPoint: c,
                  originPoint: l,
                  position: a,
                  overlayRect: t,
                });
          }
          if (s.length) {
            let a = null,
              l = -1;
            for (const c of s) {
              const u =
                c.boundingBoxRect.width *
                c.boundingBoxRect.height *
                (c.position.weight || 1);
              u > l && ((l = u), (a = c));
            }
            return (
              (this._isPushed = !1),
              void this._applyPosition(a.position, a.origin)
            );
          }
          if (this._canPush)
            return (
              (this._isPushed = !0),
              void this._applyPosition(o.position, o.originPoint)
            );
          this._applyPosition(o.position, o.originPoint);
        }
        detach() {
          this._clearPanelClasses(),
            (this._lastPosition = null),
            (this._previousPushAmount = null),
            this._resizeSubscription.unsubscribe();
        }
        dispose() {
          this._isDisposed ||
            (this._boundingBox &&
              da(this._boundingBox.style, {
                top: '',
                left: '',
                right: '',
                bottom: '',
                height: '',
                width: '',
                alignItems: '',
                justifyContent: '',
              }),
            this._pane && this._resetOverlayElementStyles(),
            this._overlayRef &&
              this._overlayRef.hostElement.classList.remove(fN),
            this.detach(),
            this._positionChanges.complete(),
            (this._overlayRef = this._boundingBox = null),
            (this._isDisposed = !0));
        }
        reapplyLastPosition() {
          if (this._isDisposed || !this._platform.isBrowser) return;
          const e = this._lastPosition;
          if (e) {
            (this._originRect = this._getOriginRect()),
              (this._overlayRect = this._pane.getBoundingClientRect()),
              (this._viewportRect = this._getNarrowedViewportRect()),
              (this._containerRect = this._overlayContainer
                .getContainerElement()
                .getBoundingClientRect());
            const t = this._getOriginPoint(
              this._originRect,
              this._containerRect,
              e
            );
            this._applyPosition(e, t);
          } else this.apply();
        }
        withScrollableContainers(e) {
          return (this._scrollables = e), this;
        }
        withPositions(e) {
          return (
            (this._preferredPositions = e),
            -1 === e.indexOf(this._lastPosition) && (this._lastPosition = null),
            this._validatePositions(),
            this
          );
        }
        withViewportMargin(e) {
          return (this._viewportMargin = e), this;
        }
        withFlexibleDimensions(e = !0) {
          return (this._hasFlexibleDimensions = e), this;
        }
        withGrowAfterOpen(e = !0) {
          return (this._growAfterOpen = e), this;
        }
        withPush(e = !0) {
          return (this._canPush = e), this;
        }
        withLockedPosition(e = !0) {
          return (this._positionLocked = e), this;
        }
        setOrigin(e) {
          return (this._origin = e), this;
        }
        withDefaultOffsetX(e) {
          return (this._offsetX = e), this;
        }
        withDefaultOffsetY(e) {
          return (this._offsetY = e), this;
        }
        withTransformOriginOn(e) {
          return (this._transformOriginSelector = e), this;
        }
        _getOriginPoint(e, t, i) {
          let r, s;
          if ('center' == i.originX) r = e.left + e.width / 2;
          else {
            const o = this._isRtl() ? e.right : e.left,
              a = this._isRtl() ? e.left : e.right;
            r = 'start' == i.originX ? o : a;
          }
          return (
            t.left < 0 && (r -= t.left),
            (s =
              'center' == i.originY
                ? e.top + e.height / 2
                : 'top' == i.originY
                ? e.top
                : e.bottom),
            t.top < 0 && (s -= t.top),
            { x: r, y: s }
          );
        }
        _getOverlayPoint(e, t, i) {
          let r, s;
          return (
            (r =
              'center' == i.overlayX
                ? -t.width / 2
                : 'start' === i.overlayX
                ? this._isRtl()
                  ? -t.width
                  : 0
                : this._isRtl()
                ? 0
                : -t.width),
            (s =
              'center' == i.overlayY
                ? -t.height / 2
                : 'top' == i.overlayY
                ? 0
                : -t.height),
            { x: e.x + r, y: e.y + s }
          );
        }
        _getOverlayFit(e, t, i, r) {
          const s = mN(t);
          let { x: o, y: a } = e,
            l = this._getOffset(r, 'x'),
            c = this._getOffset(r, 'y');
          l && (o += l), c && (a += c);
          let f = 0 - a,
            p = a + s.height - i.height,
            m = this._subtractOverflows(s.width, 0 - o, o + s.width - i.width),
            g = this._subtractOverflows(s.height, f, p),
            w = m * g;
          return {
            visibleArea: w,
            isCompletelyWithinViewport: s.width * s.height === w,
            fitsInViewportVertically: g === s.height,
            fitsInViewportHorizontally: m == s.width,
          };
        }
        _canFitWithFlexibleDimensions(e, t, i) {
          if (this._hasFlexibleDimensions) {
            const r = i.bottom - t.y,
              s = i.right - t.x,
              o = pN(this._overlayRef.getConfig().minHeight),
              a = pN(this._overlayRef.getConfig().minWidth);
            return (
              (e.fitsInViewportVertically || (null != o && o <= r)) &&
              (e.fitsInViewportHorizontally || (null != a && a <= s))
            );
          }
          return !1;
        }
        _pushOverlayOnScreen(e, t, i) {
          if (this._previousPushAmount && this._positionLocked)
            return {
              x: e.x + this._previousPushAmount.x,
              y: e.y + this._previousPushAmount.y,
            };
          const r = mN(t),
            s = this._viewportRect,
            o = Math.max(e.x + r.width - s.width, 0),
            a = Math.max(e.y + r.height - s.height, 0),
            l = Math.max(s.top - i.top - e.y, 0),
            c = Math.max(s.left - i.left - e.x, 0);
          let u = 0,
            h = 0;
          return (
            (u =
              r.width <= s.width
                ? c || -o
                : e.x < this._viewportMargin
                ? s.left - i.left - e.x
                : 0),
            (h =
              r.height <= s.height
                ? l || -a
                : e.y < this._viewportMargin
                ? s.top - i.top - e.y
                : 0),
            (this._previousPushAmount = { x: u, y: h }),
            { x: e.x + u, y: e.y + h }
          );
        }
        _applyPosition(e, t) {
          if (
            (this._setTransformOrigin(e),
            this._setOverlayElementStyles(t, e),
            this._setBoundingBoxStyles(t, e),
            e.panelClass && this._addPanelClasses(e.panelClass),
            (this._lastPosition = e),
            this._positionChanges.observers.length)
          ) {
            const i = this._getScrollVisibility(),
              r = new Mee(e, i);
            this._positionChanges.next(r);
          }
          this._isInitialRender = !1;
        }
        _setTransformOrigin(e) {
          if (!this._transformOriginSelector) return;
          const t = this._boundingBox.querySelectorAll(
            this._transformOriginSelector
          );
          let i,
            r = e.overlayY;
          i =
            'center' === e.overlayX
              ? 'center'
              : this._isRtl()
              ? 'start' === e.overlayX
                ? 'right'
                : 'left'
              : 'start' === e.overlayX
              ? 'left'
              : 'right';
          for (let s = 0; s < t.length; s++)
            t[s].style.transformOrigin = `${i} ${r}`;
        }
        _calculateBoundingBoxRect(e, t) {
          const i = this._viewportRect,
            r = this._isRtl();
          let s, o, a, u, h, f;
          if ('top' === t.overlayY)
            (o = e.y), (s = i.height - o + this._viewportMargin);
          else if ('bottom' === t.overlayY)
            (a = i.height - e.y + 2 * this._viewportMargin),
              (s = i.height - a + this._viewportMargin);
          else {
            const p = Math.min(i.bottom - e.y + i.top, e.y),
              m = this._lastBoundingBoxSize.height;
            (s = 2 * p),
              (o = e.y - p),
              s > m &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (o = e.y - m / 2);
          }
          if (('end' === t.overlayX && !r) || ('start' === t.overlayX && r))
            (f = i.width - e.x + this._viewportMargin),
              (u = e.x - this._viewportMargin);
          else if (
            ('start' === t.overlayX && !r) ||
            ('end' === t.overlayX && r)
          )
            (h = e.x), (u = i.right - e.x);
          else {
            const p = Math.min(i.right - e.x + i.left, e.x),
              m = this._lastBoundingBoxSize.width;
            (u = 2 * p),
              (h = e.x - p),
              u > m &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (h = e.x - m / 2);
          }
          return { top: o, left: h, bottom: a, right: f, width: u, height: s };
        }
        _setBoundingBoxStyles(e, t) {
          const i = this._calculateBoundingBoxRect(e, t);
          !this._isInitialRender &&
            !this._growAfterOpen &&
            ((i.height = Math.min(i.height, this._lastBoundingBoxSize.height)),
            (i.width = Math.min(i.width, this._lastBoundingBoxSize.width)));
          const r = {};
          if (this._hasExactPosition())
            (r.top = r.left = '0'),
              (r.bottom = r.right = r.maxHeight = r.maxWidth = ''),
              (r.width = r.height = '100%');
          else {
            const s = this._overlayRef.getConfig().maxHeight,
              o = this._overlayRef.getConfig().maxWidth;
            (r.height = Zt(i.height)),
              (r.top = Zt(i.top)),
              (r.bottom = Zt(i.bottom)),
              (r.width = Zt(i.width)),
              (r.left = Zt(i.left)),
              (r.right = Zt(i.right)),
              (r.alignItems =
                'center' === t.overlayX
                  ? 'center'
                  : 'end' === t.overlayX
                  ? 'flex-end'
                  : 'flex-start'),
              (r.justifyContent =
                'center' === t.overlayY
                  ? 'center'
                  : 'bottom' === t.overlayY
                  ? 'flex-end'
                  : 'flex-start'),
              s && (r.maxHeight = Zt(s)),
              o && (r.maxWidth = Zt(o));
          }
          (this._lastBoundingBoxSize = i), da(this._boundingBox.style, r);
        }
        _resetBoundingBoxStyles() {
          da(this._boundingBox.style, {
            top: '0',
            left: '0',
            right: '0',
            bottom: '0',
            height: '',
            width: '',
            alignItems: '',
            justifyContent: '',
          });
        }
        _resetOverlayElementStyles() {
          da(this._pane.style, {
            top: '',
            left: '',
            bottom: '',
            right: '',
            position: '',
            transform: '',
          });
        }
        _setOverlayElementStyles(e, t) {
          const i = {},
            r = this._hasExactPosition(),
            s = this._hasFlexibleDimensions,
            o = this._overlayRef.getConfig();
          if (r) {
            const u = this._viewportRuler.getViewportScrollPosition();
            da(i, this._getExactOverlayY(t, e, u)),
              da(i, this._getExactOverlayX(t, e, u));
          } else i.position = 'static';
          let a = '',
            l = this._getOffset(t, 'x'),
            c = this._getOffset(t, 'y');
          l && (a += `translateX(${l}px) `),
            c && (a += `translateY(${c}px)`),
            (i.transform = a.trim()),
            o.maxHeight &&
              (r ? (i.maxHeight = Zt(o.maxHeight)) : s && (i.maxHeight = '')),
            o.maxWidth &&
              (r ? (i.maxWidth = Zt(o.maxWidth)) : s && (i.maxWidth = '')),
            da(this._pane.style, i);
        }
        _getExactOverlayY(e, t, i) {
          let r = { top: '', bottom: '' },
            s = this._getOverlayPoint(t, this._overlayRect, e);
          return (
            this._isPushed &&
              (s = this._pushOverlayOnScreen(s, this._overlayRect, i)),
            'bottom' === e.overlayY
              ? (r.bottom =
                  this._document.documentElement.clientHeight -
                  (s.y + this._overlayRect.height) +
                  'px')
              : (r.top = Zt(s.y)),
            r
          );
        }
        _getExactOverlayX(e, t, i) {
          let o,
            r = { left: '', right: '' },
            s = this._getOverlayPoint(t, this._overlayRect, e);
          return (
            this._isPushed &&
              (s = this._pushOverlayOnScreen(s, this._overlayRect, i)),
            (o = this._isRtl()
              ? 'end' === e.overlayX
                ? 'left'
                : 'right'
              : 'end' === e.overlayX
              ? 'right'
              : 'left'),
            'right' === o
              ? (r.right =
                  this._document.documentElement.clientWidth -
                  (s.x + this._overlayRect.width) +
                  'px')
              : (r.left = Zt(s.x)),
            r
          );
        }
        _getScrollVisibility() {
          const e = this._getOriginRect(),
            t = this._pane.getBoundingClientRect(),
            i = this._scrollables.map((r) =>
              r.getElementRef().nativeElement.getBoundingClientRect()
            );
          return {
            isOriginClipped: cN(e, i),
            isOriginOutsideView: wE(e, i),
            isOverlayClipped: cN(t, i),
            isOverlayOutsideView: wE(t, i),
          };
        }
        _subtractOverflows(e, ...t) {
          return t.reduce((i, r) => i - Math.max(r, 0), e);
        }
        _getNarrowedViewportRect() {
          const e = this._document.documentElement.clientWidth,
            t = this._document.documentElement.clientHeight,
            i = this._viewportRuler.getViewportScrollPosition();
          return {
            top: i.top + this._viewportMargin,
            left: i.left + this._viewportMargin,
            right: i.left + e - this._viewportMargin,
            bottom: i.top + t - this._viewportMargin,
            width: e - 2 * this._viewportMargin,
            height: t - 2 * this._viewportMargin,
          };
        }
        _isRtl() {
          return 'rtl' === this._overlayRef.getDirection();
        }
        _hasExactPosition() {
          return !this._hasFlexibleDimensions || this._isPushed;
        }
        _getOffset(e, t) {
          return 'x' === t
            ? null == e.offsetX
              ? this._offsetX
              : e.offsetX
            : null == e.offsetY
            ? this._offsetY
            : e.offsetY;
        }
        _validatePositions() {}
        _addPanelClasses(e) {
          this._pane &&
            Lm(e).forEach((t) => {
              '' !== t &&
                -1 === this._appliedPanelClasses.indexOf(t) &&
                (this._appliedPanelClasses.push(t),
                this._pane.classList.add(t));
            });
        }
        _clearPanelClasses() {
          this._pane &&
            (this._appliedPanelClasses.forEach((e) => {
              this._pane.classList.remove(e);
            }),
            (this._appliedPanelClasses = []));
        }
        _getOriginRect() {
          const e = this._origin;
          if (e instanceof Ne) return e.nativeElement.getBoundingClientRect();
          if (e instanceof Element) return e.getBoundingClientRect();
          const t = e.width || 0,
            i = e.height || 0;
          return {
            top: e.y,
            bottom: e.y + i,
            left: e.x,
            right: e.x + t,
            height: i,
            width: t,
          };
        }
      }
      function da(n, e) {
        for (let t in e) e.hasOwnProperty(t) && (n[t] = e[t]);
        return n;
      }
      function pN(n) {
        if ('number' != typeof n && null != n) {
          const [e, t] = n.split(kee);
          return t && 'px' !== t ? null : parseFloat(e);
        }
        return n || null;
      }
      function mN(n) {
        return {
          top: Math.floor(n.top),
          right: Math.floor(n.right),
          bottom: Math.floor(n.bottom),
          left: Math.floor(n.left),
          width: Math.floor(n.width),
          height: Math.floor(n.height),
        };
      }
      const gN = 'cdk-global-overlay-wrapper';
      class Ree {
        constructor() {
          (this._cssPosition = 'static'),
            (this._topOffset = ''),
            (this._bottomOffset = ''),
            (this._alignItems = ''),
            (this._xPosition = ''),
            (this._xOffset = ''),
            (this._width = ''),
            (this._height = ''),
            (this._isDisposed = !1);
        }
        attach(e) {
          const t = e.getConfig();
          (this._overlayRef = e),
            this._width && !t.width && e.updateSize({ width: this._width }),
            this._height && !t.height && e.updateSize({ height: this._height }),
            e.hostElement.classList.add(gN),
            (this._isDisposed = !1);
        }
        top(e = '') {
          return (
            (this._bottomOffset = ''),
            (this._topOffset = e),
            (this._alignItems = 'flex-start'),
            this
          );
        }
        left(e = '') {
          return (this._xOffset = e), (this._xPosition = 'left'), this;
        }
        bottom(e = '') {
          return (
            (this._topOffset = ''),
            (this._bottomOffset = e),
            (this._alignItems = 'flex-end'),
            this
          );
        }
        right(e = '') {
          return (this._xOffset = e), (this._xPosition = 'right'), this;
        }
        start(e = '') {
          return (this._xOffset = e), (this._xPosition = 'start'), this;
        }
        end(e = '') {
          return (this._xOffset = e), (this._xPosition = 'end'), this;
        }
        width(e = '') {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ width: e })
              : (this._width = e),
            this
          );
        }
        height(e = '') {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ height: e })
              : (this._height = e),
            this
          );
        }
        centerHorizontally(e = '') {
          return this.left(e), (this._xPosition = 'center'), this;
        }
        centerVertically(e = '') {
          return this.top(e), (this._alignItems = 'center'), this;
        }
        apply() {
          if (!this._overlayRef || !this._overlayRef.hasAttached()) return;
          const e = this._overlayRef.overlayElement.style,
            t = this._overlayRef.hostElement.style,
            i = this._overlayRef.getConfig(),
            { width: r, height: s, maxWidth: o, maxHeight: a } = i,
            l = !(
              ('100%' !== r && '100vw' !== r) ||
              (o && '100%' !== o && '100vw' !== o)
            ),
            c = !(
              ('100%' !== s && '100vh' !== s) ||
              (a && '100%' !== a && '100vh' !== a)
            ),
            u = this._xPosition,
            h = this._xOffset,
            f = 'rtl' === this._overlayRef.getConfig().direction;
          let p = '',
            m = '',
            g = '';
          l
            ? (g = 'flex-start')
            : 'center' === u
            ? ((g = 'center'), f ? (m = h) : (p = h))
            : f
            ? 'left' === u || 'end' === u
              ? ((g = 'flex-end'), (p = h))
              : ('right' === u || 'start' === u) &&
                ((g = 'flex-start'), (m = h))
            : 'left' === u || 'start' === u
            ? ((g = 'flex-start'), (p = h))
            : ('right' === u || 'end' === u) && ((g = 'flex-end'), (m = h)),
            (e.position = this._cssPosition),
            (e.marginLeft = l ? '0' : p),
            (e.marginTop = c ? '0' : this._topOffset),
            (e.marginBottom = this._bottomOffset),
            (e.marginRight = l ? '0' : m),
            (t.justifyContent = g),
            (t.alignItems = c ? 'flex-start' : this._alignItems);
        }
        dispose() {
          if (this._isDisposed || !this._overlayRef) return;
          const e = this._overlayRef.overlayElement.style,
            t = this._overlayRef.hostElement,
            i = t.style;
          t.classList.remove(gN),
            (i.justifyContent =
              i.alignItems =
              e.marginTop =
              e.marginBottom =
              e.marginLeft =
              e.marginRight =
              e.position =
                ''),
            (this._overlayRef = null),
            (this._isDisposed = !0);
        }
      }
      let Fee = (() => {
          class n {
            constructor(t, i, r, s) {
              (this._viewportRuler = t),
                (this._document = i),
                (this._platform = r),
                (this._overlayContainer = s);
            }
            global() {
              return new Ree();
            }
            flexibleConnectedTo(t) {
              return new Pee(
                t,
                this._viewportRuler,
                this._document,
                this._platform,
                this._overlayContainer
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(L(Gm), L(He), L(jt), L(hN));
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })(),
        Oee = 0,
        Kl = (() => {
          class n {
            constructor(t, i, r, s, o, a, l, c, u, h, f, p) {
              (this.scrollStrategies = t),
                (this._overlayContainer = i),
                (this._componentFactoryResolver = r),
                (this._positionBuilder = s),
                (this._keyboardDispatcher = o),
                (this._injector = a),
                (this._ngZone = l),
                (this._document = c),
                (this._directionality = u),
                (this._location = h),
                (this._outsideClickDispatcher = f),
                (this._animationsModuleType = p);
            }
            create(t) {
              const i = this._createHostElement(),
                r = this._createPaneElement(i),
                s = this._createPortalOutlet(r),
                o = new dN(t);
              return (
                (o.direction = o.direction || this._directionality.value),
                new Iee(
                  s,
                  i,
                  r,
                  o,
                  this._ngZone,
                  this._keyboardDispatcher,
                  this._document,
                  this._location,
                  this._outsideClickDispatcher,
                  'NoopAnimations' === this._animationsModuleType
                )
              );
            }
            position() {
              return this._positionBuilder;
            }
            _createPaneElement(t) {
              const i = this._document.createElement('div');
              return (
                (i.id = 'cdk-overlay-' + Oee++),
                i.classList.add('cdk-overlay-pane'),
                t.appendChild(i),
                i
              );
            }
            _createHostElement() {
              const t = this._document.createElement('div');
              return (
                this._overlayContainer.getContainerElement().appendChild(t), t
              );
            }
            _createPortalOutlet(t) {
              return (
                this._appRef || (this._appRef = this._injector.get(Ko)),
                new wee(
                  t,
                  this._componentFactoryResolver,
                  this._appRef,
                  this._injector,
                  this._document
                )
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                L(See),
                L(hN),
                L(Dd),
                L(Fee),
                L(Dee),
                L(nr),
                L(ue),
                L(He),
                L(ca),
                L(lR),
                L(Tee),
                L(Ii, 8)
              );
            }),
            (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
            n
          );
        })();
      const Lee = [
          {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top',
          },
          {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom',
          },
          {
            originX: 'end',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'bottom',
          },
          {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'top',
          },
        ],
        _N = new j('cdk-connected-overlay-scroll-strategy');
      let EE = (() => {
          class n {
            constructor(t) {
              this.elementRef = t;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Ne));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [
                ['', 'cdk-overlay-origin', ''],
                ['', 'overlay-origin', ''],
                ['', 'cdkOverlayOrigin', ''],
              ],
              exportAs: ['cdkOverlayOrigin'],
              standalone: !0,
            })),
            n
          );
        })(),
        bN = (() => {
          class n {
            get offsetX() {
              return this._offsetX;
            }
            set offsetX(t) {
              (this._offsetX = t),
                this._position && this._updatePositionStrategy(this._position);
            }
            get offsetY() {
              return this._offsetY;
            }
            set offsetY(t) {
              (this._offsetY = t),
                this._position && this._updatePositionStrategy(this._position);
            }
            get hasBackdrop() {
              return this._hasBackdrop;
            }
            set hasBackdrop(t) {
              this._hasBackdrop = vt(t);
            }
            get lockPosition() {
              return this._lockPosition;
            }
            set lockPosition(t) {
              this._lockPosition = vt(t);
            }
            get flexibleDimensions() {
              return this._flexibleDimensions;
            }
            set flexibleDimensions(t) {
              this._flexibleDimensions = vt(t);
            }
            get growAfterOpen() {
              return this._growAfterOpen;
            }
            set growAfterOpen(t) {
              this._growAfterOpen = vt(t);
            }
            get push() {
              return this._push;
            }
            set push(t) {
              this._push = vt(t);
            }
            constructor(t, i, r, s, o) {
              (this._overlay = t),
                (this._dir = o),
                (this._hasBackdrop = !1),
                (this._lockPosition = !1),
                (this._growAfterOpen = !1),
                (this._flexibleDimensions = !1),
                (this._push = !1),
                (this._backdropSubscription = $t.EMPTY),
                (this._attachSubscription = $t.EMPTY),
                (this._detachSubscription = $t.EMPTY),
                (this._positionSubscription = $t.EMPTY),
                (this.viewportMargin = 0),
                (this.open = !1),
                (this.disableClose = !1),
                (this.backdropClick = new ke()),
                (this.positionChange = new ke()),
                (this.attach = new ke()),
                (this.detach = new ke()),
                (this.overlayKeydown = new ke()),
                (this.overlayOutsideClick = new ke()),
                (this._templatePortal = new oN(i, r)),
                (this._scrollStrategyFactory = s),
                (this.scrollStrategy = this._scrollStrategyFactory());
            }
            get overlayRef() {
              return this._overlayRef;
            }
            get dir() {
              return this._dir ? this._dir.value : 'ltr';
            }
            ngOnDestroy() {
              this._attachSubscription.unsubscribe(),
                this._detachSubscription.unsubscribe(),
                this._backdropSubscription.unsubscribe(),
                this._positionSubscription.unsubscribe(),
                this._overlayRef && this._overlayRef.dispose();
            }
            ngOnChanges(t) {
              this._position &&
                (this._updatePositionStrategy(this._position),
                this._overlayRef.updateSize({
                  width: this.width,
                  minWidth: this.minWidth,
                  height: this.height,
                  minHeight: this.minHeight,
                }),
                t.origin && this.open && this._position.apply()),
                t.open &&
                  (this.open ? this._attachOverlay() : this._detachOverlay());
            }
            _createOverlay() {
              (!this.positions || !this.positions.length) &&
                (this.positions = Lee);
              const t = (this._overlayRef = this._overlay.create(
                this._buildConfig()
              ));
              (this._attachSubscription = t
                .attachments()
                .subscribe(() => this.attach.emit())),
                (this._detachSubscription = t
                  .detachments()
                  .subscribe(() => this.detach.emit())),
                t.keydownEvents().subscribe((i) => {
                  this.overlayKeydown.next(i),
                    27 === i.keyCode &&
                      !this.disableClose &&
                      !aa(i) &&
                      (i.preventDefault(), this._detachOverlay());
                }),
                this._overlayRef.outsidePointerEvents().subscribe((i) => {
                  this.overlayOutsideClick.next(i);
                });
            }
            _buildConfig() {
              const t = (this._position =
                  this.positionStrategy || this._createPositionStrategy()),
                i = new dN({
                  direction: this._dir,
                  positionStrategy: t,
                  scrollStrategy: this.scrollStrategy,
                  hasBackdrop: this.hasBackdrop,
                });
              return (
                (this.width || 0 === this.width) && (i.width = this.width),
                (this.height || 0 === this.height) && (i.height = this.height),
                (this.minWidth || 0 === this.minWidth) &&
                  (i.minWidth = this.minWidth),
                (this.minHeight || 0 === this.minHeight) &&
                  (i.minHeight = this.minHeight),
                this.backdropClass && (i.backdropClass = this.backdropClass),
                this.panelClass && (i.panelClass = this.panelClass),
                i
              );
            }
            _updatePositionStrategy(t) {
              const i = this.positions.map((r) => ({
                originX: r.originX,
                originY: r.originY,
                overlayX: r.overlayX,
                overlayY: r.overlayY,
                offsetX: r.offsetX || this.offsetX,
                offsetY: r.offsetY || this.offsetY,
                panelClass: r.panelClass || void 0,
              }));
              return t
                .setOrigin(this._getFlexibleConnectedPositionStrategyOrigin())
                .withPositions(i)
                .withFlexibleDimensions(this.flexibleDimensions)
                .withPush(this.push)
                .withGrowAfterOpen(this.growAfterOpen)
                .withViewportMargin(this.viewportMargin)
                .withLockedPosition(this.lockPosition)
                .withTransformOriginOn(this.transformOriginSelector);
            }
            _createPositionStrategy() {
              const t = this._overlay
                .position()
                .flexibleConnectedTo(
                  this._getFlexibleConnectedPositionStrategyOrigin()
                );
              return this._updatePositionStrategy(t), t;
            }
            _getFlexibleConnectedPositionStrategyOrigin() {
              return this.origin instanceof EE
                ? this.origin.elementRef
                : this.origin;
            }
            _attachOverlay() {
              this._overlayRef
                ? (this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop)
                : this._createOverlay(),
                this._overlayRef.hasAttached() ||
                  this._overlayRef.attach(this._templatePortal),
                this.hasBackdrop
                  ? (this._backdropSubscription = this._overlayRef
                      .backdropClick()
                      .subscribe((t) => {
                        this.backdropClick.emit(t);
                      }))
                  : this._backdropSubscription.unsubscribe(),
                this._positionSubscription.unsubscribe(),
                this.positionChange.observers.length > 0 &&
                  (this._positionSubscription = this._position.positionChanges
                    .pipe(
                      (function bee(n, e = !1) {
                        return gn((t, i) => {
                          let r = 0;
                          t.subscribe(
                            hn(i, (s) => {
                              const o = n(s, r++);
                              (o || e) && i.next(s), !o && i.complete();
                            })
                          );
                        });
                      })(() => this.positionChange.observers.length > 0)
                    )
                    .subscribe((t) => {
                      this.positionChange.emit(t),
                        0 === this.positionChange.observers.length &&
                          this._positionSubscription.unsubscribe();
                    }));
            }
            _detachOverlay() {
              this._overlayRef && this._overlayRef.detach(),
                this._backdropSubscription.unsubscribe(),
                this._positionSubscription.unsubscribe();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Kl), D(Nr), D($i), D(_N), D(ca, 8));
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [
                ['', 'cdk-connected-overlay', ''],
                ['', 'connected-overlay', ''],
                ['', 'cdkConnectedOverlay', ''],
              ],
              inputs: {
                origin: ['cdkConnectedOverlayOrigin', 'origin'],
                positions: ['cdkConnectedOverlayPositions', 'positions'],
                positionStrategy: [
                  'cdkConnectedOverlayPositionStrategy',
                  'positionStrategy',
                ],
                offsetX: ['cdkConnectedOverlayOffsetX', 'offsetX'],
                offsetY: ['cdkConnectedOverlayOffsetY', 'offsetY'],
                width: ['cdkConnectedOverlayWidth', 'width'],
                height: ['cdkConnectedOverlayHeight', 'height'],
                minWidth: ['cdkConnectedOverlayMinWidth', 'minWidth'],
                minHeight: ['cdkConnectedOverlayMinHeight', 'minHeight'],
                backdropClass: [
                  'cdkConnectedOverlayBackdropClass',
                  'backdropClass',
                ],
                panelClass: ['cdkConnectedOverlayPanelClass', 'panelClass'],
                viewportMargin: [
                  'cdkConnectedOverlayViewportMargin',
                  'viewportMargin',
                ],
                scrollStrategy: [
                  'cdkConnectedOverlayScrollStrategy',
                  'scrollStrategy',
                ],
                open: ['cdkConnectedOverlayOpen', 'open'],
                disableClose: [
                  'cdkConnectedOverlayDisableClose',
                  'disableClose',
                ],
                transformOriginSelector: [
                  'cdkConnectedOverlayTransformOriginOn',
                  'transformOriginSelector',
                ],
                hasBackdrop: ['cdkConnectedOverlayHasBackdrop', 'hasBackdrop'],
                lockPosition: [
                  'cdkConnectedOverlayLockPosition',
                  'lockPosition',
                ],
                flexibleDimensions: [
                  'cdkConnectedOverlayFlexibleDimensions',
                  'flexibleDimensions',
                ],
                growAfterOpen: [
                  'cdkConnectedOverlayGrowAfterOpen',
                  'growAfterOpen',
                ],
                push: ['cdkConnectedOverlayPush', 'push'],
              },
              outputs: {
                backdropClick: 'backdropClick',
                positionChange: 'positionChange',
                attach: 'attach',
                detach: 'detach',
                overlayKeydown: 'overlayKeydown',
                overlayOutsideClick: 'overlayOutsideClick',
              },
              exportAs: ['cdkConnectedOverlay'],
              standalone: !0,
              features: [ri],
            })),
            n
          );
        })();
      const Vee = {
        provide: _N,
        deps: [Kl],
        useFactory: function Nee(n) {
          return () => n.scrollStrategies.reposition();
        },
      };
      let vN = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = Ze({ type: n })),
          (n.ɵinj = qe({ providers: [Kl, Vee], imports: [vu, Eee, QL, QL] })),
          n
        );
      })();
      const Bee = ['tooltip'],
        yN = new j('mat-tooltip-scroll-strategy'),
        jee = {
          provide: yN,
          deps: [Kl],
          useFactory: function Wee(n) {
            return () => n.scrollStrategies.reposition({ scrollThrottle: 20 });
          },
        },
        Uee = new j('mat-tooltip-default-options', {
          providedIn: 'root',
          factory: function zee() {
            return { showDelay: 0, hideDelay: 0, touchendHideDelay: 1500 };
          },
        }),
        wN = 'tooltip-panel',
        EN = Gl({ passive: !0 });
      let Kee = (() => {
          class n {
            get position() {
              return this._position;
            }
            set position(t) {
              t !== this._position &&
                ((this._position = t),
                this._overlayRef &&
                  (this._updatePosition(this._overlayRef),
                  this._tooltipInstance?.show(0),
                  this._overlayRef.updatePosition()));
            }
            get positionAtOrigin() {
              return this._positionAtOrigin;
            }
            set positionAtOrigin(t) {
              (this._positionAtOrigin = vt(t)),
                this._detach(),
                (this._overlayRef = null);
            }
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              (this._disabled = vt(t)),
                this._disabled
                  ? this.hide(0)
                  : this._setupPointerEnterEventsIfNeeded();
            }
            get showDelay() {
              return this._showDelay;
            }
            set showDelay(t) {
              this._showDelay = _u(t);
            }
            get hideDelay() {
              return this._hideDelay;
            }
            set hideDelay(t) {
              (this._hideDelay = _u(t)),
                this._tooltipInstance &&
                  (this._tooltipInstance._mouseLeaveHideDelay =
                    this._hideDelay);
            }
            get message() {
              return this._message;
            }
            set message(t) {
              this._ariaDescriber.removeDescription(
                this._elementRef.nativeElement,
                this._message,
                'tooltip'
              ),
                (this._message = null != t ? String(t).trim() : ''),
                !this._message && this._isTooltipVisible()
                  ? this.hide(0)
                  : (this._setupPointerEnterEventsIfNeeded(),
                    this._updateTooltipMessage(),
                    this._ngZone.runOutsideAngular(() => {
                      Promise.resolve().then(() => {
                        this._ariaDescriber.describe(
                          this._elementRef.nativeElement,
                          this.message,
                          'tooltip'
                        );
                      });
                    }));
            }
            get tooltipClass() {
              return this._tooltipClass;
            }
            set tooltipClass(t) {
              (this._tooltipClass = t),
                this._tooltipInstance &&
                  this._setTooltipClass(this._tooltipClass);
            }
            constructor(t, i, r, s, o, a, l, c, u, h, f, p) {
              (this._overlay = t),
                (this._elementRef = i),
                (this._scrollDispatcher = r),
                (this._viewContainerRef = s),
                (this._ngZone = o),
                (this._platform = a),
                (this._ariaDescriber = l),
                (this._focusMonitor = c),
                (this._dir = h),
                (this._defaultOptions = f),
                (this._position = 'below'),
                (this._positionAtOrigin = !1),
                (this._disabled = !1),
                (this._viewInitialized = !1),
                (this._pointerExitEventsInitialized = !1),
                (this._viewportMargin = 8),
                (this._cssClassPrefix = 'mat'),
                (this.touchGestures = 'auto'),
                (this._message = ''),
                (this._passiveListeners = []),
                (this._destroyed = new Le()),
                (this._scrollStrategy = u),
                (this._document = p),
                f &&
                  ((this._showDelay = f.showDelay),
                  (this._hideDelay = f.hideDelay),
                  f.position && (this.position = f.position),
                  f.positionAtOrigin &&
                    (this.positionAtOrigin = f.positionAtOrigin),
                  f.touchGestures && (this.touchGestures = f.touchGestures)),
                h.change.pipe(se(this._destroyed)).subscribe(() => {
                  this._overlayRef && this._updatePosition(this._overlayRef);
                });
            }
            ngAfterViewInit() {
              (this._viewInitialized = !0),
                this._setupPointerEnterEventsIfNeeded(),
                this._focusMonitor
                  .monitor(this._elementRef)
                  .pipe(se(this._destroyed))
                  .subscribe((t) => {
                    t
                      ? 'keyboard' === t && this._ngZone.run(() => this.show())
                      : this._ngZone.run(() => this.hide(0));
                  });
            }
            ngOnDestroy() {
              const t = this._elementRef.nativeElement;
              clearTimeout(this._touchstartTimeout),
                this._overlayRef &&
                  (this._overlayRef.dispose(), (this._tooltipInstance = null)),
                this._passiveListeners.forEach(([i, r]) => {
                  t.removeEventListener(i, r, EN);
                }),
                (this._passiveListeners.length = 0),
                this._destroyed.next(),
                this._destroyed.complete(),
                this._ariaDescriber.removeDescription(
                  t,
                  this.message,
                  'tooltip'
                ),
                this._focusMonitor.stopMonitoring(t);
            }
            show(t = this.showDelay, i) {
              if (this.disabled || !this.message || this._isTooltipVisible())
                return void this._tooltipInstance?._cancelPendingAnimations();
              const r = this._createOverlay(i);
              this._detach(),
                (this._portal =
                  this._portal ||
                  new sN(this._tooltipComponent, this._viewContainerRef));
              const s = (this._tooltipInstance = r.attach(
                this._portal
              ).instance);
              (s._triggerElement = this._elementRef.nativeElement),
                (s._mouseLeaveHideDelay = this._hideDelay),
                s
                  .afterHidden()
                  .pipe(se(this._destroyed))
                  .subscribe(() => this._detach()),
                this._setTooltipClass(this._tooltipClass),
                this._updateTooltipMessage(),
                s.show(t);
            }
            hide(t = this.hideDelay) {
              const i = this._tooltipInstance;
              i &&
                (i.isVisible()
                  ? i.hide(t)
                  : (i._cancelPendingAnimations(), this._detach()));
            }
            toggle(t) {
              this._isTooltipVisible() ? this.hide() : this.show(void 0, t);
            }
            _isTooltipVisible() {
              return (
                !!this._tooltipInstance && this._tooltipInstance.isVisible()
              );
            }
            _createOverlay(t) {
              if (this._overlayRef) {
                const s = this._overlayRef.getConfig().positionStrategy;
                if ((!this.positionAtOrigin || !t) && s._origin instanceof Ne)
                  return this._overlayRef;
                this._detach();
              }
              const i = this._scrollDispatcher.getAncestorScrollContainers(
                  this._elementRef
                ),
                r = this._overlay
                  .position()
                  .flexibleConnectedTo(
                    (this.positionAtOrigin && t) || this._elementRef
                  )
                  .withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`)
                  .withFlexibleDimensions(!1)
                  .withViewportMargin(this._viewportMargin)
                  .withScrollableContainers(i);
              return (
                r.positionChanges.pipe(se(this._destroyed)).subscribe((s) => {
                  this._updateCurrentPositionClass(s.connectionPair),
                    this._tooltipInstance &&
                      s.scrollableViewProperties.isOverlayClipped &&
                      this._tooltipInstance.isVisible() &&
                      this._ngZone.run(() => this.hide(0));
                }),
                (this._overlayRef = this._overlay.create({
                  direction: this._dir,
                  positionStrategy: r,
                  panelClass: `${this._cssClassPrefix}-${wN}`,
                  scrollStrategy: this._scrollStrategy(),
                })),
                this._updatePosition(this._overlayRef),
                this._overlayRef
                  .detachments()
                  .pipe(se(this._destroyed))
                  .subscribe(() => this._detach()),
                this._overlayRef
                  .outsidePointerEvents()
                  .pipe(se(this._destroyed))
                  .subscribe(() =>
                    this._tooltipInstance?._handleBodyInteraction()
                  ),
                this._overlayRef
                  .keydownEvents()
                  .pipe(se(this._destroyed))
                  .subscribe((s) => {
                    this._isTooltipVisible() &&
                      27 === s.keyCode &&
                      !aa(s) &&
                      (s.preventDefault(),
                      s.stopPropagation(),
                      this._ngZone.run(() => this.hide(0)));
                  }),
                this._defaultOptions?.disableTooltipInteractivity &&
                  this._overlayRef.addPanelClass(
                    `${this._cssClassPrefix}-tooltip-panel-non-interactive`
                  ),
                this._overlayRef
              );
            }
            _detach() {
              this._overlayRef &&
                this._overlayRef.hasAttached() &&
                this._overlayRef.detach(),
                (this._tooltipInstance = null);
            }
            _updatePosition(t) {
              const i = t.getConfig().positionStrategy,
                r = this._getOrigin(),
                s = this._getOverlayPosition();
              i.withPositions([
                this._addOffset({ ...r.main, ...s.main }),
                this._addOffset({ ...r.fallback, ...s.fallback }),
              ]);
            }
            _addOffset(t) {
              return t;
            }
            _getOrigin() {
              const t = !this._dir || 'ltr' == this._dir.value,
                i = this.position;
              let r;
              'above' == i || 'below' == i
                ? (r = {
                    originX: 'center',
                    originY: 'above' == i ? 'top' : 'bottom',
                  })
                : 'before' == i || ('left' == i && t) || ('right' == i && !t)
                ? (r = { originX: 'start', originY: 'center' })
                : ('after' == i ||
                    ('right' == i && t) ||
                    ('left' == i && !t)) &&
                  (r = { originX: 'end', originY: 'center' });
              const { x: s, y: o } = this._invertPosition(r.originX, r.originY);
              return { main: r, fallback: { originX: s, originY: o } };
            }
            _getOverlayPosition() {
              const t = !this._dir || 'ltr' == this._dir.value,
                i = this.position;
              let r;
              'above' == i
                ? (r = { overlayX: 'center', overlayY: 'bottom' })
                : 'below' == i
                ? (r = { overlayX: 'center', overlayY: 'top' })
                : 'before' == i || ('left' == i && t) || ('right' == i && !t)
                ? (r = { overlayX: 'end', overlayY: 'center' })
                : ('after' == i ||
                    ('right' == i && t) ||
                    ('left' == i && !t)) &&
                  (r = { overlayX: 'start', overlayY: 'center' });
              const { x: s, y: o } = this._invertPosition(
                r.overlayX,
                r.overlayY
              );
              return { main: r, fallback: { overlayX: s, overlayY: o } };
            }
            _updateTooltipMessage() {
              this._tooltipInstance &&
                ((this._tooltipInstance.message = this.message),
                this._tooltipInstance._markForCheck(),
                this._ngZone.onMicrotaskEmpty
                  .pipe(ps(1), se(this._destroyed))
                  .subscribe(() => {
                    this._tooltipInstance && this._overlayRef.updatePosition();
                  }));
            }
            _setTooltipClass(t) {
              this._tooltipInstance &&
                ((this._tooltipInstance.tooltipClass = t),
                this._tooltipInstance._markForCheck());
            }
            _invertPosition(t, i) {
              return (
                'above' === this.position || 'below' === this.position
                  ? 'top' === i
                    ? (i = 'bottom')
                    : 'bottom' === i && (i = 'top')
                  : 'end' === t
                  ? (t = 'start')
                  : 'start' === t && (t = 'end'),
                { x: t, y: i }
              );
            }
            _updateCurrentPositionClass(t) {
              const { overlayY: i, originX: r, originY: s } = t;
              let o;
              if (
                ((o =
                  'center' === i
                    ? this._dir && 'rtl' === this._dir.value
                      ? 'end' === r
                        ? 'left'
                        : 'right'
                      : 'start' === r
                      ? 'left'
                      : 'right'
                    : 'bottom' === i && 'top' === s
                    ? 'above'
                    : 'below'),
                o !== this._currentPosition)
              ) {
                const a = this._overlayRef;
                if (a) {
                  const l = `${this._cssClassPrefix}-${wN}-`;
                  a.removePanelClass(l + this._currentPosition),
                    a.addPanelClass(l + o);
                }
                this._currentPosition = o;
              }
            }
            _setupPointerEnterEventsIfNeeded() {
              this._disabled ||
                !this.message ||
                !this._viewInitialized ||
                this._passiveListeners.length ||
                (this._platformSupportsMouseEvents()
                  ? this._passiveListeners.push([
                      'mouseenter',
                      (t) => {
                        let i;
                        this._setupPointerExitEventsIfNeeded(),
                          void 0 !== t.x && void 0 !== t.y && (i = t),
                          this.show(void 0, i);
                      },
                    ])
                  : 'off' !== this.touchGestures &&
                    (this._disableNativeGesturesIfNecessary(),
                    this._passiveListeners.push([
                      'touchstart',
                      (t) => {
                        const i = t.targetTouches?.[0],
                          r = i ? { x: i.clientX, y: i.clientY } : void 0;
                        this._setupPointerExitEventsIfNeeded(),
                          clearTimeout(this._touchstartTimeout),
                          (this._touchstartTimeout = setTimeout(
                            () => this.show(void 0, r),
                            500
                          ));
                      },
                    ])),
                this._addListeners(this._passiveListeners));
            }
            _setupPointerExitEventsIfNeeded() {
              if (this._pointerExitEventsInitialized) return;
              this._pointerExitEventsInitialized = !0;
              const t = [];
              if (this._platformSupportsMouseEvents())
                t.push(
                  [
                    'mouseleave',
                    (i) => {
                      const r = i.relatedTarget;
                      (!r || !this._overlayRef?.overlayElement.contains(r)) &&
                        this.hide();
                    },
                  ],
                  ['wheel', (i) => this._wheelListener(i)]
                );
              else if ('off' !== this.touchGestures) {
                this._disableNativeGesturesIfNecessary();
                const i = () => {
                  clearTimeout(this._touchstartTimeout),
                    this.hide(this._defaultOptions.touchendHideDelay);
                };
                t.push(['touchend', i], ['touchcancel', i]);
              }
              this._addListeners(t), this._passiveListeners.push(...t);
            }
            _addListeners(t) {
              t.forEach(([i, r]) => {
                this._elementRef.nativeElement.addEventListener(i, r, EN);
              });
            }
            _platformSupportsMouseEvents() {
              return !this._platform.IOS && !this._platform.ANDROID;
            }
            _wheelListener(t) {
              if (this._isTooltipVisible()) {
                const i = this._document.elementFromPoint(t.clientX, t.clientY),
                  r = this._elementRef.nativeElement;
                i !== r && !r.contains(i) && this.hide();
              }
            }
            _disableNativeGesturesIfNecessary() {
              const t = this.touchGestures;
              if ('off' !== t) {
                const i = this._elementRef.nativeElement,
                  r = i.style;
                ('on' === t ||
                  ('INPUT' !== i.nodeName && 'TEXTAREA' !== i.nodeName)) &&
                  (r.userSelect =
                    r.msUserSelect =
                    r.webkitUserSelect =
                    r.MozUserSelect =
                      'none'),
                  ('on' === t || !i.draggable) && (r.webkitUserDrag = 'none'),
                  (r.touchAction = 'none'),
                  (r.webkitTapHighlightColor = 'transparent');
              }
            }
          }
          return (
            (n.ɵfac = function (t) {
              wl();
            }),
            (n.ɵdir = J({
              type: n,
              inputs: {
                position: ['matTooltipPosition', 'position'],
                positionAtOrigin: [
                  'matTooltipPositionAtOrigin',
                  'positionAtOrigin',
                ],
                disabled: ['matTooltipDisabled', 'disabled'],
                showDelay: ['matTooltipShowDelay', 'showDelay'],
                hideDelay: ['matTooltipHideDelay', 'hideDelay'],
                touchGestures: ['matTooltipTouchGestures', 'touchGestures'],
                message: ['matTooltip', 'message'],
                tooltipClass: ['matTooltipClass', 'tooltipClass'],
              },
            })),
            n
          );
        })(),
        Zee = (() => {
          class n extends Kee {
            constructor(t, i, r, s, o, a, l, c, u, h, f, p) {
              super(t, i, r, s, o, a, l, c, u, h, f, p),
                (this._tooltipComponent = Jee),
                (this._cssClassPrefix = 'mat-mdc'),
                (this._viewportMargin = 8);
            }
            _addOffset(t) {
              const r = !this._dir || 'ltr' == this._dir.value;
              return (
                'top' === t.originY
                  ? (t.offsetY = -8)
                  : 'bottom' === t.originY
                  ? (t.offsetY = 8)
                  : 'start' === t.originX
                  ? (t.offsetX = r ? -8 : 8)
                  : 'end' === t.originX && (t.offsetX = r ? 8 : -8),
                t
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                D(Kl),
                D(Ne),
                D($m),
                D($i),
                D(ue),
                D(jt),
                D(LZ),
                D(Hm),
                D(yN),
                D(ca, 8),
                D(Uee, 8),
                D(He)
              );
            }),
            (n.ɵdir = J({
              type: n,
              selectors: [['', 'matTooltip', '']],
              hostAttrs: [1, 'mat-mdc-tooltip-trigger'],
              exportAs: ['matTooltip'],
              features: [ye],
            })),
            n
          );
        })(),
        Qee = (() => {
          class n {
            constructor(t, i) {
              (this._changeDetectorRef = t),
                (this._closeOnInteraction = !1),
                (this._isVisible = !1),
                (this._onHide = new Le()),
                (this._animationsDisabled = 'NoopAnimations' === i);
            }
            show(t) {
              null != this._hideTimeoutId && clearTimeout(this._hideTimeoutId),
                (this._showTimeoutId = setTimeout(() => {
                  this._toggleVisibility(!0), (this._showTimeoutId = void 0);
                }, t));
            }
            hide(t) {
              null != this._showTimeoutId && clearTimeout(this._showTimeoutId),
                (this._hideTimeoutId = setTimeout(() => {
                  this._toggleVisibility(!1), (this._hideTimeoutId = void 0);
                }, t));
            }
            afterHidden() {
              return this._onHide;
            }
            isVisible() {
              return this._isVisible;
            }
            ngOnDestroy() {
              this._cancelPendingAnimations(),
                this._onHide.complete(),
                (this._triggerElement = null);
            }
            _handleBodyInteraction() {
              this._closeOnInteraction && this.hide(0);
            }
            _markForCheck() {
              this._changeDetectorRef.markForCheck();
            }
            _handleMouseLeave({ relatedTarget: t }) {
              (!t || !this._triggerElement.contains(t)) &&
                (this.isVisible()
                  ? this.hide(this._mouseLeaveHideDelay)
                  : this._finalizeAnimation(!1));
            }
            _onShow() {}
            _handleAnimationEnd({ animationName: t }) {
              (t === this._showAnimation || t === this._hideAnimation) &&
                this._finalizeAnimation(t === this._showAnimation);
            }
            _cancelPendingAnimations() {
              null != this._showTimeoutId && clearTimeout(this._showTimeoutId),
                null != this._hideTimeoutId &&
                  clearTimeout(this._hideTimeoutId),
                (this._showTimeoutId = this._hideTimeoutId = void 0);
            }
            _finalizeAnimation(t) {
              t
                ? (this._closeOnInteraction = !0)
                : this.isVisible() || this._onHide.next();
            }
            _toggleVisibility(t) {
              const i = this._tooltip.nativeElement,
                r = this._showAnimation,
                s = this._hideAnimation;
              if (
                (i.classList.remove(t ? s : r),
                i.classList.add(t ? r : s),
                (this._isVisible = t),
                t &&
                  !this._animationsDisabled &&
                  'function' == typeof getComputedStyle)
              ) {
                const o = getComputedStyle(i);
                ('0s' === o.getPropertyValue('animation-duration') ||
                  'none' === o.getPropertyValue('animation-name')) &&
                  (this._animationsDisabled = !0);
              }
              t && this._onShow(),
                this._animationsDisabled &&
                  (i.classList.add('_mat-animation-noopable'),
                  this._finalizeAnimation(t));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Br), D(Ii, 8));
            }),
            (n.ɵdir = J({ type: n })),
            n
          );
        })(),
        Jee = (() => {
          class n extends Qee {
            constructor(t, i, r) {
              super(t, r),
                (this._elementRef = i),
                (this._isMultiline = !1),
                (this._showAnimation = 'mat-mdc-tooltip-show'),
                (this._hideAnimation = 'mat-mdc-tooltip-hide');
            }
            _onShow() {
              (this._isMultiline = this._isTooltipMultiline()),
                this._markForCheck();
            }
            _isTooltipMultiline() {
              const t = this._elementRef.nativeElement.getBoundingClientRect();
              return t.height > 24 && t.width >= 200;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(D(Br), D(Ne), D(Ii, 8));
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-tooltip-component']],
              viewQuery: function (t, i) {
                if ((1 & t && vn(Bee, 7), 2 & t)) {
                  let r;
                  ut((r = ht())) && (i._tooltip = r.first);
                }
              },
              hostAttrs: ['aria-hidden', 'true'],
              hostVars: 2,
              hostBindings: function (t, i) {
                1 & t &&
                  pe('mouseleave', function (s) {
                    return i._handleMouseLeave(s);
                  }),
                  2 & t && Rl('zoom', i.isVisible() ? 1 : null);
              },
              features: [ye],
              decls: 4,
              vars: 4,
              consts: [
                [
                  1,
                  'mdc-tooltip',
                  'mdc-tooltip--shown',
                  'mat-mdc-tooltip',
                  3,
                  'ngClass',
                  'animationend',
                ],
                ['tooltip', ''],
                [1, 'mdc-tooltip__surface', 'mdc-tooltip__surface-animation'],
              ],
              template: function (t, i) {
                1 & t &&
                  (z(0, 'div', 0, 1),
                  pe('animationend', function (s) {
                    return i._handleAnimationEnd(s);
                  }),
                  z(2, 'div', 2),
                  Ue(3),
                  G()()),
                  2 & t &&
                    (_t('mdc-tooltip--multiline', i._isMultiline),
                    X('ngClass', i.tooltipClass),
                    Y(3),
                    Fl(i.message));
              },
              dependencies: [Hw],
              styles: [
                '.mdc-tooltip__surface{word-break:var(--mdc-tooltip-word-break, normal);overflow-wrap:anywhere}.mdc-tooltip{position:fixed;display:none;z-index:9}.mdc-tooltip-wrapper--rich{position:relative}.mdc-tooltip--shown,.mdc-tooltip--showing,.mdc-tooltip--hide{display:inline-flex}.mdc-tooltip--shown.mdc-tooltip--rich,.mdc-tooltip--showing.mdc-tooltip--rich,.mdc-tooltip--hide.mdc-tooltip--rich{display:inline-block;left:-320px;position:absolute}.mdc-tooltip__surface{line-height:16px;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center}.mdc-tooltip__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-tooltip__surface::before{border-color:CanvasText}}.mdc-tooltip--rich .mdc-tooltip__surface{align-items:flex-start;display:flex;flex-direction:column;min-height:24px;min-width:40px;max-width:320px;position:relative}.mdc-tooltip--multiline .mdc-tooltip__surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mdc-tooltip__surface,.mdc-tooltip--multiline .mdc-tooltip__surface[dir=rtl]{text-align:right}.mdc-tooltip__surface .mdc-tooltip__title{margin:0 8px}.mdc-tooltip__surface .mdc-tooltip__content{max-width:calc(200px - (2 * 8px));margin:8px;text-align:left}[dir=rtl] .mdc-tooltip__surface .mdc-tooltip__content,.mdc-tooltip__surface .mdc-tooltip__content[dir=rtl]{text-align:right}.mdc-tooltip--rich .mdc-tooltip__surface .mdc-tooltip__content{max-width:calc(320px - (2 * 8px));align-self:stretch}.mdc-tooltip__surface .mdc-tooltip__content-link{text-decoration:none}.mdc-tooltip--rich-actions,.mdc-tooltip__content,.mdc-tooltip__title{z-index:1}.mdc-tooltip__surface-animation{opacity:0;transform:scale(0.8);will-change:transform,opacity}.mdc-tooltip--shown .mdc-tooltip__surface-animation{transform:scale(1);opacity:1}.mdc-tooltip--hide .mdc-tooltip__surface-animation{transform:scale(1)}.mdc-tooltip__caret-surface-top,.mdc-tooltip__caret-surface-bottom{position:absolute;height:24px;width:24px;transform:rotate(35deg) skewY(20deg) scaleX(0.9396926208)}.mdc-tooltip__caret-surface-top .mdc-elevation-overlay,.mdc-tooltip__caret-surface-bottom .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-tooltip__caret-surface-bottom{outline:1px solid rgba(0,0,0,0);z-index:-1}@media screen and (forced-colors: active){.mdc-tooltip__caret-surface-bottom{outline-color:CanvasText}}.mdc-tooltip__surface{background-color:var(--mdc-plain-tooltip-container-color, #fff)}.mdc-tooltip__surface{border-radius:var(--mdc-plain-tooltip-container-shape, var(--mdc-shape-small, 4px))}.mdc-tooltip__caret-surface-top,.mdc-tooltip__caret-surface-bottom{border-radius:var(--mdc-plain-tooltip-container-shape, var(--mdc-shape-small, 4px))}.mdc-tooltip__surface{color:var(--mdc-plain-tooltip-supporting-text-color, #000)}.mdc-tooltip__surface{font-family:var(--mdc-plain-tooltip-supporting-text-font, inherit);font-size:var(--mdc-plain-tooltip-supporting-text-size, inherit);font-weight:var(--mdc-plain-tooltip-supporting-text-weight, inherit);letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking, inherit)}.mat-mdc-tooltip{position:relative;transform:scale(0)}.mat-mdc-tooltip::before{content:"";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        CN = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({
              providers: [jee],
              imports: [oQ, Jo, vN, Vt, Vt, Yl],
            })),
            n
          );
        })();
      class ete {
        get selected() {
          return (
            this._selected ||
              (this._selected = Array.from(this._selection.values())),
            this._selected
          );
        }
        constructor(e = !1, t, i = !0, r) {
          (this._multiple = e),
            (this._emitChanges = i),
            (this.compareWith = r),
            (this._selection = new Set()),
            (this._deselectedToEmit = []),
            (this._selectedToEmit = []),
            (this.changed = new Le()),
            t &&
              t.length &&
              (e
                ? t.forEach((s) => this._markSelected(s))
                : this._markSelected(t[0]),
              (this._selectedToEmit.length = 0));
        }
        select(...e) {
          this._verifyValueAssignment(e),
            e.forEach((i) => this._markSelected(i));
          const t = this._hasQueuedChanges();
          return this._emitChangeEvent(), t;
        }
        deselect(...e) {
          this._verifyValueAssignment(e),
            e.forEach((i) => this._unmarkSelected(i));
          const t = this._hasQueuedChanges();
          return this._emitChangeEvent(), t;
        }
        setSelection(...e) {
          this._verifyValueAssignment(e);
          const t = this.selected,
            i = new Set(e);
          e.forEach((s) => this._markSelected(s)),
            t.filter((s) => !i.has(s)).forEach((s) => this._unmarkSelected(s));
          const r = this._hasQueuedChanges();
          return this._emitChangeEvent(), r;
        }
        toggle(e) {
          return this.isSelected(e) ? this.deselect(e) : this.select(e);
        }
        clear(e = !0) {
          this._unmarkAll();
          const t = this._hasQueuedChanges();
          return e && this._emitChangeEvent(), t;
        }
        isSelected(e) {
          return this._selection.has(this._getConcreteValue(e));
        }
        isEmpty() {
          return 0 === this._selection.size;
        }
        hasValue() {
          return !this.isEmpty();
        }
        sort(e) {
          this._multiple && this.selected && this._selected.sort(e);
        }
        isMultipleSelection() {
          return this._multiple;
        }
        _emitChangeEvent() {
          (this._selected = null),
            (this._selectedToEmit.length || this._deselectedToEmit.length) &&
              (this.changed.next({
                source: this,
                added: this._selectedToEmit,
                removed: this._deselectedToEmit,
              }),
              (this._deselectedToEmit = []),
              (this._selectedToEmit = []));
        }
        _markSelected(e) {
          (e = this._getConcreteValue(e)),
            this.isSelected(e) ||
              (this._multiple || this._unmarkAll(),
              this.isSelected(e) || this._selection.add(e),
              this._emitChanges && this._selectedToEmit.push(e));
        }
        _unmarkSelected(e) {
          (e = this._getConcreteValue(e)),
            this.isSelected(e) &&
              (this._selection.delete(e),
              this._emitChanges && this._deselectedToEmit.push(e));
        }
        _unmarkAll() {
          this.isEmpty() ||
            this._selection.forEach((e) => this._unmarkSelected(e));
        }
        _verifyValueAssignment(e) {}
        _hasQueuedChanges() {
          return !(
            !this._deselectedToEmit.length && !this._selectedToEmit.length
          );
        }
        _getConcreteValue(e) {
          if (this.compareWith) {
            for (let t of this._selection) if (this.compareWith(e, t)) return t;
            return e;
          }
          return e;
        }
      }
      const nte = ['trigger'],
        ite = ['panel'];
      function rte(n, e) {
        if ((1 & n && (z(0, 'span', 10), Ue(1), G()), 2 & n)) {
          const t = Be();
          Y(1), Fl(t.placeholder);
        }
      }
      function ste(n, e) {
        if ((1 & n && (z(0, 'span', 14), Ue(1), G()), 2 & n)) {
          const t = Be(2);
          Y(1), Fl(t.triggerValue);
        }
      }
      function ote(n, e) {
        1 & n && dt(0, 0, ['*ngSwitchCase', 'true']);
      }
      function ate(n, e) {
        1 & n &&
          (z(0, 'span', 11),
          Ie(1, ste, 2, 1, 'span', 12),
          Ie(2, ote, 1, 0, 'ng-content', 13),
          G()),
          2 & n &&
            (X('ngSwitch', !!Be().customTrigger), Y(2), X('ngSwitchCase', !0));
      }
      function lte(n, e) {
        if (1 & n) {
          const t = Ui();
          Wi(),
            tr(),
            z(0, 'div', 15, 16),
            pe('@transformPanel.done', function (r) {
              return Hn(t), Wn(Be()._panelDoneAnimatingStream.next(r.toState));
            })('keydown', function (r) {
              return Hn(t), Wn(Be()._handleKeydown(r));
            }),
            dt(2, 1),
            G();
        }
        if (2 & n) {
          const t = Be();
          zy(
            'mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open ',
            t._getPanelTheme(),
            ''
          ),
            X('ngClass', t.panelClass)('@transformPanel', 'showing'),
            Dt('id', t.id + '-panel')('aria-multiselectable', t.multiple)(
              'aria-label',
              t.ariaLabel || null
            )('aria-labelledby', t._getPanelAriaLabelledby());
        }
      }
      const cte = [[['mat-select-trigger']], '*'],
        dte = ['mat-select-trigger', '*'],
        ute = {
          transformPanelWrap: au('transformPanelWrap', [
            Ks('* => void', c9('@transformPanel', [l9()], { optional: !0 })),
          ]),
          transformPanel: au('transformPanel', [
            zl('void', cr({ opacity: 0, transform: 'scale(1, 0.8)' })),
            Ks(
              'void => showing',
              na(
                '120ms cubic-bezier(0, 0, 0.2, 1)',
                cr({ opacity: 1, transform: 'scale(1, 1)' })
              )
            ),
            Ks('* => void', na('100ms linear', cr({ opacity: 0 }))),
          ]),
        };
      let xN = 0;
      const AN = new j('mat-select-scroll-strategy'),
        fte = new j('MAT_SELECT_CONFIG'),
        pte = {
          provide: AN,
          deps: [Kl],
          useFactory: function hte(n) {
            return () => n.scrollStrategies.reposition();
          },
        },
        mte = new j('MatSelectTrigger');
      class gte {
        constructor(e, t) {
          (this.source = e), (this.value = t);
        }
      }
      const _te = uE(
        fL(
          dE(
            pL(
              class {
                constructor(n, e, t, i, r) {
                  (this._elementRef = n),
                    (this._defaultErrorStateMatcher = e),
                    (this._parentForm = t),
                    (this._parentFormGroup = i),
                    (this.ngControl = r),
                    (this.stateChanges = new Le());
                }
              }
            )
          )
        )
      );
      let bte = (() => {
          class n extends _te {
            get focused() {
              return this._focused || this._panelOpen;
            }
            get placeholder() {
              return this._placeholder;
            }
            set placeholder(t) {
              (this._placeholder = t), this.stateChanges.next();
            }
            get required() {
              return (
                this._required ??
                this.ngControl?.control?.hasValidator(rF.required) ??
                !1
              );
            }
            set required(t) {
              (this._required = vt(t)), this.stateChanges.next();
            }
            get multiple() {
              return this._multiple;
            }
            set multiple(t) {
              this._multiple = vt(t);
            }
            get disableOptionCentering() {
              return this._disableOptionCentering;
            }
            set disableOptionCentering(t) {
              this._disableOptionCentering = vt(t);
            }
            get compareWith() {
              return this._compareWith;
            }
            set compareWith(t) {
              (this._compareWith = t),
                this._selectionModel && this._initializeSelection();
            }
            get value() {
              return this._value;
            }
            set value(t) {
              this._assignValue(t) && this._onChange(t);
            }
            get typeaheadDebounceInterval() {
              return this._typeaheadDebounceInterval;
            }
            set typeaheadDebounceInterval(t) {
              this._typeaheadDebounceInterval = _u(t);
            }
            get id() {
              return this._id;
            }
            set id(t) {
              (this._id = t || this._uid), this.stateChanges.next();
            }
            constructor(t, i, r, s, o, a, l, c, u, h, f, p, m, g) {
              super(o, s, l, c, h),
                (this._viewportRuler = t),
                (this._changeDetectorRef = i),
                (this._ngZone = r),
                (this._dir = a),
                (this._parentFormField = u),
                (this._liveAnnouncer = m),
                (this._defaultOptions = g),
                (this._panelOpen = !1),
                (this._compareWith = (w, y) => w === y),
                (this._uid = 'mat-select-' + xN++),
                (this._triggerAriaLabelledBy = null),
                (this._destroy = new Le()),
                (this._onChange = () => {}),
                (this._onTouched = () => {}),
                (this._valueId = 'mat-select-value-' + xN++),
                (this._panelDoneAnimatingStream = new Le()),
                (this._overlayPanelClass =
                  this._defaultOptions?.overlayPanelClass || ''),
                (this._focused = !1),
                (this.controlType = 'mat-select'),
                (this._multiple = !1),
                (this._disableOptionCentering =
                  this._defaultOptions?.disableOptionCentering ?? !1),
                (this.ariaLabel = ''),
                (this.optionSelectionChanges = (function tte(n) {
                  return new Mt((e) => {
                    Bn(n()).subscribe(e);
                  });
                })(() => {
                  const w = this.options;
                  return w
                    ? w.changes.pipe(
                        bu(w),
                        Gb(() => Ro(...w.map((y) => y.onSelectionChange)))
                      )
                    : this._ngZone.onStable.pipe(
                        ps(1),
                        Gb(() => this.optionSelectionChanges)
                      );
                })),
                (this.openedChange = new ke()),
                (this._openedStream = this.openedChange.pipe(
                  di((w) => w),
                  Gt(() => {})
                )),
                (this._closedStream = this.openedChange.pipe(
                  di((w) => !w),
                  Gt(() => {})
                )),
                (this.selectionChange = new ke()),
                (this.valueChange = new ke()),
                this.ngControl && (this.ngControl.valueAccessor = this),
                null != g?.typeaheadDebounceInterval &&
                  (this._typeaheadDebounceInterval =
                    g.typeaheadDebounceInterval),
                (this._scrollStrategyFactory = p),
                (this._scrollStrategy = this._scrollStrategyFactory()),
                (this.tabIndex = parseInt(f) || 0),
                (this.id = this.id);
            }
            ngOnInit() {
              (this._selectionModel = new ete(this.multiple)),
                this.stateChanges.next(),
                this._panelDoneAnimatingStream
                  .pipe(Sf(), se(this._destroy))
                  .subscribe(() => this._panelDoneAnimating(this.panelOpen));
            }
            ngAfterContentInit() {
              this._initKeyManager(),
                this._selectionModel.changed
                  .pipe(se(this._destroy))
                  .subscribe((t) => {
                    t.added.forEach((i) => i.select()),
                      t.removed.forEach((i) => i.deselect());
                  }),
                this.options.changes
                  .pipe(bu(null), se(this._destroy))
                  .subscribe(() => {
                    this._resetOptions(), this._initializeSelection();
                  });
            }
            ngDoCheck() {
              const t = this._getTriggerAriaLabelledby(),
                i = this.ngControl;
              if (t !== this._triggerAriaLabelledBy) {
                const r = this._elementRef.nativeElement;
                (this._triggerAriaLabelledBy = t),
                  t
                    ? r.setAttribute('aria-labelledby', t)
                    : r.removeAttribute('aria-labelledby');
              }
              i &&
                (this._previousControl !== i.control &&
                  (void 0 !== this._previousControl &&
                    null !== i.disabled &&
                    i.disabled !== this.disabled &&
                    (this.disabled = i.disabled),
                  (this._previousControl = i.control)),
                this.updateErrorState());
            }
            ngOnChanges(t) {
              (t.disabled || t.userAriaDescribedBy) && this.stateChanges.next(),
                t.typeaheadDebounceInterval &&
                  this._keyManager &&
                  this._keyManager.withTypeAhead(
                    this._typeaheadDebounceInterval
                  );
            }
            ngOnDestroy() {
              this._keyManager?.destroy(),
                this._destroy.next(),
                this._destroy.complete(),
                this.stateChanges.complete();
            }
            toggle() {
              this.panelOpen ? this.close() : this.open();
            }
            open() {
              this._canOpen() &&
                ((this._panelOpen = !0),
                this._keyManager.withHorizontalOrientation(null),
                this._highlightCorrectOption(),
                this._changeDetectorRef.markForCheck());
            }
            close() {
              this._panelOpen &&
                ((this._panelOpen = !1),
                this._keyManager.withHorizontalOrientation(
                  this._isRtl() ? 'rtl' : 'ltr'
                ),
                this._changeDetectorRef.markForCheck(),
                this._onTouched());
            }
            writeValue(t) {
              this._assignValue(t);
            }
            registerOnChange(t) {
              this._onChange = t;
            }
            registerOnTouched(t) {
              this._onTouched = t;
            }
            setDisabledState(t) {
              (this.disabled = t),
                this._changeDetectorRef.markForCheck(),
                this.stateChanges.next();
            }
            get panelOpen() {
              return this._panelOpen;
            }
            get selected() {
              return this.multiple
                ? this._selectionModel?.selected || []
                : this._selectionModel?.selected[0];
            }
            get triggerValue() {
              if (this.empty) return '';
              if (this._multiple) {
                const t = this._selectionModel.selected.map((i) => i.viewValue);
                return this._isRtl() && t.reverse(), t.join(', ');
              }
              return this._selectionModel.selected[0].viewValue;
            }
            _isRtl() {
              return !!this._dir && 'rtl' === this._dir.value;
            }
            _handleKeydown(t) {
              this.disabled ||
                (this.panelOpen
                  ? this._handleOpenKeydown(t)
                  : this._handleClosedKeydown(t));
            }
            _handleClosedKeydown(t) {
              const i = t.keyCode,
                r = 40 === i || 38 === i || 37 === i || 39 === i,
                s = 13 === i || 32 === i,
                o = this._keyManager;
              if (
                (!o.isTyping() && s && !aa(t)) ||
                ((this.multiple || t.altKey) && r)
              )
                t.preventDefault(), this.open();
              else if (!this.multiple) {
                const a = this.selected;
                o.onKeydown(t);
                const l = this.selected;
                l && a !== l && this._liveAnnouncer.announce(l.viewValue, 1e4);
              }
            }
            _handleOpenKeydown(t) {
              const i = this._keyManager,
                r = t.keyCode,
                s = 40 === r || 38 === r,
                o = i.isTyping();
              if (s && t.altKey) t.preventDefault(), this.close();
              else if (o || (13 !== r && 32 !== r) || !i.activeItem || aa(t))
                if (!o && this._multiple && 65 === r && t.ctrlKey) {
                  t.preventDefault();
                  const a = this.options.some(
                    (l) => !l.disabled && !l.selected
                  );
                  this.options.forEach((l) => {
                    l.disabled || (a ? l.select() : l.deselect());
                  });
                } else {
                  const a = i.activeItemIndex;
                  i.onKeydown(t),
                    this._multiple &&
                      s &&
                      t.shiftKey &&
                      i.activeItem &&
                      i.activeItemIndex !== a &&
                      i.activeItem._selectViaInteraction();
                }
              else t.preventDefault(), i.activeItem._selectViaInteraction();
            }
            _onFocus() {
              this.disabled || ((this._focused = !0), this.stateChanges.next());
            }
            _onBlur() {
              (this._focused = !1),
                this._keyManager?.cancelTypeahead(),
                !this.disabled &&
                  !this.panelOpen &&
                  (this._onTouched(),
                  this._changeDetectorRef.markForCheck(),
                  this.stateChanges.next());
            }
            _onAttached() {
              this._overlayDir.positionChange.pipe(ps(1)).subscribe(() => {
                this._changeDetectorRef.detectChanges(),
                  this._positioningSettled();
              });
            }
            _getPanelTheme() {
              return this._parentFormField
                ? `mat-${this._parentFormField.color}`
                : '';
            }
            get empty() {
              return !this._selectionModel || this._selectionModel.isEmpty();
            }
            _initializeSelection() {
              Promise.resolve().then(() => {
                this.ngControl && (this._value = this.ngControl.value),
                  this._setSelectionByValue(this._value),
                  this.stateChanges.next();
              });
            }
            _setSelectionByValue(t) {
              if (
                (this.options.forEach((i) => i.setInactiveStyles()),
                this._selectionModel.clear(),
                this.multiple && t)
              )
                Array.isArray(t),
                  t.forEach((i) => this._selectOptionByValue(i)),
                  this._sortValues();
              else {
                const i = this._selectOptionByValue(t);
                i
                  ? this._keyManager.updateActiveItem(i)
                  : this.panelOpen || this._keyManager.updateActiveItem(-1);
              }
              this._changeDetectorRef.markForCheck();
            }
            _selectOptionByValue(t) {
              const i = this.options.find((r) => {
                if (this._selectionModel.isSelected(r)) return !1;
                try {
                  return null != r.value && this._compareWith(r.value, t);
                } catch {
                  return !1;
                }
              });
              return i && this._selectionModel.select(i), i;
            }
            _assignValue(t) {
              return (
                !!(t !== this._value || (this._multiple && Array.isArray(t))) &&
                (this.options && this._setSelectionByValue(t),
                (this._value = t),
                !0)
              );
            }
            _skipPredicate(t) {
              return t.disabled;
            }
            _initKeyManager() {
              (this._keyManager = new VZ(this.options)
                .withTypeAhead(this._typeaheadDebounceInterval)
                .withVerticalOrientation()
                .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')
                .withHomeAndEnd()
                .withPageUpDown()
                .withAllowedModifierKeys(['shiftKey'])
                .skipPredicate(this._skipPredicate)),
                this._keyManager.tabOut.subscribe(() => {
                  this.panelOpen &&
                    (!this.multiple &&
                      this._keyManager.activeItem &&
                      this._keyManager.activeItem._selectViaInteraction(),
                    this.focus(),
                    this.close());
                }),
                this._keyManager.change.subscribe(() => {
                  this._panelOpen && this.panel
                    ? this._scrollOptionIntoView(
                        this._keyManager.activeItemIndex || 0
                      )
                    : !this._panelOpen &&
                      !this.multiple &&
                      this._keyManager.activeItem &&
                      this._keyManager.activeItem._selectViaInteraction();
                });
            }
            _resetOptions() {
              const t = Ro(this.options.changes, this._destroy);
              this.optionSelectionChanges.pipe(se(t)).subscribe((i) => {
                this._onSelect(i.source, i.isUserInput),
                  i.isUserInput &&
                    !this.multiple &&
                    this._panelOpen &&
                    (this.close(), this.focus());
              }),
                Ro(...this.options.map((i) => i._stateChanges))
                  .pipe(se(t))
                  .subscribe(() => {
                    this._changeDetectorRef.detectChanges(),
                      this.stateChanges.next();
                  });
            }
            _onSelect(t, i) {
              const r = this._selectionModel.isSelected(t);
              null != t.value || this._multiple
                ? (r !== t.selected &&
                    (t.selected
                      ? this._selectionModel.select(t)
                      : this._selectionModel.deselect(t)),
                  i && this._keyManager.setActiveItem(t),
                  this.multiple && (this._sortValues(), i && this.focus()))
                : (t.deselect(),
                  this._selectionModel.clear(),
                  null != this.value && this._propagateChanges(t.value)),
                r !== this._selectionModel.isSelected(t) &&
                  this._propagateChanges(),
                this.stateChanges.next();
            }
            _sortValues() {
              if (this.multiple) {
                const t = this.options.toArray();
                this._selectionModel.sort((i, r) =>
                  this.sortComparator
                    ? this.sortComparator(i, r, t)
                    : t.indexOf(i) - t.indexOf(r)
                ),
                  this.stateChanges.next();
              }
            }
            _propagateChanges(t) {
              let i = null;
              (i = this.multiple
                ? this.selected.map((r) => r.value)
                : this.selected
                ? this.selected.value
                : t),
                (this._value = i),
                this.valueChange.emit(i),
                this._onChange(i),
                this.selectionChange.emit(this._getChangeEvent(i)),
                this._changeDetectorRef.markForCheck();
            }
            _highlightCorrectOption() {
              if (this._keyManager)
                if (this.empty) {
                  let t = -1;
                  for (let i = 0; i < this.options.length; i++)
                    if (!this.options.get(i).disabled) {
                      t = i;
                      break;
                    }
                  this._keyManager.setActiveItem(t);
                } else
                  this._keyManager.setActiveItem(
                    this._selectionModel.selected[0]
                  );
            }
            _canOpen() {
              return (
                !this._panelOpen && !this.disabled && this.options?.length > 0
              );
            }
            focus(t) {
              this._elementRef.nativeElement.focus(t);
            }
            _getPanelAriaLabelledby() {
              if (this.ariaLabel) return null;
              const t = this._parentFormField?.getLabelId();
              return this.ariaLabelledby
                ? (t ? t + ' ' : '') + this.ariaLabelledby
                : t;
            }
            _getAriaActiveDescendant() {
              return this.panelOpen &&
                this._keyManager &&
                this._keyManager.activeItem
                ? this._keyManager.activeItem.id
                : null;
            }
            _getTriggerAriaLabelledby() {
              if (this.ariaLabel) return null;
              const t = this._parentFormField?.getLabelId();
              let i = (t ? t + ' ' : '') + this._valueId;
              return this.ariaLabelledby && (i += ' ' + this.ariaLabelledby), i;
            }
            _panelDoneAnimating(t) {
              this.openedChange.emit(t);
            }
            setDescribedByIds(t) {
              t.length
                ? this._elementRef.nativeElement.setAttribute(
                    'aria-describedby',
                    t.join(' ')
                  )
                : this._elementRef.nativeElement.removeAttribute(
                    'aria-describedby'
                  );
            }
            onContainerClick() {
              this.focus(), this.open();
            }
            get shouldLabelFloat() {
              return (
                this._panelOpen ||
                !this.empty ||
                (this._focused && !!this._placeholder)
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                D(Gm),
                D(Br),
                D(ue),
                D(mL),
                D(Ne),
                D(ca, 8),
                D(su, 8),
                D(ou, 8),
                D(_E, 8),
                D(Hr, 10),
                Bo('tabindex'),
                D(AN),
                D(rQ),
                D(fte, 8)
              );
            }),
            (n.ɵdir = J({
              type: n,
              viewQuery: function (t, i) {
                if ((1 & t && (vn(nte, 5), vn(ite, 5), vn(bN, 5)), 2 & t)) {
                  let r;
                  ut((r = ht())) && (i.trigger = r.first),
                    ut((r = ht())) && (i.panel = r.first),
                    ut((r = ht())) && (i._overlayDir = r.first);
                }
              },
              inputs: {
                userAriaDescribedBy: [
                  'aria-describedby',
                  'userAriaDescribedBy',
                ],
                panelClass: 'panelClass',
                placeholder: 'placeholder',
                required: 'required',
                multiple: 'multiple',
                disableOptionCentering: 'disableOptionCentering',
                compareWith: 'compareWith',
                value: 'value',
                ariaLabel: ['aria-label', 'ariaLabel'],
                ariaLabelledby: ['aria-labelledby', 'ariaLabelledby'],
                errorStateMatcher: 'errorStateMatcher',
                typeaheadDebounceInterval: 'typeaheadDebounceInterval',
                sortComparator: 'sortComparator',
                id: 'id',
              },
              outputs: {
                openedChange: 'openedChange',
                _openedStream: 'opened',
                _closedStream: 'closed',
                selectionChange: 'selectionChange',
                valueChange: 'valueChange',
              },
              features: [ye, ri],
            })),
            n
          );
        })(),
        vte = (() => {
          class n extends bte {
            constructor() {
              super(...arguments),
                (this._positions = [
                  {
                    originX: 'start',
                    originY: 'bottom',
                    overlayX: 'start',
                    overlayY: 'top',
                  },
                  {
                    originX: 'start',
                    originY: 'top',
                    overlayX: 'start',
                    overlayY: 'bottom',
                    panelClass: 'mat-mdc-select-panel-above',
                  },
                ]),
                (this._hideSingleSelectionIndicator =
                  this._defaultOptions?.hideSingleSelectionIndicator ?? !1),
                (this._skipPredicate = (t) => !this.panelOpen && t.disabled);
            }
            get shouldLabelFloat() {
              return (
                this.panelOpen ||
                !this.empty ||
                (this.focused && !!this.placeholder)
              );
            }
            ngOnInit() {
              super.ngOnInit(),
                this._viewportRuler
                  .change()
                  .pipe(se(this._destroy))
                  .subscribe(() => {
                    this.panelOpen &&
                      ((this._overlayWidth = this._getOverlayWidth()),
                      this._changeDetectorRef.detectChanges());
                  });
            }
            ngAfterViewInit() {
              this._parentFormField &&
                (this._preferredOverlayOrigin =
                  this._parentFormField.getConnectedOverlayOrigin());
            }
            open() {
              (this._overlayWidth = this._getOverlayWidth()),
                super.open(),
                this.stateChanges.next();
            }
            close() {
              super.close(), this.stateChanges.next();
            }
            _scrollOptionIntoView(t) {
              const i = this.options.toArray()[t];
              if (i) {
                const r = this.panel.nativeElement,
                  s = (function TQ(n, e, t) {
                    if (t.length) {
                      let i = e.toArray(),
                        r = t.toArray(),
                        s = 0;
                      for (let o = 0; o < n + 1; o++)
                        i[o].group && i[o].group === r[s] && s++;
                      return s;
                    }
                    return 0;
                  })(t, this.options, this.optionGroups),
                  o = i._getHostElement();
                r.scrollTop =
                  0 === t && 1 === s
                    ? 0
                    : (function IQ(n, e, t, i) {
                        return n < t
                          ? n
                          : n + e > t + i
                          ? Math.max(0, n - i + e)
                          : t;
                      })(
                        o.offsetTop,
                        o.offsetHeight,
                        r.scrollTop,
                        r.offsetHeight
                      );
              }
            }
            _positioningSettled() {
              this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);
            }
            _getChangeEvent(t) {
              return new gte(this, t);
            }
            _getOverlayWidth() {
              return (
                this._preferredOverlayOrigin instanceof EE
                  ? this._preferredOverlayOrigin.elementRef
                  : this._preferredOverlayOrigin || this._elementRef
              ).nativeElement.getBoundingClientRect().width;
            }
            get hideSingleSelectionIndicator() {
              return this._hideSingleSelectionIndicator;
            }
            set hideSingleSelectionIndicator(t) {
              (this._hideSingleSelectionIndicator = vt(t)),
                this._syncParentProperties();
            }
            _syncParentProperties() {
              if (this.options)
                for (const t of this.options)
                  t._changeDetectorRef.markForCheck();
            }
          }
          return (
            (n.ɵfac = (function () {
              let e;
              return function (i) {
                return (e || (e = pn(n)))(i || n);
              };
            })()),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-select']],
              contentQueries: function (t, i, r) {
                if (
                  (1 & t && (li(r, mte, 5), li(r, xL, 5), li(r, CL, 5)), 2 & t)
                ) {
                  let s;
                  ut((s = ht())) && (i.customTrigger = s.first),
                    ut((s = ht())) && (i.options = s),
                    ut((s = ht())) && (i.optionGroups = s);
                }
              },
              hostAttrs: [
                'role',
                'combobox',
                'aria-autocomplete',
                'none',
                'aria-haspopup',
                'listbox',
                'ngSkipHydration',
                '',
                1,
                'mat-mdc-select',
              ],
              hostVars: 19,
              hostBindings: function (t, i) {
                1 & t &&
                  pe('keydown', function (s) {
                    return i._handleKeydown(s);
                  })('focus', function () {
                    return i._onFocus();
                  })('blur', function () {
                    return i._onBlur();
                  }),
                  2 & t &&
                    (Dt('id', i.id)('tabindex', i.tabIndex)(
                      'aria-controls',
                      i.panelOpen ? i.id + '-panel' : null
                    )('aria-expanded', i.panelOpen)(
                      'aria-label',
                      i.ariaLabel || null
                    )('aria-required', i.required.toString())(
                      'aria-disabled',
                      i.disabled.toString()
                    )('aria-invalid', i.errorState)(
                      'aria-activedescendant',
                      i._getAriaActiveDescendant()
                    ),
                    _t('mat-mdc-select-disabled', i.disabled)(
                      'mat-mdc-select-invalid',
                      i.errorState
                    )('mat-mdc-select-required', i.required)(
                      'mat-mdc-select-empty',
                      i.empty
                    )('mat-mdc-select-multiple', i.multiple));
              },
              inputs: {
                disabled: 'disabled',
                disableRipple: 'disableRipple',
                tabIndex: 'tabIndex',
                hideSingleSelectionIndicator: 'hideSingleSelectionIndicator',
              },
              exportAs: ['matSelect'],
              features: [
                tt([
                  { provide: gE, useExisting: n },
                  { provide: EL, useExisting: n },
                ]),
                ye,
              ],
              ngContentSelectors: dte,
              decls: 11,
              vars: 11,
              consts: [
                [
                  'cdk-overlay-origin',
                  '',
                  1,
                  'mat-mdc-select-trigger',
                  3,
                  'click',
                ],
                ['fallbackOverlayOrigin', 'cdkOverlayOrigin', 'trigger', ''],
                [1, 'mat-mdc-select-value', 3, 'ngSwitch'],
                [
                  'class',
                  'mat-mdc-select-placeholder mat-mdc-select-min-line',
                  4,
                  'ngSwitchCase',
                ],
                [
                  'class',
                  'mat-mdc-select-value-text',
                  3,
                  'ngSwitch',
                  4,
                  'ngSwitchCase',
                ],
                [1, 'mat-mdc-select-arrow-wrapper'],
                [1, 'mat-mdc-select-arrow'],
                [
                  'viewBox',
                  '0 0 24 24',
                  'width',
                  '24px',
                  'height',
                  '24px',
                  'focusable',
                  'false',
                  'aria-hidden',
                  'true',
                ],
                ['d', 'M7 10l5 5 5-5z'],
                [
                  'cdk-connected-overlay',
                  '',
                  'cdkConnectedOverlayLockPosition',
                  '',
                  'cdkConnectedOverlayHasBackdrop',
                  '',
                  'cdkConnectedOverlayBackdropClass',
                  'cdk-overlay-transparent-backdrop',
                  3,
                  'cdkConnectedOverlayPanelClass',
                  'cdkConnectedOverlayScrollStrategy',
                  'cdkConnectedOverlayOrigin',
                  'cdkConnectedOverlayOpen',
                  'cdkConnectedOverlayPositions',
                  'cdkConnectedOverlayWidth',
                  'backdropClick',
                  'attach',
                  'detach',
                ],
                [1, 'mat-mdc-select-placeholder', 'mat-mdc-select-min-line'],
                [1, 'mat-mdc-select-value-text', 3, 'ngSwitch'],
                ['class', 'mat-mdc-select-min-line', 4, 'ngSwitchDefault'],
                [4, 'ngSwitchCase'],
                [1, 'mat-mdc-select-min-line'],
                ['role', 'listbox', 'tabindex', '-1', 3, 'ngClass', 'keydown'],
                ['panel', ''],
              ],
              template: function (t, i) {
                if (
                  (1 & t &&
                    (Pi(cte),
                    z(0, 'div', 0, 1),
                    pe('click', function () {
                      return i.toggle();
                    }),
                    z(3, 'div', 2),
                    Ie(4, rte, 2, 1, 'span', 3),
                    Ie(5, ate, 3, 2, 'span', 4),
                    G(),
                    z(6, 'div', 5)(7, 'div', 6),
                    Wi(),
                    z(8, 'svg', 7),
                    ct(9, 'path', 8),
                    G()()()(),
                    Ie(10, lte, 3, 9, 'ng-template', 9),
                    pe('backdropClick', function () {
                      return i.close();
                    })('attach', function () {
                      return i._onAttached();
                    })('detach', function () {
                      return i.close();
                    })),
                  2 & t)
                ) {
                  const r = Go(1);
                  Dt('aria-owns', i.panelOpen ? i.id + '-panel' : null),
                    Y(3),
                    X('ngSwitch', i.empty),
                    Dt('id', i._valueId),
                    Y(1),
                    X('ngSwitchCase', !0),
                    Y(1),
                    X('ngSwitchCase', !1),
                    Y(5),
                    X('cdkConnectedOverlayPanelClass', i._overlayPanelClass)(
                      'cdkConnectedOverlayScrollStrategy',
                      i._scrollStrategy
                    )(
                      'cdkConnectedOverlayOrigin',
                      i._preferredOverlayOrigin || r
                    )('cdkConnectedOverlayOpen', i.panelOpen)(
                      'cdkConnectedOverlayPositions',
                      i._positions
                    )('cdkConnectedOverlayWidth', i._overlayWidth);
                }
              },
              dependencies: [Hw, Qd, jw, CR, bN, EE],
              styles: [
                '.mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.mdc-menu-surface{max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height, calc(100vh - 32px));z-index:8;border-radius:4px;border-radius:var(--mdc-shape-medium, 4px)}.mat-mdc-select{display:inline-block;width:100%;outline:none}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:translateY(-8px)}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-select-arrow{width:10px;height:5px;position:relative}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:GrayText}.mdc-menu-surface.mat-mdc-select-panel{width:100%;max-height:275px;position:static;outline:0;margin:0;padding:8px 0;list-style-type:none}.mdc-menu-surface.mat-mdc-select-panel:focus{outline:none}.cdk-high-contrast-active .mdc-menu-surface.mat-mdc-select-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) .mdc-menu-surface.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above .mdc-menu-surface.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}',
              ],
              encapsulation: 2,
              data: { animation: [ute.transformPanel] },
              changeDetection: 0,
            })),
            n
          );
        })(),
        SN = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({
              providers: [pte],
              imports: [Jo, vN, AL, Vt, Yl, Eu, AL, Vt],
            })),
            n
          );
        })();
      function MN(n) {
        return gn((e, t) => {
          let s,
            i = null,
            r = !1;
          (i = e.subscribe(
            hn(t, void 0, void 0, (o) => {
              (s = Bn(n(o, MN(n)(e)))),
                i ? (i.unsubscribe(), (i = null), s.subscribe(t)) : (r = !0);
            })
          )),
            r && (i.unsubscribe(), (i = null), s.subscribe(t));
        });
      }
      class CE {}
      class gs {
        constructor(e) {
          (this.normalizedNames = new Map()),
            (this.lazyUpdate = null),
            e
              ? 'string' == typeof e
                ? (this.lazyInit = () => {
                    (this.headers = new Map()),
                      e.split('\n').forEach((t) => {
                        const i = t.indexOf(':');
                        if (i > 0) {
                          const r = t.slice(0, i),
                            s = r.toLowerCase(),
                            o = t.slice(i + 1).trim();
                          this.maybeSetNormalizedName(r, s),
                            this.headers.has(s)
                              ? this.headers.get(s).push(o)
                              : this.headers.set(s, [o]);
                        }
                      });
                  })
                : typeof Headers < 'u' && e instanceof Headers
                ? ((this.headers = new Map()),
                  e.forEach((t, i) => {
                    this.setHeaderEntries(i, t);
                  }))
                : (this.lazyInit = () => {
                    (this.headers = new Map()),
                      Object.entries(e).forEach(([t, i]) => {
                        this.setHeaderEntries(t, i);
                      });
                  })
              : (this.headers = new Map());
        }
        has(e) {
          return this.init(), this.headers.has(e.toLowerCase());
        }
        get(e) {
          this.init();
          const t = this.headers.get(e.toLowerCase());
          return t && t.length > 0 ? t[0] : null;
        }
        keys() {
          return this.init(), Array.from(this.normalizedNames.values());
        }
        getAll(e) {
          return this.init(), this.headers.get(e.toLowerCase()) || null;
        }
        append(e, t) {
          return this.clone({ name: e, value: t, op: 'a' });
        }
        set(e, t) {
          return this.clone({ name: e, value: t, op: 's' });
        }
        delete(e, t) {
          return this.clone({ name: e, value: t, op: 'd' });
        }
        maybeSetNormalizedName(e, t) {
          this.normalizedNames.has(t) || this.normalizedNames.set(t, e);
        }
        init() {
          this.lazyInit &&
            (this.lazyInit instanceof gs
              ? this.copyFrom(this.lazyInit)
              : this.lazyInit(),
            (this.lazyInit = null),
            this.lazyUpdate &&
              (this.lazyUpdate.forEach((e) => this.applyUpdate(e)),
              (this.lazyUpdate = null)));
        }
        copyFrom(e) {
          e.init(),
            Array.from(e.headers.keys()).forEach((t) => {
              this.headers.set(t, e.headers.get(t)),
                this.normalizedNames.set(t, e.normalizedNames.get(t));
            });
        }
        clone(e) {
          const t = new gs();
          return (
            (t.lazyInit =
              this.lazyInit && this.lazyInit instanceof gs
                ? this.lazyInit
                : this),
            (t.lazyUpdate = (this.lazyUpdate || []).concat([e])),
            t
          );
        }
        applyUpdate(e) {
          const t = e.name.toLowerCase();
          switch (e.op) {
            case 'a':
            case 's':
              let i = e.value;
              if (('string' == typeof i && (i = [i]), 0 === i.length)) return;
              this.maybeSetNormalizedName(e.name, t);
              const r = ('a' === e.op ? this.headers.get(t) : void 0) || [];
              r.push(...i), this.headers.set(t, r);
              break;
            case 'd':
              const s = e.value;
              if (s) {
                let o = this.headers.get(t);
                if (!o) return;
                (o = o.filter((a) => -1 === s.indexOf(a))),
                  0 === o.length
                    ? (this.headers.delete(t), this.normalizedNames.delete(t))
                    : this.headers.set(t, o);
              } else this.headers.delete(t), this.normalizedNames.delete(t);
          }
        }
        setHeaderEntries(e, t) {
          const i = (Array.isArray(t) ? t : [t]).map((s) => s.toString()),
            r = e.toLowerCase();
          this.headers.set(r, i), this.maybeSetNormalizedName(e, r);
        }
        forEach(e) {
          this.init(),
            Array.from(this.normalizedNames.keys()).forEach((t) =>
              e(this.normalizedNames.get(t), this.headers.get(t))
            );
        }
      }
      class Cte {
        encodeKey(e) {
          return DN(e);
        }
        encodeValue(e) {
          return DN(e);
        }
        decodeKey(e) {
          return decodeURIComponent(e);
        }
        decodeValue(e) {
          return decodeURIComponent(e);
        }
      }
      const Ate = /%(\d[a-f0-9])/gi,
        Ste = {
          40: '@',
          '3A': ':',
          24: '$',
          '2C': ',',
          '3B': ';',
          '3D': '=',
          '3F': '?',
          '2F': '/',
        };
      function DN(n) {
        return encodeURIComponent(n).replace(Ate, (e, t) => Ste[t] ?? e);
      }
      function Xm(n) {
        return `${n}`;
      }
      class eo {
        constructor(e = {}) {
          if (
            ((this.updates = null),
            (this.cloneFrom = null),
            (this.encoder = e.encoder || new Cte()),
            e.fromString)
          ) {
            if (e.fromObject)
              throw new Error('Cannot specify both fromString and fromObject.');
            this.map = (function xte(n, e) {
              const t = new Map();
              return (
                n.length > 0 &&
                  n
                    .replace(/^\?/, '')
                    .split('&')
                    .forEach((r) => {
                      const s = r.indexOf('='),
                        [o, a] =
                          -1 == s
                            ? [e.decodeKey(r), '']
                            : [
                                e.decodeKey(r.slice(0, s)),
                                e.decodeValue(r.slice(s + 1)),
                              ],
                        l = t.get(o) || [];
                      l.push(a), t.set(o, l);
                    }),
                t
              );
            })(e.fromString, this.encoder);
          } else
            e.fromObject
              ? ((this.map = new Map()),
                Object.keys(e.fromObject).forEach((t) => {
                  const i = e.fromObject[t],
                    r = Array.isArray(i) ? i.map(Xm) : [Xm(i)];
                  this.map.set(t, r);
                }))
              : (this.map = null);
        }
        has(e) {
          return this.init(), this.map.has(e);
        }
        get(e) {
          this.init();
          const t = this.map.get(e);
          return t ? t[0] : null;
        }
        getAll(e) {
          return this.init(), this.map.get(e) || null;
        }
        keys() {
          return this.init(), Array.from(this.map.keys());
        }
        append(e, t) {
          return this.clone({ param: e, value: t, op: 'a' });
        }
        appendAll(e) {
          const t = [];
          return (
            Object.keys(e).forEach((i) => {
              const r = e[i];
              Array.isArray(r)
                ? r.forEach((s) => {
                    t.push({ param: i, value: s, op: 'a' });
                  })
                : t.push({ param: i, value: r, op: 'a' });
            }),
            this.clone(t)
          );
        }
        set(e, t) {
          return this.clone({ param: e, value: t, op: 's' });
        }
        delete(e, t) {
          return this.clone({ param: e, value: t, op: 'd' });
        }
        toString() {
          return (
            this.init(),
            this.keys()
              .map((e) => {
                const t = this.encoder.encodeKey(e);
                return this.map
                  .get(e)
                  .map((i) => t + '=' + this.encoder.encodeValue(i))
                  .join('&');
              })
              .filter((e) => '' !== e)
              .join('&')
          );
        }
        clone(e) {
          const t = new eo({ encoder: this.encoder });
          return (
            (t.cloneFrom = this.cloneFrom || this),
            (t.updates = (this.updates || []).concat(e)),
            t
          );
        }
        init() {
          null === this.map && (this.map = new Map()),
            null !== this.cloneFrom &&
              (this.cloneFrom.init(),
              this.cloneFrom
                .keys()
                .forEach((e) => this.map.set(e, this.cloneFrom.map.get(e))),
              this.updates.forEach((e) => {
                switch (e.op) {
                  case 'a':
                  case 's':
                    const t =
                      ('a' === e.op ? this.map.get(e.param) : void 0) || [];
                    t.push(Xm(e.value)), this.map.set(e.param, t);
                    break;
                  case 'd':
                    if (void 0 === e.value) {
                      this.map.delete(e.param);
                      break;
                    }
                    {
                      let i = this.map.get(e.param) || [];
                      const r = i.indexOf(Xm(e.value));
                      -1 !== r && i.splice(r, 1),
                        i.length > 0
                          ? this.map.set(e.param, i)
                          : this.map.delete(e.param);
                    }
                }
              }),
              (this.cloneFrom = this.updates = null));
        }
      }
      class Mte {
        constructor() {
          this.map = new Map();
        }
        set(e, t) {
          return this.map.set(e, t), this;
        }
        get(e) {
          return (
            this.map.has(e) || this.map.set(e, e.defaultValue()),
            this.map.get(e)
          );
        }
        delete(e) {
          return this.map.delete(e), this;
        }
        has(e) {
          return this.map.has(e);
        }
        keys() {
          return this.map.keys();
        }
      }
      function TN(n) {
        return typeof ArrayBuffer < 'u' && n instanceof ArrayBuffer;
      }
      function IN(n) {
        return typeof Blob < 'u' && n instanceof Blob;
      }
      function kN(n) {
        return typeof FormData < 'u' && n instanceof FormData;
      }
      class xu {
        constructor(e, t, i, r) {
          let s;
          if (
            ((this.url = t),
            (this.body = null),
            (this.reportProgress = !1),
            (this.withCredentials = !1),
            (this.responseType = 'json'),
            (this.method = e.toUpperCase()),
            (function Dte(n) {
              switch (n) {
                case 'DELETE':
                case 'GET':
                case 'HEAD':
                case 'OPTIONS':
                case 'JSONP':
                  return !1;
                default:
                  return !0;
              }
            })(this.method) || r
              ? ((this.body = void 0 !== i ? i : null), (s = r))
              : (s = i),
            s &&
              ((this.reportProgress = !!s.reportProgress),
              (this.withCredentials = !!s.withCredentials),
              s.responseType && (this.responseType = s.responseType),
              s.headers && (this.headers = s.headers),
              s.context && (this.context = s.context),
              s.params && (this.params = s.params)),
            this.headers || (this.headers = new gs()),
            this.context || (this.context = new Mte()),
            this.params)
          ) {
            const o = this.params.toString();
            if (0 === o.length) this.urlWithParams = t;
            else {
              const a = t.indexOf('?');
              this.urlWithParams =
                t + (-1 === a ? '?' : a < t.length - 1 ? '&' : '') + o;
            }
          } else (this.params = new eo()), (this.urlWithParams = t);
        }
        serializeBody() {
          return null === this.body
            ? null
            : TN(this.body) ||
              IN(this.body) ||
              kN(this.body) ||
              (function Tte(n) {
                return (
                  typeof URLSearchParams < 'u' && n instanceof URLSearchParams
                );
              })(this.body) ||
              'string' == typeof this.body
            ? this.body
            : this.body instanceof eo
            ? this.body.toString()
            : 'object' == typeof this.body ||
              'boolean' == typeof this.body ||
              Array.isArray(this.body)
            ? JSON.stringify(this.body)
            : this.body.toString();
        }
        detectContentTypeHeader() {
          return null === this.body || kN(this.body)
            ? null
            : IN(this.body)
            ? this.body.type || null
            : TN(this.body)
            ? null
            : 'string' == typeof this.body
            ? 'text/plain'
            : this.body instanceof eo
            ? 'application/x-www-form-urlencoded;charset=UTF-8'
            : 'object' == typeof this.body ||
              'number' == typeof this.body ||
              'boolean' == typeof this.body
            ? 'application/json'
            : null;
        }
        clone(e = {}) {
          const t = e.method || this.method,
            i = e.url || this.url,
            r = e.responseType || this.responseType,
            s = void 0 !== e.body ? e.body : this.body,
            o =
              void 0 !== e.withCredentials
                ? e.withCredentials
                : this.withCredentials,
            a =
              void 0 !== e.reportProgress
                ? e.reportProgress
                : this.reportProgress;
          let l = e.headers || this.headers,
            c = e.params || this.params;
          const u = e.context ?? this.context;
          return (
            void 0 !== e.setHeaders &&
              (l = Object.keys(e.setHeaders).reduce(
                (h, f) => h.set(f, e.setHeaders[f]),
                l
              )),
            e.setParams &&
              (c = Object.keys(e.setParams).reduce(
                (h, f) => h.set(f, e.setParams[f]),
                c
              )),
            new xu(t, i, s, {
              params: c,
              headers: l,
              context: u,
              reportProgress: a,
              responseType: r,
              withCredentials: o,
            })
          );
        }
      }
      var wn = (() => (
        ((wn = wn || {})[(wn.Sent = 0)] = 'Sent'),
        (wn[(wn.UploadProgress = 1)] = 'UploadProgress'),
        (wn[(wn.ResponseHeader = 2)] = 'ResponseHeader'),
        (wn[(wn.DownloadProgress = 3)] = 'DownloadProgress'),
        (wn[(wn.Response = 4)] = 'Response'),
        (wn[(wn.User = 5)] = 'User'),
        wn
      ))();
      class Ite {
        constructor(e, t = 200, i = 'OK') {
          (this.headers = e.headers || new gs()),
            (this.status = void 0 !== e.status ? e.status : t),
            (this.statusText = e.statusText || i),
            (this.url = e.url || null),
            (this.ok = this.status >= 200 && this.status < 300);
        }
      }
      class Au extends Ite {
        constructor(e = {}) {
          super(e),
            (this.type = wn.Response),
            (this.body = void 0 !== e.body ? e.body : null);
        }
        clone(e = {}) {
          return new Au({
            body: void 0 !== e.body ? e.body : this.body,
            headers: e.headers || this.headers,
            status: void 0 !== e.status ? e.status : this.status,
            statusText: e.statusText || this.statusText,
            url: e.url || this.url || void 0,
          });
        }
      }
      function AE(n, e) {
        return {
          body: e,
          headers: n.headers,
          context: n.context,
          observe: n.observe,
          params: n.params,
          reportProgress: n.reportProgress,
          responseType: n.responseType,
          withCredentials: n.withCredentials,
        };
      }
      let SE = (() => {
        class n {
          constructor(t) {
            this.handler = t;
          }
          request(t, i, r = {}) {
            let s;
            if (t instanceof xu) s = t;
            else {
              let l, c;
              (l = r.headers instanceof gs ? r.headers : new gs(r.headers)),
                r.params &&
                  (c =
                    r.params instanceof eo
                      ? r.params
                      : new eo({ fromObject: r.params })),
                (s = new xu(t, i, void 0 !== r.body ? r.body : null, {
                  headers: l,
                  context: r.context,
                  params: c,
                  reportProgress: r.reportProgress,
                  responseType: r.responseType || 'json',
                  withCredentials: r.withCredentials,
                }));
            }
            const o = ts(s).pipe(
              (function Ete(n, e) {
                return ot(e) ? Qc(n, e, 1) : Qc(n, 1);
              })((l) => this.handler.handle(l))
            );
            if (t instanceof xu || 'events' === r.observe) return o;
            const a = o.pipe(di((l) => l instanceof Au));
            switch (r.observe || 'body') {
              case 'body':
                switch (s.responseType) {
                  case 'arraybuffer':
                    return a.pipe(
                      Gt((l) => {
                        if (null !== l.body && !(l.body instanceof ArrayBuffer))
                          throw new Error('Response is not an ArrayBuffer.');
                        return l.body;
                      })
                    );
                  case 'blob':
                    return a.pipe(
                      Gt((l) => {
                        if (null !== l.body && !(l.body instanceof Blob))
                          throw new Error('Response is not a Blob.');
                        return l.body;
                      })
                    );
                  case 'text':
                    return a.pipe(
                      Gt((l) => {
                        if (null !== l.body && 'string' != typeof l.body)
                          throw new Error('Response is not a string.');
                        return l.body;
                      })
                    );
                  default:
                    return a.pipe(Gt((l) => l.body));
                }
              case 'response':
                return a;
              default:
                throw new Error(
                  `Unreachable: unhandled observe type ${r.observe}}`
                );
            }
          }
          delete(t, i = {}) {
            return this.request('DELETE', t, i);
          }
          get(t, i = {}) {
            return this.request('GET', t, i);
          }
          head(t, i = {}) {
            return this.request('HEAD', t, i);
          }
          jsonp(t, i) {
            return this.request('JSONP', t, {
              params: new eo().append(i, 'JSONP_CALLBACK'),
              observe: 'body',
              responseType: 'json',
            });
          }
          options(t, i = {}) {
            return this.request('OPTIONS', t, i);
          }
          patch(t, i, r = {}) {
            return this.request('PATCH', t, AE(r, i));
          }
          post(t, i, r = {}) {
            return this.request('POST', t, AE(r, i));
          }
          put(t, i, r = {}) {
            return this.request('PUT', t, AE(r, i));
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(CE));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const Kte = ['*'];
      let Zm;
      function Su(n) {
        return (
          (function Zte() {
            if (void 0 === Zm && ((Zm = null), typeof window < 'u')) {
              const n = window;
              void 0 !== n.trustedTypes &&
                (Zm = n.trustedTypes.createPolicy('angular#components', {
                  createHTML: (e) => e,
                }));
            }
            return Zm;
          })()?.createHTML(n) || n
        );
      }
      function WN(n) {
        return Error(`Unable to find icon with the name "${n}"`);
      }
      function jN(n) {
        return Error(
          `The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${n}".`
        );
      }
      function zN(n) {
        return Error(
          `The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${n}".`
        );
      }
      class fa {
        constructor(e, t, i) {
          (this.url = e), (this.svgText = t), (this.options = i);
        }
      }
      let Qm = (() => {
        class n {
          constructor(t, i, r, s) {
            (this._httpClient = t),
              (this._sanitizer = i),
              (this._errorHandler = s),
              (this._svgIconConfigs = new Map()),
              (this._iconSetConfigs = new Map()),
              (this._cachedIconsByUrl = new Map()),
              (this._inProgressUrlFetches = new Map()),
              (this._fontCssClassesByAlias = new Map()),
              (this._resolvers = []),
              (this._defaultFontSetClass = [
                'material-icons',
                'mat-ligature-font',
              ]),
              (this._document = r);
          }
          addSvgIcon(t, i, r) {
            return this.addSvgIconInNamespace('', t, i, r);
          }
          addSvgIconLiteral(t, i, r) {
            return this.addSvgIconLiteralInNamespace('', t, i, r);
          }
          addSvgIconInNamespace(t, i, r, s) {
            return this._addSvgIconConfig(t, i, new fa(r, null, s));
          }
          addSvgIconResolver(t) {
            return this._resolvers.push(t), this;
          }
          addSvgIconLiteralInNamespace(t, i, r, s) {
            const o = this._sanitizer.sanitize(rt.HTML, r);
            if (!o) throw zN(r);
            const a = Su(o);
            return this._addSvgIconConfig(t, i, new fa('', a, s));
          }
          addSvgIconSet(t, i) {
            return this.addSvgIconSetInNamespace('', t, i);
          }
          addSvgIconSetLiteral(t, i) {
            return this.addSvgIconSetLiteralInNamespace('', t, i);
          }
          addSvgIconSetInNamespace(t, i, r) {
            return this._addSvgIconSetConfig(t, new fa(i, null, r));
          }
          addSvgIconSetLiteralInNamespace(t, i, r) {
            const s = this._sanitizer.sanitize(rt.HTML, i);
            if (!s) throw zN(i);
            const o = Su(s);
            return this._addSvgIconSetConfig(t, new fa('', o, r));
          }
          registerFontClassAlias(t, i = t) {
            return this._fontCssClassesByAlias.set(t, i), this;
          }
          classNameForFontAlias(t) {
            return this._fontCssClassesByAlias.get(t) || t;
          }
          setDefaultFontSetClass(...t) {
            return (this._defaultFontSetClass = t), this;
          }
          getDefaultFontSetClass() {
            return this._defaultFontSetClass;
          }
          getSvgIconFromUrl(t) {
            const i = this._sanitizer.sanitize(rt.RESOURCE_URL, t);
            if (!i) throw jN(t);
            const r = this._cachedIconsByUrl.get(i);
            return r
              ? ts(Jm(r))
              : this._loadSvgIconFromConfig(new fa(t, null)).pipe(
                  Fm((s) => this._cachedIconsByUrl.set(i, s)),
                  Gt((s) => Jm(s))
                );
          }
          getNamedSvgIcon(t, i = '') {
            const r = UN(i, t);
            let s = this._svgIconConfigs.get(r);
            if (s) return this._getSvgFromConfig(s);
            if (((s = this._getIconConfigFromResolvers(i, t)), s))
              return this._svgIconConfigs.set(r, s), this._getSvgFromConfig(s);
            const o = this._iconSetConfigs.get(i);
            return o
              ? this._getSvgFromIconSetConfigs(t, o)
              : (function yte(n, e) {
                  const t = ot(n) ? n : () => n,
                    i = (r) => r.error(t());
                  return new Mt(e ? (r) => e.schedule(i, 0, r) : i);
                })(WN(r));
          }
          ngOnDestroy() {
            (this._resolvers = []),
              this._svgIconConfigs.clear(),
              this._iconSetConfigs.clear(),
              this._cachedIconsByUrl.clear();
          }
          _getSvgFromConfig(t) {
            return t.svgText
              ? ts(Jm(this._svgElementFromConfig(t)))
              : this._loadSvgIconFromConfig(t).pipe(Gt((i) => Jm(i)));
          }
          _getSvgFromIconSetConfigs(t, i) {
            const r = this._extractIconWithNameFromAnySet(t, i);
            return r
              ? ts(r)
              : eF(
                  i
                    .filter((o) => !o.svgText)
                    .map((o) =>
                      this._loadSvgIconSetFromConfig(o).pipe(
                        MN((a) => {
                          const c = `Loading icon set URL: ${this._sanitizer.sanitize(
                            rt.RESOURCE_URL,
                            o.url
                          )} failed: ${a.message}`;
                          return (
                            this._errorHandler.handleError(new Error(c)),
                            ts(null)
                          );
                        })
                      )
                    )
                ).pipe(
                  Gt(() => {
                    const o = this._extractIconWithNameFromAnySet(t, i);
                    if (!o) throw WN(t);
                    return o;
                  })
                );
          }
          _extractIconWithNameFromAnySet(t, i) {
            for (let r = i.length - 1; r >= 0; r--) {
              const s = i[r];
              if (s.svgText && s.svgText.toString().indexOf(t) > -1) {
                const o = this._svgElementFromConfig(s),
                  a = this._extractSvgIconFromSet(o, t, s.options);
                if (a) return a;
              }
            }
            return null;
          }
          _loadSvgIconFromConfig(t) {
            return this._fetchIcon(t).pipe(
              Fm((i) => (t.svgText = i)),
              Gt(() => this._svgElementFromConfig(t))
            );
          }
          _loadSvgIconSetFromConfig(t) {
            return t.svgText
              ? ts(null)
              : this._fetchIcon(t).pipe(Fm((i) => (t.svgText = i)));
          }
          _extractSvgIconFromSet(t, i, r) {
            const s = t.querySelector(`[id="${i}"]`);
            if (!s) return null;
            const o = s.cloneNode(!0);
            if ((o.removeAttribute('id'), 'svg' === o.nodeName.toLowerCase()))
              return this._setSvgAttributes(o, r);
            if ('symbol' === o.nodeName.toLowerCase())
              return this._setSvgAttributes(this._toSvgElement(o), r);
            const a = this._svgElementFromString(Su('<svg></svg>'));
            return a.appendChild(o), this._setSvgAttributes(a, r);
          }
          _svgElementFromString(t) {
            const i = this._document.createElement('DIV');
            i.innerHTML = t;
            const r = i.querySelector('svg');
            if (!r) throw Error('<svg> tag not found');
            return r;
          }
          _toSvgElement(t) {
            const i = this._svgElementFromString(Su('<svg></svg>')),
              r = t.attributes;
            for (let s = 0; s < r.length; s++) {
              const { name: o, value: a } = r[s];
              'id' !== o && i.setAttribute(o, a);
            }
            for (let s = 0; s < t.childNodes.length; s++)
              t.childNodes[s].nodeType === this._document.ELEMENT_NODE &&
                i.appendChild(t.childNodes[s].cloneNode(!0));
            return i;
          }
          _setSvgAttributes(t, i) {
            return (
              t.setAttribute('fit', ''),
              t.setAttribute('height', '100%'),
              t.setAttribute('width', '100%'),
              t.setAttribute('preserveAspectRatio', 'xMidYMid meet'),
              t.setAttribute('focusable', 'false'),
              i && i.viewBox && t.setAttribute('viewBox', i.viewBox),
              t
            );
          }
          _fetchIcon(t) {
            const { url: i, options: r } = t,
              s = r?.withCredentials ?? !1;
            if (!this._httpClient)
              throw (function Qte() {
                return Error(
                  'Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.'
                );
              })();
            if (null == i) throw Error(`Cannot fetch icon from URL "${i}".`);
            const o = this._sanitizer.sanitize(rt.RESOURCE_URL, i);
            if (!o) throw jN(i);
            const a = this._inProgressUrlFetches.get(o);
            if (a) return a;
            const l = this._httpClient
              .get(o, { responseType: 'text', withCredentials: s })
              .pipe(
                Gt((c) => Su(c)),
                (function wte(n) {
                  return gn((e, t) => {
                    try {
                      e.subscribe(t);
                    } finally {
                      t.add(n);
                    }
                  });
                })(() => this._inProgressUrlFetches.delete(o)),
                Ub()
              );
            return this._inProgressUrlFetches.set(o, l), l;
          }
          _addSvgIconConfig(t, i, r) {
            return this._svgIconConfigs.set(UN(t, i), r), this;
          }
          _addSvgIconSetConfig(t, i) {
            const r = this._iconSetConfigs.get(t);
            return r ? r.push(i) : this._iconSetConfigs.set(t, [i]), this;
          }
          _svgElementFromConfig(t) {
            if (!t.svgElement) {
              const i = this._svgElementFromString(t.svgText);
              this._setSvgAttributes(i, t.options), (t.svgElement = i);
            }
            return t.svgElement;
          }
          _getIconConfigFromResolvers(t, i) {
            for (let r = 0; r < this._resolvers.length; r++) {
              const s = this._resolvers[r](i, t);
              if (s)
                return ene(s)
                  ? new fa(s.url, null, s.options)
                  : new fa(s, null);
            }
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(L(SE, 8), L(n0), L(He, 8), L(Pr));
          }),
          (n.ɵprov = ee({ token: n, factory: n.ɵfac, providedIn: 'root' })),
          n
        );
      })();
      function Jm(n) {
        return n.cloneNode(!0);
      }
      function UN(n, e) {
        return n + ':' + e;
      }
      function ene(n) {
        return !(!n.url || !n.options);
      }
      const tne = Wm(
          class {
            constructor(n) {
              this._elementRef = n;
            }
          }
        ),
        nne = new j('MAT_ICON_DEFAULT_OPTIONS'),
        ine = new j('mat-icon-location', {
          providedIn: 'root',
          factory: function rne() {
            const n = Te(He),
              e = n ? n.location : null;
            return { getPathname: () => (e ? e.pathname + e.search : '') };
          },
        }),
        $N = [
          'clip-path',
          'color-profile',
          'src',
          'cursor',
          'fill',
          'filter',
          'marker',
          'marker-start',
          'marker-mid',
          'marker-end',
          'mask',
          'stroke',
        ],
        sne = $N.map((n) => `[${n}]`).join(', '),
        one = /^url\(['"]?#(.*?)['"]?\)$/;
      let QN,
        ane = (() => {
          class n extends tne {
            get inline() {
              return this._inline;
            }
            set inline(t) {
              this._inline = vt(t);
            }
            get svgIcon() {
              return this._svgIcon;
            }
            set svgIcon(t) {
              t !== this._svgIcon &&
                (t
                  ? this._updateSvgIcon(t)
                  : this._svgIcon && this._clearSvgElement(),
                (this._svgIcon = t));
            }
            get fontSet() {
              return this._fontSet;
            }
            set fontSet(t) {
              const i = this._cleanupFontValue(t);
              i !== this._fontSet &&
                ((this._fontSet = i), this._updateFontIconClasses());
            }
            get fontIcon() {
              return this._fontIcon;
            }
            set fontIcon(t) {
              const i = this._cleanupFontValue(t);
              i !== this._fontIcon &&
                ((this._fontIcon = i), this._updateFontIconClasses());
            }
            constructor(t, i, r, s, o, a) {
              super(t),
                (this._iconRegistry = i),
                (this._location = s),
                (this._errorHandler = o),
                (this._inline = !1),
                (this._previousFontSetClass = []),
                (this._currentIconFetch = $t.EMPTY),
                a &&
                  (a.color && (this.color = this.defaultColor = a.color),
                  a.fontSet && (this.fontSet = a.fontSet)),
                r || t.nativeElement.setAttribute('aria-hidden', 'true');
            }
            _splitIconName(t) {
              if (!t) return ['', ''];
              const i = t.split(':');
              switch (i.length) {
                case 1:
                  return ['', i[0]];
                case 2:
                  return i;
                default:
                  throw Error(`Invalid icon name: "${t}"`);
              }
            }
            ngOnInit() {
              this._updateFontIconClasses();
            }
            ngAfterViewChecked() {
              const t = this._elementsWithExternalReferences;
              if (t && t.size) {
                const i = this._location.getPathname();
                i !== this._previousPath &&
                  ((this._previousPath = i), this._prependPathToReferences(i));
              }
            }
            ngOnDestroy() {
              this._currentIconFetch.unsubscribe(),
                this._elementsWithExternalReferences &&
                  this._elementsWithExternalReferences.clear();
            }
            _usingFontIcon() {
              return !this.svgIcon;
            }
            _setSvgElement(t) {
              this._clearSvgElement();
              const i = this._location.getPathname();
              (this._previousPath = i),
                this._cacheChildrenWithExternalReferences(t),
                this._prependPathToReferences(i),
                this._elementRef.nativeElement.appendChild(t);
            }
            _clearSvgElement() {
              const t = this._elementRef.nativeElement;
              let i = t.childNodes.length;
              for (
                this._elementsWithExternalReferences &&
                this._elementsWithExternalReferences.clear();
                i--;

              ) {
                const r = t.childNodes[i];
                (1 !== r.nodeType || 'svg' === r.nodeName.toLowerCase()) &&
                  r.remove();
              }
            }
            _updateFontIconClasses() {
              if (!this._usingFontIcon()) return;
              const t = this._elementRef.nativeElement,
                i = (
                  this.fontSet
                    ? this._iconRegistry
                        .classNameForFontAlias(this.fontSet)
                        .split(/ +/)
                    : this._iconRegistry.getDefaultFontSetClass()
                ).filter((r) => r.length > 0);
              this._previousFontSetClass.forEach((r) => t.classList.remove(r)),
                i.forEach((r) => t.classList.add(r)),
                (this._previousFontSetClass = i),
                this.fontIcon !== this._previousFontIconClass &&
                  !i.includes('mat-ligature-font') &&
                  (this._previousFontIconClass &&
                    t.classList.remove(this._previousFontIconClass),
                  this.fontIcon && t.classList.add(this.fontIcon),
                  (this._previousFontIconClass = this.fontIcon));
            }
            _cleanupFontValue(t) {
              return 'string' == typeof t ? t.trim().split(' ')[0] : t;
            }
            _prependPathToReferences(t) {
              const i = this._elementsWithExternalReferences;
              i &&
                i.forEach((r, s) => {
                  r.forEach((o) => {
                    s.setAttribute(o.name, `url('${t}#${o.value}')`);
                  });
                });
            }
            _cacheChildrenWithExternalReferences(t) {
              const i = t.querySelectorAll(sne),
                r = (this._elementsWithExternalReferences =
                  this._elementsWithExternalReferences || new Map());
              for (let s = 0; s < i.length; s++)
                $N.forEach((o) => {
                  const a = i[s],
                    l = a.getAttribute(o),
                    c = l ? l.match(one) : null;
                  if (c) {
                    let u = r.get(a);
                    u || ((u = []), r.set(a, u)),
                      u.push({ name: o, value: c[1] });
                  }
                });
            }
            _updateSvgIcon(t) {
              if (
                ((this._svgNamespace = null),
                (this._svgName = null),
                this._currentIconFetch.unsubscribe(),
                t)
              ) {
                const [i, r] = this._splitIconName(t);
                i && (this._svgNamespace = i),
                  r && (this._svgName = r),
                  (this._currentIconFetch = this._iconRegistry
                    .getNamedSvgIcon(r, i)
                    .pipe(ps(1))
                    .subscribe(
                      (s) => this._setSvgElement(s),
                      (s) => {
                        this._errorHandler.handleError(
                          new Error(
                            `Error retrieving icon ${i}:${r}! ${s.message}`
                          )
                        );
                      }
                    ));
              }
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                D(Ne),
                D(Qm),
                Bo('aria-hidden'),
                D(ine),
                D(Pr),
                D(nne, 8)
              );
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['mat-icon']],
              hostAttrs: ['role', 'img', 1, 'mat-icon', 'notranslate'],
              hostVars: 8,
              hostBindings: function (t, i) {
                2 & t &&
                  (Dt(
                    'data-mat-icon-type',
                    i._usingFontIcon() ? 'font' : 'svg'
                  )('data-mat-icon-name', i._svgName || i.fontIcon)(
                    'data-mat-icon-namespace',
                    i._svgNamespace || i.fontSet
                  )('fontIcon', i._usingFontIcon() ? i.fontIcon : null),
                  _t('mat-icon-inline', i.inline)(
                    'mat-icon-no-color',
                    'primary' !== i.color &&
                      'accent' !== i.color &&
                      'warn' !== i.color
                  ));
              },
              inputs: {
                color: 'color',
                inline: 'inline',
                svgIcon: 'svgIcon',
                fontSet: 'fontSet',
                fontIcon: 'fontIcon',
              },
              exportAs: ['matIcon'],
              features: [ye],
              ngContentSelectors: Kte,
              decls: 1,
              vars: 0,
              template: function (t, i) {
                1 & t && (Pi(), dt(0));
              },
              styles: [
                '.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        GN = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({ imports: [Vt, Vt] })),
            n
          );
        })(),
        lne = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({
              imports: [
                PL,
                jL,
                Eu,
                GL,
                SN,
                XL,
                rN,
                CN,
                GN,
                PL,
                jL,
                Eu,
                GL,
                SN,
                XL,
                rN,
                CN,
                GN,
              ],
            })),
            n
          );
        })(),
        cne = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n })),
            (n.ɵinj = qe({})),
            n
          );
        })();
      function DE(n, e, t) {
        if (!e.has(n))
          throw new TypeError(
            'attempted to ' + t + ' private field on non-instance'
          );
        return e.get(n);
      }
      function eg(n, e) {
        return (function dne(n, e) {
          if (e.set)
            return (
              '__destrObj' in e ||
                (e.__destrObj = {
                  set value(t) {
                    e.set.call(n, t);
                  },
                }),
              e.__destrObj
            );
          if (!e.writable)
            throw new TypeError('attempted to set read only private field');
          return e;
        })(n, DE(n, e, 'set'));
      }
      function qN(n, e, t) {
        if (e.set) e.set.call(n, t);
        else {
          if (!e.writable)
            throw new TypeError('attempted to set read only private field');
          e.value = t;
        }
      }
      function TE(n, e) {
        if (n !== e)
          throw new TypeError('Private static access of wrong provenance');
      }
      function XN(n, e) {
        if (void 0 === n)
          throw new TypeError(
            'attempted to ' + e + ' private static field before its declaration'
          );
      }
      function pa(n, e, t, i) {
        return TE(n, e), XN(t, 'set'), qN(n, t, i), i;
      }
      function YN(n, e) {
        return e.get ? e.get.call(n) : e.value;
      }
      function de(n, e, t) {
        return TE(n, e), XN(t, 'get'), YN(n, t);
      }
      function KN(n, e) {
        if (e.has(n))
          throw new TypeError(
            'Cannot initialize the same private elements twice on an object'
          );
      }
      function S(n, e) {
        KN(n, e), e.add(n);
      }
      function b(n, e, t) {
        if (!e.has(n))
          throw new TypeError('attempted to get private field on non-instance');
        return t;
      }
      function Mu(n) {
        return (Mu =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (e) {
                return typeof e;
              }
            : function (e) {
                return e &&
                  'function' == typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? 'symbol'
                  : typeof e;
              })(n);
      }
      function Se(n, e, t) {
        return (
          (e = (function hne(n) {
            var e = (function une(n, e) {
              if ('object' !== Mu(n) || null === n) return n;
              var t = n[Symbol.toPrimitive];
              if (void 0 !== t) {
                var i = t.call(n, e || 'default');
                if ('object' !== Mu(i)) return i;
                throw new TypeError(
                  '@@toPrimitive must return a primitive value.'
                );
              }
              return ('string' === e ? String : Number)(n);
            })(n, 'string');
            return 'symbol' === Mu(e) ? e : String(e);
          })(e)) in n
            ? Object.defineProperty(n, e, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (n[e] = t),
          n
        );
      }
      function ZN(n, e, t, i, r, s, o) {
        try {
          var a = n[s](o),
            l = a.value;
        } catch (c) {
          return void t(c);
        }
        a.done ? e(l) : Promise.resolve(l).then(i, r);
      }
      function U(n) {
        return function () {
          var e = this,
            t = arguments;
          return new Promise(function (i, r) {
            var s = n.apply(e, t);
            function o(l) {
              ZN(s, i, r, o, a, 'next', l);
            }
            function a(l) {
              ZN(s, i, r, o, a, 'throw', l);
            }
            o(void 0);
          });
        };
      }
      function v(n, e, t) {
        KN(n, e), e.set(n, t);
      }
      function d(n, e) {
        return YN(n, DE(n, e, 'get'));
      }
      function _(n, e, t) {
        return qN(n, DE(n, e, 'set'), t), t;
      }
      function we(n, e, t) {
        return TE(n, e), t;
      }
      var Du = {
          d: (n, e) => {
            for (var t in e)
              Du.o(e, t) &&
                !Du.o(n, t) &&
                Object.defineProperty(n, t, { enumerable: !0, get: e[t] });
          },
          o: (n, e) => Object.prototype.hasOwnProperty.call(n, e),
        },
        Me = (globalThis.pdfjsLib = {});
      Du.d(Me, {
        AbortException: () => ga,
        AnnotationEditorLayer: () => Rse,
        AnnotationEditorParamsType: () => Ee,
        AnnotationEditorType: () => $e,
        AnnotationEditorUIManager: () => Uu,
        AnnotationLayer: () => $re,
        AnnotationMode: () => to,
        CMapCompressionType: () => kE,
        ColorPicker: () => Gr,
        DOMSVGFactory: () => $E,
        DrawLayer: () => en,
        FeatureTest: () => ui,
        GlobalWorkerOptions: () => Ur,
        ImageKind: () => ng,
        InvalidPDFException: () => e2,
        MissingPDFException: () => ma,
        OPS: () => dr,
        PDFDataRangeTransport: () => yV,
        PDFDateString: () => f2,
        PDFWorker: () => zt,
        PasswordResponses: () => gne,
        PermissionFlag: () => mne,
        PixelsPerInch: () => ur,
        RenderingCancelledException: () => GE,
        TextLayer: () => We,
        UnexpectedResponseException: () => og,
        Util: () => te,
        VerbosityLevel: () => ig,
        XfaLayer: () => SV,
        build: () => _re,
        createValidAbsoluteUrl: () => yne,
        fetchData: () => mg,
        getDocument: () => are,
        getFilenameFromUrl: () => One,
        getPdfFilenameFromUrl: () => Lne,
        getXfaPageViewport: () => Nne,
        isDataScheme: () => gg,
        isPdfFile: () => qE,
        noContextMenu: () => fi,
        normalizeUnicode: () => Mne,
        setLayerDimensions: () => ba,
        shadow: () => Ye,
        version: () => gre,
      });
      const kn = !(
          'object' != typeof process ||
          process + '' != '[object process]' ||
          process.versions.nw ||
          (process.versions.electron &&
            process.type &&
            'browser' !== process.type)
        ),
        JN = [1, 0, 0, 1, 0, 0],
        IE = [0.001, 0, 0, 0.001, 0, 0],
        to = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 },
        $e = {
          DISABLE: -1,
          NONE: 0,
          FREETEXT: 3,
          HIGHLIGHT: 9,
          STAMP: 13,
          INK: 15,
        },
        Ee = {
          RESIZE: 1,
          CREATE: 2,
          FREETEXT_SIZE: 11,
          FREETEXT_COLOR: 12,
          FREETEXT_OPACITY: 13,
          INK_COLOR: 21,
          INK_THICKNESS: 22,
          INK_OPACITY: 23,
          HIGHLIGHT_COLOR: 31,
          HIGHLIGHT_DEFAULT_COLOR: 32,
          HIGHLIGHT_THICKNESS: 33,
          HIGHLIGHT_FREE: 34,
          HIGHLIGHT_SHOW_ALL: 35,
        },
        mne = {
          PRINT: 4,
          MODIFY_CONTENTS: 8,
          COPY: 16,
          MODIFY_ANNOTATIONS: 32,
          FILL_INTERACTIVE_FORMS: 256,
          COPY_FOR_ACCESSIBILITY: 512,
          ASSEMBLE: 1024,
          PRINT_HIGH_QUALITY: 2048,
        },
        ng = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 },
        ig = { ERRORS: 0, WARNINGS: 1, INFOS: 5 },
        kE = { NONE: 0, BINARY: 1 },
        dr = {
          dependency: 1,
          setLineWidth: 2,
          setLineCap: 3,
          setLineJoin: 4,
          setMiterLimit: 5,
          setDash: 6,
          setRenderingIntent: 7,
          setFlatness: 8,
          setGState: 9,
          save: 10,
          restore: 11,
          transform: 12,
          moveTo: 13,
          lineTo: 14,
          curveTo: 15,
          curveTo2: 16,
          curveTo3: 17,
          closePath: 18,
          rectangle: 19,
          stroke: 20,
          closeStroke: 21,
          fill: 22,
          eoFill: 23,
          fillStroke: 24,
          eoFillStroke: 25,
          closeFillStroke: 26,
          closeEOFillStroke: 27,
          endPath: 28,
          clip: 29,
          eoClip: 30,
          beginText: 31,
          endText: 32,
          setCharSpacing: 33,
          setWordSpacing: 34,
          setHScale: 35,
          setLeading: 36,
          setFont: 37,
          setTextRenderingMode: 38,
          setTextRise: 39,
          moveText: 40,
          setLeadingMoveText: 41,
          setTextMatrix: 42,
          nextLine: 43,
          showText: 44,
          showSpacedText: 45,
          nextLineShowText: 46,
          nextLineSetSpacingShowText: 47,
          setCharWidth: 48,
          setCharWidthAndBounds: 49,
          setStrokeColorSpace: 50,
          setFillColorSpace: 51,
          setStrokeColor: 52,
          setStrokeColorN: 53,
          setFillColor: 54,
          setFillColorN: 55,
          setStrokeGray: 56,
          setFillGray: 57,
          setStrokeRGBColor: 58,
          setFillRGBColor: 59,
          setStrokeCMYKColor: 60,
          setFillCMYKColor: 61,
          shadingFill: 62,
          beginInlineImage: 63,
          beginImageData: 64,
          endInlineImage: 65,
          paintXObject: 66,
          markPoint: 67,
          markPointProps: 68,
          beginMarkedContent: 69,
          beginMarkedContentProps: 70,
          endMarkedContent: 71,
          beginCompat: 72,
          endCompat: 73,
          paintFormXObjectBegin: 74,
          paintFormXObjectEnd: 75,
          beginGroup: 76,
          endGroup: 77,
          beginAnnotation: 80,
          endAnnotation: 81,
          paintImageMaskXObject: 83,
          paintImageMaskXObjectGroup: 84,
          paintImageXObject: 85,
          paintInlineImageXObject: 86,
          paintInlineImageXObjectGroup: 87,
          paintImageXObjectRepeat: 88,
          paintImageMaskXObjectRepeat: 89,
          paintSolidColorImageMask: 90,
          constructPath: 91,
          setStrokeTransparent: 92,
          setFillTransparent: 93,
        },
        gne = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
      let rg = ig.WARNINGS;
      function bne() {
        return rg;
      }
      function sg(n) {
        rg >= ig.INFOS && console.log(`Info: ${n}`);
      }
      function Ve(n) {
        rg >= ig.WARNINGS && console.log(`Warning: ${n}`);
      }
      function bt(n) {
        throw new Error(n);
      }
      function cn(n, e) {
        n || bt(e);
      }
      function yne(n, e = null, t = null) {
        if (!n) return null;
        try {
          if (
            t &&
            'string' == typeof n &&
            (t.addDefaultProtocol &&
              n.startsWith('www.') &&
              n.match(/\./g)?.length >= 2 &&
              (n = `http://${n}`),
            t.tryConvertEncoding)
          )
            try {
              n = (function Sne(n) {
                return decodeURIComponent(escape(n));
              })(n);
            } catch {}
          const i = e ? new URL(n, e) : new URL(n);
          if (
            (function vne(n) {
              switch (n?.protocol) {
                case 'http:':
                case 'https:':
                case 'ftp:':
                case 'mailto:':
                case 'tel:':
                  return !0;
                default:
                  return !1;
              }
            })(i)
          )
            return i;
        } catch {}
        return null;
      }
      function Ye(n, e, t, i = !1) {
        return (
          Object.defineProperty(n, e, {
            value: t,
            enumerable: !i,
            configurable: !0,
            writable: !1,
          }),
          t
        );
      }
      const no = (function () {
        function e(t, i) {
          this.constructor === e && bt('Cannot initialize BaseException.'),
            (this.message = t),
            (this.name = i);
        }
        return (e.prototype = new Error()), (e.constructor = e), e;
      })();
      class PE extends no {
        constructor(e, t) {
          super(e, 'PasswordException'), (this.code = t);
        }
      }
      class RE extends no {
        constructor(e, t) {
          super(e, 'UnknownErrorException'), (this.details = t);
        }
      }
      class e2 extends no {
        constructor(e) {
          super(e, 'InvalidPDFException');
        }
      }
      class ma extends no {
        constructor(e) {
          super(e, 'MissingPDFException');
        }
      }
      class og extends no {
        constructor(e, t) {
          super(e, 'UnexpectedResponseException'), (this.status = t);
        }
      }
      class wne extends no {
        constructor(e) {
          super(e, 'FormatError');
        }
      }
      class ga extends no {
        constructor(e) {
          super(e, 'AbortException');
        }
      }
      function t2(n) {
        ('object' != typeof n || void 0 === n?.length) &&
          bt('Invalid argument for bytesToString');
        const e = n.length,
          t = 8192;
        if (e < t) return String.fromCharCode.apply(null, n);
        const i = [];
        for (let r = 0; r < e; r += t) {
          const s = Math.min(r + t, e),
            o = n.subarray(r, s);
          i.push(String.fromCharCode.apply(null, o));
        }
        return i.join('');
      }
      function Iu(n) {
        'string' != typeof n && bt('Invalid argument for stringToBytes');
        const e = n.length,
          t = new Uint8Array(e);
        for (let i = 0; i < e; ++i) t[i] = 255 & n.charCodeAt(i);
        return t;
      }
      function FE(n) {
        const e = Object.create(null);
        for (const [t, i] of n) e[t] = i;
        return e;
      }
      class ui {
        static get isLittleEndian() {
          return Ye(
            this,
            'isLittleEndian',
            (function Cne() {
              const n = new Uint8Array(4);
              return (n[0] = 1), 1 === new Uint32Array(n.buffer, 0, 1)[0];
            })()
          );
        }
        static get isEvalSupported() {
          return Ye(
            this,
            'isEvalSupported',
            (function xne() {
              try {
                return new Function(''), !0;
              } catch {
                return !1;
              }
            })()
          );
        }
        static get isOffscreenCanvasSupported() {
          return Ye(
            this,
            'isOffscreenCanvasSupported',
            typeof OffscreenCanvas < 'u'
          );
        }
        static get platform() {
          return typeof navigator < 'u' &&
            'string' == typeof navigator?.platform
            ? Ye(this, 'platform', {
                isMac: navigator.platform.includes('Mac'),
              })
            : Ye(this, 'platform', { isMac: !1 });
        }
        static get isCSSRoundSupported() {
          return Ye(
            this,
            'isCSSRoundSupported',
            globalThis.CSS?.supports?.('width: round(1.5px, 1px)')
          );
        }
      }
      const OE = Array.from(Array(256).keys(), (n) =>
        n.toString(16).padStart(2, '0')
      );
      class te {
        static makeHexColor(e, t, i) {
          return `#${OE[e]}${OE[t]}${OE[i]}`;
        }
        static scaleMinMax(e, t) {
          let i;
          e[0]
            ? (e[0] < 0 && ((i = t[0]), (t[0] = t[2]), (t[2] = i)),
              (t[0] *= e[0]),
              (t[2] *= e[0]),
              e[3] < 0 && ((i = t[1]), (t[1] = t[3]), (t[3] = i)),
              (t[1] *= e[3]),
              (t[3] *= e[3]))
            : ((i = t[0]),
              (t[0] = t[1]),
              (t[1] = i),
              (i = t[2]),
              (t[2] = t[3]),
              (t[3] = i),
              e[1] < 0 && ((i = t[1]), (t[1] = t[3]), (t[3] = i)),
              (t[1] *= e[1]),
              (t[3] *= e[1]),
              e[2] < 0 && ((i = t[0]), (t[0] = t[2]), (t[2] = i)),
              (t[0] *= e[2]),
              (t[2] *= e[2])),
            (t[0] += e[4]),
            (t[1] += e[5]),
            (t[2] += e[4]),
            (t[3] += e[5]);
        }
        static transform(e, t) {
          return [
            e[0] * t[0] + e[2] * t[1],
            e[1] * t[0] + e[3] * t[1],
            e[0] * t[2] + e[2] * t[3],
            e[1] * t[2] + e[3] * t[3],
            e[0] * t[4] + e[2] * t[5] + e[4],
            e[1] * t[4] + e[3] * t[5] + e[5],
          ];
        }
        static applyTransform(e, t) {
          return [
            e[0] * t[0] + e[1] * t[2] + t[4],
            e[0] * t[1] + e[1] * t[3] + t[5],
          ];
        }
        static applyInverseTransform(e, t) {
          const i = t[0] * t[3] - t[1] * t[2];
          return [
            (e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / i,
            (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / i,
          ];
        }
        static getAxialAlignedBoundingBox(e, t) {
          const i = this.applyTransform(e, t),
            r = this.applyTransform(e.slice(2, 4), t),
            s = this.applyTransform([e[0], e[3]], t),
            o = this.applyTransform([e[2], e[1]], t);
          return [
            Math.min(i[0], r[0], s[0], o[0]),
            Math.min(i[1], r[1], s[1], o[1]),
            Math.max(i[0], r[0], s[0], o[0]),
            Math.max(i[1], r[1], s[1], o[1]),
          ];
        }
        static inverseTransform(e) {
          const t = e[0] * e[3] - e[1] * e[2];
          return [
            e[3] / t,
            -e[1] / t,
            -e[2] / t,
            e[0] / t,
            (e[2] * e[5] - e[4] * e[3]) / t,
            (e[4] * e[1] - e[5] * e[0]) / t,
          ];
        }
        static singularValueDecompose2dScale(e) {
          const t = [e[0], e[2], e[1], e[3]],
            i = e[0] * t[0] + e[1] * t[2],
            o = e[2] * t[1] + e[3] * t[3],
            a = (i + o) / 2,
            l =
              Math.sqrt(
                (i + o) ** 2 -
                  4 *
                    (i * o -
                      (e[2] * t[0] + e[3] * t[2]) * (e[0] * t[1] + e[1] * t[3]))
              ) / 2,
            u = a - l || 1;
          return [Math.sqrt(a + l || 1), Math.sqrt(u)];
        }
        static normalizeRect(e) {
          const t = e.slice(0);
          return (
            e[0] > e[2] && ((t[0] = e[2]), (t[2] = e[0])),
            e[1] > e[3] && ((t[1] = e[3]), (t[3] = e[1])),
            t
          );
        }
        static intersect(e, t) {
          const i = Math.max(Math.min(e[0], e[2]), Math.min(t[0], t[2])),
            r = Math.min(Math.max(e[0], e[2]), Math.max(t[0], t[2]));
          if (i > r) return null;
          const s = Math.max(Math.min(e[1], e[3]), Math.min(t[1], t[3])),
            o = Math.min(Math.max(e[1], e[3]), Math.max(t[1], t[3]));
          return s > o ? null : [i, s, r, o];
        }
        static bezierBoundingBox(e, t, i, r, s, o, a, l, c) {
          return (
            c
              ? ((c[0] = Math.min(c[0], e, a)),
                (c[1] = Math.min(c[1], t, l)),
                (c[2] = Math.max(c[2], e, a)),
                (c[3] = Math.max(c[3], t, l)))
              : (c = [
                  Math.min(e, a),
                  Math.min(t, l),
                  Math.max(e, a),
                  Math.max(t, l),
                ]),
            we(this, te, n2).call(
              this,
              e,
              i,
              s,
              a,
              t,
              r,
              o,
              l,
              3 * (3 * (i - s) - e + a),
              6 * (e - 2 * i + s),
              3 * (i - e),
              c
            ),
            we(this, te, n2).call(
              this,
              e,
              i,
              s,
              a,
              t,
              r,
              o,
              l,
              3 * (3 * (r - o) - t + l),
              6 * (t - 2 * r + o),
              3 * (r - t),
              c
            ),
            c
          );
        }
      }
      function LE(n, e, t, i, r, s, o, a, l, c) {
        if (l <= 0 || l >= 1) return;
        const u = 1 - l,
          h = l * l,
          f = h * l,
          p = u * (u * (u * n + 3 * l * e) + 3 * h * t) + f * i,
          m = u * (u * (u * r + 3 * l * s) + 3 * h * o) + f * a;
        (c[0] = Math.min(c[0], p)),
          (c[1] = Math.min(c[1], m)),
          (c[2] = Math.max(c[2], p)),
          (c[3] = Math.max(c[3], m));
      }
      function n2(n, e, t, i, r, s, o, a, l, c, u, h) {
        if (Math.abs(l) < 1e-12)
          return void (
            Math.abs(c) >= 1e-12 &&
            we(this, te, LE).call(this, n, e, t, i, r, s, o, a, -u / c, h)
          );
        const f = c ** 2 - 4 * u * l;
        if (f < 0) return;
        const p = Math.sqrt(f),
          m = 2 * l;
        we(this, te, LE).call(this, n, e, t, i, r, s, o, a, (-c + p) / m, h),
          we(this, te, LE).call(this, n, e, t, i, r, s, o, a, (-c - p) / m, h);
      }
      let NE = null,
        r2 = null;
      function Mne(n) {
        return (
          NE ||
            ((NE =
              /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu),
            (r2 = new Map([['\ufb05', '\u017ft']]))),
          n.replaceAll(NE, (e, t, i) => (t ? t.normalize('NFKC') : r2.get(i)))
        );
      }
      function Dne() {
        if (typeof crypto < 'u' && 'function' == typeof crypto?.randomUUID)
          return crypto.randomUUID();
        const n = new Uint8Array(32);
        if (typeof crypto < 'u' && 'function' == typeof crypto?.getRandomValues)
          crypto.getRandomValues(n);
        else
          for (let e = 0; e < 32; e++) n[e] = Math.floor(255 * Math.random());
        return t2(n);
      }
      const s2 = 'pdfjs_internal_id_';
      class ag {
        constructor() {
          this.constructor === ag && bt('Cannot initialize BaseFilterFactory.');
        }
        addFilter(e) {
          return 'none';
        }
        addHCMFilter(e, t) {
          return 'none';
        }
        addAlphaFilter(e) {
          return 'none';
        }
        addLuminosityFilter(e) {
          return 'none';
        }
        addHighlightHCMFilter(e, t, i, r, s) {
          return 'none';
        }
        destroy(e = !1) {}
      }
      var VE = new WeakMap();
      class lg {
        constructor({ enableHWA: e = !1 } = {}) {
          v(this, VE, { writable: !0, value: !1 }),
            this.constructor === lg &&
              bt('Cannot initialize BaseCanvasFactory.'),
            _(this, VE, e);
        }
        create(e, t) {
          if (e <= 0 || t <= 0) throw new Error('Invalid canvas size');
          const i = this._createCanvas(e, t);
          return {
            canvas: i,
            context: i.getContext('2d', { willReadFrequently: !d(this, VE) }),
          };
        }
        reset(e, t, i) {
          if (!e.canvas) throw new Error('Canvas is not specified');
          if (t <= 0 || i <= 0) throw new Error('Invalid canvas size');
          (e.canvas.width = t), (e.canvas.height = i);
        }
        destroy(e) {
          if (!e.canvas) throw new Error('Canvas is not specified');
          (e.canvas.width = 0),
            (e.canvas.height = 0),
            (e.canvas = null),
            (e.context = null);
        }
        _createCanvas(e, t) {
          bt('Abstract method `_createCanvas` called.');
        }
      }
      class cg {
        constructor({ baseUrl: e = null, isCompressed: t = !0 }) {
          this.constructor === cg &&
            bt('Cannot initialize BaseCMapReaderFactory.'),
            (this.baseUrl = e),
            (this.isCompressed = t);
        }
        fetch({ name: e }) {
          var t = this;
          return U(function* () {
            if (!t.baseUrl)
              throw new Error(
                'The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.'
              );
            if (!e) throw new Error('CMap name must be specified.');
            const i = t.baseUrl + e + (t.isCompressed ? '.bcmap' : '');
            return t
              ._fetchData(i, t.isCompressed ? kE.BINARY : kE.NONE)
              .catch((s) => {
                throw new Error(
                  `Unable to load ${
                    t.isCompressed ? 'binary ' : ''
                  }CMap at: ${i}`
                );
              });
          })();
        }
        _fetchData(e, t) {
          bt('Abstract method `_fetchData` called.');
        }
      }
      class dg {
        constructor({ baseUrl: e = null }) {
          this.constructor === dg &&
            bt('Cannot initialize BaseStandardFontDataFactory.'),
            (this.baseUrl = e);
        }
        fetch({ filename: e }) {
          var t = this;
          return U(function* () {
            if (!t.baseUrl)
              throw new Error(
                'The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.'
              );
            if (!e) throw new Error('Font filename must be specified.');
            const i = `${t.baseUrl}${e}`;
            return t._fetchData(i).catch((r) => {
              throw new Error(`Unable to load font data at: ${i}`);
            });
          })();
        }
        _fetchData(e) {
          bt('Abstract method `_fetchData` called.');
        }
      }
      class BE {
        constructor() {
          this.constructor === BE && bt('Cannot initialize BaseSVGFactory.');
        }
        create(e, t, i = !1) {
          if (e <= 0 || t <= 0) throw new Error('Invalid SVG dimensions');
          const r = this._createSVG('svg:svg');
          return (
            r.setAttribute('version', '1.1'),
            i ||
              (r.setAttribute('width', `${e}px`),
              r.setAttribute('height', `${t}px`)),
            r.setAttribute('preserveAspectRatio', 'none'),
            r.setAttribute('viewBox', `0 0 ${e} ${t}`),
            r
          );
        }
        createElement(e) {
          if ('string' != typeof e) throw new Error('Invalid SVG element type');
          return this._createSVG(e);
        }
        _createSVG(e) {
          bt('Abstract method `_createSVG` called.');
        }
      }
      const bs = 'http://www.w3.org/2000/svg';
      class ur {}
      Se(ur, 'CSS', 96),
        Se(ur, 'PDF', 72),
        Se(ur, 'PDF_TO_CSS_UNITS', ur.CSS / ur.PDF);
      var ku = new WeakMap(),
        Zl = new WeakMap(),
        io = new WeakMap(),
        _a = new WeakMap(),
        hi = new WeakMap(),
        HE = new WeakMap(),
        ro = new WeakMap(),
        Rn = new WeakMap(),
        Ql = new WeakMap(),
        Jl = new WeakMap(),
        ug = new WeakSet(),
        ec = new WeakSet(),
        o2 = new WeakSet(),
        WE = new WeakSet(),
        tc = new WeakSet(),
        Pu = new WeakSet(),
        Ru = new WeakSet(),
        jE = new WeakSet(),
        Fu = new WeakSet();
      function Ine() {
        return d(this, Zl) || _(this, Zl, new Map());
      }
      function kne() {
        return d(this, HE) || _(this, HE, new Map());
      }
      function Pne() {
        if (!d(this, io)) {
          const n = d(this, hi).createElement('div'),
            { style: e } = n;
          (e.visibility = 'hidden'),
            (e.contain = 'strict'),
            (e.width = e.height = 0),
            (e.position = 'absolute'),
            (e.top = e.left = 0),
            (e.zIndex = -1);
          const t = d(this, hi).createElementNS(bs, 'svg');
          t.setAttribute('width', 0),
            t.setAttribute('height', 0),
            _(this, io, d(this, hi).createElementNS(bs, 'defs')),
            n.append(t),
            t.append(d(this, io)),
            d(this, hi).body.append(n);
        }
        return d(this, io);
      }
      function zE(n) {
        if (1 === n.length) {
          const a = n[0],
            l = new Array(256);
          for (let u = 0; u < 256; u++) l[u] = a[u] / 255;
          const c = l.join(',');
          return [c, c, c];
        }
        const [e, t, i] = n,
          r = new Array(256),
          s = new Array(256),
          o = new Array(256);
        for (let a = 0; a < 256; a++)
          (r[a] = e[a] / 255), (s[a] = t[a] / 255), (o[a] = i[a] / 255);
        return [r.join(','), s.join(','), o.join(',')];
      }
      function Ou(n) {
        if (void 0 === d(this, ku)) {
          _(this, ku, '');
          const e = d(this, hi).URL;
          e !== d(this, hi).baseURI &&
            (gg(e)
              ? Ve('#createUrl: ignore "data:"-URL for performance reasons.')
              : _(this, ku, e.split('#', 1)[0]));
        }
        return `url(${d(this, ku)}#${n})`;
      }
      function Rne(n) {
        const e = d(this, hi).createElementNS(bs, 'feColorMatrix');
        e.setAttribute('type', 'matrix'),
          e.setAttribute(
            'values',
            '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0'
          ),
          n.append(e);
      }
      function a2(n) {
        const e = d(this, hi).createElementNS(bs, 'feColorMatrix');
        e.setAttribute('type', 'matrix'),
          e.setAttribute(
            'values',
            '0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0'
          ),
          n.append(e);
      }
      function Lu(n) {
        const e = d(this, hi).createElementNS(bs, 'filter');
        return (
          e.setAttribute('color-interpolation-filters', 'sRGB'),
          e.setAttribute('id', n),
          d(this, Jl).append(e),
          e
        );
      }
      function hg(n, e, t) {
        const i = d(this, hi).createElementNS(bs, e);
        i.setAttribute('type', 'discrete'),
          i.setAttribute('tableValues', t),
          n.append(i);
      }
      function fg(n, e, t, i) {
        const r = d(this, hi).createElementNS(bs, 'feComponentTransfer');
        i.append(r),
          b(this, Pu, hg).call(this, r, 'feFuncR', n),
          b(this, Pu, hg).call(this, r, 'feFuncG', e),
          b(this, Pu, hg).call(this, r, 'feFuncB', t);
      }
      function l2(n, e) {
        const t = d(this, hi).createElementNS(bs, 'feComponentTransfer');
        e.append(t), b(this, Pu, hg).call(this, t, 'feFuncA', n);
      }
      function pg(n) {
        return (
          (d(this, Jl).style.color = n),
          XE(getComputedStyle(d(this, Jl)).getPropertyValue('color'))
        );
      }
      function mg(n) {
        return UE.apply(this, arguments);
      }
      function UE() {
        return (UE = U(function* (n, e = 'text') {
          if (Vu(n, document.baseURI)) {
            const t = yield fetch(n);
            if (!t.ok) throw new Error(t.statusText);
            switch (e) {
              case 'arraybuffer':
                return t.arrayBuffer();
              case 'blob':
                return t.blob();
              case 'json':
                return t.json();
            }
            return t.text();
          }
          return new Promise((t, i) => {
            const r = new XMLHttpRequest();
            r.open('GET', n, !0),
              (r.responseType = e),
              (r.onreadystatechange = () => {
                if (r.readyState === XMLHttpRequest.DONE) {
                  if (200 === r.status || 0 === r.status) {
                    switch (e) {
                      case 'arraybuffer':
                      case 'blob':
                      case 'json':
                        return void t(r.response);
                    }
                    return void t(r.responseText);
                  }
                  i(new Error(r.statusText));
                }
              }),
              r.send(null);
          });
        })).apply(this, arguments);
      }
      class c2 extends cg {
        _fetchData(e, t) {
          return mg(e, this.isCompressed ? 'arraybuffer' : 'text').then(
            (i) => ({
              cMapData: i instanceof ArrayBuffer ? new Uint8Array(i) : Iu(i),
              compressionType: t,
            })
          );
        }
      }
      class d2 extends dg {
        _fetchData(e) {
          return mg(e, 'arraybuffer').then((t) => new Uint8Array(t));
        }
      }
      class $E extends BE {
        _createSVG(e) {
          return document.createElementNS(bs, e);
        }
      }
      class Nu {
        constructor({
          viewBox: e,
          scale: t,
          rotation: i,
          offsetX: r = 0,
          offsetY: s = 0,
          dontFlip: o = !1,
        }) {
          (this.viewBox = e),
            (this.scale = t),
            (this.rotation = i),
            (this.offsetX = r),
            (this.offsetY = s);
          const a = (e[2] + e[0]) / 2,
            l = (e[3] + e[1]) / 2;
          let c, u, h, f, p, m, g, w;
          switch (((i %= 360) < 0 && (i += 360), i)) {
            case 180:
              (c = -1), (u = 0), (h = 0), (f = 1);
              break;
            case 90:
              (c = 0), (u = 1), (h = 1), (f = 0);
              break;
            case 270:
              (c = 0), (u = -1), (h = -1), (f = 0);
              break;
            case 0:
              (c = 1), (u = 0), (h = 0), (f = -1);
              break;
            default:
              throw new Error(
                'PageViewport: Invalid rotation, must be a multiple of 90 degrees.'
              );
          }
          o && ((h = -h), (f = -f)),
            0 === c
              ? ((p = Math.abs(l - e[1]) * t + r),
                (m = Math.abs(a - e[0]) * t + s),
                (g = (e[3] - e[1]) * t),
                (w = (e[2] - e[0]) * t))
              : ((p = Math.abs(a - e[0]) * t + r),
                (m = Math.abs(l - e[1]) * t + s),
                (g = (e[2] - e[0]) * t),
                (w = (e[3] - e[1]) * t)),
            (this.transform = [
              c * t,
              u * t,
              h * t,
              f * t,
              p - c * t * a - h * t * l,
              m - u * t * a - f * t * l,
            ]),
            (this.width = g),
            (this.height = w);
        }
        get rawDims() {
          const { viewBox: e } = this;
          return Ye(this, 'rawDims', {
            pageWidth: e[2] - e[0],
            pageHeight: e[3] - e[1],
            pageX: e[0],
            pageY: e[1],
          });
        }
        clone({
          scale: e = this.scale,
          rotation: t = this.rotation,
          offsetX: i = this.offsetX,
          offsetY: r = this.offsetY,
          dontFlip: s = !1,
        } = {}) {
          return new Nu({
            viewBox: this.viewBox.slice(),
            scale: e,
            rotation: t,
            offsetX: i,
            offsetY: r,
            dontFlip: s,
          });
        }
        convertToViewportPoint(e, t) {
          return te.applyTransform([e, t], this.transform);
        }
        convertToViewportRectangle(e) {
          const t = te.applyTransform([e[0], e[1]], this.transform),
            i = te.applyTransform([e[2], e[3]], this.transform);
          return [t[0], t[1], i[0], i[1]];
        }
        convertToPdfPoint(e, t) {
          return te.applyInverseTransform([e, t], this.transform);
        }
      }
      class GE extends no {
        constructor(e, t = 0) {
          super(e, 'RenderingCancelledException'), (this.extraDelay = t);
        }
      }
      function gg(n) {
        const e = n.length;
        let t = 0;
        for (; t < e && '' === n[t].trim(); ) t++;
        return 'data:' === n.substring(t, t + 5).toLowerCase();
      }
      function qE(n) {
        return 'string' == typeof n && /\.pdf$/i.test(n);
      }
      function One(n) {
        return ([n] = n.split(/[#?]/, 1)), n.substring(n.lastIndexOf('/') + 1);
      }
      function Lne(n, e = 'document.pdf') {
        if ('string' != typeof n) return e;
        if (gg(n))
          return (
            Ve(
              'getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'
            ),
            e
          );
        const i = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i,
          r = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(n);
        let s = i.exec(r[1]) || i.exec(r[2]) || i.exec(r[3]);
        if (s && ((s = s[0]), s.includes('%')))
          try {
            s = i.exec(decodeURIComponent(s))[0];
          } catch {}
        return s || e;
      }
      class u2 {
        constructor() {
          Se(this, 'started', Object.create(null)), Se(this, 'times', []);
        }
        time(e) {
          e in this.started && Ve(`Timer is already running for ${e}`),
            (this.started[e] = Date.now());
        }
        timeEnd(e) {
          e in this.started || Ve(`Timer has not been started for ${e}`),
            this.times.push({
              name: e,
              start: this.started[e],
              end: Date.now(),
            }),
            delete this.started[e];
        }
        toString() {
          const e = [];
          let t = 0;
          for (const { name: i } of this.times) t = Math.max(i.length, t);
          for (const { name: i, start: r, end: s } of this.times)
            e.push(`${i.padEnd(t)} ${s - r}ms\n`);
          return e.join('');
        }
      }
      function Vu(n, e) {
        try {
          const { protocol: t } = e ? new URL(n, e) : new URL(n);
          return 'http:' === t || 'https:' === t;
        } catch {
          return !1;
        }
      }
      function fi(n) {
        n.preventDefault();
      }
      let h2;
      class f2 {
        static toDateObject(e) {
          if (!e || 'string' != typeof e) return null;
          h2 ||= new RegExp(
            "^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"
          );
          const t = h2.exec(e);
          if (!t) return null;
          const i = parseInt(t[1], 10);
          let r = parseInt(t[2], 10);
          r = r >= 1 && r <= 12 ? r - 1 : 0;
          let s = parseInt(t[3], 10);
          s = s >= 1 && s <= 31 ? s : 1;
          let o = parseInt(t[4], 10);
          o = o >= 0 && o <= 23 ? o : 0;
          let a = parseInt(t[5], 10);
          a = a >= 0 && a <= 59 ? a : 0;
          let l = parseInt(t[6], 10);
          l = l >= 0 && l <= 59 ? l : 0;
          const c = t[7] || 'Z';
          let u = parseInt(t[8], 10);
          u = u >= 0 && u <= 23 ? u : 0;
          let h = parseInt(t[9], 10) || 0;
          return (
            (h = h >= 0 && h <= 59 ? h : 0),
            '-' === c
              ? ((o += u), (a += h))
              : '+' === c && ((o -= u), (a -= h)),
            new Date(Date.UTC(i, r, s, o, a, l))
          );
        }
      }
      function Nne(n, { scale: e = 1, rotation: t = 0 }) {
        const { width: i, height: r } = n.attributes.style,
          s = [0, 0, parseInt(i), parseInt(r)];
        return new Nu({ viewBox: s, scale: e, rotation: t });
      }
      function XE(n) {
        if (n.startsWith('#')) {
          const e = parseInt(n.slice(1), 16);
          return [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e];
        }
        return n.startsWith('rgb(')
          ? n
              .slice(4, -1)
              .split(',')
              .map((e) => parseInt(e))
          : n.startsWith('rgba(')
          ? n
              .slice(5, -1)
              .split(',')
              .map((e) => parseInt(e))
              .slice(0, 3)
          : (Ve(`Not a valid color format: "${n}"`), [0, 0, 0]);
      }
      function Rt(n) {
        const { a: e, b: t, c: i, d: r, e: s, f: o } = n.getTransform();
        return [e, t, i, r, s, o];
      }
      function vs(n) {
        const {
          a: e,
          b: t,
          c: i,
          d: r,
          e: s,
          f: o,
        } = n.getTransform().invertSelf();
        return [e, t, i, r, s, o];
      }
      function ba(n, e, t = !1, i = !0) {
        if (e instanceof Nu) {
          const { pageWidth: r, pageHeight: s } = e.rawDims,
            { style: o } = n,
            a = ui.isCSSRoundSupported,
            l = `var(--scale-factor) * ${r}px`,
            c = `var(--scale-factor) * ${s}px`,
            u = a ? `round(${l}, 1px)` : `calc(${l})`,
            h = a ? `round(${c}, 1px)` : `calc(${c})`;
          t && e.rotation % 180 != 0
            ? ((o.width = h), (o.height = u))
            : ((o.width = u), (o.height = h));
        }
        i && n.setAttribute('data-main-rotation', e.rotation);
      }
      var Bu = new WeakMap(),
        Hu = new WeakMap(),
        hr = new WeakMap(),
        Wu = new WeakMap(),
        p2 = new WeakSet(),
        m2 = new WeakSet(),
        _g = new WeakSet(),
        g2 = new WeakSet(),
        YE = new WeakMap();
      class bg {
        constructor(e) {
          v(this, YE, { get: zne, set: void 0 }),
            S(this, g2),
            S(this, _g),
            S(this, m2),
            S(this, p2),
            v(this, Bu, { writable: !0, value: null }),
            v(this, Hu, { writable: !0, value: null }),
            v(this, hr, { writable: !0, value: void 0 }),
            v(this, Wu, { writable: !0, value: null }),
            _(this, hr, e);
        }
        render() {
          const e = _(this, Bu, document.createElement('div'));
          (e.className = 'editToolbar'), e.setAttribute('role', 'toolbar');
          const t = d(this, hr)._uiManager._signal;
          e.addEventListener('contextmenu', fi, { signal: t }),
            e.addEventListener('pointerdown', we(bg, bg, Bne), { signal: t });
          const i = _(this, Wu, document.createElement('div'));
          (i.className = 'buttons'), e.append(i);
          const r = d(this, hr).toolbarPosition;
          if (r) {
            const { style: s } = e,
              o = 'ltr' === d(this, hr)._uiManager.direction ? 1 - r[0] : r[0];
            (s.insetInlineEnd = 100 * o + '%'),
              (s.top = `calc(${
                100 * r[1]
              }% + var(--editor-toolbar-vert-offset))`);
          }
          return b(this, g2, jne).call(this), e;
        }
        hide() {
          d(this, Bu).classList.add('hidden'), d(this, Hu)?.hideDropdown();
        }
        show() {
          d(this, Bu).classList.remove('hidden');
        }
        addAltTextButton(e) {
          b(this, _g, KE).call(this, e), d(this, Wu).prepend(e, d(this, YE));
        }
        addColorPicker(e) {
          _(this, Hu, e);
          const t = e.renderButton();
          b(this, _g, KE).call(this, t), d(this, Wu).prepend(t, d(this, YE));
        }
        remove() {
          d(this, Bu).remove(), d(this, Hu)?.destroy(), _(this, Hu, null);
        }
      }
      function Bne(n) {
        n.stopPropagation();
      }
      function Hne(n) {
        (d(this, hr)._focusEventsAllowed = !1),
          n.preventDefault(),
          n.stopPropagation();
      }
      function Wne(n) {
        (d(this, hr)._focusEventsAllowed = !0),
          n.preventDefault(),
          n.stopPropagation();
      }
      function KE(n) {
        const e = d(this, hr)._uiManager._signal;
        n.addEventListener('focusin', b(this, p2, Hne).bind(this), {
          capture: !0,
          signal: e,
        }),
          n.addEventListener('focusout', b(this, m2, Wne).bind(this), {
            capture: !0,
            signal: e,
          }),
          n.addEventListener('contextmenu', fi, { signal: e });
      }
      function jne() {
        const n = document.createElement('button');
        (n.className = 'delete'),
          (n.tabIndex = 0),
          n.setAttribute(
            'data-l10n-id',
            `pdfjs-editor-remove-${d(this, hr).editorType}-button`
          ),
          b(this, _g, KE).call(this, n),
          n.addEventListener(
            'click',
            (e) => {
              d(this, hr)._uiManager.delete();
            },
            { signal: d(this, hr)._uiManager._signal }
          ),
          d(this, Wu).append(n);
      }
      function zne() {
        const n = document.createElement('div');
        return (n.className = 'divider'), n;
      }
      var ZE = new WeakMap(),
        nc = new WeakMap(),
        ju = new WeakMap(),
        _2 = new WeakSet(),
        b2 = new WeakSet(),
        v2 = new WeakSet();
      class Une {
        constructor(e) {
          S(this, v2),
            S(this, b2),
            S(this, _2),
            v(this, ZE, { writable: !0, value: null }),
            v(this, nc, { writable: !0, value: null }),
            v(this, ju, { writable: !0, value: void 0 }),
            _(this, ju, e);
        }
        show(e, t, i) {
          const [r, s] = b(this, b2, Gne).call(this, t, i),
            { style: o } =
              d(this, nc) || _(this, nc, b(this, _2, $ne).call(this));
          e.append(d(this, nc)),
            (o.insetInlineEnd = 100 * r + '%'),
            (o.top = `calc(${100 * s}% + var(--editor-toolbar-vert-offset))`);
        }
        hide() {
          d(this, nc).remove();
        }
      }
      function $ne() {
        const n = _(this, nc, document.createElement('div'));
        (n.className = 'editToolbar'),
          n.setAttribute('role', 'toolbar'),
          n.addEventListener('contextmenu', fi, {
            signal: d(this, ju)._signal,
          });
        const e = _(this, ZE, document.createElement('div'));
        return (
          (e.className = 'buttons'), n.append(e), b(this, v2, qne).call(this), n
        );
      }
      function Gne(n, e) {
        let t = 0,
          i = 0;
        for (const r of n) {
          const s = r.y + r.height;
          if (s < t) continue;
          const o = r.x + (e ? r.width : 0);
          s > t ? ((i = o), (t = s)) : e ? o > i && (i = o) : o < i && (i = o);
        }
        return [e ? 1 - i : i, t];
      }
      function qne() {
        const n = document.createElement('button');
        (n.className = 'highlightButton'),
          (n.tabIndex = 0),
          n.setAttribute('data-l10n-id', 'pdfjs-highlight-floating-button1');
        const e = document.createElement('span');
        n.append(e),
          (e.className = 'visuallyHidden'),
          e.setAttribute(
            'data-l10n-id',
            'pdfjs-highlight-floating-button-label'
          );
        const t = d(this, ju)._signal;
        n.addEventListener('contextmenu', fi, { signal: t }),
          n.addEventListener(
            'click',
            () => {
              d(this, ju).highlightSelection('floating_button');
            },
            { signal: t }
          ),
          d(this, ZE).append(n);
      }
      function vg(n, e, t) {
        for (const i of t) e.addEventListener(i, n[i].bind(n));
      }
      var QE = new WeakMap();
      class Yne {
        constructor() {
          v(this, QE, { writable: !0, value: 0 });
        }
        get id() {
          var e, t;
          return `pdfjs_internal_editor_${
            (_(this, QE, ((e = d(this, QE)), (t = e++), e)), t)
          }`;
        }
      }
      var JE = new WeakMap(),
        eC = new WeakMap(),
        Li = new WeakMap(),
        tC = new WeakSet();
      class y2 {
        constructor() {
          S(this, tC),
            v(this, JE, { writable: !0, value: Dne() }),
            v(this, eC, { writable: !0, value: 0 }),
            v(this, Li, { writable: !0, value: null });
        }
        static get _isSVGFittingCanvas() {
          const i = new OffscreenCanvas(1, 3).getContext('2d', {
              willReadFrequently: !0,
            }),
            r = new Image();
          return (
            (r.src =
              'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>'),
            Ye(
              this,
              '_isSVGFittingCanvas',
              r
                .decode()
                .then(
                  () => (
                    i.drawImage(r, 0, 0, 1, 1, 0, 0, 1, 3),
                    0 ===
                      new Uint32Array(i.getImageData(0, 0, 1, 1).data.buffer)[0]
                  )
                )
            )
          );
        }
        getFromFile(e) {
          var t = this;
          return U(function* () {
            const { lastModified: i, name: r, size: s, type: o } = e;
            return b(t, tC, w2).call(t, `${i}_${r}_${s}_${o}`, e);
          })();
        }
        getFromUrl(e) {
          var t = this;
          return U(function* () {
            return b(t, tC, w2).call(t, e, e);
          })();
        }
        getFromId(e) {
          var t = this;
          return U(function* () {
            d(t, Li) || _(t, Li, new Map());
            const i = d(t, Li).get(e);
            return i
              ? i.bitmap
                ? ((i.refCounter += 1), i)
                : i.file
                ? t.getFromFile(i.file)
                : t.getFromUrl(i.url)
              : null;
          })();
        }
        getSvgUrl(e) {
          const t = d(this, Li).get(e);
          return t?.isSvg ? t.svgUrl : null;
        }
        deleteId(e) {
          d(this, Li) || _(this, Li, new Map());
          const t = d(this, Li).get(e);
          t && ((t.refCounter -= 1), 0 === t.refCounter && (t.bitmap = null));
        }
        isValidId(e) {
          return e.startsWith(`image_${d(this, JE)}_`);
        }
      }
      function w2(n, e) {
        return nC.apply(this, arguments);
      }
      function nC() {
        return (nC = U(function* (n, e) {
          d(this, Li) || _(this, Li, new Map());
          let t = d(this, Li).get(n);
          if (null === t) return null;
          if (t?.bitmap) return (t.refCounter += 1), t;
          try {
            var i, r;
            let s;
            if (
              ((t ||= {
                bitmap: null,
                id: `image_${d(this, JE)}_${
                  (_(this, eC, ((i = d(this, eC)), (r = i++), i)), r)
                }`,
                refCounter: 0,
                isSvg: !1,
              }),
              'string' == typeof e
                ? ((t.url = e), (s = yield mg(e, 'blob')))
                : (s = t.file = e),
              'image/svg+xml' === s.type)
            ) {
              const o = y2._isSVGFittingCanvas,
                a = new FileReader(),
                l = new Image(),
                c = new Promise((u, h) => {
                  (l.onload = () => {
                    (t.bitmap = l), (t.isSvg = !0), u();
                  }),
                    (a.onload = U(function* () {
                      const f = (t.svgUrl = a.result);
                      l.src = (yield o)
                        ? `${f}#svgView(preserveAspectRatio(none))`
                        : f;
                    })),
                    (l.onerror = a.onerror = h);
                });
              a.readAsDataURL(s), yield c;
            } else t.bitmap = yield createImageBitmap(s);
            t.refCounter = 1;
          } catch (s) {
            console.error(s), (t = null);
          }
          return d(this, Li).set(n, t), t && d(this, Li).set(t.id, t), t;
        })).apply(this, arguments);
      }
      var Fn = new WeakMap(),
        ic = new WeakMap(),
        iC = new WeakMap(),
        mn = new WeakMap();
      class Kne {
        constructor(e = 128) {
          v(this, Fn, { writable: !0, value: [] }),
            v(this, ic, { writable: !0, value: !1 }),
            v(this, iC, { writable: !0, value: void 0 }),
            v(this, mn, { writable: !0, value: -1 }),
            _(this, iC, e);
        }
        add({
          cmd: e,
          undo: t,
          post: i,
          mustExec: r,
          type: s = NaN,
          overwriteIfSameType: o = !1,
          keepUndo: a = !1,
        }) {
          if ((r && e(), d(this, ic))) return;
          const l = { cmd: e, undo: t, post: i, type: s };
          if (-1 === d(this, mn))
            return (
              d(this, Fn).length > 0 && (d(this, Fn).length = 0),
              _(this, mn, 0),
              void d(this, Fn).push(l)
            );
          if (o && d(this, Fn)[d(this, mn)].type === s)
            return (
              a && (l.undo = d(this, Fn)[d(this, mn)].undo),
              void (d(this, Fn)[d(this, mn)] = l)
            );
          const c = d(this, mn) + 1;
          c === d(this, iC)
            ? d(this, Fn).splice(0, 1)
            : (_(this, mn, c), c < d(this, Fn).length && d(this, Fn).splice(c)),
            d(this, Fn).push(l);
        }
        undo() {
          if (-1 === d(this, mn)) return;
          _(this, ic, !0);
          const { undo: e, post: t } = d(this, Fn)[d(this, mn)];
          e(), t?.(), _(this, ic, !1), _(this, mn, d(this, mn) - 1);
        }
        redo() {
          if (d(this, mn) < d(this, Fn).length - 1) {
            _(this, mn, d(this, mn) + 1), _(this, ic, !0);
            const { cmd: e, post: t } = d(this, Fn)[d(this, mn)];
            e(), t?.(), _(this, ic, !1);
          }
        }
        hasSomethingToUndo() {
          return -1 !== d(this, mn);
        }
        hasSomethingToRedo() {
          return d(this, mn) < d(this, Fn).length - 1;
        }
        destroy() {
          _(this, Fn, null);
        }
      }
      var E2 = new WeakSet();
      class zu {
        constructor(e) {
          S(this, E2),
            (this.buffer = []),
            (this.callbacks = new Map()),
            (this.allKeys = new Set());
          const { isMac: t } = ui.platform;
          for (const [i, r, s = {}] of e)
            for (const o of i) {
              const a = o.startsWith('mac+');
              t && a
                ? (this.callbacks.set(o.slice(4), { callback: r, options: s }),
                  this.allKeys.add(o.split('+').at(-1)))
                : !t &&
                  !a &&
                  (this.callbacks.set(o, { callback: r, options: s }),
                  this.allKeys.add(o.split('+').at(-1)));
            }
        }
        exec(e, t) {
          if (!this.allKeys.has(t.key)) return;
          const i = this.callbacks.get(b(this, E2, Zne).call(this, t));
          if (!i) return;
          const {
            callback: r,
            options: { bubbles: s = !1, args: o = [], checker: a = null },
          } = i;
          (a && !a(e, t)) ||
            (r.bind(e, ...o, t)(),
            s || (t.stopPropagation(), t.preventDefault()));
        }
      }
      function Zne(n) {
        n.altKey && this.buffer.push('alt'),
          n.ctrlKey && this.buffer.push('ctrl'),
          n.metaKey && this.buffer.push('meta'),
          n.shiftKey && this.buffer.push('shift'),
          this.buffer.push(n.key);
        const e = this.buffer.join('+');
        return (this.buffer.length = 0), e;
      }
      class yg {
        get _colors() {
          const e = new Map([
            ['CanvasText', null],
            ['Canvas', null],
          ]);
          return (
            (function Vne(n) {
              const e = document.createElement('span');
              (e.style.visibility = 'hidden'), document.body.append(e);
              for (const t of n.keys()) {
                e.style.color = t;
                const i = window.getComputedStyle(e).color;
                n.set(t, XE(i));
              }
              e.remove();
            })(e),
            Ye(this, '_colors', e)
          );
        }
        convert(e) {
          const t = XE(e);
          if (!window.matchMedia('(forced-colors: active)').matches) return t;
          for (const [i, r] of this._colors)
            if (r.every((s, o) => s === t[o])) return yg._colorsMapping.get(i);
          return t;
        }
        getHexCode(e) {
          const t = this._colors.get(e);
          return t ? te.makeHexColor(...t) : e;
        }
      }
      Se(
        yg,
        '_colorsMapping',
        new Map([
          ['CanvasText', [0, 0, 0]],
          ['Canvas', [255, 255, 255]],
        ])
      );
      let Uu = (() => {
          var n = new WeakMap(),
            e = new WeakMap(),
            t = new WeakMap(),
            i = new WeakMap(),
            r = new WeakMap(),
            s = new WeakMap(),
            o = new WeakMap(),
            a = new WeakMap(),
            l = new WeakMap(),
            c = new WeakMap(),
            u = new WeakMap(),
            h = new WeakMap(),
            f = new WeakMap(),
            p = new WeakMap(),
            m = new WeakMap(),
            g = new WeakMap(),
            w = new WeakMap(),
            y = new WeakMap(),
            E = new WeakMap(),
            A = new WeakMap(),
            M = new WeakMap(),
            T = new WeakMap(),
            k = new WeakMap(),
            P = new WeakMap(),
            O = new WeakMap(),
            I = new WeakMap(),
            C = new WeakMap(),
            R = new WeakMap(),
            $ = new WeakMap(),
            q = new WeakMap(),
            oe = new WeakMap(),
            Oe = new WeakMap(),
            F = new WeakMap(),
            W = new WeakMap(),
            Q = new WeakMap(),
            ge = new WeakMap(),
            st = new WeakMap(),
            un = new WeakMap(),
            Je = new WeakMap(),
            ft = new WeakMap(),
            nt = new WeakMap(),
            vi = new WeakMap(),
            yi = new WeakMap(),
            De = new WeakMap(),
            Ct = new WeakMap(),
            Ot = new WeakMap(),
            Do = new WeakMap(),
            To = new WeakSet(),
            XS = new WeakSet(),
            JW = new WeakSet(),
            ej = new WeakSet(),
            Sb = new WeakSet(),
            tj = new WeakSet(),
            nj = new WeakSet(),
            ij = new WeakSet(),
            YS = new WeakSet(),
            rj = new WeakSet(),
            KS = new WeakSet(),
            ZS = new WeakSet(),
            sj = new WeakSet(),
            Qn = new WeakSet(),
            Io = new WeakSet(),
            oj = new WeakSet(),
            aj = new WeakSet(),
            QS = new WeakSet(),
            lj = new WeakMap(),
            yf = new WeakSet(),
            JS = new WeakSet();
          class Yc {
            static get _keyboardManager() {
              const x = Yc.prototype,
                B = (_e) =>
                  d(_e, Ot).contains(document.activeElement) &&
                  'BUTTON' !== document.activeElement.tagName &&
                  _e.hasSomethingToControl(),
                ne = (_e, { target: Fe }) => {
                  if (Fe instanceof HTMLInputElement) {
                    const { type: xt } = Fe;
                    return 'text' !== xt && 'number' !== xt;
                  }
                  return !0;
                },
                ce = this.TRANSLATE_SMALL,
                ae = this.TRANSLATE_BIG;
              return Ye(
                this,
                '_keyboardManager',
                new zu([
                  [['ctrl+a', 'mac+meta+a'], x.selectAll, { checker: ne }],
                  [['ctrl+z', 'mac+meta+z'], x.undo, { checker: ne }],
                  [
                    [
                      'ctrl+y',
                      'ctrl+shift+z',
                      'mac+meta+shift+z',
                      'ctrl+shift+Z',
                      'mac+meta+shift+Z',
                    ],
                    x.redo,
                    { checker: ne },
                  ],
                  [
                    [
                      'Backspace',
                      'alt+Backspace',
                      'ctrl+Backspace',
                      'shift+Backspace',
                      'mac+Backspace',
                      'mac+alt+Backspace',
                      'mac+ctrl+Backspace',
                      'Delete',
                      'ctrl+Delete',
                      'shift+Delete',
                      'mac+Delete',
                    ],
                    x.delete,
                    { checker: ne },
                  ],
                  [
                    ['Enter', 'mac+Enter'],
                    x.addNewEditorFromKeyboard,
                    {
                      checker: (_e, { target: Fe }) =>
                        !(Fe instanceof HTMLButtonElement) &&
                        d(_e, Ot).contains(Fe) &&
                        !_e.isEnterHandled,
                    },
                  ],
                  [
                    [' ', 'mac+ '],
                    x.addNewEditorFromKeyboard,
                    {
                      checker: (_e, { target: Fe }) =>
                        !(Fe instanceof HTMLButtonElement) &&
                        d(_e, Ot).contains(document.activeElement),
                    },
                  ],
                  [['Escape', 'mac+Escape'], x.unselectAll],
                  [
                    ['ArrowLeft', 'mac+ArrowLeft'],
                    x.translateSelectedEditors,
                    { args: [-ce, 0], checker: B },
                  ],
                  [
                    ['ctrl+ArrowLeft', 'mac+shift+ArrowLeft'],
                    x.translateSelectedEditors,
                    { args: [-ae, 0], checker: B },
                  ],
                  [
                    ['ArrowRight', 'mac+ArrowRight'],
                    x.translateSelectedEditors,
                    { args: [ce, 0], checker: B },
                  ],
                  [
                    ['ctrl+ArrowRight', 'mac+shift+ArrowRight'],
                    x.translateSelectedEditors,
                    { args: [ae, 0], checker: B },
                  ],
                  [
                    ['ArrowUp', 'mac+ArrowUp'],
                    x.translateSelectedEditors,
                    { args: [0, -ce], checker: B },
                  ],
                  [
                    ['ctrl+ArrowUp', 'mac+shift+ArrowUp'],
                    x.translateSelectedEditors,
                    { args: [0, -ae], checker: B },
                  ],
                  [
                    ['ArrowDown', 'mac+ArrowDown'],
                    x.translateSelectedEditors,
                    { args: [0, ce], checker: B },
                  ],
                  [
                    ['ctrl+ArrowDown', 'mac+shift+ArrowDown'],
                    x.translateSelectedEditors,
                    { args: [0, ae], checker: B },
                  ],
                ])
              );
            }
            constructor(x, B, ne, ce, ae, _e, Fe, xt, Lt, Vn) {
              S(this, JS),
                S(this, yf),
                v(this, lj, { get: Qce, set: void 0 }),
                S(this, QS),
                S(this, aj),
                S(this, oj),
                S(this, Io),
                S(this, Qn),
                S(this, sj),
                S(this, ZS),
                S(this, KS),
                S(this, rj),
                S(this, YS),
                S(this, ij),
                S(this, nj),
                S(this, tj),
                S(this, Sb),
                S(this, ej),
                S(this, JW),
                S(this, XS),
                S(this, To),
                v(this, n, { writable: !0, value: new AbortController() }),
                v(this, e, { writable: !0, value: null }),
                v(this, t, { writable: !0, value: new Map() }),
                v(this, i, { writable: !0, value: new Map() }),
                v(this, r, { writable: !0, value: null }),
                v(this, s, { writable: !0, value: null }),
                v(this, o, { writable: !0, value: null }),
                v(this, a, { writable: !0, value: new Kne() }),
                v(this, l, { writable: !0, value: 0 }),
                v(this, c, { writable: !0, value: new Set() }),
                v(this, u, { writable: !0, value: null }),
                v(this, h, { writable: !0, value: null }),
                v(this, f, { writable: !0, value: new Set() }),
                v(this, p, { writable: !0, value: !1 }),
                v(this, m, { writable: !0, value: !1 }),
                v(this, g, { writable: !0, value: null }),
                v(this, w, { writable: !0, value: null }),
                v(this, y, { writable: !0, value: null }),
                v(this, E, { writable: !0, value: !1 }),
                v(this, A, { writable: !0, value: null }),
                v(this, M, { writable: !0, value: new Yne() }),
                v(this, T, { writable: !0, value: !1 }),
                v(this, k, { writable: !0, value: !1 }),
                v(this, P, { writable: !0, value: null }),
                v(this, O, { writable: !0, value: null }),
                v(this, I, { writable: !0, value: null }),
                v(this, C, { writable: !0, value: $e.NONE }),
                v(this, R, { writable: !0, value: new Set() }),
                v(this, $, { writable: !0, value: null }),
                v(this, q, { writable: !0, value: null }),
                v(this, oe, { writable: !0, value: null }),
                v(this, Oe, { writable: !0, value: this.blur.bind(this) }),
                v(this, F, { writable: !0, value: this.focus.bind(this) }),
                v(this, W, { writable: !0, value: this.copy.bind(this) }),
                v(this, Q, { writable: !0, value: this.cut.bind(this) }),
                v(this, ge, { writable: !0, value: this.paste.bind(this) }),
                v(this, st, { writable: !0, value: this.keydown.bind(this) }),
                v(this, un, { writable: !0, value: this.keyup.bind(this) }),
                v(this, Je, {
                  writable: !0,
                  value: this.onEditingAction.bind(this),
                }),
                v(this, ft, {
                  writable: !0,
                  value: this.onPageChanging.bind(this),
                }),
                v(this, nt, {
                  writable: !0,
                  value: this.onScaleChanging.bind(this),
                }),
                v(this, vi, {
                  writable: !0,
                  value: this.onRotationChanging.bind(this),
                }),
                v(this, yi, {
                  writable: !0,
                  value: {
                    isEditing: !1,
                    isEmpty: !0,
                    hasSomethingToUndo: !1,
                    hasSomethingToRedo: !1,
                    hasSelectedEditor: !1,
                    hasSelectedText: !1,
                  },
                }),
                v(this, De, { writable: !0, value: [0, 0] }),
                v(this, Ct, { writable: !0, value: null }),
                v(this, Ot, { writable: !0, value: null }),
                v(this, Do, { writable: !0, value: null }),
                (this._signal = d(this, n).signal),
                _(this, Ot, x),
                _(this, Do, B),
                _(this, r, ne),
                (this._eventBus = ce),
                this._eventBus._on('editingaction', d(this, Je)),
                this._eventBus._on('pagechanging', d(this, ft)),
                this._eventBus._on('scalechanging', d(this, nt)),
                this._eventBus._on('rotationchanging', d(this, vi)),
                b(this, tj, $ce).call(this),
                b(this, sj, Yce).call(this),
                b(this, YS, dj).call(this),
                _(this, s, ae.annotationStorage),
                _(this, g, ae.filterFactory),
                _(this, q, _e),
                _(this, y, Fe || null),
                _(this, p, xt),
                _(this, m, Lt),
                _(this, I, Vn || null),
                (this.viewParameters = {
                  realScale: ur.PDF_TO_CSS_UNITS,
                  rotation: 0,
                }),
                (this.isShiftKeyDown = !1);
            }
            destroy() {
              d(this, n)?.abort(),
                _(this, n, null),
                (this._signal = null),
                this._eventBus._off('editingaction', d(this, Je)),
                this._eventBus._off('pagechanging', d(this, ft)),
                this._eventBus._off('scalechanging', d(this, nt)),
                this._eventBus._off('rotationchanging', d(this, vi));
              for (const x of d(this, i).values()) x.destroy();
              d(this, i).clear(),
                d(this, t).clear(),
                d(this, f).clear(),
                _(this, e, null),
                d(this, R).clear(),
                d(this, a).destroy(),
                d(this, r)?.destroy(),
                d(this, A)?.hide(),
                _(this, A, null),
                d(this, w) && (clearTimeout(d(this, w)), _(this, w, null)),
                d(this, Ct) && (clearTimeout(d(this, Ct)), _(this, Ct, null));
            }
            mlGuess(x) {
              var B = this;
              return U(function* () {
                return d(B, I)?.guess(x) || null;
              })();
            }
            isMLEnabledFor(x) {
              var B = this;
              return U(function* () {
                return !!(yield d(B, I)?.isEnabledFor(x));
              })();
            }
            get useNewAltTextFlow() {
              return d(this, m);
            }
            get hcmFilter() {
              return Ye(
                this,
                'hcmFilter',
                d(this, q)
                  ? d(this, g).addHCMFilter(
                      d(this, q).foreground,
                      d(this, q).background
                    )
                  : 'none'
              );
            }
            get direction() {
              return Ye(
                this,
                'direction',
                getComputedStyle(d(this, Ot)).direction
              );
            }
            get highlightColors() {
              return Ye(
                this,
                'highlightColors',
                d(this, y)
                  ? new Map(
                      d(this, y)
                        .split(',')
                        .map((x) => x.split('=').map((B) => B.trim()))
                    )
                  : null
              );
            }
            get highlightColorNames() {
              return Ye(
                this,
                'highlightColorNames',
                this.highlightColors
                  ? new Map(
                      Array.from(this.highlightColors, (x) => x.reverse())
                    )
                  : null
              );
            }
            setMainHighlightColorPicker(x) {
              _(this, O, x);
            }
            editAltText(x) {
              d(this, r)?.editAltText(this, x);
            }
            switchToMode(x, B) {
              this._eventBus.on('annotationeditormodechanged', B, {
                once: !0,
                signal: this._signal,
              }),
                this._eventBus.dispatch('showannotationeditorui', {
                  source: this,
                  mode: x,
                });
            }
            setPreference(x, B) {
              this._eventBus.dispatch('setpreference', {
                source: this,
                name: x,
                value: B,
              });
            }
            onPageChanging({ pageNumber: x }) {
              _(this, l, x - 1);
            }
            focusMainContainer() {
              d(this, Ot).focus();
            }
            findParent(x, B) {
              for (const ne of d(this, i).values()) {
                const {
                  x: ce,
                  y: ae,
                  width: _e,
                  height: Fe,
                } = ne.div.getBoundingClientRect();
                if (x >= ce && x <= ce + _e && B >= ae && B <= ae + Fe)
                  return ne;
              }
              return null;
            }
            disableUserSelect(x = !1) {
              d(this, Do).classList.toggle('noUserSelect', x);
            }
            addShouldRescale(x) {
              d(this, f).add(x);
            }
            removeShouldRescale(x) {
              d(this, f).delete(x);
            }
            onScaleChanging({ scale: x }) {
              this.commitOrRemove(),
                (this.viewParameters.realScale = x * ur.PDF_TO_CSS_UNITS);
              for (const B of d(this, f)) B.onScaleChanging();
            }
            onRotationChanging({ pagesRotation: x }) {
              this.commitOrRemove(), (this.viewParameters.rotation = x);
            }
            highlightSelection(x = '') {
              const B = document.getSelection();
              if (!B || B.isCollapsed) return;
              const {
                  anchorNode: ne,
                  anchorOffset: ce,
                  focusNode: ae,
                  focusOffset: _e,
                } = B,
                Fe = B.toString(),
                Lt = b(this, To, eM).call(this, B).closest('.textLayer'),
                Vn = this.getSelectionBoxes(Lt);
              if (!Vn) return;
              B.empty();
              const Ei = b(this, XS, cj).call(this, Lt),
                Ci = d(this, C) === $e.NONE,
                Db = () => {
                  Ei?.createAndAddNewEditor({ x: 0, y: 0 }, !1, {
                    methodOfCreation: x,
                    boxes: Vn,
                    anchorNode: ne,
                    anchorOffset: ce,
                    focusNode: ae,
                    focusOffset: _e,
                    text: Fe,
                  }),
                    Ci && this.showAllEditors('highlight', !0, !0);
                };
              Ci ? this.switchToMode($e.HIGHLIGHT, Db) : Db();
            }
            addToAnnotationStorage(x) {
              !x.isEmpty() &&
                d(this, s) &&
                !d(this, s).has(x.id) &&
                d(this, s).setValue(x.id, x);
            }
            blur() {
              if (
                ((this.isShiftKeyDown = !1),
                d(this, E) &&
                  (_(this, E, !1), b(this, Sb, tM).call(this, 'main_toolbar')),
                !this.hasSelection)
              )
                return;
              const { activeElement: x } = document;
              for (const B of d(this, R))
                if (B.div.contains(x)) {
                  _(this, P, [B, x]), (B._focusEventsAllowed = !1);
                  break;
                }
            }
            focus() {
              if (!d(this, P)) return;
              const [x, B] = d(this, P);
              _(this, P, null),
                B.addEventListener(
                  'focusin',
                  () => {
                    x._focusEventsAllowed = !0;
                  },
                  { once: !0, signal: this._signal }
                ),
                B.focus();
            }
            addEditListeners() {
              b(this, YS, dj).call(this), b(this, KS, uj).call(this);
            }
            removeEditListeners() {
              b(this, rj, Xce).call(this), b(this, ZS, hj).call(this);
            }
            dragOver(x) {
              for (const { type: B } of x.dataTransfer.items)
                for (const ne of d(this, h))
                  if (ne.isHandlingMimeForPasting(B))
                    return (
                      (x.dataTransfer.dropEffect = 'copy'),
                      void x.preventDefault()
                    );
            }
            drop(x) {
              for (const B of x.dataTransfer.items)
                for (const ne of d(this, h))
                  if (ne.isHandlingMimeForPasting(B.type))
                    return (
                      ne.paste(B, this.currentLayer), void x.preventDefault()
                    );
            }
            copy(x) {
              if (
                (x.preventDefault(),
                d(this, e)?.commitOrRemove(),
                !this.hasSelection)
              )
                return;
              const B = [];
              for (const ne of d(this, R)) {
                const ce = ne.serialize(!0);
                ce && B.push(ce);
              }
              0 !== B.length &&
                x.clipboardData.setData('application/pdfjs', JSON.stringify(B));
            }
            cut(x) {
              this.copy(x), this.delete();
            }
            paste(x) {
              x.preventDefault();
              const { clipboardData: B } = x;
              for (const ae of B.items)
                for (const _e of d(this, h))
                  if (_e.isHandlingMimeForPasting(ae.type))
                    return void _e.paste(ae, this.currentLayer);
              let ne = B.getData('application/pdfjs');
              if (!ne) return;
              try {
                ne = JSON.parse(ne);
              } catch (ae) {
                return void Ve(`paste: "${ae.message}".`);
              }
              if (!Array.isArray(ne)) return;
              this.unselectAll();
              const ce = this.currentLayer;
              try {
                const ae = [];
                for (const xt of ne) {
                  const Lt = ce.deserialize(xt);
                  if (!Lt) return;
                  ae.push(Lt);
                }
                this.addCommands({
                  cmd: () => {
                    for (const xt of ae) b(this, QS, fj).call(this, xt);
                    b(this, JS, pj).call(this, ae);
                  },
                  undo: () => {
                    for (const xt of ae) xt.remove();
                  },
                  mustExec: !0,
                });
              } catch (ae) {
                Ve(`paste: "${ae.message}".`);
              }
            }
            keydown(x) {
              !this.isShiftKeyDown &&
                'Shift' === x.key &&
                (this.isShiftKeyDown = !0),
                d(this, C) !== $e.NONE &&
                  !this.isEditorHandlingKeyboard &&
                  Yc._keyboardManager.exec(this, x);
            }
            keyup(x) {
              this.isShiftKeyDown &&
                'Shift' === x.key &&
                ((this.isShiftKeyDown = !1),
                d(this, E) &&
                  (_(this, E, !1), b(this, Sb, tM).call(this, 'main_toolbar')));
            }
            onEditingAction({ name: x }) {
              switch (x) {
                case 'undo':
                case 'redo':
                case 'delete':
                case 'selectAll':
                  this[x]();
                  break;
                case 'highlightSelection':
                  this.highlightSelection('context_menu');
              }
            }
            setEditingState(x) {
              x
                ? (b(this, nj, Gce).call(this),
                  b(this, KS, uj).call(this),
                  b(this, Qn, wi).call(this, {
                    isEditing: d(this, C) !== $e.NONE,
                    isEmpty: b(this, yf, Mb).call(this),
                    hasSomethingToUndo: d(this, a).hasSomethingToUndo(),
                    hasSomethingToRedo: d(this, a).hasSomethingToRedo(),
                    hasSelectedEditor: !1,
                  }))
                : (b(this, ij, qce).call(this),
                  b(this, ZS, hj).call(this),
                  b(this, Qn, wi).call(this, { isEditing: !1 }),
                  this.disableUserSelect(!1));
            }
            registerEditorTypes(x) {
              if (!d(this, h)) {
                _(this, h, x);
                for (const B of d(this, h))
                  b(this, Io, qa).call(this, B.defaultPropertiesToUpdate);
              }
            }
            getId() {
              return d(this, M).id;
            }
            get currentLayer() {
              return d(this, i).get(d(this, l));
            }
            getLayer(x) {
              return d(this, i).get(x);
            }
            get currentPageIndex() {
              return d(this, l);
            }
            addLayer(x) {
              d(this, i).set(x.pageIndex, x),
                d(this, T) ? x.enable() : x.disable();
            }
            removeLayer(x) {
              d(this, i).delete(x.pageIndex);
            }
            updateMode(x, B = null, ne = !1) {
              if (d(this, C) !== x) {
                if ((_(this, C, x), x === $e.NONE))
                  return (
                    this.setEditingState(!1), void b(this, aj, Zce).call(this)
                  );
                this.setEditingState(!0),
                  b(this, oj, Kce).call(this),
                  this.unselectAll();
                for (const ce of d(this, i).values()) ce.updateMode(x);
                if (!B && ne) return void this.addNewEditorFromKeyboard();
                if (B)
                  for (const ce of d(this, t).values())
                    if (ce.annotationElementId === B) {
                      this.setSelected(ce), ce.enterInEditMode();
                      break;
                    }
              }
            }
            addNewEditorFromKeyboard() {
              this.currentLayer.canCreateNewEmptyEditor() &&
                this.currentLayer.addNewEditor();
            }
            updateToolbar(x) {
              x !== d(this, C) &&
                this._eventBus.dispatch('switchannotationeditormode', {
                  source: this,
                  mode: x,
                });
            }
            updateParams(x, B) {
              if (d(this, h)) {
                switch (x) {
                  case Ee.CREATE:
                    return void this.currentLayer.addNewEditor();
                  case Ee.HIGHLIGHT_DEFAULT_COLOR:
                    d(this, O)?.updateColor(B);
                    break;
                  case Ee.HIGHLIGHT_SHOW_ALL:
                    this._eventBus.dispatch('reporttelemetry', {
                      source: this,
                      details: {
                        type: 'editing',
                        data: {
                          type: 'highlight',
                          action: 'toggle_visibility',
                        },
                      },
                    }),
                      (d(this, oe) || _(this, oe, new Map())).set(x, B),
                      this.showAllEditors('highlight', B);
                }
                for (const ne of d(this, R)) ne.updateParams(x, B);
                for (const ne of d(this, h)) ne.updateDefaultParams(x, B);
              }
            }
            showAllEditors(x, B, ne = !1) {
              for (const ae of d(this, t).values())
                ae.editorType === x && ae.show(B);
              (d(this, oe)?.get(Ee.HIGHLIGHT_SHOW_ALL) ?? !0) !== B &&
                b(this, Io, qa).call(this, [[Ee.HIGHLIGHT_SHOW_ALL, B]]);
            }
            enableWaiting(x = !1) {
              if (d(this, k) !== x) {
                _(this, k, x);
                for (const B of d(this, i).values())
                  x ? B.disableClick() : B.enableClick(),
                    B.div.classList.toggle('waiting', x);
              }
            }
            getEditors(x) {
              const B = [];
              for (const ne of d(this, t).values())
                ne.pageIndex === x && B.push(ne);
              return B;
            }
            getEditor(x) {
              return d(this, t).get(x);
            }
            addEditor(x) {
              d(this, t).set(x.id, x);
            }
            removeEditor(x) {
              x.div.contains(document.activeElement) &&
                (d(this, w) && clearTimeout(d(this, w)),
                _(
                  this,
                  w,
                  setTimeout(() => {
                    this.focusMainContainer(), _(this, w, null);
                  }, 0)
                )),
                d(this, t).delete(x.id),
                this.unselect(x),
                (!x.annotationElementId ||
                  !d(this, c).has(x.annotationElementId)) &&
                  d(this, s)?.remove(x.id);
            }
            addDeletedAnnotationElement(x) {
              d(this, c).add(x.annotationElementId),
                this.addChangedExistingAnnotation(x),
                (x.deleted = !0);
            }
            isDeletedAnnotationElement(x) {
              return d(this, c).has(x);
            }
            removeDeletedAnnotationElement(x) {
              d(this, c).delete(x.annotationElementId),
                this.removeChangedExistingAnnotation(x),
                (x.deleted = !1);
            }
            setActiveEditor(x) {
              d(this, e) !== x &&
                (_(this, e, x),
                x && b(this, Io, qa).call(this, x.propertiesToUpdate));
            }
            updateUI(x) {
              d(this, lj) === x &&
                b(this, Io, qa).call(this, x.propertiesToUpdate);
            }
            toggleSelected(x) {
              if (d(this, R).has(x))
                return (
                  d(this, R).delete(x),
                  x.unselect(),
                  void b(this, Qn, wi).call(this, {
                    hasSelectedEditor: this.hasSelection,
                  })
                );
              d(this, R).add(x),
                x.select(),
                b(this, Io, qa).call(this, x.propertiesToUpdate),
                b(this, Qn, wi).call(this, { hasSelectedEditor: !0 });
            }
            setSelected(x) {
              for (const B of d(this, R)) B !== x && B.unselect();
              d(this, R).clear(),
                d(this, R).add(x),
                x.select(),
                b(this, Io, qa).call(this, x.propertiesToUpdate),
                b(this, Qn, wi).call(this, { hasSelectedEditor: !0 });
            }
            isSelected(x) {
              return d(this, R).has(x);
            }
            get firstSelectedEditor() {
              return d(this, R).values().next().value;
            }
            unselect(x) {
              x.unselect(),
                d(this, R).delete(x),
                b(this, Qn, wi).call(this, {
                  hasSelectedEditor: this.hasSelection,
                });
            }
            get hasSelection() {
              return 0 !== d(this, R).size;
            }
            get isEnterHandled() {
              return (
                1 === d(this, R).size && this.firstSelectedEditor.isEnterHandled
              );
            }
            undo() {
              d(this, a).undo(),
                b(this, Qn, wi).call(this, {
                  hasSomethingToUndo: d(this, a).hasSomethingToUndo(),
                  hasSomethingToRedo: !0,
                  isEmpty: b(this, yf, Mb).call(this),
                });
            }
            redo() {
              d(this, a).redo(),
                b(this, Qn, wi).call(this, {
                  hasSomethingToUndo: !0,
                  hasSomethingToRedo: d(this, a).hasSomethingToRedo(),
                  isEmpty: b(this, yf, Mb).call(this),
                });
            }
            addCommands(x) {
              d(this, a).add(x),
                b(this, Qn, wi).call(this, {
                  hasSomethingToUndo: !0,
                  hasSomethingToRedo: !1,
                  isEmpty: b(this, yf, Mb).call(this),
                });
            }
            delete() {
              if ((this.commitOrRemove(), !this.hasSelection)) return;
              const x = [...d(this, R)];
              this.addCommands({
                cmd: () => {
                  for (const ce of x) ce.remove();
                },
                undo: () => {
                  for (const ce of x) b(this, QS, fj).call(this, ce);
                },
                mustExec: !0,
              });
            }
            commitOrRemove() {
              d(this, e)?.commitOrRemove();
            }
            hasSomethingToControl() {
              return d(this, e) || this.hasSelection;
            }
            selectAll() {
              for (const x of d(this, R)) x.commit();
              b(this, JS, pj).call(this, d(this, t).values());
            }
            unselectAll() {
              if (
                (!d(this, e) ||
                  (d(this, e).commitOrRemove(), d(this, C) === $e.NONE)) &&
                this.hasSelection
              ) {
                for (const x of d(this, R)) x.unselect();
                d(this, R).clear(),
                  b(this, Qn, wi).call(this, { hasSelectedEditor: !1 });
              }
            }
            translateSelectedEditors(x, B, ne = !1) {
              if ((ne || this.commitOrRemove(), !this.hasSelection)) return;
              (d(this, De)[0] += x), (d(this, De)[1] += B);
              const [ce, ae] = d(this, De),
                _e = [...d(this, R)];
              d(this, Ct) && clearTimeout(d(this, Ct)),
                _(
                  this,
                  Ct,
                  setTimeout(() => {
                    _(this, Ct, null),
                      (d(this, De)[0] = d(this, De)[1] = 0),
                      this.addCommands({
                        cmd: () => {
                          for (const xt of _e)
                            d(this, t).has(xt.id) && xt.translateInPage(ce, ae);
                        },
                        undo: () => {
                          for (const xt of _e)
                            d(this, t).has(xt.id) &&
                              xt.translateInPage(-ce, -ae);
                        },
                        mustExec: !1,
                      });
                  }, 1e3)
                );
              for (const xt of _e) xt.translateInPage(x, B);
            }
            setUpDragSession() {
              if (this.hasSelection) {
                this.disableUserSelect(!0), _(this, u, new Map());
                for (const x of d(this, R))
                  d(this, u).set(x, {
                    savedX: x.x,
                    savedY: x.y,
                    savedPageIndex: x.pageIndex,
                    newX: 0,
                    newY: 0,
                    newPageIndex: -1,
                  });
              }
            }
            endDragSession() {
              if (!d(this, u)) return !1;
              this.disableUserSelect(!1);
              const x = d(this, u);
              _(this, u, null);
              let B = !1;
              for (const [{ x: ce, y: ae, pageIndex: _e }, Fe] of x)
                (Fe.newX = ce),
                  (Fe.newY = ae),
                  (Fe.newPageIndex = _e),
                  (B ||=
                    ce !== Fe.savedX ||
                    ae !== Fe.savedY ||
                    _e !== Fe.savedPageIndex);
              if (!B) return !1;
              const ne = (ce, ae, _e, Fe) => {
                if (d(this, t).has(ce.id)) {
                  const xt = d(this, i).get(Fe);
                  xt
                    ? ce._setParentAndPosition(xt, ae, _e)
                    : ((ce.pageIndex = Fe), (ce.x = ae), (ce.y = _e));
                }
              };
              return (
                this.addCommands({
                  cmd: () => {
                    for (const [
                      ce,
                      { newX: ae, newY: _e, newPageIndex: Fe },
                    ] of x)
                      ne(ce, ae, _e, Fe);
                  },
                  undo: () => {
                    for (const [
                      ce,
                      { savedX: ae, savedY: _e, savedPageIndex: Fe },
                    ] of x)
                      ne(ce, ae, _e, Fe);
                  },
                  mustExec: !0,
                }),
                !0
              );
            }
            dragSelectedEditors(x, B) {
              if (d(this, u)) for (const ne of d(this, u).keys()) ne.drag(x, B);
            }
            rebuild(x) {
              if (null === x.parent) {
                const B = this.getLayer(x.pageIndex);
                B
                  ? (B.changeParent(x), B.addOrRebuild(x))
                  : (this.addEditor(x),
                    this.addToAnnotationStorage(x),
                    x.rebuild());
              } else x.parent.addOrRebuild(x);
            }
            get isEditorHandlingKeyboard() {
              return (
                this.getActive()?.shouldGetKeyboardEvents() ||
                (1 === d(this, R).size &&
                  this.firstSelectedEditor.shouldGetKeyboardEvents())
              );
            }
            isActive(x) {
              return d(this, e) === x;
            }
            getActive() {
              return d(this, e);
            }
            getMode() {
              return d(this, C);
            }
            get imageManager() {
              return Ye(this, 'imageManager', new y2());
            }
            getSelectionBoxes(x) {
              if (!x) return null;
              const B = document.getSelection();
              for (let Lt = 0, Vn = B.rangeCount; Lt < Vn; Lt++)
                if (!x.contains(B.getRangeAt(Lt).commonAncestorContainer))
                  return null;
              const {
                x: ne,
                y: ce,
                width: ae,
                height: _e,
              } = x.getBoundingClientRect();
              let Fe;
              switch (x.getAttribute('data-main-rotation')) {
                case '90':
                  Fe = (Lt, Vn, Ei, Ci) => ({
                    x: (Vn - ce) / _e,
                    y: 1 - (Lt + Ei - ne) / ae,
                    width: Ci / _e,
                    height: Ei / ae,
                  });
                  break;
                case '180':
                  Fe = (Lt, Vn, Ei, Ci) => ({
                    x: 1 - (Lt + Ei - ne) / ae,
                    y: 1 - (Vn + Ci - ce) / _e,
                    width: Ei / ae,
                    height: Ci / _e,
                  });
                  break;
                case '270':
                  Fe = (Lt, Vn, Ei, Ci) => ({
                    x: 1 - (Vn + Ci - ce) / _e,
                    y: (Lt - ne) / ae,
                    width: Ci / _e,
                    height: Ei / ae,
                  });
                  break;
                default:
                  Fe = (Lt, Vn, Ei, Ci) => ({
                    x: (Lt - ne) / ae,
                    y: (Vn - ce) / _e,
                    width: Ei / ae,
                    height: Ci / _e,
                  });
              }
              const xt = [];
              for (let Lt = 0, Vn = B.rangeCount; Lt < Vn; Lt++) {
                const Ei = B.getRangeAt(Lt);
                if (!Ei.collapsed)
                  for (const {
                    x: Ci,
                    y: Db,
                    width: mj,
                    height: gj,
                  } of Ei.getClientRects())
                    0 === mj || 0 === gj || xt.push(Fe(Ci, Db, mj, gj));
              }
              return 0 === xt.length ? null : xt;
            }
            addChangedExistingAnnotation({ annotationElementId: x, id: B }) {
              (d(this, o) || _(this, o, new Map())).set(x, B);
            }
            removeChangedExistingAnnotation({ annotationElementId: x }) {
              d(this, o)?.delete(x);
            }
            renderAnnotationElement(x) {
              const B = d(this, o)?.get(x.data.id);
              if (!B) return;
              const ne = d(this, s).getRawValue(B);
              ne &&
                ((d(this, C) === $e.NONE && !ne.hasBeenModified) ||
                  ne.renderAnnotationElement(x));
            }
          }
          function eM({ anchorNode: ie }) {
            return ie.nodeType === Node.TEXT_NODE ? ie.parentElement : ie;
          }
          function cj(ie) {
            const { currentLayer: x } = this;
            if (x.hasTextLayer(ie)) return x;
            for (const B of d(this, i).values())
              if (B.hasTextLayer(ie)) return B;
            return null;
          }
          function zce() {
            const ie = document.getSelection();
            if (!ie || ie.isCollapsed) return;
            const B = b(this, To, eM).call(this, ie).closest('.textLayer'),
              ne = this.getSelectionBoxes(B);
            ne &&
              (d(this, A) || _(this, A, new Une(this)),
              d(this, A).show(B, ne, 'ltr' === this.direction));
          }
          function Uce() {
            const ie = document.getSelection();
            if (!ie || ie.isCollapsed)
              return void (
                d(this, $) &&
                (d(this, A)?.hide(),
                _(this, $, null),
                b(this, Qn, wi).call(this, { hasSelectedText: !1 }))
              );
            const { anchorNode: x } = ie;
            if (x === d(this, $)) return;
            const ne = b(this, To, eM).call(this, ie).closest('.textLayer');
            if (ne) {
              if (
                (d(this, A)?.hide(),
                _(this, $, x),
                b(this, Qn, wi).call(this, { hasSelectedText: !0 }),
                (d(this, C) === $e.HIGHLIGHT || d(this, C) === $e.NONE) &&
                  (d(this, C) === $e.HIGHLIGHT &&
                    this.showAllEditors('highlight', !0, !0),
                  _(this, E, this.isShiftKeyDown),
                  !this.isShiftKeyDown))
              ) {
                const ce =
                  d(this, C) === $e.HIGHLIGHT
                    ? b(this, XS, cj).call(this, ne)
                    : null;
                ce?.toggleDrawing();
                const ae = this._signal,
                  _e = (Fe) => {
                    ('pointerup' === Fe.type && 0 !== Fe.button) ||
                      (ce?.toggleDrawing(!0),
                      window.removeEventListener('pointerup', _e),
                      window.removeEventListener('blur', _e),
                      'pointerup' === Fe.type &&
                        b(this, Sb, tM).call(this, 'main_toolbar'));
                  };
                window.addEventListener('pointerup', _e, { signal: ae }),
                  window.addEventListener('blur', _e, { signal: ae });
              }
            } else
              d(this, $) &&
                (d(this, A)?.hide(),
                _(this, $, null),
                b(this, Qn, wi).call(this, { hasSelectedText: !1 }));
          }
          function tM(ie = '') {
            d(this, C) === $e.HIGHLIGHT
              ? this.highlightSelection(ie)
              : d(this, p) && b(this, JW, zce).call(this);
          }
          function $ce() {
            document.addEventListener(
              'selectionchange',
              b(this, ej, Uce).bind(this),
              { signal: this._signal }
            );
          }
          function Gce() {
            const ie = this._signal;
            window.addEventListener('focus', d(this, F), { signal: ie }),
              window.addEventListener('blur', d(this, Oe), { signal: ie });
          }
          function qce() {
            window.removeEventListener('focus', d(this, F)),
              window.removeEventListener('blur', d(this, Oe));
          }
          function dj() {
            const ie = this._signal;
            window.addEventListener('keydown', d(this, st), { signal: ie }),
              window.addEventListener('keyup', d(this, un), { signal: ie });
          }
          function Xce() {
            window.removeEventListener('keydown', d(this, st)),
              window.removeEventListener('keyup', d(this, un));
          }
          function uj() {
            const ie = this._signal;
            document.addEventListener('copy', d(this, W), { signal: ie }),
              document.addEventListener('cut', d(this, Q), { signal: ie }),
              document.addEventListener('paste', d(this, ge), { signal: ie });
          }
          function hj() {
            document.removeEventListener('copy', d(this, W)),
              document.removeEventListener('cut', d(this, Q)),
              document.removeEventListener('paste', d(this, ge));
          }
          function Yce() {
            const ie = this._signal;
            document.addEventListener('dragover', this.dragOver.bind(this), {
              signal: ie,
            }),
              document.addEventListener('drop', this.drop.bind(this), {
                signal: ie,
              });
          }
          function wi(ie) {
            Object.entries(ie).some(([B, ne]) => d(this, yi)[B] !== ne) &&
              (this._eventBus.dispatch('annotationeditorstateschanged', {
                source: this,
                details: Object.assign(d(this, yi), ie),
              }),
              d(this, C) === $e.HIGHLIGHT &&
                !1 === ie.hasSelectedEditor &&
                b(this, Io, qa).call(this, [[Ee.HIGHLIGHT_FREE, !0]]));
          }
          function qa(ie) {
            this._eventBus.dispatch('annotationeditorparamschanged', {
              source: this,
              details: ie,
            });
          }
          function Kce() {
            if (!d(this, T)) {
              _(this, T, !0);
              for (const ie of d(this, i).values()) ie.enable();
              for (const ie of d(this, t).values()) ie.enable();
            }
          }
          function Zce() {
            if ((this.unselectAll(), d(this, T))) {
              _(this, T, !1);
              for (const ie of d(this, i).values()) ie.disable();
              for (const ie of d(this, t).values()) ie.disable();
            }
          }
          function fj(ie) {
            const x = d(this, i).get(ie.pageIndex);
            x
              ? x.addOrRebuild(ie)
              : (this.addEditor(ie), this.addToAnnotationStorage(ie));
          }
          function Qce() {
            let ie = null;
            for (ie of d(this, R));
            return ie;
          }
          function Mb() {
            if (0 === d(this, t).size) return !0;
            if (1 === d(this, t).size)
              for (const ie of d(this, t).values()) return ie.isEmpty();
            return !1;
          }
          function pj(ie) {
            for (const x of d(this, R)) x.unselect();
            d(this, R).clear();
            for (const x of ie) x.isEmpty() || (d(this, R).add(x), x.select());
            b(this, Qn, wi).call(this, {
              hasSelectedEditor: this.hasSelection,
            });
          }
          return Se(Yc, 'TRANSLATE_SMALL', 1), Se(Yc, 'TRANSLATE_BIG', 10), Yc;
        })(),
        C2 = (() => {
          var n = new WeakMap(),
            e = new WeakMap(),
            t = new WeakMap(),
            i = new WeakMap(),
            r = new WeakMap(),
            s = new WeakMap(),
            o = new WeakMap(),
            a = new WeakSet();
          class l {
            constructor(f) {
              S(this, a),
                v(this, n, { writable: !0, value: '' }),
                v(this, e, { writable: !0, value: !1 }),
                v(this, t, { writable: !0, value: null }),
                v(this, i, { writable: !0, value: null }),
                v(this, r, { writable: !0, value: null }),
                v(this, s, { writable: !0, value: !1 }),
                v(this, o, { writable: !0, value: null }),
                _(this, o, f);
            }
            static initialize(f) {
              l._l10nPromise ||= f;
            }
            render() {
              var f = this;
              return U(function* () {
                const p = _(f, t, document.createElement('button'));
                p.className = 'altText';
                const m = yield l._l10nPromise.get(
                  'pdfjs-editor-alt-text-button-label'
                );
                (p.textContent = m),
                  p.setAttribute('aria-label', m),
                  (p.tabIndex = '0');
                const g = d(f, o)._uiManager._signal;
                p.addEventListener('contextmenu', fi, { signal: g }),
                  p.addEventListener(
                    'pointerdown',
                    (y) => y.stopPropagation(),
                    { signal: g }
                  );
                const w = (y) => {
                  y.preventDefault(), d(f, o)._uiManager.editAltText(d(f, o));
                };
                return (
                  p.addEventListener('click', w, { capture: !0, signal: g }),
                  p.addEventListener(
                    'keydown',
                    (y) => {
                      y.target === p &&
                        'Enter' === y.key &&
                        (_(f, s, !0), w(y));
                    },
                    { signal: g }
                  ),
                  yield b(f, a, c).call(f),
                  p
                );
              })();
            }
            finish() {
              d(this, t) &&
                (d(this, t).focus({ focusVisible: d(this, s) }),
                _(this, s, !1));
            }
            isEmpty() {
              return !d(this, n) && !d(this, e);
            }
            get data() {
              return { altText: d(this, n), decorative: d(this, e) };
            }
            set data({ altText: f, decorative: p }) {
              (d(this, n) === f && d(this, e) === p) ||
                (_(this, n, f), _(this, e, p), b(this, a, c).call(this));
            }
            toggle(f = !1) {
              d(this, t) &&
                (!f &&
                  d(this, r) &&
                  (clearTimeout(d(this, r)), _(this, r, null)),
                (d(this, t).disabled = !f));
            }
            destroy() {
              d(this, t)?.remove(), _(this, t, null), _(this, i, null);
            }
          }
          function c() {
            return u.apply(this, arguments);
          }
          function u() {
            return (u = U(function* () {
              const h = d(this, t);
              if (!h) return;
              if (!d(this, n) && !d(this, e))
                return h.classList.remove('done'), void d(this, i)?.remove();
              h.classList.add('done'),
                l._l10nPromise
                  .get('pdfjs-editor-alt-text-edit-button-label')
                  .then((m) => {
                    h.setAttribute('aria-label', m);
                  });
              let f = d(this, i);
              if (!f) {
                _(this, i, (f = document.createElement('span'))),
                  (f.className = 'tooltip'),
                  f.setAttribute('role', 'tooltip');
                const m = (f.id = `alt-text-tooltip-${d(this, o).id}`);
                h.setAttribute('aria-describedby', m);
                const g = 100,
                  w = d(this, o)._uiManager._signal;
                w.addEventListener(
                  'abort',
                  () => {
                    clearTimeout(d(this, r)), _(this, r, null);
                  },
                  { once: !0 }
                ),
                  h.addEventListener(
                    'mouseenter',
                    () => {
                      _(
                        this,
                        r,
                        setTimeout(() => {
                          _(this, r, null),
                            d(this, i).classList.add('show'),
                            d(this, o)._reportTelemetry({
                              action: 'alt_text_tooltip',
                            });
                        }, g)
                      );
                    },
                    { signal: w }
                  ),
                  h.addEventListener(
                    'mouseleave',
                    () => {
                      d(this, r) &&
                        (clearTimeout(d(this, r)), _(this, r, null)),
                        d(this, i)?.classList.remove('show');
                    },
                    { signal: w }
                  );
              }
              (f.innerText = d(this, e)
                ? yield l._l10nPromise.get(
                    'pdfjs-editor-alt-text-decorative-tooltip'
                  )
                : d(this, n)),
                f.parentNode || h.append(f),
                d(this, o)
                  .getImageForAltText()
                  ?.setAttribute('aria-describedby', f.id);
            })).apply(this, arguments);
          }
          return Se(l, '_l10nPromise', null), l;
        })();
      var $u = new WeakMap(),
        ys = new WeakMap(),
        pi = new WeakMap(),
        wg = new WeakMap(),
        Gu = new WeakMap(),
        qn = new WeakMap(),
        qu = new WeakMap(),
        Eg = new WeakMap(),
        Cg = new WeakMap(),
        mi = new WeakMap(),
        rC = new WeakMap(),
        Xu = new WeakMap(),
        so = new WeakMap(),
        sC = new WeakMap(),
        Yu = new WeakMap(),
        va = new WeakMap(),
        oo = new WeakMap(),
        xg = new WeakMap(),
        Ag = new WeakMap(),
        fr = new WeakMap(),
        oC = new WeakMap(),
        x2 = new WeakMap(),
        aC = new WeakSet(),
        lC = new WeakSet(),
        A2 = new WeakSet(),
        S2 = new WeakSet(),
        cC = new WeakSet(),
        dC = new WeakSet(),
        uC = new WeakSet(),
        M2 = new WeakSet(),
        D2 = new WeakSet(),
        T2 = new WeakSet(),
        I2 = new WeakSet(),
        hC = new WeakSet(),
        Ku = new WeakSet();
      class re {
        static get _resizerKeyboardManager() {
          const e = re.prototype._resizeWithKeyboard,
            t = Uu.TRANSLATE_SMALL,
            i = Uu.TRANSLATE_BIG;
          return Ye(
            this,
            '_resizerKeyboardManager',
            new zu([
              [['ArrowLeft', 'mac+ArrowLeft'], e, { args: [-t, 0] }],
              [['ctrl+ArrowLeft', 'mac+shift+ArrowLeft'], e, { args: [-i, 0] }],
              [['ArrowRight', 'mac+ArrowRight'], e, { args: [t, 0] }],
              [
                ['ctrl+ArrowRight', 'mac+shift+ArrowRight'],
                e,
                { args: [i, 0] },
              ],
              [['ArrowUp', 'mac+ArrowUp'], e, { args: [0, -t] }],
              [['ctrl+ArrowUp', 'mac+shift+ArrowUp'], e, { args: [0, -i] }],
              [['ArrowDown', 'mac+ArrowDown'], e, { args: [0, t] }],
              [['ctrl+ArrowDown', 'mac+shift+ArrowDown'], e, { args: [0, i] }],
              [
                ['Escape', 'mac+Escape'],
                re.prototype._stopResizingWithKeyboard,
              ],
            ])
          );
        }
        constructor(e) {
          S(this, Ku),
            S(this, hC),
            S(this, I2),
            S(this, T2),
            S(this, D2),
            S(this, M2),
            S(this, uC),
            S(this, dC),
            S(this, cC),
            S(this, S2),
            S(this, A2),
            S(this, lC),
            S(this, aC),
            v(this, $u, { writable: !0, value: null }),
            v(this, ys, { writable: !0, value: null }),
            v(this, pi, { writable: !0, value: null }),
            v(this, wg, { writable: !0, value: !1 }),
            v(this, Gu, { writable: !0, value: !1 }),
            v(this, qn, { writable: !0, value: null }),
            v(this, qu, { writable: !0, value: null }),
            v(this, Eg, { writable: !0, value: this.focusin.bind(this) }),
            v(this, Cg, { writable: !0, value: this.focusout.bind(this) }),
            v(this, mi, { writable: !0, value: null }),
            v(this, rC, { writable: !0, value: '' }),
            v(this, Xu, { writable: !0, value: !1 }),
            v(this, so, { writable: !0, value: null }),
            v(this, sC, { writable: !0, value: !1 }),
            v(this, Yu, { writable: !0, value: !1 }),
            v(this, va, { writable: !0, value: !1 }),
            v(this, oo, { writable: !0, value: null }),
            v(this, xg, { writable: !0, value: 0 }),
            v(this, Ag, { writable: !0, value: 0 }),
            v(this, fr, { writable: !0, value: null }),
            Se(this, '_initialOptions', Object.create(null)),
            Se(this, '_isVisible', !0),
            Se(this, '_uiManager', null),
            Se(this, '_focusEventsAllowed', !0),
            Se(this, '_l10nPromise', null),
            v(this, oC, { writable: !0, value: !1 }),
            v(this, x2, { writable: !0, value: re._zIndex++ }),
            this.constructor === re &&
              bt('Cannot initialize AnnotationEditor.'),
            (this.parent = e.parent),
            (this.id = e.id),
            (this.width = this.height = null),
            (this.pageIndex = e.parent.pageIndex),
            (this.name = e.name),
            (this.div = null),
            (this._uiManager = e.uiManager),
            (this.annotationElementId = null),
            (this._willKeepAspectRatio = !1),
            (this._initialOptions.isCentered = e.isCentered),
            (this._structTreeParentId = null);
          const {
            rotation: t,
            rawDims: { pageWidth: i, pageHeight: r, pageX: s, pageY: o },
          } = this.parent.viewport;
          (this.rotation = t),
            (this.pageRotation =
              (360 + t - this._uiManager.viewParameters.rotation) % 360),
            (this.pageDimensions = [i, r]),
            (this.pageTranslation = [s, o]);
          const [a, l] = this.parentDimensions;
          (this.x = e.x / a),
            (this.y = e.y / l),
            (this.isAttachedToDOM = !1),
            (this.deleted = !1);
        }
        get editorType() {
          return Object.getPrototypeOf(this).constructor._type;
        }
        static get _defaultLineColor() {
          return Ye(
            this,
            '_defaultLineColor',
            this._colorManager.getHexCode('CanvasText')
          );
        }
        static deleteAnnotationElement(e) {
          const t = new rie({
            id: e.parent.getNextId(),
            parent: e.parent,
            uiManager: e._uiManager,
          });
          (t.annotationElementId = e.annotationElementId),
            (t.deleted = !0),
            t._uiManager.addToAnnotationStorage(t);
        }
        static initialize(e, t, i) {
          if (
            ((re._l10nPromise ||= new Map(
              [
                'pdfjs-editor-alt-text-button-label',
                'pdfjs-editor-alt-text-edit-button-label',
                'pdfjs-editor-alt-text-decorative-tooltip',
                'pdfjs-editor-resizer-label-topLeft',
                'pdfjs-editor-resizer-label-topMiddle',
                'pdfjs-editor-resizer-label-topRight',
                'pdfjs-editor-resizer-label-middleRight',
                'pdfjs-editor-resizer-label-bottomRight',
                'pdfjs-editor-resizer-label-bottomMiddle',
                'pdfjs-editor-resizer-label-bottomLeft',
                'pdfjs-editor-resizer-label-middleLeft',
              ].map((s) => [
                s,
                e.get(s.replaceAll(/([A-Z])/g, (o) => `-${o.toLowerCase()}`)),
              ])
            )),
            i?.strings)
          )
            for (const s of i.strings) re._l10nPromise.set(s, e.get(s));
          if (-1 !== re._borderLineWidth) return;
          const r = getComputedStyle(document.documentElement);
          re._borderLineWidth =
            parseFloat(r.getPropertyValue('--outline-width')) || 0;
        }
        static updateDefaultParams(e, t) {}
        static get defaultPropertiesToUpdate() {
          return [];
        }
        static isHandlingMimeForPasting(e) {
          return !1;
        }
        static paste(e, t) {
          bt('Not implemented');
        }
        get propertiesToUpdate() {
          return [];
        }
        get _isDraggable() {
          return d(this, oC);
        }
        set _isDraggable(e) {
          _(this, oC, e), this.div?.classList.toggle('draggable', e);
        }
        get isEnterHandled() {
          return !0;
        }
        center() {
          const [e, t] = this.pageDimensions;
          switch (this.parentRotation) {
            case 90:
              (this.x -= (this.height * t) / (2 * e)),
                (this.y += (this.width * e) / (2 * t));
              break;
            case 180:
              (this.x += this.width / 2), (this.y += this.height / 2);
              break;
            case 270:
              (this.x += (this.height * t) / (2 * e)),
                (this.y -= (this.width * e) / (2 * t));
              break;
            default:
              (this.x -= this.width / 2), (this.y -= this.height / 2);
          }
          this.fixAndSetPosition();
        }
        addCommands(e) {
          this._uiManager.addCommands(e);
        }
        get currentLayer() {
          return this._uiManager.currentLayer;
        }
        setInBackground() {
          this.div.style.zIndex = 0;
        }
        setInForeground() {
          this.div.style.zIndex = d(this, x2);
        }
        setParent(e) {
          null !== e
            ? ((this.pageIndex = e.pageIndex),
              (this.pageDimensions = e.pageDimensions))
            : b(this, Ku, Sg).call(this),
            (this.parent = e);
        }
        focusin(e) {
          this._focusEventsAllowed &&
            (d(this, Xu) ? _(this, Xu, !1) : this.parent.setSelected(this));
        }
        focusout(e) {
          !this._focusEventsAllowed ||
            !this.isAttachedToDOM ||
            e.relatedTarget?.closest(`#${this.id}`) ||
            (e.preventDefault(),
            this.parent?.isMultipleSelection || this.commitOrRemove());
        }
        commitOrRemove() {
          this.isEmpty() ? this.remove() : this.commit();
        }
        commit() {
          this.addToAnnotationStorage();
        }
        addToAnnotationStorage() {
          this._uiManager.addToAnnotationStorage(this);
        }
        setAt(e, t, i, r) {
          const [s, o] = this.parentDimensions;
          ([i, r] = this.screenToPageTranslation(i, r)),
            (this.x = (e + i) / s),
            (this.y = (t + r) / o),
            this.fixAndSetPosition();
        }
        translate(e, t) {
          b(this, aC, k2).call(this, this.parentDimensions, e, t);
        }
        translateInPage(e, t) {
          d(this, so) || _(this, so, [this.x, this.y]),
            b(this, aC, k2).call(this, this.pageDimensions, e, t),
            this.div.scrollIntoView({ block: 'nearest' });
        }
        drag(e, t) {
          d(this, so) || _(this, so, [this.x, this.y]);
          const [i, r] = this.parentDimensions;
          if (
            ((this.x += e / i),
            (this.y += t / r),
            this.parent &&
              (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1))
          ) {
            const { x: c, y: u } = this.div.getBoundingClientRect();
            this.parent.findNewParent(this, c, u) &&
              ((this.x -= Math.floor(this.x)), (this.y -= Math.floor(this.y)));
          }
          let { x: s, y: o } = this;
          const [a, l] = this.getBaseTranslation();
          (s += a),
            (o += l),
            (this.div.style.left = `${(100 * s).toFixed(2)}%`),
            (this.div.style.top = `${(100 * o).toFixed(2)}%`),
            this.div.scrollIntoView({ block: 'nearest' });
        }
        get _hasBeenMoved() {
          return (
            !!d(this, so) &&
            (d(this, so)[0] !== this.x || d(this, so)[1] !== this.y)
          );
        }
        getBaseTranslation() {
          const [e, t] = this.parentDimensions,
            { _borderLineWidth: i } = re,
            r = i / e,
            s = i / t;
          switch (this.rotation) {
            case 90:
              return [-r, s];
            case 180:
              return [r, s];
            case 270:
              return [r, -s];
            default:
              return [-r, -s];
          }
        }
        get _mustFixPosition() {
          return !0;
        }
        fixAndSetPosition(e = this.rotation) {
          const [t, i] = this.pageDimensions;
          let { x: r, y: s, width: o, height: a } = this;
          if (((o *= t), (a *= i), (r *= t), (s *= i), this._mustFixPosition))
            switch (e) {
              case 0:
                (r = Math.max(0, Math.min(t - o, r))),
                  (s = Math.max(0, Math.min(i - a, s)));
                break;
              case 90:
                (r = Math.max(0, Math.min(t - a, r))),
                  (s = Math.min(i, Math.max(o, s)));
                break;
              case 180:
                (r = Math.min(t, Math.max(o, r))),
                  (s = Math.min(i, Math.max(a, s)));
                break;
              case 270:
                (r = Math.min(t, Math.max(a, r))),
                  (s = Math.max(0, Math.min(i - o, s)));
            }
          (this.x = r /= t), (this.y = s /= i);
          const [l, c] = this.getBaseTranslation();
          (r += l), (s += c);
          const { style: u } = this.div;
          (u.left = `${(100 * r).toFixed(2)}%`),
            (u.top = `${(100 * s).toFixed(2)}%`),
            this.moveInDOM();
        }
        screenToPageTranslation(e, t) {
          return we(re, re, P2).call(re, e, t, this.parentRotation);
        }
        pageTranslationToScreen(e, t) {
          return we(re, re, P2).call(re, e, t, 360 - this.parentRotation);
        }
        get parentScale() {
          return this._uiManager.viewParameters.realScale;
        }
        get parentRotation() {
          return (
            (this._uiManager.viewParameters.rotation + this.pageRotation) % 360
          );
        }
        get parentDimensions() {
          const {
              parentScale: e,
              pageDimensions: [t, i],
            } = this,
            r = t * e,
            s = i * e;
          return ui.isCSSRoundSupported
            ? [Math.round(r), Math.round(s)]
            : [r, s];
        }
        setDims(e, t) {
          const [i, r] = this.parentDimensions;
          (this.div.style.width = `${((100 * e) / i).toFixed(2)}%`),
            d(this, Gu) ||
              (this.div.style.height = `${((100 * t) / r).toFixed(2)}%`);
        }
        fixDims() {
          const { style: e } = this.div,
            { height: t, width: i } = e,
            r = i.endsWith('%'),
            s = !d(this, Gu) && t.endsWith('%');
          if (r && s) return;
          const [o, a] = this.parentDimensions;
          r || (e.width = `${((100 * parseFloat(i)) / o).toFixed(2)}%`),
            !d(this, Gu) &&
              !s &&
              (e.height = `${((100 * parseFloat(t)) / a).toFixed(2)}%`);
        }
        getInitialTranslation() {
          return [0, 0];
        }
        altTextFinish() {
          d(this, pi)?.finish();
        }
        addEditToolbar() {
          var e = this;
          return U(function* () {
            return (
              d(e, mi) ||
                d(e, Yu) ||
                (_(e, mi, new bg(e)),
                e.div.append(d(e, mi).render()),
                d(e, pi) && d(e, mi).addAltTextButton(yield d(e, pi).render())),
              d(e, mi)
            );
          })();
        }
        removeEditToolbar() {
          d(this, mi) &&
            (d(this, mi).remove(), _(this, mi, null), d(this, pi)?.destroy());
        }
        getClientDimensions() {
          return this.div.getBoundingClientRect();
        }
        addAltTextButton() {
          var e = this;
          return U(function* () {
            d(e, pi) ||
              (C2.initialize(re._l10nPromise),
              _(e, pi, new C2(e)),
              d(e, $u) && ((d(e, pi).data = d(e, $u)), _(e, $u, null)),
              yield e.addEditToolbar());
          })();
        }
        get altTextData() {
          return d(this, pi)?.data;
        }
        set altTextData(e) {
          d(this, pi) && (d(this, pi).data = e);
        }
        hasAltText() {
          return !d(this, pi)?.isEmpty();
        }
        render() {
          (this.div = document.createElement('div')),
            this.div.setAttribute(
              'data-editor-rotation',
              (360 - this.rotation) % 360
            ),
            (this.div.className = this.name),
            this.div.setAttribute('id', this.id),
            (this.div.tabIndex = d(this, wg) ? -1 : 0),
            this._isVisible || this.div.classList.add('hidden'),
            this.setInForeground();
          const e = this._uiManager._signal;
          this.div.addEventListener('focusin', d(this, Eg), { signal: e }),
            this.div.addEventListener('focusout', d(this, Cg), { signal: e });
          const [t, i] = this.parentDimensions;
          this.parentRotation % 180 != 0 &&
            ((this.div.style.maxWidth = `${((100 * i) / t).toFixed(2)}%`),
            (this.div.style.maxHeight = `${((100 * t) / i).toFixed(2)}%`));
          const [r, s] = this.getInitialTranslation();
          return (
            this.translate(r, s), vg(this, this.div, ['pointerdown']), this.div
          );
        }
        pointerdown(e) {
          const { isMac: t } = ui.platform;
          0 !== e.button || (e.ctrlKey && t)
            ? e.preventDefault()
            : (_(this, Xu, !0),
              this._isDraggable
                ? b(this, M2, eie).call(this, e)
                : b(this, uC, L2).call(this, e));
        }
        moveInDOM() {
          d(this, oo) && clearTimeout(d(this, oo)),
            _(
              this,
              oo,
              setTimeout(() => {
                _(this, oo, null), this.parent?.moveEditorInDOM(this);
              }, 0)
            );
        }
        _setParentAndPosition(e, t, i) {
          e.changeParent(this),
            (this.x = t),
            (this.y = i),
            this.fixAndSetPosition();
        }
        getRect(e, t, i = this.rotation) {
          const r = this.parentScale,
            [s, o] = this.pageDimensions,
            [a, l] = this.pageTranslation,
            c = e / r,
            u = t / r,
            h = this.x * s,
            f = this.y * o,
            p = this.width * s,
            m = this.height * o;
          switch (i) {
            case 0:
              return [
                h + c + a,
                o - f - u - m + l,
                h + c + p + a,
                o - f - u + l,
              ];
            case 90:
              return [
                h + u + a,
                o - f + c + l,
                h + u + m + a,
                o - f + c + p + l,
              ];
            case 180:
              return [
                h - c - p + a,
                o - f + u + l,
                h - c + a,
                o - f + u + m + l,
              ];
            case 270:
              return [
                h - u - m + a,
                o - f - c - p + l,
                h - u + a,
                o - f - c + l,
              ];
            default:
              throw new Error('Invalid rotation');
          }
        }
        getRectInCurrentCoords(e, t) {
          const [i, r, s, o] = e,
            a = s - i,
            l = o - r;
          switch (this.rotation) {
            case 0:
              return [i, t - o, a, l];
            case 90:
              return [i, t - r, l, a];
            case 180:
              return [s, t - r, a, l];
            case 270:
              return [s, t - o, l, a];
            default:
              throw new Error('Invalid rotation');
          }
        }
        onceAdded() {}
        isEmpty() {
          return !1;
        }
        enableEditMode() {
          _(this, Yu, !0);
        }
        disableEditMode() {
          _(this, Yu, !1);
        }
        isInEditMode() {
          return d(this, Yu);
        }
        shouldGetKeyboardEvents() {
          return d(this, va);
        }
        needsToBeRebuilt() {
          return this.div && !this.isAttachedToDOM;
        }
        rebuild() {
          const e = this._uiManager._signal;
          this.div?.addEventListener('focusin', d(this, Eg), { signal: e }),
            this.div?.addEventListener('focusout', d(this, Cg), { signal: e });
        }
        rotate(e) {}
        serialize(e = !1, t = null) {
          bt('An editor must be serializable');
        }
        static deserialize(e, t, i) {
          const r = new this.prototype.constructor({
            parent: t,
            id: t.getNextId(),
            uiManager: i,
          });
          (r.rotation = e.rotation), _(r, $u, e.accessibilityData);
          const [s, o] = r.pageDimensions,
            [a, l, c, u] = r.getRectInCurrentCoords(e.rect, o);
          return (
            (r.x = a / s),
            (r.y = l / o),
            (r.width = c / s),
            (r.height = u / o),
            r
          );
        }
        get hasBeenModified() {
          return (
            !!this.annotationElementId &&
            (this.deleted || null !== this.serialize())
          );
        }
        remove() {
          if (
            (this.div.removeEventListener('focusin', d(this, Eg)),
            this.div.removeEventListener('focusout', d(this, Cg)),
            this.isEmpty() || this.commit(),
            this.parent
              ? this.parent.remove(this)
              : this._uiManager.removeEditor(this),
            d(this, oo) && (clearTimeout(d(this, oo)), _(this, oo, null)),
            b(this, Ku, Sg).call(this),
            this.removeEditToolbar(),
            d(this, fr))
          ) {
            for (const e of d(this, fr).values()) clearTimeout(e);
            _(this, fr, null);
          }
          this.parent = null;
        }
        get isResizable() {
          return !1;
        }
        makeResizable() {
          this.isResizable &&
            (b(this, A2, Qne).call(this),
            d(this, qn).classList.remove('hidden'),
            vg(this, this.div, ['keydown']));
        }
        get toolbarPosition() {
          return null;
        }
        keydown(e) {
          if (!this.isResizable || e.target !== this.div || 'Enter' !== e.key)
            return;
          this._uiManager.setSelected(this),
            _(this, qu, {
              savedX: this.x,
              savedY: this.y,
              savedWidth: this.width,
              savedHeight: this.height,
            });
          const t = d(this, qn).children;
          if (!d(this, ys)) {
            _(this, ys, Array.from(t));
            const o = b(this, D2, tie).bind(this),
              a = b(this, T2, nie).bind(this),
              l = this._uiManager._signal;
            for (const c of d(this, ys)) {
              const u = c.getAttribute('data-resizer-name');
              c.setAttribute('role', 'spinbutton'),
                c.addEventListener('keydown', o, { signal: l }),
                c.addEventListener('blur', a, { signal: l }),
                c.addEventListener('focus', b(this, I2, iie).bind(this, u), {
                  signal: l,
                }),
                re._l10nPromise
                  .get(`pdfjs-editor-resizer-label-${u}`)
                  .then((h) => c.setAttribute('aria-label', h));
            }
          }
          const i = d(this, ys)[0];
          let r = 0;
          for (const o of t) {
            if (o === i) break;
            r++;
          }
          const s =
            (((360 - this.rotation + this.parentRotation) % 360) / 90) *
            (d(this, ys).length / 4);
          if (s !== r) {
            if (s < r)
              for (let a = 0; a < r - s; a++)
                d(this, qn).append(d(this, qn).firstChild);
            else if (s > r)
              for (let a = 0; a < s - r; a++)
                d(this, qn).firstChild.before(d(this, qn).lastChild);
            let o = 0;
            for (const a of t) {
              const c = d(this, ys)[o++].getAttribute('data-resizer-name');
              re._l10nPromise
                .get(`pdfjs-editor-resizer-label-${c}`)
                .then((u) => a.setAttribute('aria-label', u));
            }
          }
          b(this, hC, N2).call(this, 0),
            _(this, va, !0),
            d(this, qn).firstChild.focus({ focusVisible: !0 }),
            e.preventDefault(),
            e.stopImmediatePropagation();
        }
        _resizeWithKeyboard(e, t) {
          d(this, va) &&
            b(this, dC, O2).call(this, d(this, rC), {
              movementX: e,
              movementY: t,
            });
        }
        _stopResizingWithKeyboard() {
          b(this, Ku, Sg).call(this), this.div.focus();
        }
        select() {
          this.makeResizable(),
            this.div?.classList.add('selectedEditor'),
            d(this, mi)
              ? d(this, mi)?.show()
              : this.addEditToolbar().then(() => {
                  this.div?.classList.contains('selectedEditor') &&
                    d(this, mi)?.show();
                });
        }
        unselect() {
          d(this, qn)?.classList.add('hidden'),
            this.div?.classList.remove('selectedEditor'),
            this.div?.contains(document.activeElement) &&
              this._uiManager.currentLayer.div.focus({ preventScroll: !0 }),
            d(this, mi)?.hide();
        }
        updateParams(e, t) {}
        disableEditing() {}
        enableEditing() {}
        enterInEditMode() {}
        getImageForAltText() {
          return null;
        }
        get contentDiv() {
          return this.div;
        }
        get isEditing() {
          return d(this, sC);
        }
        set isEditing(e) {
          _(this, sC, e),
            this.parent &&
              (e
                ? (this.parent.setSelected(this),
                  this.parent.setActiveEditor(this))
                : this.parent.setActiveEditor(null));
        }
        setAspectRatio(e, t) {
          _(this, Gu, !0);
          const i = e / t,
            { style: r } = this.div;
          (r.aspectRatio = i), (r.height = 'auto');
        }
        static get MIN_SIZE() {
          return 16;
        }
        static canCreateNewEmptyEditor() {
          return !0;
        }
        get telemetryInitialData() {
          return { action: 'added' };
        }
        get telemetryFinalData() {
          return null;
        }
        _reportTelemetry(e, t = !1) {
          if (t) {
            d(this, fr) || _(this, fr, new Map());
            const { action: i } = e;
            let r = d(this, fr).get(i);
            return (
              r && clearTimeout(r),
              (r = setTimeout(() => {
                this._reportTelemetry(e),
                  d(this, fr).delete(i),
                  0 === d(this, fr).size && _(this, fr, null);
              }, re._telemetryTimeout)),
              void d(this, fr).set(i, r)
            );
          }
          (e.type ||= this.editorType),
            this._uiManager._eventBus.dispatch('reporttelemetry', {
              source: this,
              details: { type: 'editing', data: e },
            });
        }
        show(e = this._isVisible) {
          this.div.classList.toggle('hidden', !e), (this._isVisible = e);
        }
        enable() {
          this.div && (this.div.tabIndex = 0), _(this, wg, !1);
        }
        disable() {
          this.div && (this.div.tabIndex = -1), _(this, wg, !0);
        }
        renderAnnotationElement(e) {
          let t = e.container.querySelector('.annotationContent');
          if (t) {
            if ('CANVAS' === t.nodeName) {
              const i = t;
              (t = document.createElement('div')),
                t.classList.add('annotationContent', this.editorType),
                i.before(t);
            }
          } else
            (t = document.createElement('div')),
              t.classList.add('annotationContent', this.editorType),
              e.container.prepend(t);
          return t;
        }
        resetAnnotationElement(e) {
          const { firstChild: t } = e.container;
          'DIV' === t.nodeName &&
            t.classList.contains('annotationContent') &&
            t.remove();
        }
      }
      function k2([n, e], t, i) {
        ([t, i] = this.screenToPageTranslation(t, i)),
          (this.x += t / n),
          (this.y += i / e),
          this.fixAndSetPosition();
      }
      function P2(n, e, t) {
        switch (t) {
          case 90:
            return [e, -n];
          case 180:
            return [-n, -e];
          case 270:
            return [-e, n];
          default:
            return [n, e];
        }
      }
      function R2(n) {
        switch (n) {
          case 90: {
            const [e, t] = this.pageDimensions;
            return [0, -e / t, t / e, 0];
          }
          case 180:
            return [-1, 0, 0, -1];
          case 270: {
            const [e, t] = this.pageDimensions;
            return [0, e / t, -t / e, 0];
          }
          default:
            return [1, 0, 0, 1];
        }
      }
      function Qne() {
        if (d(this, qn)) return;
        _(this, qn, document.createElement('div')),
          d(this, qn).classList.add('resizers');
        const n = this._willKeepAspectRatio
            ? ['topLeft', 'topRight', 'bottomRight', 'bottomLeft']
            : [
                'topLeft',
                'topMiddle',
                'topRight',
                'middleRight',
                'bottomRight',
                'bottomMiddle',
                'bottomLeft',
                'middleLeft',
              ],
          e = this._uiManager._signal;
        for (const t of n) {
          const i = document.createElement('div');
          d(this, qn).append(i),
            i.classList.add('resizer', t),
            i.setAttribute('data-resizer-name', t),
            i.addEventListener('pointerdown', b(this, S2, Jne).bind(this, t), {
              signal: e,
            }),
            i.addEventListener('contextmenu', fi, { signal: e }),
            (i.tabIndex = -1);
        }
        this.div.prepend(d(this, qn));
      }
      function Jne(n, e) {
        e.preventDefault();
        const { isMac: t } = ui.platform;
        if (0 !== e.button || (e.ctrlKey && t)) return;
        d(this, pi)?.toggle(!1);
        const i = b(this, dC, O2).bind(this, n),
          r = this._isDraggable;
        this._isDraggable = !1;
        const s = this._uiManager._signal,
          o = { passive: !0, capture: !0, signal: s };
        this.parent.togglePointerEvents(!1),
          window.addEventListener('pointermove', i, o),
          window.addEventListener('contextmenu', fi, { signal: s });
        const a = this.x,
          l = this.y,
          c = this.width,
          u = this.height,
          h = this.parent.div.style.cursor,
          f = this.div.style.cursor;
        this.div.style.cursor = this.parent.div.style.cursor =
          window.getComputedStyle(e.target).cursor;
        const p = () => {
          this.parent.togglePointerEvents(!0),
            d(this, pi)?.toggle(!0),
            (this._isDraggable = r),
            window.removeEventListener('pointerup', p),
            window.removeEventListener('blur', p),
            window.removeEventListener('pointermove', i, o),
            window.removeEventListener('contextmenu', fi),
            (this.parent.div.style.cursor = h),
            (this.div.style.cursor = f),
            b(this, cC, F2).call(this, a, l, c, u);
        };
        window.addEventListener('pointerup', p, { signal: s }),
          window.addEventListener('blur', p, { signal: s });
      }
      function F2(n, e, t, i) {
        const r = this.x,
          s = this.y,
          o = this.width,
          a = this.height;
        (r === n && s === e && o === t && a === i) ||
          this.addCommands({
            cmd: () => {
              (this.width = o), (this.height = a), (this.x = r), (this.y = s);
              const [l, c] = this.parentDimensions;
              this.setDims(l * o, c * a), this.fixAndSetPosition();
            },
            undo: () => {
              (this.width = t), (this.height = i), (this.x = n), (this.y = e);
              const [l, c] = this.parentDimensions;
              this.setDims(l * t, c * i), this.fixAndSetPosition();
            },
            mustExec: !0,
          });
      }
      function O2(n, e) {
        const [t, i] = this.parentDimensions,
          r = this.x,
          s = this.y,
          o = this.width,
          a = this.height,
          l = re.MIN_SIZE / t,
          c = re.MIN_SIZE / i,
          u = (F) => Math.round(1e4 * F) / 1e4,
          h = b(this, lC, R2).call(this, this.rotation),
          f = (F, W) => [h[0] * F + h[2] * W, h[1] * F + h[3] * W],
          p = b(this, lC, R2).call(this, 360 - this.rotation);
        let g,
          w,
          y = !1,
          E = !1;
        switch (n) {
          case 'topLeft':
            (y = !0), (g = (F, W) => [0, 0]), (w = (F, W) => [F, W]);
            break;
          case 'topMiddle':
            (g = (F, W) => [F / 2, 0]), (w = (F, W) => [F / 2, W]);
            break;
          case 'topRight':
            (y = !0), (g = (F, W) => [F, 0]), (w = (F, W) => [0, W]);
            break;
          case 'middleRight':
            (E = !0), (g = (F, W) => [F, W / 2]), (w = (F, W) => [0, W / 2]);
            break;
          case 'bottomRight':
            (y = !0), (g = (F, W) => [F, W]), (w = (F, W) => [0, 0]);
            break;
          case 'bottomMiddle':
            (g = (F, W) => [F / 2, W]), (w = (F, W) => [F / 2, 0]);
            break;
          case 'bottomLeft':
            (y = !0), (g = (F, W) => [0, W]), (w = (F, W) => [F, 0]);
            break;
          case 'middleLeft':
            (E = !0), (g = (F, W) => [0, W / 2]), (w = (F, W) => [F, W / 2]);
        }
        const A = g(o, a),
          M = w(o, a);
        let T = f(...M);
        const k = u(r + T[0]),
          P = u(s + T[1]);
        let O = 1,
          I = 1,
          [C, R] = this.screenToPageTranslation(e.movementX, e.movementY);
        if (
          (([C, R] = [
            p[0] * (F = C / t) + p[2] * (W = R / i),
            p[1] * F + p[3] * W,
          ]),
          y)
        ) {
          const F = Math.hypot(o, a);
          O = I = Math.max(
            Math.min(
              Math.hypot(M[0] - A[0] - C, M[1] - A[1] - R) / F,
              1 / o,
              1 / a
            ),
            l / o,
            c / a
          );
        } else
          E
            ? (O = Math.max(l, Math.min(1, Math.abs(M[0] - A[0] - C))) / o)
            : (I = Math.max(c, Math.min(1, Math.abs(M[1] - A[1] - R))) / a);
        var F, W;
        const $ = u(o * O),
          q = u(a * I);
        T = f(...w($, q));
        const oe = k - T[0],
          Oe = P - T[1];
        (this.width = $),
          (this.height = q),
          (this.x = oe),
          (this.y = Oe),
          this.setDims(t * $, i * q),
          this.fixAndSetPosition();
      }
      function L2(n) {
        const { isMac: e } = ui.platform;
        (n.ctrlKey && !e) || n.shiftKey || (n.metaKey && e)
          ? this.parent.toggleSelected(this)
          : this.parent.setSelected(this);
      }
      function eie(n) {
        const e = this._uiManager.isSelected(this);
        let t, i;
        this._uiManager.setUpDragSession();
        const r = this._uiManager._signal;
        e &&
          (this.div.classList.add('moving'),
          (t = { passive: !0, capture: !0, signal: r }),
          _(this, xg, n.clientX),
          _(this, Ag, n.clientY),
          (i = (o) => {
            const { clientX: a, clientY: l } = o,
              [c, u] = this.screenToPageTranslation(
                a - d(this, xg),
                l - d(this, Ag)
              );
            _(this, xg, a),
              _(this, Ag, l),
              this._uiManager.dragSelectedEditors(c, u);
          }),
          window.addEventListener('pointermove', i, t));
        const s = () => {
          window.removeEventListener('pointerup', s),
            window.removeEventListener('blur', s),
            e &&
              (this.div.classList.remove('moving'),
              window.removeEventListener('pointermove', i, t)),
            _(this, Xu, !1),
            this._uiManager.endDragSession() || b(this, uC, L2).call(this, n);
        };
        window.addEventListener('pointerup', s, { signal: r }),
          window.addEventListener('blur', s, { signal: r });
      }
      function tie(n) {
        re._resizerKeyboardManager.exec(this, n);
      }
      function nie(n) {
        d(this, va) &&
          n.relatedTarget?.parentNode !== d(this, qn) &&
          b(this, Ku, Sg).call(this);
      }
      function iie(n) {
        _(this, rC, d(this, va) ? n : '');
      }
      function N2(n) {
        if (d(this, ys)) for (const e of d(this, ys)) e.tabIndex = n;
      }
      function Sg() {
        if ((_(this, va, !1), b(this, hC, N2).call(this, -1), d(this, qu))) {
          const {
            savedX: n,
            savedY: e,
            savedWidth: t,
            savedHeight: i,
          } = d(this, qu);
          b(this, cC, F2).call(this, n, e, t, i), _(this, qu, null);
        }
      }
      Se(re, '_borderLineWidth', -1),
        Se(re, '_colorManager', new yg()),
        Se(re, '_zIndex', 1),
        Se(re, '_telemetryTimeout', 1e3);
      class rie extends re {
        constructor(e) {
          super(e),
            (this.annotationElementId = e.annotationElementId),
            (this.deleted = !0);
        }
        serialize() {
          return {
            id: this.annotationElementId,
            deleted: !0,
            pageIndex: this.pageIndex,
          };
        }
      }
      const V2 = 3285377520,
        Ki = 4294901760,
        jr = 65535;
      class B2 {
        constructor(e) {
          (this.h1 = e ? 4294967295 & e : V2),
            (this.h2 = e ? 4294967295 & e : V2);
        }
        update(e) {
          let t, i;
          if ('string' == typeof e) {
            (t = new Uint8Array(2 * e.length)), (i = 0);
            for (let g = 0, w = e.length; g < w; g++) {
              const y = e.charCodeAt(g);
              y <= 255
                ? (t[i++] = y)
                : ((t[i++] = y >>> 8), (t[i++] = 255 & y));
            }
          } else {
            if (!ArrayBuffer.isView(e))
              throw new Error(
                'Invalid data format, must be a string or TypedArray.'
              );
            (t = e.slice()), (i = t.byteLength);
          }
          const r = i >> 2,
            s = i - 4 * r,
            o = new Uint32Array(t.buffer, 0, r);
          let a = 0,
            l = 0,
            c = this.h1,
            u = this.h2;
          const h = 3432918353,
            f = 461845907,
            p = h & jr,
            m = f & jr;
          for (let g = 0; g < r; g++)
            1 & g
              ? ((a = o[g]),
                (a = ((a * h) & Ki) | ((a * p) & jr)),
                (a = (a << 15) | (a >>> 17)),
                (a = ((a * f) & Ki) | ((a * m) & jr)),
                (c ^= a),
                (c = (c << 13) | (c >>> 19)),
                (c = 5 * c + 3864292196))
              : ((l = o[g]),
                (l = ((l * h) & Ki) | ((l * p) & jr)),
                (l = (l << 15) | (l >>> 17)),
                (l = ((l * f) & Ki) | ((l * m) & jr)),
                (u ^= l),
                (u = (u << 13) | (u >>> 19)),
                (u = 5 * u + 3864292196));
          switch (((a = 0), s)) {
            case 3:
              a ^= t[4 * r + 2] << 16;
            case 2:
              a ^= t[4 * r + 1] << 8;
            case 1:
              (a ^= t[4 * r]),
                (a = ((a * h) & Ki) | ((a * p) & jr)),
                (a = (a << 15) | (a >>> 17)),
                (a = ((a * f) & Ki) | ((a * m) & jr)),
                1 & r ? (c ^= a) : (u ^= a);
          }
          (this.h1 = c), (this.h2 = u);
        }
        hexdigest() {
          let e = this.h1,
            t = this.h2;
          return (
            (e ^= t >>> 1),
            (e = ((3981806797 * e) & Ki) | ((36045 * e) & jr)),
            (t =
              ((4283543511 * t) & Ki) |
              (((2950163797 * ((t << 16) | (e >>> 16))) & Ki) >>> 16)),
            (e ^= t >>> 1),
            (e = ((444984403 * e) & Ki) | ((60499 * e) & jr)),
            (t =
              ((3301882366 * t) & Ki) |
              (((3120437893 * ((t << 16) | (e >>> 16))) & Ki) >>> 16)),
            (e ^= t >>> 1),
            (e >>> 0).toString(16).padStart(8, '0') +
              (t >>> 0).toString(16).padStart(8, '0')
          );
        }
      }
      const fC = Object.freeze({ map: null, hash: '', transfer: void 0 });
      var Zu = new WeakMap(),
        Qu = new WeakMap(),
        On = new WeakMap(),
        H2 = new WeakSet();
      class pC {
        constructor() {
          S(this, H2),
            v(this, Zu, { writable: !0, value: !1 }),
            v(this, Qu, { writable: !0, value: null }),
            v(this, On, { writable: !0, value: new Map() }),
            (this.onSetModified = null),
            (this.onResetModified = null),
            (this.onAnnotationEditor = null);
        }
        getValue(e, t) {
          const i = d(this, On).get(e);
          return void 0 === i ? t : Object.assign(t, i);
        }
        getRawValue(e) {
          return d(this, On).get(e);
        }
        remove(e) {
          if (
            (d(this, On).delete(e),
            0 === d(this, On).size && this.resetModified(),
            'function' == typeof this.onAnnotationEditor)
          ) {
            for (const t of d(this, On).values()) if (t instanceof re) return;
            this.onAnnotationEditor(null);
          }
        }
        setValue(e, t) {
          const i = d(this, On).get(e);
          let r = !1;
          if (void 0 !== i)
            for (const [s, o] of Object.entries(t))
              i[s] !== o && ((r = !0), (i[s] = o));
          else (r = !0), d(this, On).set(e, t);
          r && b(this, H2, sie).call(this),
            t instanceof re &&
              'function' == typeof this.onAnnotationEditor &&
              this.onAnnotationEditor(t.constructor._type);
        }
        has(e) {
          return d(this, On).has(e);
        }
        getAll() {
          return d(this, On).size > 0 ? FE(d(this, On)) : null;
        }
        setAll(e) {
          for (const [t, i] of Object.entries(e)) this.setValue(t, i);
        }
        get size() {
          return d(this, On).size;
        }
        resetModified() {
          d(this, Zu) &&
            (_(this, Zu, !1),
            'function' == typeof this.onResetModified &&
              this.onResetModified());
        }
        get print() {
          return new W2(this);
        }
        get serializable() {
          if (0 === d(this, On).size) return fC;
          const e = new Map(),
            t = new B2(),
            i = [],
            r = Object.create(null);
          let s = !1;
          for (const [o, a] of d(this, On)) {
            const l = a instanceof re ? a.serialize(!1, r) : a;
            l &&
              (e.set(o, l),
              t.update(`${o}:${JSON.stringify(l)}`),
              (s ||= !!l.bitmap));
          }
          if (s) for (const o of e.values()) o.bitmap && i.push(o.bitmap);
          return e.size > 0 ? { map: e, hash: t.hexdigest(), transfer: i } : fC;
        }
        get editorStats() {
          let e = null;
          const t = new Map();
          for (const i of d(this, On).values()) {
            if (!(i instanceof re)) continue;
            const r = i.telemetryFinalData;
            if (!r) continue;
            const { type: s } = r;
            t.has(s) || t.set(s, Object.getPrototypeOf(i).constructor),
              (e ||= Object.create(null));
            const o = (e[s] ||= new Map());
            for (const [a, l] of Object.entries(r)) {
              if ('type' === a) continue;
              let c = o.get(a);
              c || ((c = new Map()), o.set(a, c));
              const u = c.get(l) ?? 0;
              c.set(l, u + 1);
            }
          }
          for (const [i, r] of t) e[i] = r.computeTelemetryFinalData(e[i]);
          return e;
        }
        resetModifiedIds() {
          _(this, Qu, null);
        }
        get modifiedIds() {
          if (d(this, Qu)) return d(this, Qu);
          const e = [];
          for (const t of d(this, On).values())
            !(t instanceof re) ||
              !t.annotationElementId ||
              !t.serialize() ||
              e.push(t.annotationElementId);
          return _(this, Qu, { ids: new Set(e), hash: e.join(',') });
        }
      }
      function sie() {
        d(this, Zu) ||
          (_(this, Zu, !0),
          'function' == typeof this.onSetModified && this.onSetModified());
      }
      var mC = new WeakMap();
      class W2 extends pC {
        constructor(e) {
          super(), v(this, mC, { writable: !0, value: void 0 });
          const { map: t, hash: i, transfer: r } = e.serializable,
            s = structuredClone(t, r ? { transfer: r } : null);
          _(this, mC, { map: s, hash: i, transfer: r });
        }
        get print() {
          bt('Should not call PrintAnnotationStorage.print');
        }
        get serializable() {
          return d(this, mC);
        }
        get modifiedIds() {
          return Ye(this, 'modifiedIds', { ids: new Set(), hash: '' });
        }
      }
      var Mg = new WeakMap();
      class oie {
        constructor({
          ownerDocument: e = globalThis.document,
          styleElement: t = null,
        }) {
          v(this, Mg, { writable: !0, value: new Set() }),
            (this._document = e),
            (this.nativeFontFaces = new Set()),
            (this.styleElement = null),
            (this.loadingRequests = []),
            (this.loadTestFontId = 0);
        }
        addNativeFontFace(e) {
          this.nativeFontFaces.add(e), this._document.fonts.add(e);
        }
        removeNativeFontFace(e) {
          this.nativeFontFaces.delete(e), this._document.fonts.delete(e);
        }
        insertRule(e) {
          this.styleElement ||
            ((this.styleElement = this._document.createElement('style')),
            this._document.documentElement
              .getElementsByTagName('head')[0]
              .append(this.styleElement));
          const t = this.styleElement.sheet;
          t.insertRule(e, t.cssRules.length);
        }
        clear() {
          for (const e of this.nativeFontFaces) this._document.fonts.delete(e);
          this.nativeFontFaces.clear(),
            d(this, Mg).clear(),
            this.styleElement &&
              (this.styleElement.remove(), (this.styleElement = null));
        }
        loadSystemFont({ systemFontInfo: e, _inspectFont: t }) {
          var i = this;
          return U(function* () {
            if (e && !d(i, Mg).has(e.loadedName)) {
              if (
                (cn(
                  !i.disableFontFace,
                  "loadSystemFont shouldn't be called when `disableFontFace` is set."
                ),
                i.isFontLoadingAPISupported)
              ) {
                const { loadedName: r, src: s, style: o } = e,
                  a = new FontFace(r, s, o);
                i.addNativeFontFace(a);
                try {
                  yield a.load(), d(i, Mg).add(r), t?.(e);
                } catch {
                  Ve(
                    `Cannot load system font: ${e.baseFontName}, installing it could help to improve PDF rendering.`
                  ),
                    i.removeNativeFontFace(a);
                }
                return;
              }
              bt(
                'Not implemented: loadSystemFont without the Font Loading API.'
              );
            }
          })();
        }
        bind(e) {
          var t = this;
          return U(function* () {
            if (e.attached || (e.missingFile && !e.systemFontInfo)) return;
            if (((e.attached = !0), e.systemFontInfo))
              return void (yield t.loadSystemFont(e));
            if (t.isFontLoadingAPISupported) {
              const r = e.createNativeFontFace();
              if (r) {
                t.addNativeFontFace(r);
                try {
                  yield r.loaded;
                } catch (s) {
                  throw (
                    (Ve(`Failed to load font '${r.family}': '${s}'.`),
                    (e.disableFontFace = !0),
                    s)
                  );
                }
              }
              return;
            }
            const i = e.createFontFaceRule();
            if (i) {
              if ((t.insertRule(i), t.isSyncFontLoadingSupported)) return;
              yield new Promise((r) => {
                const s = t._queueLoadingCallback(r);
                t._prepareFontLoadEvent(e, s);
              });
            }
          })();
        }
        get isFontLoadingAPISupported() {
          return Ye(this, 'isFontLoadingAPISupported', !!this._document?.fonts);
        }
        get isSyncFontLoadingSupported() {
          let e = !1;
          return (
            (kn ||
              (typeof navigator < 'u' &&
                'string' == typeof navigator?.userAgent &&
                /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent))) &&
              (e = !0),
            Ye(this, 'isSyncFontLoadingSupported', e)
          );
        }
        _queueLoadingCallback(e) {
          const { loadingRequests: i } = this,
            r = {
              done: !1,
              complete: function t() {
                for (
                  cn(!r.done, 'completeRequest() cannot be called twice.'),
                    r.done = !0;
                  i.length > 0 && i[0].done;

                ) {
                  const s = i.shift();
                  setTimeout(s.callback, 0);
                }
              },
              callback: e,
            };
          return i.push(r), r;
        }
        get _loadTestFont() {
          return Ye(
            this,
            '_loadTestFont',
            atob(
              'T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=='
            )
          );
        }
        _prepareFontLoadEvent(e, t) {
          function i(M, T) {
            return (
              (M.charCodeAt(T) << 24) |
              (M.charCodeAt(T + 1) << 16) |
              (M.charCodeAt(T + 2) << 8) |
              (255 & M.charCodeAt(T + 3))
            );
          }
          function r(M, T, k, P) {
            return M.substring(0, T) + P + M.substring(T + k);
          }
          let s, o;
          const a = this._document.createElement('canvas');
          (a.width = 1), (a.height = 1);
          const l = a.getContext('2d');
          let c = 0;
          const h = `lt${Date.now()}${this.loadTestFontId++}`;
          let f = this._loadTestFont;
          f = r(f, 976, h.length, h);
          const g = 1482184792;
          let w = i(f, 16);
          for (s = 0, o = h.length - 3; s < o; s += 4)
            w = (w - g + i(h, s)) | 0;
          s < h.length && (w = (w - g + i(h + 'XXX', s)) | 0),
            (f = r(
              f,
              16,
              4,
              (function Ene(n) {
                return String.fromCharCode(
                  (n >> 24) & 255,
                  (n >> 16) & 255,
                  (n >> 8) & 255,
                  255 & n
                );
              })(w)
            ));
          const y = `url(data:font/opentype;base64,${btoa(f)});`;
          this.insertRule(`@font-face {font-family:"${h}";src:${y}}`);
          const A = this._document.createElement('div');
          (A.style.visibility = 'hidden'),
            (A.style.width = A.style.height = '10px'),
            (A.style.position = 'absolute'),
            (A.style.top = A.style.left = '0px');
          for (const M of [e.loadedName, h]) {
            const T = this._document.createElement('span');
            (T.textContent = 'Hi'), (T.style.fontFamily = M), A.append(T);
          }
          this._document.body.append(A),
            (function u(M, T) {
              if (++c > 30) return Ve('Load test font never loaded.'), void T();
              (l.font = '30px ' + M),
                l.fillText('.', 0, 20),
                l.getImageData(0, 0, 1, 1).data[3] > 0
                  ? T()
                  : setTimeout(u.bind(null, M, T));
            })(h, () => {
              A.remove(), t.complete();
            });
        }
      }
      class aie {
        constructor(e, { disableFontFace: t = !1, inspectFont: i = null }) {
          this.compiledGlyphs = Object.create(null);
          for (const r in e) this[r] = e[r];
          (this.disableFontFace = !0 === t), (this._inspectFont = i);
        }
        createNativeFontFace() {
          if (!this.data || this.disableFontFace) return null;
          let e;
          if (this.cssFontInfo) {
            const t = { weight: this.cssFontInfo.fontWeight };
            this.cssFontInfo.italicAngle &&
              (t.style = `oblique ${this.cssFontInfo.italicAngle}deg`),
              (e = new FontFace(this.cssFontInfo.fontFamily, this.data, t));
          } else e = new FontFace(this.loadedName, this.data, {});
          return this._inspectFont?.(this), e;
        }
        createFontFaceRule() {
          if (!this.data || this.disableFontFace) return null;
          const e = t2(this.data),
            t = `url(data:${this.mimetype};base64,${btoa(e)});`;
          let i;
          if (this.cssFontInfo) {
            let r = `font-weight: ${this.cssFontInfo.fontWeight};`;
            this.cssFontInfo.italicAngle &&
              (r += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`),
              (i = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${r}src:${t}}`);
          } else i = `@font-face {font-family:"${this.loadedName}";src:${t}}`;
          return this._inspectFont?.(this, t), i;
        }
        getPathGenerator(e, t) {
          if (void 0 !== this.compiledGlyphs[t]) return this.compiledGlyphs[t];
          let i;
          try {
            i = e.get(this.loadedName + '_path_' + t);
          } catch (s) {
            Ve(`getPathGenerator - ignoring character: "${s}".`);
          }
          if (!Array.isArray(i) || 0 === i.length)
            return (this.compiledGlyphs[t] = function (s, o) {});
          const r = [];
          for (let s = 0, o = i.length; s < o; )
            switch (i[s++]) {
              case 0:
                {
                  const [a, l, c, u, h, f] = i.slice(s, s + 6);
                  r.push((p) => p.bezierCurveTo(a, l, c, u, h, f)), (s += 6);
                }
                break;
              case 1:
                {
                  const [a, l] = i.slice(s, s + 2);
                  r.push((c) => c.moveTo(a, l)), (s += 2);
                }
                break;
              case 2:
                {
                  const [a, l] = i.slice(s, s + 2);
                  r.push((c) => c.lineTo(a, l)), (s += 2);
                }
                break;
              case 3:
                {
                  const [a, l, c, u] = i.slice(s, s + 4);
                  r.push((h) => h.quadraticCurveTo(a, l, c, u)), (s += 4);
                }
                break;
              case 4:
                r.push((a) => a.restore());
                break;
              case 5:
                r.push((a) => a.save());
                break;
              case 6:
                cn(
                  2 === r.length,
                  'Scale command is only valid at the third position.'
                );
                break;
              case 7:
                {
                  const [a, l, c, u, h, f] = i.slice(s, s + 6);
                  r.push((p) => p.transform(a, l, c, u, h, f)), (s += 6);
                }
                break;
              case 8: {
                const [a, l] = i.slice(s, s + 2);
                r.push((c) => c.translate(a, l)), (s += 2);
              }
            }
          return (this.compiledGlyphs[t] = function (o, a) {
            r[0](o), r[1](o), o.scale(a, -a);
            for (let l = 2, c = r.length; l < c; l++) r[l](o);
          });
        }
      }
      if (kn) {
        var gC = Promise.withResolvers(),
          _C = null;
        (function () {
          var e = U(function* () {
            const t = yield import('fs'),
              i = yield import('http'),
              r = yield import('https'),
              s = yield import('url');
            return new Map(
              Object.entries({
                fs: t,
                http: i,
                https: r,
                url: s,
                canvas: void 0,
                path2d: void 0,
              })
            );
          });
          return function () {
            return e.apply(this, arguments);
          };
        })()().then(
          (e) => {
            (_C = e), gC.resolve();
          },
          (e) => {
            Ve(`loadPackages: ${e}`), (_C = new Map()), gC.resolve();
          }
        );
      }
      class zr {
        static get promise() {
          return gC.promise;
        }
        static get(e) {
          return _C?.get(e);
        }
      }
      const j2 = function (n) {
        return zr
          .get('fs')
          .promises.readFile(n)
          .then((t) => new Uint8Array(t));
      };
      function bC(n, e) {
        if (!e) return;
        const t = e[2] - e[0],
          i = e[3] - e[1],
          r = new Path2D();
        r.rect(e[0], e[1], t, i), n.clip(r);
      }
      class Ju {
        constructor() {
          this.constructor === Ju &&
            bt('Cannot initialize BaseShadingPattern.');
        }
        getPattern() {
          bt('Abstract method `getPattern` called.');
        }
      }
      class hie extends Ju {
        constructor(e) {
          super(),
            (this._type = e[1]),
            (this._bbox = e[2]),
            (this._colorStops = e[3]),
            (this._p0 = e[4]),
            (this._p1 = e[5]),
            (this._r0 = e[6]),
            (this._r1 = e[7]),
            (this.matrix = null);
        }
        _createGradient(e) {
          let t;
          'axial' === this._type
            ? (t = e.createLinearGradient(
                this._p0[0],
                this._p0[1],
                this._p1[0],
                this._p1[1]
              ))
            : 'radial' === this._type &&
              (t = e.createRadialGradient(
                this._p0[0],
                this._p0[1],
                this._r0,
                this._p1[0],
                this._p1[1],
                this._r1
              ));
          for (const i of this._colorStops) t.addColorStop(i[0], i[1]);
          return t;
        }
        getPattern(e, t, i, r) {
          let s;
          if ('Stroke' === r || 'Fill' === r) {
            const o = t.current.getClippedPathBoundingBox(r, Rt(e)) || [
                0, 0, 0, 0,
              ],
              a = Math.ceil(o[2] - o[0]) || 1,
              l = Math.ceil(o[3] - o[1]) || 1,
              c = t.cachedCanvases.getCanvas('pattern', a, l, !0),
              u = c.context;
            u.clearRect(0, 0, u.canvas.width, u.canvas.height),
              u.beginPath(),
              u.rect(0, 0, u.canvas.width, u.canvas.height),
              u.translate(-o[0], -o[1]),
              (i = te.transform(i, [1, 0, 0, 1, o[0], o[1]])),
              u.transform(...t.baseTransform),
              this.matrix && u.transform(...this.matrix),
              bC(u, this._bbox),
              (u.fillStyle = this._createGradient(u)),
              u.fill(),
              (s = e.createPattern(c.canvas, 'no-repeat'));
            const h = new DOMMatrix(i);
            s.setTransform(h);
          } else bC(e, this._bbox), (s = this._createGradient(e));
          return s;
        }
      }
      function vC(n, e, t, i, r, s, o, a) {
        const l = e.coords,
          c = e.colors,
          u = n.data,
          h = 4 * n.width;
        let f;
        l[t + 1] > l[i + 1] &&
          ((f = t), (t = i), (i = f), (f = s), (s = o), (o = f)),
          l[i + 1] > l[r + 1] &&
            ((f = i), (i = r), (r = f), (f = o), (o = a), (a = f)),
          l[t + 1] > l[i + 1] &&
            ((f = t), (t = i), (i = f), (f = s), (s = o), (o = f));
        const p = (l[t] + e.offsetX) * e.scaleX,
          m = (l[t + 1] + e.offsetY) * e.scaleY,
          g = (l[i] + e.offsetX) * e.scaleX,
          w = (l[i + 1] + e.offsetY) * e.scaleY,
          y = (l[r] + e.offsetX) * e.scaleX,
          E = (l[r + 1] + e.offsetY) * e.scaleY;
        if (m >= E) return;
        const A = c[s],
          M = c[s + 1],
          T = c[s + 2],
          k = c[o],
          P = c[o + 1],
          O = c[o + 2],
          I = c[a],
          C = c[a + 1],
          R = c[a + 2],
          $ = Math.round(m),
          q = Math.round(E);
        let oe, Oe, F, W, Q, ge, st, un;
        for (let Je = $; Je <= q; Je++) {
          if (Je < w) {
            const De = Je < m ? 0 : (m - Je) / (m - w);
            (oe = p - (p - g) * De),
              (Oe = A - (A - k) * De),
              (F = M - (M - P) * De),
              (W = T - (T - O) * De);
          } else {
            let De;
            (De = Je > E ? 1 : w === E ? 0 : (w - Je) / (w - E)),
              (oe = g - (g - y) * De),
              (Oe = k - (k - I) * De),
              (F = P - (P - C) * De),
              (W = O - (O - R) * De);
          }
          let ft;
          (ft = Je < m ? 0 : Je > E ? 1 : (m - Je) / (m - E)),
            (Q = p - (p - y) * ft),
            (ge = A - (A - I) * ft),
            (st = M - (M - C) * ft),
            (un = T - (T - R) * ft);
          const nt = Math.round(Math.min(oe, Q)),
            vi = Math.round(Math.max(oe, Q));
          let yi = h * Je + 4 * nt;
          for (let De = nt; De <= vi; De++)
            (ft = (oe - De) / (oe - Q)),
              ft < 0 ? (ft = 0) : ft > 1 && (ft = 1),
              (u[yi++] = (Oe - (Oe - ge) * ft) | 0),
              (u[yi++] = (F - (F - st) * ft) | 0),
              (u[yi++] = (W - (W - un) * ft) | 0),
              (u[yi++] = 255);
        }
      }
      function fie(n, e, t) {
        const i = e.coords,
          r = e.colors;
        let s, o;
        switch (e.type) {
          case 'lattice':
            const a = e.verticesPerRow,
              l = Math.floor(i.length / a) - 1,
              c = a - 1;
            for (s = 0; s < l; s++) {
              let u = s * a;
              for (let h = 0; h < c; h++, u++)
                vC(n, t, i[u], i[u + 1], i[u + a], r[u], r[u + 1], r[u + a]),
                  vC(
                    n,
                    t,
                    i[u + a + 1],
                    i[u + 1],
                    i[u + a],
                    r[u + a + 1],
                    r[u + 1],
                    r[u + a]
                  );
            }
            break;
          case 'triangles':
            for (s = 0, o = i.length; s < o; s += 3)
              vC(n, t, i[s], i[s + 1], i[s + 2], r[s], r[s + 1], r[s + 2]);
            break;
          default:
            throw new Error('illegal figure');
        }
      }
      class pie extends Ju {
        constructor(e) {
          super(),
            (this._coords = e[2]),
            (this._colors = e[3]),
            (this._figures = e[4]),
            (this._bounds = e[5]),
            (this._bbox = e[7]),
            (this._background = e[8]),
            (this.matrix = null);
        }
        _createMeshCanvas(e, t, i) {
          const a = Math.floor(this._bounds[0]),
            l = Math.floor(this._bounds[1]),
            c = Math.ceil(this._bounds[2]) - a,
            u = Math.ceil(this._bounds[3]) - l,
            h = Math.min(Math.ceil(Math.abs(c * e[0] * 1.1)), 3e3),
            f = Math.min(Math.ceil(Math.abs(u * e[1] * 1.1)), 3e3),
            p = c / h,
            m = u / f,
            g = {
              coords: this._coords,
              colors: this._colors,
              offsetX: -a,
              offsetY: -l,
              scaleX: 1 / p,
              scaleY: 1 / m,
            },
            E = i.getCanvas('mesh', h + 4, f + 4, !1),
            A = E.context,
            M = A.createImageData(h, f);
          if (t) {
            const k = M.data;
            for (let P = 0, O = k.length; P < O; P += 4)
              (k[P] = t[0]),
                (k[P + 1] = t[1]),
                (k[P + 2] = t[2]),
                (k[P + 3] = 255);
          }
          for (const k of this._figures) fie(M, k, g);
          return (
            A.putImageData(M, 2, 2),
            {
              canvas: E.canvas,
              offsetX: a - 2 * p,
              offsetY: l - 2 * m,
              scaleX: p,
              scaleY: m,
            }
          );
        }
        getPattern(e, t, i, r) {
          let s;
          if ((bC(e, this._bbox), 'Shading' === r))
            s = te.singularValueDecompose2dScale(Rt(e));
          else if (
            ((s = te.singularValueDecompose2dScale(t.baseTransform)),
            this.matrix)
          ) {
            const a = te.singularValueDecompose2dScale(this.matrix);
            s = [s[0] * a[0], s[1] * a[1]];
          }
          const o = this._createMeshCanvas(
            s,
            'Shading' === r ? null : this._background,
            t.cachedCanvases
          );
          return (
            'Shading' !== r &&
              (e.setTransform(...t.baseTransform),
              this.matrix && e.transform(...this.matrix)),
            e.translate(o.offsetX, o.offsetY),
            e.scale(o.scaleX, o.scaleY),
            e.createPattern(o.canvas, 'no-repeat')
          );
        }
      }
      class mie extends Ju {
        getPattern() {
          return 'hotpink';
        }
      }
      let _ie = (() => {
        class n {
          constructor(t, i, r, s, o) {
            (this.operatorList = t[2]),
              (this.matrix = t[3]),
              (this.bbox = t[4]),
              (this.xstep = t[5]),
              (this.ystep = t[6]),
              (this.paintType = t[7]),
              (this.tilingType = t[8]),
              (this.color = i),
              (this.ctx = r),
              (this.canvasGraphicsFactory = s),
              (this.baseTransform = o);
          }
          createPatternCanvas(t) {
            const i = this.operatorList,
              r = this.bbox,
              s = this.xstep,
              o = this.ystep,
              a = this.paintType,
              c = this.color,
              u = this.canvasGraphicsFactory;
            sg('TilingType: ' + this.tilingType);
            const h = r[0],
              f = r[1],
              p = r[2],
              m = r[3],
              g = te.singularValueDecompose2dScale(this.matrix),
              w = te.singularValueDecompose2dScale(this.baseTransform),
              y = [g[0] * w[0], g[1] * w[1]],
              E = this.getSizeAndScale(s, this.ctx.canvas.width, y[0]),
              A = this.getSizeAndScale(o, this.ctx.canvas.height, y[1]),
              M = t.cachedCanvases.getCanvas('pattern', E.size, A.size, !0),
              T = M.context,
              k = u.createCanvasGraphics(T);
            (k.groupLevel = t.groupLevel),
              this.setFillAndStrokeStyleToContext(k, a, c);
            let P = h,
              O = f,
              I = p,
              C = m;
            return (
              h < 0 && ((P = 0), (I += Math.abs(h))),
              f < 0 && ((O = 0), (C += Math.abs(f))),
              T.translate(-E.scale * P, -A.scale * O),
              k.transform(E.scale, 0, 0, A.scale, 0, 0),
              T.save(),
              this.clipBbox(k, P, O, I, C),
              (k.baseTransform = Rt(k.ctx)),
              k.executeOperatorList(i),
              k.endDrawing(),
              {
                canvas: M.canvas,
                scaleX: E.scale,
                scaleY: A.scale,
                offsetX: P,
                offsetY: O,
              }
            );
          }
          getSizeAndScale(t, i, r) {
            t = Math.abs(t);
            const s = Math.max(n.MAX_PATTERN_SIZE, i);
            let o = Math.ceil(t * r);
            return o >= s ? (o = s) : (r = o / t), { scale: r, size: o };
          }
          clipBbox(t, i, r, s, o) {
            t.ctx.rect(i, r, s - i, o - r),
              t.current.updateRectMinMax(Rt(t.ctx), [i, r, s, o]),
              t.clip(),
              t.endPath();
          }
          setFillAndStrokeStyleToContext(t, i, r) {
            const s = t.ctx,
              o = t.current;
            switch (i) {
              case 1:
                const a = this.ctx;
                (s.fillStyle = a.fillStyle),
                  (s.strokeStyle = a.strokeStyle),
                  (o.fillColor = a.fillStyle),
                  (o.strokeColor = a.strokeStyle);
                break;
              case 2:
                const l = te.makeHexColor(r[0], r[1], r[2]);
                (s.fillStyle = l),
                  (s.strokeStyle = l),
                  (o.fillColor = l),
                  (o.strokeColor = l);
                break;
              default:
                throw new wne(`Unsupported paint type: ${i}`);
            }
          }
          getPattern(t, i, r, s) {
            let o = r;
            'Shading' !== s &&
              ((o = te.transform(o, i.baseTransform)),
              this.matrix && (o = te.transform(o, this.matrix)));
            const a = this.createPatternCanvas(i);
            let l = new DOMMatrix(o);
            (l = l.translate(a.offsetX, a.offsetY)),
              (l = l.scale(1 / a.scaleX, 1 / a.scaleY));
            const c = t.createPattern(a.canvas, 'repeat');
            return c.setTransform(l), c;
          }
        }
        return Se(n, 'MAX_PATTERN_SIZE', 3e3), n;
      })();
      function U2({
        src: n,
        srcPos: e = 0,
        dest: t,
        width: i,
        height: r,
        nonBlackColor: s = 4294967295,
        inverseDecode: o = !1,
      }) {
        const a = ui.isLittleEndian ? 4278190080 : 255,
          [l, c] = o ? [s, a] : [a, s],
          u = i >> 3,
          h = 7 & i,
          f = n.length;
        t = new Uint32Array(t.buffer);
        let p = 0;
        for (let m = 0; m < r; m++) {
          for (const w = e + u; e < w; e++) {
            const y = e < f ? n[e] : 255;
            (t[p++] = 128 & y ? c : l),
              (t[p++] = 64 & y ? c : l),
              (t[p++] = 32 & y ? c : l),
              (t[p++] = 16 & y ? c : l),
              (t[p++] = 8 & y ? c : l),
              (t[p++] = 4 & y ? c : l),
              (t[p++] = 2 & y ? c : l),
              (t[p++] = 1 & y ? c : l);
          }
          if (0 === h) continue;
          const g = e < f ? n[e++] : 255;
          for (let w = 0; w < h; w++) t[p++] = g & (1 << (7 - w)) ? c : l;
        }
        return { srcPos: e, destPos: p };
      }
      class wie {
        constructor(e) {
          (this.canvasFactory = e), (this.cache = Object.create(null));
        }
        getCanvas(e, t, i) {
          let r;
          return (
            void 0 !== this.cache[e]
              ? ((r = this.cache[e]), this.canvasFactory.reset(r, t, i))
              : ((r = this.canvasFactory.create(t, i)), (this.cache[e] = r)),
            r
          );
        }
        delete(e) {
          delete this.cache[e];
        }
        clear() {
          for (const e in this.cache)
            this.canvasFactory.destroy(this.cache[e]), delete this.cache[e];
        }
      }
      function Dg(n, e, t, i, r, s, o, a, l, c) {
        const [u, h, f, p, m, g] = Rt(n);
        if (0 === h && 0 === f) {
          const A = Math.round(o * u + m),
            T = Math.round(a * p + g),
            P = Math.abs(Math.round((o + l) * u + m) - A) || 1,
            I = Math.abs(Math.round((a + c) * p + g) - T) || 1;
          return (
            n.setTransform(Math.sign(u), 0, 0, Math.sign(p), A, T),
            n.drawImage(e, t, i, r, s, 0, 0, P, I),
            n.setTransform(u, h, f, p, m, g),
            [P, I]
          );
        }
        if (0 === u && 0 === p) {
          const A = Math.round(a * f + m),
            T = Math.round(o * h + g),
            P = Math.abs(Math.round((a + c) * f + m) - A) || 1,
            I = Math.abs(Math.round((o + l) * h + g) - T) || 1;
          return (
            n.setTransform(0, Math.sign(h), Math.sign(f), 0, A, T),
            n.drawImage(e, t, i, r, s, 0, 0, I, P),
            n.setTransform(u, h, f, p, m, g),
            [I, P]
          );
        }
        return (
          n.drawImage(e, t, i, r, s, o, a, l, c),
          [Math.hypot(u, h) * l, Math.hypot(f, p) * c]
        );
      }
      class Y2 {
        constructor(e, t) {
          (this.alphaIsShape = !1),
            (this.fontSize = 0),
            (this.fontSizeScale = 1),
            (this.textMatrix = JN),
            (this.textMatrixScale = 1),
            (this.fontMatrix = IE),
            (this.leading = 0),
            (this.x = 0),
            (this.y = 0),
            (this.lineX = 0),
            (this.lineY = 0),
            (this.charSpacing = 0),
            (this.wordSpacing = 0),
            (this.textHScale = 1),
            (this.textRenderingMode = 0),
            (this.textRise = 0),
            (this.fillColor = '#000000'),
            (this.strokeColor = '#000000'),
            (this.patternFill = !1),
            (this.fillAlpha = 1),
            (this.strokeAlpha = 1),
            (this.lineWidth = 1),
            (this.activeSMask = null),
            (this.transferMaps = 'none'),
            this.startNewPathAndClipBox([0, 0, e, t]);
        }
        clone() {
          const e = Object.create(this);
          return (e.clipBox = this.clipBox.slice()), e;
        }
        setCurrentPoint(e, t) {
          (this.x = e), (this.y = t);
        }
        updatePathMinMax(e, t, i) {
          ([t, i] = te.applyTransform([t, i], e)),
            (this.minX = Math.min(this.minX, t)),
            (this.minY = Math.min(this.minY, i)),
            (this.maxX = Math.max(this.maxX, t)),
            (this.maxY = Math.max(this.maxY, i));
        }
        updateRectMinMax(e, t) {
          const i = te.applyTransform(t, e),
            r = te.applyTransform(t.slice(2), e),
            s = te.applyTransform([t[0], t[3]], e),
            o = te.applyTransform([t[2], t[1]], e);
          (this.minX = Math.min(this.minX, i[0], r[0], s[0], o[0])),
            (this.minY = Math.min(this.minY, i[1], r[1], s[1], o[1])),
            (this.maxX = Math.max(this.maxX, i[0], r[0], s[0], o[0])),
            (this.maxY = Math.max(this.maxY, i[1], r[1], s[1], o[1]));
        }
        updateScalingPathMinMax(e, t) {
          te.scaleMinMax(e, t),
            (this.minX = Math.min(this.minX, t[0])),
            (this.minY = Math.min(this.minY, t[1])),
            (this.maxX = Math.max(this.maxX, t[2])),
            (this.maxY = Math.max(this.maxY, t[3]));
        }
        updateCurvePathMinMax(e, t, i, r, s, o, a, l, c, u) {
          const h = te.bezierBoundingBox(t, i, r, s, o, a, l, c, u);
          u || this.updateRectMinMax(e, h);
        }
        getPathBoundingBox(e = 'Fill', t = null) {
          const i = [this.minX, this.minY, this.maxX, this.maxY];
          if ('Stroke' === e) {
            t || bt('Stroke bounding box must include transform.');
            const r = te.singularValueDecompose2dScale(t),
              s = (r[0] * this.lineWidth) / 2,
              o = (r[1] * this.lineWidth) / 2;
            (i[0] -= s), (i[1] -= o), (i[2] += s), (i[3] += o);
          }
          return i;
        }
        updateClipFromPath() {
          const e = te.intersect(this.clipBox, this.getPathBoundingBox());
          this.startNewPathAndClipBox(e || [0, 0, 0, 0]);
        }
        isEmptyClip() {
          return this.minX === 1 / 0;
        }
        startNewPathAndClipBox(e) {
          (this.clipBox = e),
            (this.minX = 1 / 0),
            (this.minY = 1 / 0),
            (this.maxX = 0),
            (this.maxY = 0);
        }
        getClippedPathBoundingBox(e = 'Fill', t = null) {
          return te.intersect(this.clipBox, this.getPathBoundingBox(e, t));
        }
      }
      function K2(n, e) {
        if (typeof ImageData < 'u' && e instanceof ImageData)
          return void n.putImageData(e, 0, 0);
        const t = e.height,
          i = e.width,
          r = t % 16,
          s = (t - r) / 16,
          o = 0 === r ? s : s + 1,
          a = n.createImageData(i, 16);
        let c,
          l = 0;
        const u = e.data,
          h = a.data;
        let f, p, m, g;
        if (e.kind === ng.GRAYSCALE_1BPP) {
          const w = u.byteLength,
            y = new Uint32Array(h.buffer, 0, h.byteLength >> 2),
            E = y.length,
            A = (i + 7) >> 3,
            M = 4294967295,
            T = ui.isLittleEndian ? 4278190080 : 255;
          for (f = 0; f < o; f++) {
            for (m = f < s ? 16 : r, c = 0, p = 0; p < m; p++) {
              const k = w - l;
              let P = 0;
              const O = k > A ? i : 8 * k - 7,
                I = -8 & O;
              let C = 0,
                R = 0;
              for (; P < I; P += 8)
                (R = u[l++]),
                  (y[c++] = 128 & R ? M : T),
                  (y[c++] = 64 & R ? M : T),
                  (y[c++] = 32 & R ? M : T),
                  (y[c++] = 16 & R ? M : T),
                  (y[c++] = 8 & R ? M : T),
                  (y[c++] = 4 & R ? M : T),
                  (y[c++] = 2 & R ? M : T),
                  (y[c++] = 1 & R ? M : T);
              for (; P < O; P++)
                0 === C && ((R = u[l++]), (C = 128)),
                  (y[c++] = R & C ? M : T),
                  (C >>= 1);
            }
            for (; c < E; ) y[c++] = 0;
            n.putImageData(a, 0, 16 * f);
          }
        } else if (e.kind === ng.RGBA_32BPP) {
          for (p = 0, g = 16 * i * 4, f = 0; f < s; f++)
            h.set(u.subarray(l, l + g)),
              (l += g),
              n.putImageData(a, 0, p),
              (p += 16);
          f < o &&
            ((g = i * r * 4),
            h.set(u.subarray(l, l + g)),
            n.putImageData(a, 0, p));
        } else {
          if (e.kind !== ng.RGB_24BPP)
            throw new Error(`bad image kind: ${e.kind}`);
          for (m = 16, g = i * m, f = 0; f < o; f++) {
            for (f >= s && ((m = r), (g = i * m)), c = 0, p = g; p--; )
              (h[c++] = u[l++]),
                (h[c++] = u[l++]),
                (h[c++] = u[l++]),
                (h[c++] = 255);
            n.putImageData(a, 0, 16 * f);
          }
        }
      }
      function Z2(n, e) {
        if (e.bitmap) return void n.drawImage(e.bitmap, 0, 0);
        const t = e.height,
          i = e.width,
          r = t % 16,
          s = (t - r) / 16,
          o = 0 === r ? s : s + 1,
          a = n.createImageData(i, 16);
        let l = 0;
        const c = e.data,
          u = a.data;
        for (let h = 0; h < o; h++) {
          const f = h < s ? 16 : r;
          ({ srcPos: l } = U2({
            src: c,
            srcPos: l,
            dest: u,
            width: i,
            height: f,
            nonBlackColor: 0,
          })),
            n.putImageData(a, 0, 16 * h);
        }
      }
      function eh(n, e) {
        const t = [
          'strokeStyle',
          'fillStyle',
          'fillRule',
          'globalAlpha',
          'lineWidth',
          'lineCap',
          'lineJoin',
          'miterLimit',
          'globalCompositeOperation',
          'font',
          'filter',
        ];
        for (const i of t) void 0 !== n[i] && (e[i] = n[i]);
        void 0 !== n.setLineDash &&
          (e.setLineDash(n.getLineDash()),
          (e.lineDashOffset = n.lineDashOffset));
      }
      function Tg(n) {
        if (
          ((n.strokeStyle = n.fillStyle = '#000000'),
          (n.fillRule = 'nonzero'),
          (n.globalAlpha = 1),
          (n.lineWidth = 1),
          (n.lineCap = 'butt'),
          (n.lineJoin = 'miter'),
          (n.miterLimit = 10),
          (n.globalCompositeOperation = 'source-over'),
          (n.font = '10px sans-serif'),
          void 0 !== n.setLineDash &&
            (n.setLineDash([]), (n.lineDashOffset = 0)),
          !kn)
        ) {
          const { filter: e } = n;
          'none' !== e && '' !== e && (n.filter = 'none');
        }
      }
      function Q2(n, e) {
        if (e) return !0;
        const t = te.singularValueDecompose2dScale(n);
        (t[0] = Math.fround(t[0])), (t[1] = Math.fround(t[1]));
        const i = Math.fround(
          (globalThis.devicePixelRatio || 1) * ur.PDF_TO_CSS_UNITS
        );
        return t[0] <= i && t[1] <= i;
      }
      const Cie = ['butt', 'round', 'square'],
        xie = ['miter', 'round', 'bevel'],
        Aie = {},
        J2 = {};
      var yC = new WeakSet(),
        wC = new WeakSet();
      class rc {
        constructor(
          e,
          t,
          i,
          r,
          s,
          { optionalContentConfig: o, markedContentStack: a = null },
          l,
          c
        ) {
          S(this, wC),
            S(this, yC),
            (this.ctx = e),
            (this.current = new Y2(
              this.ctx.canvas.width,
              this.ctx.canvas.height
            )),
            (this.stateStack = []),
            (this.pendingClip = null),
            (this.pendingEOFill = !1),
            (this.res = null),
            (this.xobjs = null),
            (this.commonObjs = t),
            (this.objs = i),
            (this.canvasFactory = r),
            (this.filterFactory = s),
            (this.groupStack = []),
            (this.processingType3 = null),
            (this.baseTransform = null),
            (this.baseTransformStack = []),
            (this.groupLevel = 0),
            (this.smaskStack = []),
            (this.smaskCounter = 0),
            (this.tempSMask = null),
            (this.suspendedCtx = null),
            (this.contentVisible = !0),
            (this.markedContentStack = a || []),
            (this.optionalContentConfig = o),
            (this.cachedCanvases = new wie(this.canvasFactory)),
            (this.cachedPatterns = new Map()),
            (this.annotationCanvasMap = l),
            (this.viewportScale = 1),
            (this.outputScaleX = 1),
            (this.outputScaleY = 1),
            (this.pageColors = c),
            (this._cachedScaleForStroking = [-1, 0]),
            (this._cachedGetSinglePixelWidth = null),
            (this._cachedBitmapsMap = new Map());
        }
        getObject(e, t = null) {
          return 'string' == typeof e
            ? e.startsWith('g_')
              ? this.commonObjs.get(e)
              : this.objs.get(e)
            : t;
        }
        beginDrawing({
          transform: e,
          viewport: t,
          transparency: i = !1,
          background: r = null,
        }) {
          const s = this.ctx.canvas.width,
            o = this.ctx.canvas.height,
            a = this.ctx.fillStyle;
          if (
            ((this.ctx.fillStyle = r || '#ffffff'),
            this.ctx.fillRect(0, 0, s, o),
            (this.ctx.fillStyle = a),
            i)
          ) {
            const l = this.cachedCanvases.getCanvas('transparent', s, o);
            (this.compositeCtx = this.ctx),
              (this.transparentCanvas = l.canvas),
              (this.ctx = l.context),
              this.ctx.save(),
              this.ctx.transform(...Rt(this.compositeCtx));
          }
          this.ctx.save(),
            Tg(this.ctx),
            e &&
              (this.ctx.transform(...e),
              (this.outputScaleX = e[0]),
              (this.outputScaleY = e[0])),
            this.ctx.transform(...t.transform),
            (this.viewportScale = t.scale),
            (this.baseTransform = Rt(this.ctx));
        }
        executeOperatorList(e, t, i, r) {
          const s = e.argsArray,
            o = e.fnArray;
          let a = t || 0;
          const l = s.length;
          if (l === a) return a;
          const c = l - a > 10 && 'function' == typeof i,
            u = c ? Date.now() + 15 : 0;
          let h = 0;
          const f = this.commonObjs,
            p = this.objs;
          let m;
          for (;;) {
            if (void 0 !== r && a === r.nextBreakPoint)
              return r.breakIt(a, i), a;
            if (((m = o[a]), m !== dr.dependency)) this[m].apply(this, s[a]);
            else
              for (const g of s[a]) {
                const w = g.startsWith('g_') ? f : p;
                if (!w.has(g)) return w.get(g, i), a;
              }
            if ((a++, a === l)) return a;
            if (c && ++h > 10) {
              if (Date.now() > u) return i(), a;
              h = 0;
            }
          }
        }
        endDrawing() {
          b(this, yC, eV).call(this),
            this.cachedCanvases.clear(),
            this.cachedPatterns.clear();
          for (const e of this._cachedBitmapsMap.values()) {
            for (const t of e.values())
              typeof HTMLCanvasElement < 'u' &&
                t instanceof HTMLCanvasElement &&
                (t.width = t.height = 0);
            e.clear();
          }
          this._cachedBitmapsMap.clear(), b(this, wC, tV).call(this);
        }
        _scaleImage(e, t) {
          const i = e.width,
            r = e.height;
          let u,
            h,
            s = Math.max(Math.hypot(t[0], t[1]), 1),
            o = Math.max(Math.hypot(t[2], t[3]), 1),
            a = i,
            l = r,
            c = 'prescale1';
          for (; (s > 2 && a > 1) || (o > 2 && l > 1); ) {
            let f = a,
              p = l;
            s > 2 &&
              a > 1 &&
              ((f = a >= 16384 ? Math.floor(a / 2) - 1 || 1 : Math.ceil(a / 2)),
              (s /= a / f)),
              o > 2 &&
                l > 1 &&
                ((p =
                  l >= 16384 ? Math.floor(l / 2) - 1 || 1 : Math.ceil(l) / 2),
                (o /= l / p)),
              (u = this.cachedCanvases.getCanvas(c, f, p)),
              (h = u.context),
              h.clearRect(0, 0, f, p),
              h.drawImage(e, 0, 0, a, l, 0, 0, f, p),
              (e = u.canvas),
              (a = f),
              (l = p),
              (c = 'prescale1' === c ? 'prescale2' : 'prescale1');
          }
          return { img: e, paintWidth: a, paintHeight: l };
        }
        _createMaskCanvas(e) {
          const t = this.ctx,
            { width: i, height: r } = e,
            s = this.current.fillColor,
            o = this.current.patternFill,
            a = Rt(t);
          let l, c, u, h;
          if ((e.bitmap || e.data) && e.count > 1) {
            const O = e.bitmap || e.data.buffer;
            (c = JSON.stringify(o ? a : [a.slice(0, 4), s])),
              (l = this._cachedBitmapsMap.get(O)),
              l || ((l = new Map()), this._cachedBitmapsMap.set(O, l));
            const I = l.get(c);
            if (I && !o)
              return {
                canvas: I,
                offsetX: Math.round(Math.min(a[0], a[2]) + a[4]),
                offsetY: Math.round(Math.min(a[1], a[3]) + a[5]),
              };
            u = I;
          }
          u ||
            ((h = this.cachedCanvases.getCanvas('maskCanvas', i, r)),
            Z2(h.context, e));
          let f = te.transform(a, [1 / i, 0, 0, -1 / r, 0, 0]);
          f = te.transform(f, [1, 0, 0, 1, 0, -r]);
          const [p, m, g, w] = te.getAxialAlignedBoundingBox([0, 0, i, r], f),
            y = Math.round(g - p) || 1,
            E = Math.round(w - m) || 1,
            A = this.cachedCanvases.getCanvas('fillCanvas', y, E),
            M = A.context,
            T = p,
            k = m;
          M.translate(-T, -k),
            M.transform(...f),
            u ||
              ((u = this._scaleImage(h.canvas, vs(M))),
              (u = u.img),
              l && o && l.set(c, u)),
            (M.imageSmoothingEnabled = Q2(Rt(M), e.interpolate)),
            Dg(M, u, 0, 0, u.width, u.height, 0, 0, i, r),
            (M.globalCompositeOperation = 'source-in');
          const P = te.transform(vs(M), [1, 0, 0, 1, -T, -k]);
          return (
            (M.fillStyle = o ? s.getPattern(t, this, P, 'Fill') : s),
            M.fillRect(0, 0, i, r),
            l &&
              !o &&
              (this.cachedCanvases.delete('fillCanvas'), l.set(c, A.canvas)),
            { canvas: A.canvas, offsetX: Math.round(T), offsetY: Math.round(k) }
          );
        }
        setLineWidth(e) {
          e !== this.current.lineWidth &&
            (this._cachedScaleForStroking[0] = -1),
            (this.current.lineWidth = e),
            (this.ctx.lineWidth = e);
        }
        setLineCap(e) {
          this.ctx.lineCap = Cie[e];
        }
        setLineJoin(e) {
          this.ctx.lineJoin = xie[e];
        }
        setMiterLimit(e) {
          this.ctx.miterLimit = e;
        }
        setDash(e, t) {
          const i = this.ctx;
          void 0 !== i.setLineDash &&
            (i.setLineDash(e), (i.lineDashOffset = t));
        }
        setRenderingIntent(e) {}
        setFlatness(e) {}
        setGState(e) {
          for (const [t, i] of e)
            switch (t) {
              case 'LW':
                this.setLineWidth(i);
                break;
              case 'LC':
                this.setLineCap(i);
                break;
              case 'LJ':
                this.setLineJoin(i);
                break;
              case 'ML':
                this.setMiterLimit(i);
                break;
              case 'D':
                this.setDash(i[0], i[1]);
                break;
              case 'RI':
                this.setRenderingIntent(i);
                break;
              case 'FL':
                this.setFlatness(i);
                break;
              case 'Font':
                this.setFont(i[0], i[1]);
                break;
              case 'CA':
                this.current.strokeAlpha = i;
                break;
              case 'ca':
                (this.current.fillAlpha = i), (this.ctx.globalAlpha = i);
                break;
              case 'BM':
                this.ctx.globalCompositeOperation = i;
                break;
              case 'SMask':
                (this.current.activeSMask = i ? this.tempSMask : null),
                  (this.tempSMask = null),
                  this.checkSMaskState();
                break;
              case 'TR':
                this.ctx.filter = this.current.transferMaps =
                  this.filterFactory.addFilter(i);
            }
        }
        get inSMaskMode() {
          return !!this.suspendedCtx;
        }
        checkSMaskState() {
          const e = this.inSMaskMode;
          this.current.activeSMask && !e
            ? this.beginSMaskMode()
            : !this.current.activeSMask && e && this.endSMaskMode();
        }
        beginSMaskMode() {
          if (this.inSMaskMode)
            throw new Error(
              'beginSMaskMode called while already in smask mode'
            );
          const r = this.cachedCanvases.getCanvas(
            'smaskGroupAt' + this.groupLevel,
            this.ctx.canvas.width,
            this.ctx.canvas.height
          );
          (this.suspendedCtx = this.ctx), (this.ctx = r.context);
          const s = this.ctx;
          s.setTransform(...Rt(this.suspendedCtx)),
            eh(this.suspendedCtx, s),
            (function yie(n, e) {
              if (n._removeMirroring)
                throw new Error('Context is already forwarding operations.');
              (n.__originalSave = n.save),
                (n.__originalRestore = n.restore),
                (n.__originalRotate = n.rotate),
                (n.__originalScale = n.scale),
                (n.__originalTranslate = n.translate),
                (n.__originalTransform = n.transform),
                (n.__originalSetTransform = n.setTransform),
                (n.__originalResetTransform = n.resetTransform),
                (n.__originalClip = n.clip),
                (n.__originalMoveTo = n.moveTo),
                (n.__originalLineTo = n.lineTo),
                (n.__originalBezierCurveTo = n.bezierCurveTo),
                (n.__originalRect = n.rect),
                (n.__originalClosePath = n.closePath),
                (n.__originalBeginPath = n.beginPath),
                (n._removeMirroring = () => {
                  (n.save = n.__originalSave),
                    (n.restore = n.__originalRestore),
                    (n.rotate = n.__originalRotate),
                    (n.scale = n.__originalScale),
                    (n.translate = n.__originalTranslate),
                    (n.transform = n.__originalTransform),
                    (n.setTransform = n.__originalSetTransform),
                    (n.resetTransform = n.__originalResetTransform),
                    (n.clip = n.__originalClip),
                    (n.moveTo = n.__originalMoveTo),
                    (n.lineTo = n.__originalLineTo),
                    (n.bezierCurveTo = n.__originalBezierCurveTo),
                    (n.rect = n.__originalRect),
                    (n.closePath = n.__originalClosePath),
                    (n.beginPath = n.__originalBeginPath),
                    delete n._removeMirroring;
                }),
                (n.save = function () {
                  e.save(), this.__originalSave();
                }),
                (n.restore = function () {
                  e.restore(), this.__originalRestore();
                }),
                (n.translate = function (i, r) {
                  e.translate(i, r), this.__originalTranslate(i, r);
                }),
                (n.scale = function (i, r) {
                  e.scale(i, r), this.__originalScale(i, r);
                }),
                (n.transform = function (i, r, s, o, a, l) {
                  e.transform(i, r, s, o, a, l),
                    this.__originalTransform(i, r, s, o, a, l);
                }),
                (n.setTransform = function (i, r, s, o, a, l) {
                  e.setTransform(i, r, s, o, a, l),
                    this.__originalSetTransform(i, r, s, o, a, l);
                }),
                (n.resetTransform = function () {
                  e.resetTransform(), this.__originalResetTransform();
                }),
                (n.rotate = function (i) {
                  e.rotate(i), this.__originalRotate(i);
                }),
                (n.clip = function (i) {
                  e.clip(i), this.__originalClip(i);
                }),
                (n.moveTo = function (t, i) {
                  e.moveTo(t, i), this.__originalMoveTo(t, i);
                }),
                (n.lineTo = function (t, i) {
                  e.lineTo(t, i), this.__originalLineTo(t, i);
                }),
                (n.bezierCurveTo = function (t, i, r, s, o, a) {
                  e.bezierCurveTo(t, i, r, s, o, a),
                    this.__originalBezierCurveTo(t, i, r, s, o, a);
                }),
                (n.rect = function (t, i, r, s) {
                  e.rect(t, i, r, s), this.__originalRect(t, i, r, s);
                }),
                (n.closePath = function () {
                  e.closePath(), this.__originalClosePath();
                }),
                (n.beginPath = function () {
                  e.beginPath(), this.__originalBeginPath();
                });
            })(s, this.suspendedCtx),
            this.setGState([
              ['BM', 'source-over'],
              ['ca', 1],
              ['CA', 1],
            ]);
        }
        endSMaskMode() {
          if (!this.inSMaskMode)
            throw new Error('endSMaskMode called while not in smask mode');
          this.ctx._removeMirroring(),
            eh(this.ctx, this.suspendedCtx),
            (this.ctx = this.suspendedCtx),
            (this.suspendedCtx = null);
        }
        compose(e) {
          this.current.activeSMask &&
            (e
              ? ((e[0] = Math.floor(e[0])),
                (e[1] = Math.floor(e[1])),
                (e[2] = Math.ceil(e[2])),
                (e[3] = Math.ceil(e[3])))
              : (e = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height]),
            this.composeSMask(
              this.suspendedCtx,
              this.current.activeSMask,
              this.ctx,
              e
            ),
            this.ctx.save(),
            this.ctx.setTransform(1, 0, 0, 1, 0, 0),
            this.ctx.clearRect(
              0,
              0,
              this.ctx.canvas.width,
              this.ctx.canvas.height
            ),
            this.ctx.restore());
        }
        composeSMask(e, t, i, r) {
          const s = r[0],
            o = r[1],
            a = r[2] - s,
            l = r[3] - o;
          0 === a ||
            0 === l ||
            (this.genericComposeSMask(
              t.context,
              i,
              a,
              l,
              t.subtype,
              t.backdrop,
              t.transferMap,
              s,
              o,
              t.offsetX,
              t.offsetY
            ),
            e.save(),
            (e.globalAlpha = 1),
            (e.globalCompositeOperation = 'source-over'),
            e.setTransform(1, 0, 0, 1, 0, 0),
            e.drawImage(i.canvas, 0, 0),
            e.restore());
        }
        genericComposeSMask(e, t, i, r, s, o, a, l, c, u, h) {
          let f = e.canvas,
            p = l - u,
            m = c - h;
          if (o)
            if (p < 0 || m < 0 || p + i > f.width || m + r > f.height) {
              const w = this.cachedCanvases.getCanvas('maskExtension', i, r),
                y = w.context;
              y.drawImage(f, -p, -m),
                o.some((E) => 0 !== E) &&
                  ((y.globalCompositeOperation = 'destination-atop'),
                  (y.fillStyle = te.makeHexColor(...o)),
                  y.fillRect(0, 0, i, r),
                  (y.globalCompositeOperation = 'source-over')),
                (f = w.canvas),
                (p = m = 0);
            } else if (o.some((w) => 0 !== w)) {
              e.save(), (e.globalAlpha = 1), e.setTransform(1, 0, 0, 1, 0, 0);
              const w = new Path2D();
              w.rect(p, m, i, r),
                e.clip(w),
                (e.globalCompositeOperation = 'destination-atop'),
                (e.fillStyle = te.makeHexColor(...o)),
                e.fillRect(p, m, i, r),
                e.restore();
            }
          t.save(),
            (t.globalAlpha = 1),
            t.setTransform(1, 0, 0, 1, 0, 0),
            'Alpha' === s && a
              ? (t.filter = this.filterFactory.addAlphaFilter(a))
              : 'Luminosity' === s &&
                (t.filter = this.filterFactory.addLuminosityFilter(a));
          const g = new Path2D();
          g.rect(l, c, i, r),
            t.clip(g),
            (t.globalCompositeOperation = 'destination-in'),
            t.drawImage(f, p, m, i, r, l, c, i, r),
            t.restore();
        }
        save() {
          this.inSMaskMode
            ? (eh(this.ctx, this.suspendedCtx), this.suspendedCtx.save())
            : this.ctx.save();
          const e = this.current;
          this.stateStack.push(e), (this.current = e.clone());
        }
        restore() {
          0 === this.stateStack.length &&
            this.inSMaskMode &&
            this.endSMaskMode(),
            0 !== this.stateStack.length &&
              ((this.current = this.stateStack.pop()),
              this.inSMaskMode
                ? (this.suspendedCtx.restore(), eh(this.suspendedCtx, this.ctx))
                : this.ctx.restore(),
              this.checkSMaskState(),
              (this.pendingClip = null),
              (this._cachedScaleForStroking[0] = -1),
              (this._cachedGetSinglePixelWidth = null));
        }
        transform(e, t, i, r, s, o) {
          this.ctx.transform(e, t, i, r, s, o),
            (this._cachedScaleForStroking[0] = -1),
            (this._cachedGetSinglePixelWidth = null);
        }
        constructPath(e, t, i) {
          const r = this.ctx,
            s = this.current;
          let l,
            c,
            o = s.x,
            a = s.y;
          const u = Rt(r),
            h = (0 === u[0] && 0 === u[3]) || (0 === u[1] && 0 === u[2]),
            f = h ? i.slice(0) : null;
          for (let p = 0, m = 0, g = e.length; p < g; p++)
            switch (0 | e[p]) {
              case dr.rectangle:
                (o = t[m++]), (a = t[m++]);
                const w = t[m++],
                  y = t[m++],
                  E = o + w,
                  A = a + y;
                r.moveTo(o, a),
                  0 === w || 0 === y
                    ? r.lineTo(E, A)
                    : (r.lineTo(E, a), r.lineTo(E, A), r.lineTo(o, A)),
                  h || s.updateRectMinMax(u, [o, a, E, A]),
                  r.closePath();
                break;
              case dr.moveTo:
                (o = t[m++]),
                  (a = t[m++]),
                  r.moveTo(o, a),
                  h || s.updatePathMinMax(u, o, a);
                break;
              case dr.lineTo:
                (o = t[m++]),
                  (a = t[m++]),
                  r.lineTo(o, a),
                  h || s.updatePathMinMax(u, o, a);
                break;
              case dr.curveTo:
                (l = o),
                  (c = a),
                  (o = t[m + 4]),
                  (a = t[m + 5]),
                  r.bezierCurveTo(t[m], t[m + 1], t[m + 2], t[m + 3], o, a),
                  s.updateCurvePathMinMax(
                    u,
                    l,
                    c,
                    t[m],
                    t[m + 1],
                    t[m + 2],
                    t[m + 3],
                    o,
                    a,
                    f
                  ),
                  (m += 6);
                break;
              case dr.curveTo2:
                (l = o),
                  (c = a),
                  r.bezierCurveTo(o, a, t[m], t[m + 1], t[m + 2], t[m + 3]),
                  s.updateCurvePathMinMax(
                    u,
                    l,
                    c,
                    o,
                    a,
                    t[m],
                    t[m + 1],
                    t[m + 2],
                    t[m + 3],
                    f
                  ),
                  (o = t[m + 2]),
                  (a = t[m + 3]),
                  (m += 4);
                break;
              case dr.curveTo3:
                (l = o),
                  (c = a),
                  (o = t[m + 2]),
                  (a = t[m + 3]),
                  r.bezierCurveTo(t[m], t[m + 1], o, a, o, a),
                  s.updateCurvePathMinMax(
                    u,
                    l,
                    c,
                    t[m],
                    t[m + 1],
                    o,
                    a,
                    o,
                    a,
                    f
                  ),
                  (m += 4);
                break;
              case dr.closePath:
                r.closePath();
            }
          h && s.updateScalingPathMinMax(u, f), s.setCurrentPoint(o, a);
        }
        closePath() {
          this.ctx.closePath();
        }
        stroke(e = !0) {
          const t = this.ctx,
            i = this.current.strokeColor;
          (t.globalAlpha = this.current.strokeAlpha),
            this.contentVisible &&
              ('object' == typeof i && i?.getPattern
                ? (t.save(),
                  (t.strokeStyle = i.getPattern(t, this, vs(t), 'Stroke')),
                  this.rescaleAndStroke(!1),
                  t.restore())
                : this.rescaleAndStroke(!0)),
            e && this.consumePath(this.current.getClippedPathBoundingBox()),
            (t.globalAlpha = this.current.fillAlpha);
        }
        closeStroke() {
          this.closePath(), this.stroke();
        }
        fill(e = !0) {
          const t = this.ctx,
            i = this.current.fillColor;
          let s = !1;
          this.current.patternFill &&
            (t.save(),
            (t.fillStyle = i.getPattern(t, this, vs(t), 'Fill')),
            (s = !0));
          const o = this.current.getClippedPathBoundingBox();
          this.contentVisible &&
            null !== o &&
            (this.pendingEOFill
              ? (t.fill('evenodd'), (this.pendingEOFill = !1))
              : t.fill()),
            s && t.restore(),
            e && this.consumePath(o);
        }
        eoFill() {
          (this.pendingEOFill = !0), this.fill();
        }
        fillStroke() {
          this.fill(!1), this.stroke(!1), this.consumePath();
        }
        eoFillStroke() {
          (this.pendingEOFill = !0), this.fillStroke();
        }
        closeFillStroke() {
          this.closePath(), this.fillStroke();
        }
        closeEOFillStroke() {
          (this.pendingEOFill = !0), this.closePath(), this.fillStroke();
        }
        endPath() {
          this.consumePath();
        }
        clip() {
          this.pendingClip = Aie;
        }
        eoClip() {
          this.pendingClip = J2;
        }
        beginText() {
          (this.current.textMatrix = JN),
            (this.current.textMatrixScale = 1),
            (this.current.x = this.current.lineX = 0),
            (this.current.y = this.current.lineY = 0);
        }
        endText() {
          const e = this.pendingTextPaths,
            t = this.ctx;
          if (void 0 !== e) {
            t.save(), t.beginPath();
            for (const i of e)
              t.setTransform(...i.transform),
                t.translate(i.x, i.y),
                i.addToPath(t, i.fontSize);
            t.restore(), t.clip(), t.beginPath(), delete this.pendingTextPaths;
          } else t.beginPath();
        }
        setCharSpacing(e) {
          this.current.charSpacing = e;
        }
        setWordSpacing(e) {
          this.current.wordSpacing = e;
        }
        setHScale(e) {
          this.current.textHScale = e / 100;
        }
        setLeading(e) {
          this.current.leading = -e;
        }
        setFont(e, t) {
          const i = this.commonObjs.get(e),
            r = this.current;
          if (!i) throw new Error(`Can't find font for ${e}`);
          if (
            ((r.fontMatrix = i.fontMatrix || IE),
            (0 === r.fontMatrix[0] || 0 === r.fontMatrix[3]) &&
              Ve('Invalid font matrix for font ' + e),
            t < 0 ? ((t = -t), (r.fontDirection = -1)) : (r.fontDirection = 1),
            (this.current.font = i),
            (this.current.fontSize = t),
            i.isType3Font)
          )
            return;
          const s = i.loadedName || 'sans-serif',
            o = i.systemFontInfo?.css || `"${s}", ${i.fallbackName}`;
          let a = 'normal';
          i.black ? (a = '900') : i.bold && (a = 'bold');
          const l = i.italic ? 'italic' : 'normal';
          let c = t;
          t < 16 ? (c = 16) : t > 100 && (c = 100),
            (this.current.fontSizeScale = t / c),
            (this.ctx.font = `${l} ${a} ${c}px ${o}`);
        }
        setTextRenderingMode(e) {
          this.current.textRenderingMode = e;
        }
        setTextRise(e) {
          this.current.textRise = e;
        }
        moveText(e, t) {
          (this.current.x = this.current.lineX += e),
            (this.current.y = this.current.lineY += t);
        }
        setLeadingMoveText(e, t) {
          this.setLeading(-t), this.moveText(e, t);
        }
        setTextMatrix(e, t, i, r, s, o) {
          (this.current.textMatrix = [e, t, i, r, s, o]),
            (this.current.textMatrixScale = Math.hypot(e, t)),
            (this.current.x = this.current.lineX = 0),
            (this.current.y = this.current.lineY = 0);
        }
        nextLine() {
          this.moveText(0, this.current.leading);
        }
        paintChar(e, t, i, r) {
          const s = this.ctx,
            o = this.current,
            a = o.font,
            l = o.textRenderingMode,
            c = o.fontSize / o.fontSizeScale,
            u = 3 & l,
            h = !!(4 & l),
            f = o.patternFill && !a.missingFile;
          let p;
          (a.disableFontFace || h || f) &&
            (p = a.getPathGenerator(this.commonObjs, e)),
            a.disableFontFace || f
              ? (s.save(),
                s.translate(t, i),
                s.beginPath(),
                p(s, c),
                r && s.setTransform(...r),
                (0 === u || 2 === u) && s.fill(),
                (1 === u || 2 === u) && s.stroke(),
                s.restore())
              : ((0 === u || 2 === u) && s.fillText(e, t, i),
                (1 === u || 2 === u) && s.strokeText(e, t, i)),
            h &&
              (this.pendingTextPaths ||= []).push({
                transform: Rt(s),
                x: t,
                y: i,
                fontSize: c,
                addToPath: p,
              });
        }
        get isFontSubpixelAAEnabled() {
          const { context: e } = this.cachedCanvases.getCanvas(
            'isFontSubpixelAAEnabled',
            10,
            10
          );
          e.scale(1.5, 1), e.fillText('I', 0, 10);
          const t = e.getImageData(0, 0, 10, 10).data;
          let i = !1;
          for (let r = 3; r < t.length; r += 4)
            if (t[r] > 0 && t[r] < 255) {
              i = !0;
              break;
            }
          return Ye(this, 'isFontSubpixelAAEnabled', i);
        }
        showText(e) {
          const t = this.current,
            i = t.font;
          if (i.isType3Font) return this.showType3Text(e);
          const r = t.fontSize;
          if (0 === r) return;
          const s = this.ctx,
            o = t.fontSizeScale,
            a = t.charSpacing,
            l = t.wordSpacing,
            c = t.fontDirection,
            u = t.textHScale * c,
            h = e.length,
            f = i.vertical,
            p = f ? 1 : -1,
            m = i.defaultVMetrics,
            g = r * t.fontMatrix[0],
            w =
              0 === t.textRenderingMode && !i.disableFontFace && !t.patternFill;
          let y;
          if (
            (s.save(),
            s.transform(...t.textMatrix),
            s.translate(t.x, t.y + t.textRise),
            s.scale(u, c > 0 ? -1 : 1),
            t.patternFill)
          ) {
            s.save();
            const k = t.fillColor.getPattern(s, this, vs(s), 'Fill');
            (y = Rt(s)), s.restore(), (s.fillStyle = k);
          }
          let E = t.lineWidth;
          const A = t.textMatrixScale;
          if (0 === A || 0 === E) {
            const k = 3 & t.textRenderingMode;
            (1 === k || 2 === k) && (E = this.getSinglePixelWidth());
          } else E /= A;
          if (
            (1 !== o && (s.scale(o, o), (E /= o)),
            (s.lineWidth = E),
            i.isInvalidPDFjsFont)
          ) {
            const k = [];
            let P = 0;
            for (const O of e) k.push(O.unicode), (P += O.width);
            return (
              s.fillText(k.join(''), 0, 0),
              (t.x += P * g * u),
              s.restore(),
              void this.compose()
            );
          }
          let T,
            M = 0;
          for (T = 0; T < h; ++T) {
            const k = e[T];
            if ('number' == typeof k) {
              M += (p * k * r) / 1e3;
              continue;
            }
            let P = !1;
            const O = (k.isSpace ? l : 0) + a,
              I = k.fontChar,
              C = k.accent;
            let R,
              $,
              q = k.width;
            if (f) {
              const Oe = k.vmetric || m,
                F = -(k.vmetric ? Oe[1] : 0.5 * q) * g;
              (q = Oe ? -Oe[0] : q), (R = F / o), ($ = (M + Oe[2] * g) / o);
            } else (R = M / o), ($ = 0);
            if (i.remeasure && q > 0) {
              const Oe = ((1e3 * s.measureText(I).width) / r) * o;
              if (q < Oe && this.isFontSubpixelAAEnabled) {
                const F = q / Oe;
                (P = !0), s.save(), s.scale(F, 1), (R /= F);
              } else q !== Oe && (R += (((q - Oe) / 2e3) * r) / o);
            }
            this.contentVisible &&
              (k.isInFont || i.missingFile) &&
              (w && !C
                ? s.fillText(I, R, $)
                : (this.paintChar(I, R, $, y),
                  C &&
                    this.paintChar(
                      C.fontChar,
                      R + (r * C.offset.x) / o,
                      $ - (r * C.offset.y) / o,
                      y
                    ))),
              (M += f ? q * g - O * c : q * g + O * c),
              P && s.restore();
          }
          f ? (t.y -= M) : (t.x += M * u), s.restore(), this.compose();
        }
        showType3Text(e) {
          const t = this.ctx,
            i = this.current,
            r = i.font,
            s = i.fontSize,
            o = i.fontDirection,
            a = r.vertical ? 1 : -1,
            l = i.charSpacing,
            c = i.wordSpacing,
            u = i.textHScale * o,
            h = i.fontMatrix || IE,
            f = e.length;
          let m, g, w, y;
          if (3 !== i.textRenderingMode && 0 !== s) {
            for (
              this._cachedScaleForStroking[0] = -1,
                this._cachedGetSinglePixelWidth = null,
                t.save(),
                t.transform(...i.textMatrix),
                t.translate(i.x, i.y),
                t.scale(u, o),
                m = 0;
              m < f;
              ++m
            ) {
              if (((g = e[m]), 'number' == typeof g)) {
                (y = (a * g * s) / 1e3),
                  this.ctx.translate(y, 0),
                  (i.x += y * u);
                continue;
              }
              const E = (g.isSpace ? c : 0) + l,
                A = r.charProcOperatorList[g.operatorListId];
              A
                ? (this.contentVisible &&
                    ((this.processingType3 = g),
                    this.save(),
                    t.scale(s, s),
                    t.transform(...h),
                    this.executeOperatorList(A),
                    this.restore()),
                  (w = te.applyTransform([g.width, 0], h)[0] * s + E),
                  t.translate(w, 0),
                  (i.x += w * u))
                : Ve(`Type3 character "${g.operatorListId}" is not available.`);
            }
            t.restore(), (this.processingType3 = null);
          }
        }
        setCharWidth(e, t) {}
        setCharWidthAndBounds(e, t, i, r, s, o) {
          this.ctx.rect(i, r, s - i, o - r), this.ctx.clip(), this.endPath();
        }
        getColorN_Pattern(e) {
          let t;
          if ('TilingPattern' === e[0]) {
            const i = e[1],
              r = this.baseTransform || Rt(this.ctx);
            t = new _ie(
              e,
              i,
              this.ctx,
              {
                createCanvasGraphics: (o) =>
                  new rc(
                    o,
                    this.commonObjs,
                    this.objs,
                    this.canvasFactory,
                    this.filterFactory,
                    {
                      optionalContentConfig: this.optionalContentConfig,
                      markedContentStack: this.markedContentStack,
                    }
                  ),
              },
              r
            );
          } else t = this._getPattern(e[1], e[2]);
          return t;
        }
        setStrokeColorN() {
          this.current.strokeColor = this.getColorN_Pattern(arguments);
        }
        setFillColorN() {
          (this.current.fillColor = this.getColorN_Pattern(arguments)),
            (this.current.patternFill = !0);
        }
        setStrokeRGBColor(e, t, i) {
          this.ctx.strokeStyle = this.current.strokeColor = te.makeHexColor(
            e,
            t,
            i
          );
        }
        setStrokeTransparent() {
          this.ctx.strokeStyle = this.current.strokeColor = 'transparent';
        }
        setFillRGBColor(e, t, i) {
          (this.ctx.fillStyle = this.current.fillColor =
            te.makeHexColor(e, t, i)),
            (this.current.patternFill = !1);
        }
        setFillTransparent() {
          (this.ctx.fillStyle = this.current.fillColor = 'transparent'),
            (this.current.patternFill = !1);
        }
        _getPattern(e, t = null) {
          let i;
          return (
            this.cachedPatterns.has(e)
              ? (i = this.cachedPatterns.get(e))
              : ((i = (function gie(n) {
                  switch (n[0]) {
                    case 'RadialAxial':
                      return new hie(n);
                    case 'Mesh':
                      return new pie(n);
                    case 'Dummy':
                      return new mie();
                  }
                  throw new Error(`Unknown IR type: ${n[0]}`);
                })(this.getObject(e))),
                this.cachedPatterns.set(e, i)),
            t && (i.matrix = t),
            i
          );
        }
        shadingFill(e) {
          if (!this.contentVisible) return;
          const t = this.ctx;
          this.save();
          const i = this._getPattern(e);
          t.fillStyle = i.getPattern(t, this, vs(t), 'Shading');
          const r = vs(t);
          if (r) {
            const { width: s, height: o } = t.canvas,
              [a, l, c, u] = te.getAxialAlignedBoundingBox([0, 0, s, o], r);
            this.ctx.fillRect(a, l, c - a, u - l);
          } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
          this.compose(this.current.getClippedPathBoundingBox()),
            this.restore();
        }
        beginInlineImage() {
          bt('Should not call beginInlineImage');
        }
        beginImageData() {
          bt('Should not call beginImageData');
        }
        paintFormXObjectBegin(e, t) {
          this.contentVisible &&
            (this.save(),
            this.baseTransformStack.push(this.baseTransform),
            e && this.transform(...e),
            (this.baseTransform = Rt(this.ctx)),
            t) &&
            (this.ctx.rect(t[0], t[1], t[2] - t[0], t[3] - t[1]),
            this.current.updateRectMinMax(Rt(this.ctx), t),
            this.clip(),
            this.endPath());
        }
        paintFormXObjectEnd() {
          this.contentVisible &&
            (this.restore(),
            (this.baseTransform = this.baseTransformStack.pop()));
        }
        beginGroup(e) {
          if (!this.contentVisible) return;
          this.save(),
            this.inSMaskMode &&
              (this.endSMaskMode(), (this.current.activeSMask = null));
          const t = this.ctx;
          e.isolated || sg('TODO: Support non-isolated groups.'),
            e.knockout && Ve('Knockout groups not supported.');
          const i = Rt(t);
          if ((e.matrix && t.transform(...e.matrix), !e.bbox))
            throw new Error('Bounding box is required.');
          let r = te.getAxialAlignedBoundingBox(e.bbox, Rt(t));
          r = te.intersect(r, [0, 0, t.canvas.width, t.canvas.height]) || [
            0, 0, 0, 0,
          ];
          const o = Math.floor(r[0]),
            a = Math.floor(r[1]),
            l = Math.max(Math.ceil(r[2]) - o, 1),
            c = Math.max(Math.ceil(r[3]) - a, 1);
          this.current.startNewPathAndClipBox([0, 0, l, c]);
          let u = 'groupAt' + this.groupLevel;
          e.smask && (u += '_smask_' + (this.smaskCounter++ % 2));
          const h = this.cachedCanvases.getCanvas(u, l, c),
            f = h.context;
          f.translate(-o, -a),
            f.transform(...i),
            e.smask
              ? this.smaskStack.push({
                  canvas: h.canvas,
                  context: f,
                  offsetX: o,
                  offsetY: a,
                  subtype: e.smask.subtype,
                  backdrop: e.smask.backdrop,
                  transferMap: e.smask.transferMap || null,
                  startTransformInverse: null,
                })
              : (t.setTransform(1, 0, 0, 1, 0, 0), t.translate(o, a), t.save()),
            eh(t, f),
            (this.ctx = f),
            this.setGState([
              ['BM', 'source-over'],
              ['ca', 1],
              ['CA', 1],
            ]),
            this.groupStack.push(t),
            this.groupLevel++;
        }
        endGroup(e) {
          if (!this.contentVisible) return;
          this.groupLevel--;
          const t = this.ctx,
            i = this.groupStack.pop();
          if (((this.ctx = i), (this.ctx.imageSmoothingEnabled = !1), e.smask))
            (this.tempSMask = this.smaskStack.pop()), this.restore();
          else {
            this.ctx.restore();
            const r = Rt(this.ctx);
            this.restore(), this.ctx.save(), this.ctx.setTransform(...r);
            const s = te.getAxialAlignedBoundingBox(
              [0, 0, t.canvas.width, t.canvas.height],
              r
            );
            this.ctx.drawImage(t.canvas, 0, 0),
              this.ctx.restore(),
              this.compose(s);
          }
        }
        beginAnnotation(e, t, i, r, s) {
          if (
            (b(this, yC, eV).call(this),
            Tg(this.ctx),
            this.ctx.save(),
            this.save(),
            this.baseTransform && this.ctx.setTransform(...this.baseTransform),
            t)
          ) {
            const o = t[2] - t[0],
              a = t[3] - t[1];
            if (s && this.annotationCanvasMap) {
              ((i = i.slice())[4] -= t[0]),
                (i[5] -= t[1]),
                ((t = t.slice())[0] = t[1] = 0),
                (t[2] = o),
                (t[3] = a);
              const [l, c] = te.singularValueDecompose2dScale(Rt(this.ctx)),
                { viewportScale: u } = this,
                h = Math.ceil(o * this.outputScaleX * u),
                f = Math.ceil(a * this.outputScaleY * u);
              this.annotationCanvas = this.canvasFactory.create(h, f);
              const { canvas: p, context: m } = this.annotationCanvas;
              this.annotationCanvasMap.set(e, p),
                (this.annotationCanvas.savedCtx = this.ctx),
                (this.ctx = m),
                this.ctx.save(),
                this.ctx.setTransform(l, 0, 0, -c, 0, a * c),
                Tg(this.ctx);
            } else
              Tg(this.ctx),
                this.ctx.rect(t[0], t[1], o, a),
                this.ctx.clip(),
                this.endPath();
          }
          (this.current = new Y2(
            this.ctx.canvas.width,
            this.ctx.canvas.height
          )),
            this.transform(...i),
            this.transform(...r);
        }
        endAnnotation() {
          this.annotationCanvas &&
            (this.ctx.restore(),
            b(this, wC, tV).call(this),
            (this.ctx = this.annotationCanvas.savedCtx),
            delete this.annotationCanvas.savedCtx,
            delete this.annotationCanvas);
        }
        paintImageMaskXObject(e) {
          if (!this.contentVisible) return;
          const t = e.count;
          (e = this.getObject(e.data, e)).count = t;
          const i = this.ctx,
            r = this.processingType3;
          if (
            r &&
            (void 0 === r.compiled &&
              (r.compiled = (function Eie(n) {
                const { width: e, height: t } = n;
                if (e > 1e3 || t > 1e3) return null;
                const r = new Uint8Array([
                    0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0,
                  ]),
                  s = e + 1;
                let a,
                  l,
                  c,
                  o = new Uint8Array(s * (t + 1));
                const u = (e + 7) & -8;
                let h = new Uint8Array(u * t),
                  f = 0;
                for (const y of n.data) {
                  let E = 128;
                  for (; E > 0; ) (h[f++] = y & E ? 0 : 255), (E >>= 1);
                }
                let p = 0;
                for (f = 0, 0 !== h[f] && ((o[0] = 1), ++p), l = 1; l < e; l++)
                  h[f] !== h[f + 1] && ((o[l] = h[f] ? 2 : 1), ++p), f++;
                for (0 !== h[f] && ((o[l] = 2), ++p), a = 1; a < t; a++) {
                  (f = a * u),
                    (c = a * s),
                    h[f - u] !== h[f] && ((o[c] = h[f] ? 1 : 8), ++p);
                  let y = (h[f] ? 4 : 0) + (h[f - u] ? 8 : 0);
                  for (l = 1; l < e; l++)
                    (y =
                      (y >> 2) + (h[f + 1] ? 4 : 0) + (h[f - u + 1] ? 8 : 0)),
                      r[y] && ((o[c + l] = r[y]), ++p),
                      f++;
                  if (
                    (h[f - u] !== h[f] && ((o[c + l] = h[f] ? 2 : 4), ++p),
                    p > 1e3)
                  )
                    return null;
                }
                for (
                  f = u * (t - 1),
                    c = a * s,
                    0 !== h[f] && ((o[c] = 8), ++p),
                    l = 1;
                  l < e;
                  l++
                )
                  h[f] !== h[f + 1] && ((o[c + l] = h[f] ? 4 : 8), ++p), f++;
                if ((0 !== h[f] && ((o[c + l] = 4), ++p), p > 1e3)) return null;
                const m = new Int32Array([0, s, -1, 0, -s, 0, 0, 0, 1]),
                  g = new Path2D();
                for (a = 0; p && a <= t; a++) {
                  let y = a * s;
                  const E = y + e;
                  for (; y < E && !o[y]; ) y++;
                  if (y === E) continue;
                  g.moveTo(y % s, a);
                  const A = y;
                  let M = o[y];
                  do {
                    const T = m[M];
                    do {
                      y += T;
                    } while (!o[y]);
                    const k = o[y];
                    5 !== k && 10 !== k
                      ? ((M = k), (o[y] = 0))
                      : ((M = k & ((51 * M) >> 4)),
                        (o[y] &= (M >> 2) | (M << 2))),
                      g.lineTo(y % s, (y / s) | 0),
                      o[y] || --p;
                  } while (A !== y);
                  --a;
                }
                return (
                  (h = null),
                  (o = null),
                  function (y) {
                    y.save(),
                      y.scale(1 / e, -1 / t),
                      y.translate(0, -t),
                      y.fill(g),
                      y.beginPath(),
                      y.restore();
                  }
                );
              })(e)),
            r.compiled)
          )
            return void r.compiled(i);
          const s = this._createMaskCanvas(e),
            o = s.canvas;
          i.save(),
            i.setTransform(1, 0, 0, 1, 0, 0),
            i.drawImage(o, s.offsetX, s.offsetY),
            i.restore(),
            this.compose();
        }
        paintImageMaskXObjectRepeat(e, t, i = 0, r = 0, s, o) {
          if (!this.contentVisible) return;
          e = this.getObject(e.data, e);
          const a = this.ctx;
          a.save();
          const l = Rt(a);
          a.transform(t, i, r, s, 0, 0);
          const c = this._createMaskCanvas(e);
          a.setTransform(1, 0, 0, 1, c.offsetX - l[4], c.offsetY - l[5]);
          for (let u = 0, h = o.length; u < h; u += 2) {
            const f = te.transform(l, [t, i, r, s, o[u], o[u + 1]]),
              [p, m] = te.applyTransform([0, 0], f);
            a.drawImage(c.canvas, p, m);
          }
          a.restore(), this.compose();
        }
        paintImageMaskXObjectGroup(e) {
          if (!this.contentVisible) return;
          const t = this.ctx,
            i = this.current.fillColor,
            r = this.current.patternFill;
          for (const s of e) {
            const { data: o, width: a, height: l, transform: c } = s,
              u = this.cachedCanvases.getCanvas('maskCanvas', a, l),
              h = u.context;
            h.save(),
              Z2(h, this.getObject(o, s)),
              (h.globalCompositeOperation = 'source-in'),
              (h.fillStyle = r ? i.getPattern(h, this, vs(t), 'Fill') : i),
              h.fillRect(0, 0, a, l),
              h.restore(),
              t.save(),
              t.transform(...c),
              t.scale(1, -1),
              Dg(t, u.canvas, 0, 0, a, l, 0, -1, 1, 1),
              t.restore();
          }
          this.compose();
        }
        paintImageXObject(e) {
          if (!this.contentVisible) return;
          const t = this.getObject(e);
          t
            ? this.paintInlineImageXObject(t)
            : Ve("Dependent image isn't ready yet");
        }
        paintImageXObjectRepeat(e, t, i, r) {
          if (!this.contentVisible) return;
          const s = this.getObject(e);
          if (!s) return void Ve("Dependent image isn't ready yet");
          const o = s.width,
            a = s.height,
            l = [];
          for (let c = 0, u = r.length; c < u; c += 2)
            l.push({
              transform: [t, 0, 0, i, r[c], r[c + 1]],
              x: 0,
              y: 0,
              w: o,
              h: a,
            });
          this.paintInlineImageXObjectGroup(s, l);
        }
        applyTransferMapsToCanvas(e) {
          return (
            'none' !== this.current.transferMaps &&
              ((e.filter = this.current.transferMaps),
              e.drawImage(e.canvas, 0, 0),
              (e.filter = 'none')),
            e.canvas
          );
        }
        applyTransferMapsToBitmap(e) {
          if ('none' === this.current.transferMaps) return e.bitmap;
          const { bitmap: t, width: i, height: r } = e,
            s = this.cachedCanvases.getCanvas('inlineImage', i, r),
            o = s.context;
          return (
            (o.filter = this.current.transferMaps),
            o.drawImage(t, 0, 0),
            (o.filter = 'none'),
            s.canvas
          );
        }
        paintInlineImageXObject(e) {
          if (!this.contentVisible) return;
          const t = e.width,
            i = e.height,
            r = this.ctx;
          if ((this.save(), !kn)) {
            const { filter: a } = r;
            'none' !== a && '' !== a && (r.filter = 'none');
          }
          let s;
          if ((r.scale(1 / t, -1 / i), e.bitmap))
            s = this.applyTransferMapsToBitmap(e);
          else if (
            ('function' == typeof HTMLElement && e instanceof HTMLElement) ||
            !e.data
          )
            s = e;
          else {
            const l = this.cachedCanvases.getCanvas(
              'inlineImage',
              t,
              i
            ).context;
            K2(l, e), (s = this.applyTransferMapsToCanvas(l));
          }
          const o = this._scaleImage(s, vs(r));
          (r.imageSmoothingEnabled = Q2(Rt(r), e.interpolate)),
            Dg(r, o.img, 0, 0, o.paintWidth, o.paintHeight, 0, -i, t, i),
            this.compose(),
            this.restore();
        }
        paintInlineImageXObjectGroup(e, t) {
          if (!this.contentVisible) return;
          const i = this.ctx;
          let r;
          if (e.bitmap) r = e.bitmap;
          else {
            const l = this.cachedCanvases.getCanvas(
              'inlineImage',
              e.width,
              e.height
            ).context;
            K2(l, e), (r = this.applyTransferMapsToCanvas(l));
          }
          for (const s of t)
            i.save(),
              i.transform(...s.transform),
              i.scale(1, -1),
              Dg(i, r, s.x, s.y, s.w, s.h, 0, -1, 1, 1),
              i.restore();
          this.compose();
        }
        paintSolidColorImageMask() {
          this.contentVisible &&
            (this.ctx.fillRect(0, 0, 1, 1), this.compose());
        }
        markPoint(e) {}
        markPointProps(e, t) {}
        beginMarkedContent(e) {
          this.markedContentStack.push({ visible: !0 });
        }
        beginMarkedContentProps(e, t) {
          this.markedContentStack.push(
            'OC' === e
              ? { visible: this.optionalContentConfig.isVisible(t) }
              : { visible: !0 }
          ),
            (this.contentVisible = this.isContentVisible());
        }
        endMarkedContent() {
          this.markedContentStack.pop(),
            (this.contentVisible = this.isContentVisible());
        }
        beginCompat() {}
        endCompat() {}
        consumePath(e) {
          const t = this.current.isEmptyClip();
          this.pendingClip && this.current.updateClipFromPath(),
            this.pendingClip || this.compose(e);
          const i = this.ctx;
          this.pendingClip &&
            (t || (this.pendingClip === J2 ? i.clip('evenodd') : i.clip()),
            (this.pendingClip = null)),
            this.current.startNewPathAndClipBox(this.current.clipBox),
            i.beginPath();
        }
        getSinglePixelWidth() {
          if (!this._cachedGetSinglePixelWidth) {
            const e = Rt(this.ctx);
            if (0 === e[1] && 0 === e[2])
              this._cachedGetSinglePixelWidth =
                1 / Math.min(Math.abs(e[0]), Math.abs(e[3]));
            else {
              const t = Math.abs(e[0] * e[3] - e[2] * e[1]),
                i = Math.hypot(e[0], e[2]),
                r = Math.hypot(e[1], e[3]);
              this._cachedGetSinglePixelWidth = Math.max(i, r) / t;
            }
          }
          return this._cachedGetSinglePixelWidth;
        }
        getScaleForStroking() {
          if (-1 === this._cachedScaleForStroking[0]) {
            const { lineWidth: e } = this.current,
              { a: t, b: i, c: r, d: s } = this.ctx.getTransform();
            let o, a;
            if (0 === i && 0 === r) {
              const l = Math.abs(t),
                c = Math.abs(s);
              if (l === c)
                if (0 === e) o = a = 1 / l;
                else {
                  const u = l * e;
                  o = a = u < 1 ? 1 / u : 1;
                }
              else if (0 === e) (o = 1 / l), (a = 1 / c);
              else {
                const u = l * e,
                  h = c * e;
                (o = u < 1 ? 1 / u : 1), (a = h < 1 ? 1 / h : 1);
              }
            } else {
              const l = Math.abs(t * s - i * r),
                c = Math.hypot(t, i),
                u = Math.hypot(r, s);
              if (0 === e) (o = u / l), (a = c / l);
              else {
                const h = e * l;
                (o = u > h ? u / h : 1), (a = c > h ? c / h : 1);
              }
            }
            (this._cachedScaleForStroking[0] = o),
              (this._cachedScaleForStroking[1] = a);
          }
          return this._cachedScaleForStroking;
        }
        rescaleAndStroke(e) {
          const { ctx: t } = this,
            { lineWidth: i } = this.current,
            [r, s] = this.getScaleForStroking();
          if (((t.lineWidth = i || 1), 1 === r && 1 === s))
            return void t.stroke();
          const o = t.getLineDash();
          if ((e && t.save(), t.scale(r, s), o.length > 0)) {
            const a = Math.max(r, s);
            t.setLineDash(o.map((l) => l / a)), (t.lineDashOffset /= a);
          }
          t.stroke(), e && t.restore();
        }
        isContentVisible() {
          for (let e = this.markedContentStack.length - 1; e >= 0; e--)
            if (!this.markedContentStack[e].visible) return !1;
          return !0;
        }
      }
      function eV() {
        for (; this.stateStack.length || this.inSMaskMode; ) this.restore();
        (this.current.activeSMask = null),
          this.ctx.restore(),
          this.transparentCanvas &&
            ((this.ctx = this.compositeCtx),
            this.ctx.save(),
            this.ctx.setTransform(1, 0, 0, 1, 0, 0),
            this.ctx.drawImage(this.transparentCanvas, 0, 0),
            this.ctx.restore(),
            (this.transparentCanvas = null));
      }
      function tV() {
        if (this.pageColors) {
          const n = this.filterFactory.addHCMFilter(
            this.pageColors.foreground,
            this.pageColors.background
          );
          if ('none' !== n) {
            const e = this.ctx.filter;
            (this.ctx.filter = n),
              this.ctx.drawImage(this.ctx.canvas, 0, 0),
              (this.ctx.filter = e);
          }
        }
      }
      for (const n in dr)
        void 0 !== rc.prototype[n] && (rc.prototype[dr[n]] = rc.prototype[n]);
      class Ur {
        static get workerPort() {
          return de(this, Ur, nV);
        }
        static set workerPort(e) {
          if (!(typeof Worker < 'u' && e instanceof Worker) && null !== e)
            throw new Error('Invalid `workerPort` type.');
          pa(this, Ur, nV, e);
        }
        static get workerSrc() {
          return de(this, Ur, iV);
        }
        static set workerSrc(e) {
          if ('string' != typeof e)
            throw new Error('Invalid `workerSrc` type.');
          pa(this, Ur, iV, e);
        }
      }
      var nV = { writable: !0, value: null },
        iV = { writable: !0, value: '' };
      function Ni(n) {
        switch (
          (n instanceof Error ||
            ('object' == typeof n && null !== n) ||
            bt(
              'wrapReason: Expected "reason" to be a (possibly cloned) Error.'
            ),
          n.name)
        ) {
          case 'AbortException':
            return new ga(n.message);
          case 'MissingPDFException':
            return new ma(n.message);
          case 'PasswordException':
            return new PE(n.message, n.code);
          case 'UnexpectedResponseException':
            return new og(n.message, n.status);
          case 'UnknownErrorException':
            return new RE(n.message, n.details);
          default:
            return new RE(n.message, n.toString());
        }
      }
      var rV = new WeakSet(),
        sV = new WeakSet(),
        kg = new WeakSet();
      class th {
        constructor(e, t, i) {
          S(this, kg),
            S(this, sV),
            S(this, rV),
            (this.sourceName = e),
            (this.targetName = t),
            (this.comObj = i),
            (this.callbackId = 1),
            (this.streamId = 1),
            (this.streamSinks = Object.create(null)),
            (this.streamControllers = Object.create(null)),
            (this.callbackCapabilities = Object.create(null)),
            (this.actionHandler = Object.create(null)),
            (this._onComObjOnMessage = (r) => {
              const s = r.data;
              if (s.targetName !== this.sourceName) return;
              if (s.stream) return void b(this, sV, Mie).call(this, s);
              if (s.callback) {
                const a = s.callbackId,
                  l = this.callbackCapabilities[a];
                if (!l) throw new Error(`Cannot resolve callback ${a}`);
                if ((delete this.callbackCapabilities[a], 1 === s.callback))
                  l.resolve(s.data);
                else {
                  if (2 !== s.callback)
                    throw new Error('Unexpected callback case');
                  l.reject(Ni(s.reason));
                }
                return;
              }
              const o = this.actionHandler[s.action];
              if (!o)
                throw new Error(`Unknown action from worker: ${s.action}`);
              if (s.callbackId) {
                const a = this.sourceName,
                  l = s.sourceName;
                new Promise(function (c) {
                  c(o(s.data));
                }).then(
                  function (c) {
                    i.postMessage({
                      sourceName: a,
                      targetName: l,
                      callback: 1,
                      callbackId: s.callbackId,
                      data: c,
                    });
                  },
                  function (c) {
                    i.postMessage({
                      sourceName: a,
                      targetName: l,
                      callback: 2,
                      callbackId: s.callbackId,
                      reason: Ni(c),
                    });
                  }
                );
              } else s.streamId ? b(this, rV, Sie).call(this, s) : o(s.data);
            }),
            i.addEventListener('message', this._onComObjOnMessage);
        }
        on(e, t) {
          const i = this.actionHandler;
          if (i[e])
            throw new Error(`There is already an actionName called "${e}"`);
          i[e] = t;
        }
        send(e, t, i) {
          this.comObj.postMessage(
            {
              sourceName: this.sourceName,
              targetName: this.targetName,
              action: e,
              data: t,
            },
            i
          );
        }
        sendWithPromise(e, t, i) {
          const r = this.callbackId++,
            s = Promise.withResolvers();
          this.callbackCapabilities[r] = s;
          try {
            this.comObj.postMessage(
              {
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: e,
                callbackId: r,
                data: t,
              },
              i
            );
          } catch (o) {
            s.reject(o);
          }
          return s.promise;
        }
        sendWithStream(e, t, i, r) {
          const s = this.streamId++,
            o = this.sourceName,
            a = this.targetName,
            l = this.comObj;
          return new ReadableStream(
            {
              start: (c) => {
                const u = Promise.withResolvers();
                return (
                  (this.streamControllers[s] = {
                    controller: c,
                    startCall: u,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1,
                  }),
                  l.postMessage(
                    {
                      sourceName: o,
                      targetName: a,
                      action: e,
                      streamId: s,
                      data: t,
                      desiredSize: c.desiredSize,
                    },
                    r
                  ),
                  u.promise
                );
              },
              pull: (c) => {
                const u = Promise.withResolvers();
                return (
                  (this.streamControllers[s].pullCall = u),
                  l.postMessage({
                    sourceName: o,
                    targetName: a,
                    stream: 6,
                    streamId: s,
                    desiredSize: c.desiredSize,
                  }),
                  u.promise
                );
              },
              cancel: (c) => {
                cn(c instanceof Error, 'cancel must have a valid reason');
                const u = Promise.withResolvers();
                return (
                  (this.streamControllers[s].cancelCall = u),
                  (this.streamControllers[s].isClosed = !0),
                  l.postMessage({
                    sourceName: o,
                    targetName: a,
                    stream: 1,
                    streamId: s,
                    reason: Ni(c),
                  }),
                  u.promise
                );
              },
            },
            i
          );
        }
        destroy() {
          this.comObj.removeEventListener('message', this._onComObjOnMessage);
        }
      }
      function Sie(n) {
        const e = n.streamId,
          t = this.sourceName,
          i = n.sourceName,
          r = this.comObj,
          s = this,
          o = this.actionHandler[n.action],
          a = {
            enqueue(l, c = 1, u) {
              if (this.isCancelled) return;
              const h = this.desiredSize;
              (this.desiredSize -= c),
                h > 0 &&
                  this.desiredSize <= 0 &&
                  ((this.sinkCapability = Promise.withResolvers()),
                  (this.ready = this.sinkCapability.promise)),
                r.postMessage(
                  {
                    sourceName: t,
                    targetName: i,
                    stream: 4,
                    streamId: e,
                    chunk: l,
                  },
                  u
                );
            },
            close() {
              this.isCancelled ||
                ((this.isCancelled = !0),
                r.postMessage({
                  sourceName: t,
                  targetName: i,
                  stream: 3,
                  streamId: e,
                }),
                delete s.streamSinks[e]);
            },
            error(l) {
              cn(l instanceof Error, 'error must have a valid reason'),
                !this.isCancelled &&
                  ((this.isCancelled = !0),
                  r.postMessage({
                    sourceName: t,
                    targetName: i,
                    stream: 5,
                    streamId: e,
                    reason: Ni(l),
                  }));
            },
            sinkCapability: Promise.withResolvers(),
            onPull: null,
            onCancel: null,
            isCancelled: !1,
            desiredSize: n.desiredSize,
            ready: null,
          };
        a.sinkCapability.resolve(),
          (a.ready = a.sinkCapability.promise),
          (this.streamSinks[e] = a),
          new Promise(function (l) {
            l(o(n.data, a));
          }).then(
            function () {
              r.postMessage({
                sourceName: t,
                targetName: i,
                stream: 8,
                streamId: e,
                success: !0,
              });
            },
            function (l) {
              r.postMessage({
                sourceName: t,
                targetName: i,
                stream: 8,
                streamId: e,
                reason: Ni(l),
              });
            }
          );
      }
      function Mie(n) {
        const e = n.streamId,
          t = this.sourceName,
          i = n.sourceName,
          r = this.comObj,
          s = this.streamControllers[e],
          o = this.streamSinks[e];
        switch (n.stream) {
          case 8:
            n.success
              ? s.startCall.resolve()
              : s.startCall.reject(Ni(n.reason));
            break;
          case 7:
            n.success ? s.pullCall.resolve() : s.pullCall.reject(Ni(n.reason));
            break;
          case 6:
            if (!o) {
              r.postMessage({
                sourceName: t,
                targetName: i,
                stream: 7,
                streamId: e,
                success: !0,
              });
              break;
            }
            o.desiredSize <= 0 &&
              n.desiredSize > 0 &&
              o.sinkCapability.resolve(),
              (o.desiredSize = n.desiredSize),
              new Promise(function (a) {
                a(o.onPull?.());
              }).then(
                function () {
                  r.postMessage({
                    sourceName: t,
                    targetName: i,
                    stream: 7,
                    streamId: e,
                    success: !0,
                  });
                },
                function (a) {
                  r.postMessage({
                    sourceName: t,
                    targetName: i,
                    stream: 7,
                    streamId: e,
                    reason: Ni(a),
                  });
                }
              );
            break;
          case 4:
            if ((cn(s, 'enqueue should have stream controller'), s.isClosed))
              break;
            s.controller.enqueue(n.chunk);
            break;
          case 3:
            if ((cn(s, 'close should have stream controller'), s.isClosed))
              break;
            (s.isClosed = !0),
              s.controller.close(),
              b(this, kg, EC).call(this, s, e);
            break;
          case 5:
            cn(s, 'error should have stream controller'),
              s.controller.error(Ni(n.reason)),
              b(this, kg, EC).call(this, s, e);
            break;
          case 2:
            n.success
              ? s.cancelCall.resolve()
              : s.cancelCall.reject(Ni(n.reason)),
              b(this, kg, EC).call(this, s, e);
            break;
          case 1:
            if (!o) break;
            new Promise(function (a) {
              a(o.onCancel?.(Ni(n.reason)));
            }).then(
              function () {
                r.postMessage({
                  sourceName: t,
                  targetName: i,
                  stream: 2,
                  streamId: e,
                  success: !0,
                });
              },
              function (a) {
                r.postMessage({
                  sourceName: t,
                  targetName: i,
                  stream: 2,
                  streamId: e,
                  reason: Ni(a),
                });
              }
            ),
              o.sinkCapability.reject(Ni(n.reason)),
              (o.isCancelled = !0),
              delete this.streamSinks[e];
            break;
          default:
            throw new Error('Unexpected stream case');
        }
      }
      function EC(n, e) {
        return CC.apply(this, arguments);
      }
      function CC() {
        return (CC = U(function* (n, e) {
          yield Promise.allSettled([
            n.startCall?.promise,
            n.pullCall?.promise,
            n.cancelCall?.promise,
          ]),
            delete this.streamControllers[e];
        })).apply(this, arguments);
      }
      var nh = new WeakMap(),
        xC = new WeakMap();
      class Die {
        constructor({ parsedData: e, rawData: t }) {
          v(this, nh, { writable: !0, value: void 0 }),
            v(this, xC, { writable: !0, value: void 0 }),
            _(this, nh, e),
            _(this, xC, t);
        }
        getRaw() {
          return d(this, xC);
        }
        get(e) {
          return d(this, nh).get(e) ?? null;
        }
        getAll() {
          return FE(d(this, nh));
        }
        has(e) {
          return d(this, nh).has(e);
        }
      }
      const ao = Symbol('INTERNAL');
      var AC = new WeakMap(),
        SC = new WeakMap(),
        MC = new WeakMap(),
        Pg = new WeakMap();
      class Tie {
        constructor(e, { name: t, intent: i, usage: r }) {
          v(this, AC, { writable: !0, value: !1 }),
            v(this, SC, { writable: !0, value: !1 }),
            v(this, MC, { writable: !0, value: !1 }),
            v(this, Pg, { writable: !0, value: !0 }),
            _(this, AC, !!(2 & e)),
            _(this, SC, !!(4 & e)),
            (this.name = t),
            (this.intent = i),
            (this.usage = r);
        }
        get visible() {
          if (d(this, MC)) return d(this, Pg);
          if (!d(this, Pg)) return !1;
          const { print: e, view: t } = this.usage;
          return d(this, AC)
            ? 'OFF' !== t?.viewState
            : !d(this, SC) || 'OFF' !== e?.printState;
        }
        _setVisible(e, t, i = !1) {
          e !== ao && bt('Internal method `_setVisible` called.'),
            _(this, MC, i),
            _(this, Pg, t);
        }
      }
      var sc = new WeakMap(),
        Et = new WeakMap(),
        Rg = new WeakMap(),
        Fg = new WeakMap(),
        DC = new WeakSet();
      class Iie {
        constructor(e, t = 2) {
          if (
            (S(this, DC),
            v(this, sc, { writable: !0, value: null }),
            v(this, Et, { writable: !0, value: new Map() }),
            v(this, Rg, { writable: !0, value: null }),
            v(this, Fg, { writable: !0, value: null }),
            (this.renderingIntent = t),
            (this.name = null),
            (this.creator = null),
            null !== e)
          ) {
            (this.name = e.name),
              (this.creator = e.creator),
              _(this, Fg, e.order);
            for (const i of e.groups) d(this, Et).set(i.id, new Tie(t, i));
            if ('OFF' === e.baseState)
              for (const i of d(this, Et).values()) i._setVisible(ao, !1);
            for (const i of e.on) d(this, Et).get(i)._setVisible(ao, !0);
            for (const i of e.off) d(this, Et).get(i)._setVisible(ao, !1);
            _(this, Rg, this.getHash());
          }
        }
        isVisible(e) {
          if (0 === d(this, Et).size) return !0;
          if (!e) return sg('Optional content group not defined.'), !0;
          if ('OCG' === e.type)
            return d(this, Et).has(e.id)
              ? d(this, Et).get(e.id).visible
              : (Ve(`Optional content group not found: ${e.id}`), !0);
          if ('OCMD' === e.type) {
            if (e.expression) return b(this, DC, oV).call(this, e.expression);
            if (!e.policy || 'AnyOn' === e.policy) {
              for (const t of e.ids) {
                if (!d(this, Et).has(t))
                  return Ve(`Optional content group not found: ${t}`), !0;
                if (d(this, Et).get(t).visible) return !0;
              }
              return !1;
            }
            if ('AllOn' === e.policy) {
              for (const t of e.ids) {
                if (!d(this, Et).has(t))
                  return Ve(`Optional content group not found: ${t}`), !0;
                if (!d(this, Et).get(t).visible) return !1;
              }
              return !0;
            }
            if ('AnyOff' === e.policy) {
              for (const t of e.ids) {
                if (!d(this, Et).has(t))
                  return Ve(`Optional content group not found: ${t}`), !0;
                if (!d(this, Et).get(t).visible) return !0;
              }
              return !1;
            }
            if ('AllOff' === e.policy) {
              for (const t of e.ids) {
                if (!d(this, Et).has(t))
                  return Ve(`Optional content group not found: ${t}`), !0;
                if (d(this, Et).get(t).visible) return !1;
              }
              return !0;
            }
            return Ve(`Unknown optional content policy ${e.policy}.`), !0;
          }
          return Ve(`Unknown group type ${e.type}.`), !0;
        }
        setVisibility(e, t = !0) {
          const i = d(this, Et).get(e);
          i
            ? (i._setVisible(ao, !!t, !0), _(this, sc, null))
            : Ve(`Optional content group not found: ${e}`);
        }
        setOCGState({ state: e }) {
          let i;
          for (const r of e) {
            switch (r) {
              case 'ON':
              case 'OFF':
              case 'Toggle':
                i = r;
                continue;
            }
            const s = d(this, Et).get(r);
            if (s)
              switch (i) {
                case 'ON':
                  s._setVisible(ao, !0);
                  break;
                case 'OFF':
                  s._setVisible(ao, !1);
                  break;
                case 'Toggle':
                  s._setVisible(ao, !s.visible);
              }
          }
          _(this, sc, null);
        }
        get hasInitialVisibility() {
          return null === d(this, Rg) || this.getHash() === d(this, Rg);
        }
        getOrder() {
          return d(this, Et).size
            ? d(this, Fg)
              ? d(this, Fg).slice()
              : [...d(this, Et).keys()]
            : null;
        }
        getGroups() {
          return d(this, Et).size > 0 ? FE(d(this, Et)) : null;
        }
        getGroup(e) {
          return d(this, Et).get(e) || null;
        }
        getHash() {
          if (null !== d(this, sc)) return d(this, sc);
          const e = new B2();
          for (const [t, i] of d(this, Et)) e.update(`${t}:${i.visible}`);
          return _(this, sc, e.hexdigest());
        }
      }
      function oV(n) {
        const e = n.length;
        if (e < 2) return !0;
        const t = n[0];
        for (let i = 1; i < e; i++) {
          const r = n[i];
          let s;
          if (Array.isArray(r)) s = b(this, DC, oV).call(this, r);
          else {
            if (!d(this, Et).has(r))
              return Ve(`Optional content group not found: ${r}`), !0;
            s = d(this, Et).get(r).visible;
          }
          switch (t) {
            case 'And':
              if (!s) return !1;
              break;
            case 'Or':
              if (s) return !0;
              break;
            case 'Not':
              return !s;
            default:
              return !0;
          }
        }
        return 'And' === t;
      }
      class kie {
        constructor(e, { disableRange: t = !1, disableStream: i = !1 }) {
          cn(
            e,
            'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'
          );
          const {
            length: r,
            initialData: s,
            progressiveDone: o,
            contentDispositionFilename: a,
          } = e;
          if (
            ((this._queuedChunks = []),
            (this._progressiveDone = o),
            (this._contentDispositionFilename = a),
            s?.length > 0)
          ) {
            const l =
              s instanceof Uint8Array && s.byteLength === s.buffer.byteLength
                ? s.buffer
                : new Uint8Array(s).buffer;
            this._queuedChunks.push(l);
          }
          (this._pdfDataRangeTransport = e),
            (this._isStreamingSupported = !i),
            (this._isRangeSupported = !t),
            (this._contentLength = r),
            (this._fullRequestReader = null),
            (this._rangeReaders = []),
            e.addRangeListener((l, c) => {
              this._onReceiveData({ begin: l, chunk: c });
            }),
            e.addProgressListener((l, c) => {
              this._onProgress({ loaded: l, total: c });
            }),
            e.addProgressiveReadListener((l) => {
              this._onReceiveData({ chunk: l });
            }),
            e.addProgressiveDoneListener(() => {
              this._onProgressiveDone();
            }),
            e.transportReady();
        }
        _onReceiveData({ begin: e, chunk: t }) {
          const i =
            t instanceof Uint8Array && t.byteLength === t.buffer.byteLength
              ? t.buffer
              : new Uint8Array(t).buffer;
          void 0 === e
            ? this._fullRequestReader
              ? this._fullRequestReader._enqueue(i)
              : this._queuedChunks.push(i)
            : cn(
                this._rangeReaders.some(function (s) {
                  return s._begin === e && (s._enqueue(i), !0);
                }),
                '_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.'
              );
        }
        get _progressiveDataLength() {
          return this._fullRequestReader?._loaded ?? 0;
        }
        _onProgress(e) {
          void 0 === e.total
            ? this._rangeReaders[0]?.onProgress?.({ loaded: e.loaded })
            : this._fullRequestReader?.onProgress?.({
                loaded: e.loaded,
                total: e.total,
              });
        }
        _onProgressiveDone() {
          this._fullRequestReader?.progressiveDone(),
            (this._progressiveDone = !0);
        }
        _removeRangeReader(e) {
          const t = this._rangeReaders.indexOf(e);
          t >= 0 && this._rangeReaders.splice(t, 1);
        }
        getFullReader() {
          cn(
            !this._fullRequestReader,
            'PDFDataTransportStream.getFullReader can only be called once.'
          );
          const e = this._queuedChunks;
          return (
            (this._queuedChunks = null),
            new Pie(
              this,
              e,
              this._progressiveDone,
              this._contentDispositionFilename
            )
          );
        }
        getRangeReader(e, t) {
          if (t <= this._progressiveDataLength) return null;
          const i = new Rie(this, e, t);
          return (
            this._pdfDataRangeTransport.requestDataRange(e, t),
            this._rangeReaders.push(i),
            i
          );
        }
        cancelAllRequests(e) {
          this._fullRequestReader?.cancel(e);
          for (const t of this._rangeReaders.slice(0)) t.cancel(e);
          this._pdfDataRangeTransport.abort();
        }
      }
      class Pie {
        constructor(e, t, i = !1, r = null) {
          (this._stream = e),
            (this._done = i || !1),
            (this._filename = qE(r) ? r : null),
            (this._queuedChunks = t || []),
            (this._loaded = 0);
          for (const s of this._queuedChunks) this._loaded += s.byteLength;
          (this._requests = []),
            (this._headersReady = Promise.resolve()),
            (e._fullRequestReader = this),
            (this.onProgress = null);
        }
        _enqueue(e) {
          this._done ||
            (this._requests.length > 0
              ? this._requests.shift().resolve({ value: e, done: !1 })
              : this._queuedChunks.push(e),
            (this._loaded += e.byteLength));
        }
        get headersReady() {
          return this._headersReady;
        }
        get filename() {
          return this._filename;
        }
        get isRangeSupported() {
          return this._stream._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._stream._isStreamingSupported;
        }
        get contentLength() {
          return this._stream._contentLength;
        }
        read() {
          var e = this;
          return U(function* () {
            if (e._queuedChunks.length > 0)
              return { value: e._queuedChunks.shift(), done: !1 };
            if (e._done) return { value: void 0, done: !0 };
            const t = Promise.withResolvers();
            return e._requests.push(t), t.promise;
          })();
        }
        cancel(e) {
          this._done = !0;
          for (const t of this._requests)
            t.resolve({ value: void 0, done: !0 });
          this._requests.length = 0;
        }
        progressiveDone() {
          this._done || (this._done = !0);
        }
      }
      class Rie {
        constructor(e, t, i) {
          (this._stream = e),
            (this._begin = t),
            (this._end = i),
            (this._queuedChunk = null),
            (this._requests = []),
            (this._done = !1),
            (this.onProgress = null);
        }
        _enqueue(e) {
          if (!this._done) {
            if (0 === this._requests.length) this._queuedChunk = e;
            else {
              this._requests.shift().resolve({ value: e, done: !1 });
              for (const i of this._requests)
                i.resolve({ value: void 0, done: !0 });
              this._requests.length = 0;
            }
            (this._done = !0), this._stream._removeRangeReader(this);
          }
        }
        get isStreamingSupported() {
          return !1;
        }
        read() {
          var e = this;
          return U(function* () {
            if (e._queuedChunk) {
              const i = e._queuedChunk;
              return (e._queuedChunk = null), { value: i, done: !1 };
            }
            if (e._done) return { value: void 0, done: !0 };
            const t = Promise.withResolvers();
            return e._requests.push(t), t.promise;
          })();
        }
        cancel(e) {
          this._done = !0;
          for (const t of this._requests)
            t.resolve({ value: void 0, done: !0 });
          (this._requests.length = 0), this._stream._removeRangeReader(this);
        }
      }
      function TC({
        getResponseHeader: n,
        isHttp: e,
        rangeChunkSize: t,
        disableRange: i,
      }) {
        const r = { allowRangeRequests: !1, suggestedLength: void 0 },
          s = parseInt(n('Content-Length'), 10);
        return (
          !Number.isInteger(s) ||
            ((r.suggestedLength = s), s <= 2 * t) ||
            i ||
            !e ||
            'bytes' !== n('Accept-Ranges') ||
            'identity' !== (n('Content-Encoding') || 'identity') ||
            (r.allowRangeRequests = !0),
          r
        );
      }
      function IC(n) {
        const e = n('Content-Disposition');
        if (e) {
          let t = (function Fie(n) {
            let e = !0,
              t = i('filename\\*', 'i').exec(n);
            if (t) {
              t = t[1];
              let u = a(t);
              return (u = unescape(u)), (u = l(u)), (u = c(u)), s(u);
            }
            if (
              ((t = (function o(u) {
                const h = [];
                let f;
                const p = i('filename\\*((?!0\\d)\\d+)(\\*?)', 'ig');
                for (; null !== (f = p.exec(u)); ) {
                  let [, g, w, y] = f;
                  if (((g = parseInt(g, 10)), g in h)) {
                    if (0 === g) break;
                  } else h[g] = [w, y];
                }
                const m = [];
                for (let g = 0; g < h.length && g in h; ++g) {
                  let [w, y] = h[g];
                  (y = a(y)),
                    w && ((y = unescape(y)), 0 === g && (y = l(y))),
                    m.push(y);
                }
                return m.join('');
              })(n)),
              t)
            )
              return s(c(t));
            if (((t = i('filename', 'i').exec(n)), t)) {
              t = t[1];
              let u = a(t);
              return (u = c(u)), s(u);
            }
            function i(u, h) {
              return new RegExp(
                '(?:^|;)\\s*' +
                  u +
                  '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)',
                h
              );
            }
            function r(u, h) {
              if (u) {
                if (!/^[\x00-\xFF]+$/.test(h)) return h;
                try {
                  const f = new TextDecoder(u, { fatal: !0 }),
                    p = Iu(h);
                  (h = f.decode(p)), (e = !1);
                } catch {}
              }
              return h;
            }
            function s(u) {
              return (
                e &&
                  /[\x80-\xff]/.test(u) &&
                  ((u = r('utf-8', u)), e && (u = r('iso-8859-1', u))),
                u
              );
            }
            function a(u) {
              if (u.startsWith('"')) {
                const h = u.slice(1).split('\\"');
                for (let f = 0; f < h.length; ++f) {
                  const p = h[f].indexOf('"');
                  -1 !== p && ((h[f] = h[f].slice(0, p)), (h.length = f + 1)),
                    (h[f] = h[f].replaceAll(/\\(.)/g, '$1'));
                }
                u = h.join('"');
              }
              return u;
            }
            function l(u) {
              const h = u.indexOf("'");
              return -1 === h
                ? u
                : r(u.slice(0, h), u.slice(h + 1).replace(/^[^']*'/, ''));
            }
            function c(u) {
              return !u.startsWith('=?') || /[\x00-\x19\x80-\xff]/.test(u)
                ? u
                : u.replaceAll(
                    /=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g,
                    function (h, f, p, m) {
                      if ('q' === p || 'Q' === p)
                        return r(
                          f,
                          (m = (m = m.replaceAll('_', ' ')).replaceAll(
                            /=([0-9a-fA-F]{2})/g,
                            function (g, w) {
                              return String.fromCharCode(parseInt(w, 16));
                            }
                          ))
                        );
                      try {
                        m = atob(m);
                      } catch {}
                      return r(f, m);
                    }
                  );
            }
            return '';
          })(e);
          if (t.includes('%'))
            try {
              t = decodeURIComponent(t);
            } catch {}
          if (qE(t)) return t;
        }
        return null;
      }
      function Og(n, e) {
        return 404 === n || (0 === n && e.startsWith('file:'))
          ? new ma('Missing PDF "' + e + '".')
          : new og(
              `Unexpected server response (${n}) while retrieving PDF "${e}".`,
              n
            );
      }
      function aV(n) {
        return 200 === n || 206 === n;
      }
      function lV(n, e, t) {
        return {
          method: 'GET',
          headers: n,
          signal: t.signal,
          mode: 'cors',
          credentials: e ? 'include' : 'same-origin',
          redirect: 'follow',
        };
      }
      function cV(n) {
        const e = new Headers();
        for (const t in n) {
          const i = n[t];
          void 0 !== i && e.append(t, i);
        }
        return e;
      }
      function dV(n) {
        return n instanceof Uint8Array
          ? n.buffer
          : n instanceof ArrayBuffer
          ? n
          : (Ve(`getArrayBuffer - unexpected data format: ${n}`),
            new Uint8Array(n).buffer);
      }
      class uV {
        constructor(e) {
          (this.source = e),
            (this.isHttp = /^https?:/i.test(e.url)),
            (this.httpHeaders = (this.isHttp && e.httpHeaders) || {}),
            (this._fullRequestReader = null),
            (this._rangeRequestReaders = []);
        }
        get _progressiveDataLength() {
          return this._fullRequestReader?._loaded ?? 0;
        }
        getFullReader() {
          return (
            cn(
              !this._fullRequestReader,
              'PDFFetchStream.getFullReader can only be called once.'
            ),
            (this._fullRequestReader = new Oie(this)),
            this._fullRequestReader
          );
        }
        getRangeReader(e, t) {
          if (t <= this._progressiveDataLength) return null;
          const i = new Lie(this, e, t);
          return this._rangeRequestReaders.push(i), i;
        }
        cancelAllRequests(e) {
          this._fullRequestReader?.cancel(e);
          for (const t of this._rangeRequestReaders.slice(0)) t.cancel(e);
        }
      }
      class Oie {
        constructor(e) {
          (this._stream = e),
            (this._reader = null),
            (this._loaded = 0),
            (this._filename = null);
          const t = e.source;
          (this._withCredentials = t.withCredentials || !1),
            (this._contentLength = t.length),
            (this._headersCapability = Promise.withResolvers()),
            (this._disableRange = t.disableRange || !1),
            (this._rangeChunkSize = t.rangeChunkSize),
            !this._rangeChunkSize &&
              !this._disableRange &&
              (this._disableRange = !0),
            (this._abortController = new AbortController()),
            (this._isStreamingSupported = !t.disableStream),
            (this._isRangeSupported = !t.disableRange),
            (this._headers = cV(this._stream.httpHeaders));
          const i = t.url;
          fetch(
            i,
            lV(this._headers, this._withCredentials, this._abortController)
          )
            .then((r) => {
              if (!aV(r.status)) throw Og(r.status, i);
              (this._reader = r.body.getReader()),
                this._headersCapability.resolve();
              const s = (l) => r.headers.get(l),
                { allowRangeRequests: o, suggestedLength: a } = TC({
                  getResponseHeader: s,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange,
                });
              (this._isRangeSupported = o),
                (this._contentLength = a || this._contentLength),
                (this._filename = IC(s)),
                !this._isStreamingSupported &&
                  this._isRangeSupported &&
                  this.cancel(new ga('Streaming is disabled.'));
            })
            .catch(this._headersCapability.reject),
            (this.onProgress = null);
        }
        get headersReady() {
          return this._headersCapability.promise;
        }
        get filename() {
          return this._filename;
        }
        get contentLength() {
          return this._contentLength;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        read() {
          var e = this;
          return U(function* () {
            yield e._headersCapability.promise;
            const { value: t, done: i } = yield e._reader.read();
            return i
              ? { value: t, done: i }
              : ((e._loaded += t.byteLength),
                e.onProgress?.({ loaded: e._loaded, total: e._contentLength }),
                { value: dV(t), done: !1 });
          })();
        }
        cancel(e) {
          this._reader?.cancel(e), this._abortController.abort();
        }
      }
      class Lie {
        constructor(e, t, i) {
          (this._stream = e), (this._reader = null), (this._loaded = 0);
          const r = e.source;
          (this._withCredentials = r.withCredentials || !1),
            (this._readCapability = Promise.withResolvers()),
            (this._isStreamingSupported = !r.disableStream),
            (this._abortController = new AbortController()),
            (this._headers = cV(this._stream.httpHeaders)),
            this._headers.append('Range', `bytes=${t}-${i - 1}`);
          const s = r.url;
          fetch(
            s,
            lV(this._headers, this._withCredentials, this._abortController)
          )
            .then((o) => {
              if (!aV(o.status)) throw Og(o.status, s);
              this._readCapability.resolve(),
                (this._reader = o.body.getReader());
            })
            .catch(this._readCapability.reject),
            (this.onProgress = null);
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        read() {
          var e = this;
          return U(function* () {
            yield e._readCapability.promise;
            const { value: t, done: i } = yield e._reader.read();
            return i
              ? { value: t, done: i }
              : ((e._loaded += t.byteLength),
                e.onProgress?.({ loaded: e._loaded }),
                { value: dV(t), done: !1 });
          })();
        }
        cancel(e) {
          this._reader?.cancel(e), this._abortController.abort();
        }
      }
      class Vie {
        constructor(e, t = {}) {
          (this.url = e),
            (this.isHttp = /^https?:/i.test(e)),
            (this.httpHeaders =
              (this.isHttp && t.httpHeaders) || Object.create(null)),
            (this.withCredentials = t.withCredentials || !1),
            (this.currXhrId = 0),
            (this.pendingRequests = Object.create(null));
        }
        requestRange(e, t, i) {
          const r = { begin: e, end: t };
          for (const s in i) r[s] = i[s];
          return this.request(r);
        }
        requestFull(e) {
          return this.request(e);
        }
        request(e) {
          const t = new XMLHttpRequest(),
            i = this.currXhrId++,
            r = (this.pendingRequests[i] = { xhr: t });
          t.open('GET', this.url), (t.withCredentials = this.withCredentials);
          for (const s in this.httpHeaders) {
            const o = this.httpHeaders[s];
            void 0 !== o && t.setRequestHeader(s, o);
          }
          return (
            this.isHttp && 'begin' in e && 'end' in e
              ? (t.setRequestHeader('Range', `bytes=${e.begin}-${e.end - 1}`),
                (r.expectedStatus = 206))
              : (r.expectedStatus = 200),
            (t.responseType = 'arraybuffer'),
            e.onError &&
              (t.onerror = function (s) {
                e.onError(t.status);
              }),
            (t.onreadystatechange = this.onStateChange.bind(this, i)),
            (t.onprogress = this.onProgress.bind(this, i)),
            (r.onHeadersReceived = e.onHeadersReceived),
            (r.onDone = e.onDone),
            (r.onError = e.onError),
            (r.onProgress = e.onProgress),
            t.send(null),
            i
          );
        }
        onProgress(e, t) {
          const i = this.pendingRequests[e];
          i && i.onProgress?.(t);
        }
        onStateChange(e, t) {
          const i = this.pendingRequests[e];
          if (!i) return;
          const r = i.xhr;
          if (
            (r.readyState >= 2 &&
              i.onHeadersReceived &&
              (i.onHeadersReceived(), delete i.onHeadersReceived),
            4 !== r.readyState || !(e in this.pendingRequests))
          )
            return;
          if ((delete this.pendingRequests[e], 0 === r.status && this.isHttp))
            return void i.onError?.(r.status);
          const s = r.status || 200;
          if ((200 !== s || 206 !== i.expectedStatus) && s !== i.expectedStatus)
            return void i.onError?.(r.status);
          const a = (function Nie(n) {
            const e = n.response;
            return 'string' != typeof e ? e : Iu(e).buffer;
          })(r);
          if (206 === s) {
            const l = r.getResponseHeader('Content-Range'),
              c = /bytes (\d+)-(\d+)\/(\d+)/.exec(l);
            i.onDone({ begin: parseInt(c[1], 10), chunk: a });
          } else a ? i.onDone({ begin: 0, chunk: a }) : i.onError?.(r.status);
        }
        getRequestXhr(e) {
          return this.pendingRequests[e].xhr;
        }
        isPendingRequest(e) {
          return e in this.pendingRequests;
        }
        abortRequest(e) {
          const t = this.pendingRequests[e].xhr;
          delete this.pendingRequests[e], t.abort();
        }
      }
      class Bie {
        constructor(e) {
          (this._source = e),
            (this._manager = new Vie(e.url, {
              httpHeaders: e.httpHeaders,
              withCredentials: e.withCredentials,
            })),
            (this._rangeChunkSize = e.rangeChunkSize),
            (this._fullRequestReader = null),
            (this._rangeRequestReaders = []);
        }
        _onRangeRequestReaderClosed(e) {
          const t = this._rangeRequestReaders.indexOf(e);
          t >= 0 && this._rangeRequestReaders.splice(t, 1);
        }
        getFullReader() {
          return (
            cn(
              !this._fullRequestReader,
              'PDFNetworkStream.getFullReader can only be called once.'
            ),
            (this._fullRequestReader = new Hie(this._manager, this._source)),
            this._fullRequestReader
          );
        }
        getRangeReader(e, t) {
          const i = new Wie(this._manager, e, t);
          return (
            (i.onClosed = this._onRangeRequestReaderClosed.bind(this)),
            this._rangeRequestReaders.push(i),
            i
          );
        }
        cancelAllRequests(e) {
          this._fullRequestReader?.cancel(e);
          for (const t of this._rangeRequestReaders.slice(0)) t.cancel(e);
        }
      }
      class Hie {
        constructor(e, t) {
          this._manager = e;
          const i = {
            onHeadersReceived: this._onHeadersReceived.bind(this),
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this),
          };
          (this._url = t.url),
            (this._fullRequestId = e.requestFull(i)),
            (this._headersReceivedCapability = Promise.withResolvers()),
            (this._disableRange = t.disableRange || !1),
            (this._contentLength = t.length),
            (this._rangeChunkSize = t.rangeChunkSize),
            !this._rangeChunkSize &&
              !this._disableRange &&
              (this._disableRange = !0),
            (this._isStreamingSupported = !1),
            (this._isRangeSupported = !1),
            (this._cachedChunks = []),
            (this._requests = []),
            (this._done = !1),
            (this._storedError = void 0),
            (this._filename = null),
            (this.onProgress = null);
        }
        _onHeadersReceived() {
          const e = this._fullRequestId,
            t = this._manager.getRequestXhr(e),
            i = (o) => t.getResponseHeader(o),
            { allowRangeRequests: r, suggestedLength: s } = TC({
              getResponseHeader: i,
              isHttp: this._manager.isHttp,
              rangeChunkSize: this._rangeChunkSize,
              disableRange: this._disableRange,
            });
          r && (this._isRangeSupported = !0),
            (this._contentLength = s || this._contentLength),
            (this._filename = IC(i)),
            this._isRangeSupported && this._manager.abortRequest(e),
            this._headersReceivedCapability.resolve();
        }
        _onDone(e) {
          if (
            (e &&
              (this._requests.length > 0
                ? this._requests.shift().resolve({ value: e.chunk, done: !1 })
                : this._cachedChunks.push(e.chunk)),
            (this._done = !0),
            !(this._cachedChunks.length > 0))
          ) {
            for (const t of this._requests)
              t.resolve({ value: void 0, done: !0 });
            this._requests.length = 0;
          }
        }
        _onError(e) {
          (this._storedError = Og(e, this._url)),
            this._headersReceivedCapability.reject(this._storedError);
          for (const t of this._requests) t.reject(this._storedError);
          (this._requests.length = 0), (this._cachedChunks.length = 0);
        }
        _onProgress(e) {
          this.onProgress?.({
            loaded: e.loaded,
            total: e.lengthComputable ? e.total : this._contentLength,
          });
        }
        get filename() {
          return this._filename;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        get contentLength() {
          return this._contentLength;
        }
        get headersReady() {
          return this._headersReceivedCapability.promise;
        }
        read() {
          var e = this;
          return U(function* () {
            if (e._storedError) throw e._storedError;
            if (e._cachedChunks.length > 0)
              return { value: e._cachedChunks.shift(), done: !1 };
            if (e._done) return { value: void 0, done: !0 };
            const t = Promise.withResolvers();
            return e._requests.push(t), t.promise;
          })();
        }
        cancel(e) {
          (this._done = !0), this._headersReceivedCapability.reject(e);
          for (const t of this._requests)
            t.resolve({ value: void 0, done: !0 });
          (this._requests.length = 0),
            this._manager.isPendingRequest(this._fullRequestId) &&
              this._manager.abortRequest(this._fullRequestId),
            (this._fullRequestReader = null);
        }
      }
      class Wie {
        constructor(e, t, i) {
          this._manager = e;
          const r = {
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this),
          };
          (this._url = e.url),
            (this._requestId = e.requestRange(t, i, r)),
            (this._requests = []),
            (this._queuedChunk = null),
            (this._done = !1),
            (this._storedError = void 0),
            (this.onProgress = null),
            (this.onClosed = null);
        }
        _close() {
          this.onClosed?.(this);
        }
        _onDone(e) {
          const t = e.chunk;
          this._requests.length > 0
            ? this._requests.shift().resolve({ value: t, done: !1 })
            : (this._queuedChunk = t),
            (this._done = !0);
          for (const i of this._requests)
            i.resolve({ value: void 0, done: !0 });
          (this._requests.length = 0), this._close();
        }
        _onError(e) {
          this._storedError = Og(e, this._url);
          for (const t of this._requests) t.reject(this._storedError);
          (this._requests.length = 0), (this._queuedChunk = null);
        }
        _onProgress(e) {
          this.isStreamingSupported || this.onProgress?.({ loaded: e.loaded });
        }
        get isStreamingSupported() {
          return !1;
        }
        read() {
          var e = this;
          return U(function* () {
            if (e._storedError) throw e._storedError;
            if (null !== e._queuedChunk) {
              const i = e._queuedChunk;
              return (e._queuedChunk = null), { value: i, done: !1 };
            }
            if (e._done) return { value: void 0, done: !0 };
            const t = Promise.withResolvers();
            return e._requests.push(t), t.promise;
          })();
        }
        cancel(e) {
          this._done = !0;
          for (const t of this._requests)
            t.resolve({ value: void 0, done: !0 });
          (this._requests.length = 0),
            this._manager.isPendingRequest(this._requestId) &&
              this._manager.abortRequest(this._requestId),
            this._close();
        }
      }
      const hV = /^file:\/\/\/[a-zA-Z]:\//;
      class zie {
        constructor(e) {
          (this.source = e),
            (this.url = (function jie(n) {
              const e = zr.get('url'),
                t = e.parse(n);
              return 'file:' === t.protocol || t.host
                ? t
                : /^[a-z]:[/\\]/i.test(n)
                ? e.parse(`file:///${n}`)
                : (t.host || (t.protocol = 'file:'), t);
            })(e.url)),
            (this.isHttp =
              'http:' === this.url.protocol || 'https:' === this.url.protocol),
            (this.isFsUrl = 'file:' === this.url.protocol),
            (this.httpHeaders = (this.isHttp && e.httpHeaders) || {}),
            (this._fullRequestReader = null),
            (this._rangeRequestReaders = []);
        }
        get _progressiveDataLength() {
          return this._fullRequestReader?._loaded ?? 0;
        }
        getFullReader() {
          return (
            cn(
              !this._fullRequestReader,
              'PDFNodeStream.getFullReader can only be called once.'
            ),
            (this._fullRequestReader = this.isFsUrl
              ? new Gie(this)
              : new Uie(this)),
            this._fullRequestReader
          );
        }
        getRangeReader(e, t) {
          if (t <= this._progressiveDataLength) return null;
          const i = this.isFsUrl ? new qie(this, e, t) : new $ie(this, e, t);
          return this._rangeRequestReaders.push(i), i;
        }
        cancelAllRequests(e) {
          this._fullRequestReader?.cancel(e);
          for (const t of this._rangeRequestReaders.slice(0)) t.cancel(e);
        }
      }
      class fV {
        constructor(e) {
          (this._url = e.url),
            (this._done = !1),
            (this._storedError = null),
            (this.onProgress = null);
          const t = e.source;
          (this._contentLength = t.length),
            (this._loaded = 0),
            (this._filename = null),
            (this._disableRange = t.disableRange || !1),
            (this._rangeChunkSize = t.rangeChunkSize),
            !this._rangeChunkSize &&
              !this._disableRange &&
              (this._disableRange = !0),
            (this._isStreamingSupported = !t.disableStream),
            (this._isRangeSupported = !t.disableRange),
            (this._readableStream = null),
            (this._readCapability = Promise.withResolvers()),
            (this._headersCapability = Promise.withResolvers());
        }
        get headersReady() {
          return this._headersCapability.promise;
        }
        get filename() {
          return this._filename;
        }
        get contentLength() {
          return this._contentLength;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        read() {
          var e = this;
          return U(function* () {
            if ((yield e._readCapability.promise, e._done))
              return { value: void 0, done: !0 };
            if (e._storedError) throw e._storedError;
            const t = e._readableStream.read();
            return null === t
              ? ((e._readCapability = Promise.withResolvers()), e.read())
              : ((e._loaded += t.length),
                e.onProgress?.({ loaded: e._loaded, total: e._contentLength }),
                { value: new Uint8Array(t).buffer, done: !1 });
          })();
        }
        cancel(e) {
          this._readableStream
            ? this._readableStream.destroy(e)
            : this._error(e);
        }
        _error(e) {
          (this._storedError = e), this._readCapability.resolve();
        }
        _setReadableStream(e) {
          (this._readableStream = e),
            e.on('readable', () => {
              this._readCapability.resolve();
            }),
            e.on('end', () => {
              e.destroy(), (this._done = !0), this._readCapability.resolve();
            }),
            e.on('error', (t) => {
              this._error(t);
            }),
            !this._isStreamingSupported &&
              this._isRangeSupported &&
              this._error(new ga('streaming is disabled')),
            this._storedError &&
              this._readableStream.destroy(this._storedError);
        }
      }
      class pV {
        constructor(e) {
          (this._url = e.url),
            (this._done = !1),
            (this._storedError = null),
            (this.onProgress = null),
            (this._loaded = 0),
            (this._readableStream = null),
            (this._readCapability = Promise.withResolvers()),
            (this._isStreamingSupported = !e.source.disableStream);
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        read() {
          var e = this;
          return U(function* () {
            if ((yield e._readCapability.promise, e._done))
              return { value: void 0, done: !0 };
            if (e._storedError) throw e._storedError;
            const t = e._readableStream.read();
            return null === t
              ? ((e._readCapability = Promise.withResolvers()), e.read())
              : ((e._loaded += t.length),
                e.onProgress?.({ loaded: e._loaded }),
                { value: new Uint8Array(t).buffer, done: !1 });
          })();
        }
        cancel(e) {
          this._readableStream
            ? this._readableStream.destroy(e)
            : this._error(e);
        }
        _error(e) {
          (this._storedError = e), this._readCapability.resolve();
        }
        _setReadableStream(e) {
          (this._readableStream = e),
            e.on('readable', () => {
              this._readCapability.resolve();
            }),
            e.on('end', () => {
              e.destroy(), (this._done = !0), this._readCapability.resolve();
            }),
            e.on('error', (t) => {
              this._error(t);
            }),
            this._storedError &&
              this._readableStream.destroy(this._storedError);
        }
      }
      function Lg(n, e) {
        return {
          protocol: n.protocol,
          auth: n.auth,
          host: n.hostname,
          port: n.port,
          path: n.path,
          method: 'GET',
          headers: e,
        };
      }
      class Uie extends fV {
        constructor(e) {
          super(e);
          const t = (i) => {
            if (404 === i.statusCode) {
              const a = new ma(`Missing PDF "${this._url}".`);
              return (
                (this._storedError = a), void this._headersCapability.reject(a)
              );
            }
            this._headersCapability.resolve(), this._setReadableStream(i);
            const r = (a) => this._readableStream.headers[a.toLowerCase()],
              { allowRangeRequests: s, suggestedLength: o } = TC({
                getResponseHeader: r,
                isHttp: e.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange,
              });
            (this._isRangeSupported = s),
              (this._contentLength = o || this._contentLength),
              (this._filename = IC(r));
          };
          if (((this._request = null), 'http:' === this._url.protocol)) {
            const i = zr.get('http');
            this._request = i.request(Lg(this._url, e.httpHeaders), t);
          } else {
            const i = zr.get('https');
            this._request = i.request(Lg(this._url, e.httpHeaders), t);
          }
          this._request.on('error', (i) => {
            (this._storedError = i), this._headersCapability.reject(i);
          }),
            this._request.end();
        }
      }
      class $ie extends pV {
        constructor(e, t, i) {
          super(e), (this._httpHeaders = {});
          for (const s in e.httpHeaders) {
            const o = e.httpHeaders[s];
            void 0 !== o && (this._httpHeaders[s] = o);
          }
          this._httpHeaders.Range = `bytes=${t}-${i - 1}`;
          const r = (s) => {
            if (404 !== s.statusCode) this._setReadableStream(s);
            else {
              const o = new ma(`Missing PDF "${this._url}".`);
              this._storedError = o;
            }
          };
          if (((this._request = null), 'http:' === this._url.protocol)) {
            const s = zr.get('http');
            this._request = s.request(Lg(this._url, this._httpHeaders), r);
          } else {
            const s = zr.get('https');
            this._request = s.request(Lg(this._url, this._httpHeaders), r);
          }
          this._request.on('error', (s) => {
            this._storedError = s;
          }),
            this._request.end();
        }
      }
      class Gie extends fV {
        constructor(e) {
          super(e);
          let t = decodeURIComponent(this._url.path);
          hV.test(this._url.href) && (t = t.replace(/^\//, ''));
          const i = zr.get('fs');
          i.promises.lstat(t).then(
            (r) => {
              (this._contentLength = r.size),
                this._setReadableStream(i.createReadStream(t)),
                this._headersCapability.resolve();
            },
            (r) => {
              'ENOENT' === r.code && (r = new ma(`Missing PDF "${t}".`)),
                (this._storedError = r),
                this._headersCapability.reject(r);
            }
          );
        }
      }
      class qie extends pV {
        constructor(e, t, i) {
          super(e);
          let r = decodeURIComponent(this._url.path);
          hV.test(this._url.href) && (r = r.replace(/^\//, ''));
          const s = zr.get('fs');
          this._setReadableStream(
            s.createReadStream(r, { start: t, end: i - 1 })
          );
        }
      }
      const _i = 30,
        Yie = 0.8;
      var oc = new WeakMap(),
        Zi = new WeakMap(),
        RC = new WeakMap(),
        FC = new WeakMap(),
        ac = new WeakMap(),
        ya = new WeakMap(),
        OC = new WeakMap(),
        LC = new WeakMap(),
        ih = new WeakMap(),
        Ng = new WeakMap(),
        Vg = new WeakMap(),
        lc = new WeakMap(),
        Bg = new WeakMap(),
        NC = new WeakMap(),
        Hg = new WeakMap(),
        rh = new WeakMap(),
        VC = new WeakMap(),
        BC = new WeakMap(),
        mV = new WeakSet(),
        gV = new WeakSet(),
        HC = new WeakSet();
      class We {
        constructor({ textContentSource: e, container: t, viewport: i }) {
          if (
            (S(this, HC),
            S(this, gV),
            S(this, mV),
            v(this, oc, { writable: !0, value: Promise.withResolvers() }),
            v(this, Zi, { writable: !0, value: null }),
            v(this, RC, { writable: !0, value: !1 }),
            v(this, FC, {
              writable: !0,
              value: !!globalThis.FontInspector?.enabled,
            }),
            v(this, ac, { writable: !0, value: null }),
            v(this, ya, { writable: !0, value: null }),
            v(this, OC, { writable: !0, value: 0 }),
            v(this, LC, { writable: !0, value: 0 }),
            v(this, ih, { writable: !0, value: null }),
            v(this, Ng, { writable: !0, value: null }),
            v(this, Vg, { writable: !0, value: 0 }),
            v(this, lc, { writable: !0, value: 0 }),
            v(this, Bg, { writable: !0, value: Object.create(null) }),
            v(this, NC, { writable: !0, value: [] }),
            v(this, Hg, { writable: !0, value: null }),
            v(this, rh, { writable: !0, value: [] }),
            v(this, VC, { writable: !0, value: new WeakMap() }),
            v(this, BC, { writable: !0, value: null }),
            e instanceof ReadableStream)
          )
            _(this, Hg, e);
          else {
            if ('object' != typeof e)
              throw new Error('No "textContentSource" parameter specified.');
            _(
              this,
              Hg,
              new ReadableStream({
                start(l) {
                  l.enqueue(e), l.close();
                },
              })
            );
          }
          _(this, Zi, _(this, Ng, t)),
            _(this, lc, i.scale * (globalThis.devicePixelRatio || 1)),
            _(this, Vg, i.rotation),
            _(this, ya, {
              prevFontSize: null,
              prevFontFamily: null,
              div: null,
              properties: null,
              ctx: null,
            });
          const { pageWidth: r, pageHeight: s, pageX: o, pageY: a } = i.rawDims;
          _(this, BC, [1, 0, 0, -1, -o, a + s]),
            _(this, LC, r),
            _(this, OC, s),
            we(We, We, Qie).call(We),
            ba(t, i),
            d(this, oc)
              .promise.catch(() => {})
              .then(() => {
                de(We, We, jC).delete(this),
                  _(this, ya, null),
                  _(this, Bg, null);
              });
        }
        render() {
          const e = () => {
            d(this, ih)
              .read()
              .then(({ value: t, done: i }) => {
                i
                  ? d(this, oc).resolve()
                  : (d(this, ac) ?? _(this, ac, t.lang),
                    Object.assign(d(this, Bg), t.styles),
                    b(this, mV, Kie).call(this, t.items),
                    e());
              }, d(this, oc).reject);
          };
          return (
            _(this, ih, d(this, Hg).getReader()),
            de(We, We, jC).add(this),
            e(),
            d(this, oc).promise
          );
        }
        update({ viewport: e, onBefore: t = null }) {
          const i = e.scale * (globalThis.devicePixelRatio || 1),
            r = e.rotation;
          if (
            (r !== d(this, Vg) &&
              (t?.(), _(this, Vg, r), ba(d(this, Ng), { rotation: r })),
            i !== d(this, lc))
          ) {
            t?.(), _(this, lc, i);
            const s = {
              prevFontSize: null,
              prevFontFamily: null,
              div: null,
              properties: null,
              ctx: we(We, We, WC).call(We, d(this, ac)),
            };
            for (const o of d(this, rh))
              (s.properties = d(this, VC).get(o)),
                (s.div = o),
                b(this, HC, _V).call(this, s);
          }
        }
        cancel() {
          const e = new ga('TextLayer task cancelled.');
          d(this, ih)
            ?.cancel(e)
            .catch(() => {}),
            _(this, ih, null),
            d(this, oc).reject(e);
        }
        get textDivs() {
          return d(this, rh);
        }
        get textContentItemsStr() {
          return d(this, NC);
        }
        static cleanup() {
          if (!(de(this, We, jC).size > 0)) {
            de(this, We, Wg).clear();
            for (const { canvas: e } of de(this, We, jg).values()) e.remove();
            de(this, We, jg).clear();
          }
        }
      }
      function Kie(n) {
        if (d(this, RC)) return;
        d(this, ya).ctx ??= we(We, We, WC).call(We, d(this, ac));
        const e = d(this, rh),
          t = d(this, NC);
        for (const i of n) {
          if (e.length > 1e5)
            return (
              Ve('Ignoring additional textDivs for performance reasons.'),
              void _(this, RC, !0)
            );
          if (void 0 !== i.str) t.push(i.str), b(this, gV, Zie).call(this, i);
          else if (
            'beginMarkedContentProps' === i.type ||
            'beginMarkedContent' === i.type
          ) {
            const r = d(this, Zi);
            _(this, Zi, document.createElement('span')),
              d(this, Zi).classList.add('markedContent'),
              null !== i.id && d(this, Zi).setAttribute('id', `${i.id}`),
              r.append(d(this, Zi));
          } else
            'endMarkedContent' === i.type &&
              _(this, Zi, d(this, Zi).parentNode);
        }
      }
      function Zie(n) {
        const e = document.createElement('span'),
          t = {
            angle: 0,
            canvasWidth: 0,
            hasText: '' !== n.str,
            hasEOL: n.hasEOL,
            fontSize: 0,
          };
        d(this, rh).push(e);
        const i = te.transform(d(this, BC), n.transform);
        let r = Math.atan2(i[1], i[0]);
        const s = d(this, Bg)[n.fontName];
        s.vertical && (r += Math.PI / 2);
        const o = (d(this, FC) && s.fontSubstitution) || s.fontFamily,
          a = Math.hypot(i[2], i[3]),
          l = a * we(We, We, Jie).call(We, o, d(this, ac));
        let c, u;
        0 === r
          ? ((c = i[4]), (u = i[5] - l))
          : ((c = i[4] + l * Math.sin(r)), (u = i[5] - l * Math.cos(r)));
        const h = 'calc(var(--scale-factor)*',
          f = e.style;
        d(this, Zi) === d(this, Ng)
          ? ((f.left = `${((100 * c) / d(this, LC)).toFixed(2)}%`),
            (f.top = `${((100 * u) / d(this, OC)).toFixed(2)}%`))
          : ((f.left = `${h}${c.toFixed(2)}px)`),
            (f.top = `${h}${u.toFixed(2)}px)`)),
          (f.fontSize = `${h}${(de(We, We, sh) * a).toFixed(2)}px)`),
          (f.fontFamily = o),
          (t.fontSize = a),
          e.setAttribute('role', 'presentation'),
          (e.textContent = n.str),
          (e.dir = n.dir),
          d(this, FC) &&
            (e.dataset.fontName = s.fontSubstitutionLoadedName || n.fontName),
          0 !== r && (t.angle = r * (180 / Math.PI));
        let p = !1;
        if (n.str.length > 1) p = !0;
        else if (' ' !== n.str && n.transform[0] !== n.transform[3]) {
          const m = Math.abs(n.transform[0]),
            g = Math.abs(n.transform[3]);
          m !== g && Math.max(m, g) / Math.min(m, g) > 1.5 && (p = !0);
        }
        if (
          (p && (t.canvasWidth = s.vertical ? n.height : n.width),
          d(this, VC).set(e, t),
          (d(this, ya).div = e),
          (d(this, ya).properties = t),
          b(this, HC, _V).call(this, d(this, ya)),
          t.hasText && d(this, Zi).append(e),
          t.hasEOL)
        ) {
          const m = document.createElement('br');
          m.setAttribute('role', 'presentation'), d(this, Zi).append(m);
        }
      }
      function _V(n) {
        const {
            div: e,
            properties: t,
            ctx: i,
            prevFontSize: r,
            prevFontFamily: s,
          } = n,
          { style: o } = e;
        let a = '';
        if (
          (de(We, We, sh) > 1 && (a = `scale(${1 / de(We, We, sh)})`),
          0 !== t.canvasWidth && t.hasText)
        ) {
          const { fontFamily: l } = o,
            { canvasWidth: c, fontSize: u } = t;
          (r !== u || s !== l) &&
            ((i.font = `${u * d(this, lc)}px ${l}`),
            (n.prevFontSize = u),
            (n.prevFontFamily = l));
          const { width: h } = i.measureText(e.textContent);
          h > 0 && (a = `scaleX(${(c * d(this, lc)) / h}) ${a}`);
        }
        0 !== t.angle && (a = `rotate(${t.angle}deg) ${a}`),
          a.length > 0 && (o.transform = a);
      }
      function WC(n = null) {
        let e = de(this, We, jg).get((n ||= ''));
        if (!e) {
          const t = document.createElement('canvas');
          (t.className = 'hiddenCanvasElement'),
            (t.lang = n),
            document.body.append(t),
            (e = t.getContext('2d', { alpha: !1, willReadFrequently: !0 })),
            de(this, We, jg).set(n, e);
        }
        return e;
      }
      function Qie() {
        if (null !== de(this, We, sh)) return;
        const n = document.createElement('div');
        (n.style.opacity = 0),
          (n.style.lineHeight = 1),
          (n.style.fontSize = '1px'),
          (n.style.position = 'absolute'),
          (n.textContent = 'X'),
          document.body.append(n),
          pa(this, We, sh, n.getBoundingClientRect().height),
          n.remove();
      }
      function Jie(n, e) {
        const t = de(this, We, Wg).get(n);
        if (t) return t;
        const i = we(this, We, WC).call(this, e),
          r = i.font;
        (i.canvas.width = i.canvas.height = _i), (i.font = `${_i}px ${n}`);
        const s = i.measureText('');
        let o = s.fontBoundingBoxAscent,
          a = Math.abs(s.fontBoundingBoxDescent);
        if (o) {
          const u = o / (o + a);
          return (
            de(this, We, Wg).set(n, u),
            (i.canvas.width = i.canvas.height = 0),
            (i.font = r),
            u
          );
        }
        (i.strokeStyle = 'red'),
          i.clearRect(0, 0, _i, _i),
          i.strokeText('g', 0, 0);
        let l = i.getImageData(0, 0, _i, _i).data;
        a = 0;
        for (let u = l.length - 1 - 3; u >= 0; u -= 4)
          if (l[u] > 0) {
            a = Math.ceil(u / 4 / _i);
            break;
          }
        i.clearRect(0, 0, _i, _i),
          i.strokeText('A', 0, _i),
          (l = i.getImageData(0, 0, _i, _i).data),
          (o = 0);
        for (let u = 0, h = l.length; u < h; u += 4)
          if (l[u] > 0) {
            o = _i - Math.floor(u / 4 / _i);
            break;
          }
        (i.canvas.width = i.canvas.height = 0), (i.font = r);
        const c = o ? o / (o + a) : Yie;
        return de(this, We, Wg).set(n, c), c;
      }
      var Wg = { writable: !0, value: new Map() },
        jg = { writable: !0, value: new Map() },
        sh = { writable: !0, value: null },
        jC = { writable: !0, value: new Set() };
      class oh {
        static textContent(e) {
          const t = [],
            i = { items: t, styles: Object.create(null) };
          return (
            (function r(s) {
              if (!s) return;
              let o = null;
              const a = s.name;
              if ('#text' === a) o = s.value;
              else {
                if (!oh.shouldBuildText(a)) return;
                s?.attributes?.textContent
                  ? (o = s.attributes.textContent)
                  : s.value && (o = s.value);
              }
              if ((null !== o && t.push({ str: o }), s.children))
                for (const l of s.children) r(l);
            })(e),
            i
          );
        }
        static shouldBuildText(e) {
          return !(
            'textarea' === e ||
            'input' === e ||
            'option' === e ||
            'select' === e
          );
        }
      }
      const ere = 65536,
        ire = kn
          ? class cie extends lg {
              _createCanvas(e, t) {
                return zr.get('canvas').createCanvas(e, t);
              }
            }
          : class Fne extends lg {
              constructor({
                ownerDocument: e = globalThis.document,
                enableHWA: t = !1,
              } = {}) {
                super({ enableHWA: t }), (this._document = e);
              }
              _createCanvas(e, t) {
                const i = this._document.createElement('canvas');
                return (i.width = e), (i.height = t), i;
              }
            },
        rre = kn
          ? class die extends cg {
              _fetchData(e, t) {
                return j2(e).then((i) => ({ cMapData: i, compressionType: t }));
              }
            }
          : c2,
        sre = kn
          ? class lie extends ag {}
          : class Tne extends ag {
              constructor({
                docId: e,
                ownerDocument: t = globalThis.document,
              } = {}) {
                super(),
                  S(this, Fu),
                  S(this, jE),
                  S(this, Ru),
                  S(this, Pu),
                  S(this, tc),
                  S(this, WE),
                  S(this, o2),
                  S(this, ec),
                  S(this, ug),
                  v(this, Jl, { get: Pne, set: void 0 }),
                  v(this, Ql, { get: kne, set: void 0 }),
                  v(this, Rn, { get: Ine, set: void 0 }),
                  v(this, ku, { writable: !0, value: void 0 }),
                  v(this, Zl, { writable: !0, value: void 0 }),
                  v(this, io, { writable: !0, value: void 0 }),
                  v(this, _a, { writable: !0, value: void 0 }),
                  v(this, hi, { writable: !0, value: void 0 }),
                  v(this, HE, { writable: !0, value: void 0 }),
                  v(this, ro, { writable: !0, value: 0 }),
                  _(this, _a, e),
                  _(this, hi, t);
              }
              addFilter(e) {
                var t, i;
                if (!e) return 'none';
                let r = d(this, Rn).get(e);
                if (r) return r;
                const [s, o, a] = b(this, ug, zE).call(this, e),
                  l = 1 === e.length ? s : `${s}${o}${a}`;
                if (((r = d(this, Rn).get(l)), r))
                  return d(this, Rn).set(e, r), r;
                const c = `g_${d(this, _a)}_transfer_map_${
                    (_(this, ro, ((t = d(this, ro)), (i = t++), t)), i)
                  }`,
                  u = b(this, ec, Ou).call(this, c);
                d(this, Rn).set(e, u), d(this, Rn).set(l, u);
                const h = b(this, tc, Lu).call(this, c);
                return b(this, Ru, fg).call(this, s, o, a, h), u;
              }
              addHCMFilter(e, t) {
                const i = `${e}-${t}`,
                  r = 'base';
                let s = d(this, Ql).get(r);
                if (
                  s?.key === i ||
                  (s
                    ? (s.filter?.remove(),
                      (s.key = i),
                      (s.url = 'none'),
                      (s.filter = null))
                    : ((s = { key: i, url: 'none', filter: null }),
                      d(this, Ql).set(r, s)),
                  !e || !t)
                )
                  return s.url;
                const o = b(this, Fu, pg).call(this, e);
                e = te.makeHexColor(...o);
                const a = b(this, Fu, pg).call(this, t);
                if (
                  ((t = te.makeHexColor(...a)),
                  (d(this, Jl).style.color = ''),
                  ('#000000' === e && '#ffffff' === t) || e === t)
                )
                  return s.url;
                const l = new Array(256);
                for (let p = 0; p <= 255; p++) {
                  const m = p / 255;
                  l[p] =
                    m <= 0.03928 ? m / 12.92 : ((m + 0.055) / 1.055) ** 2.4;
                }
                const c = l.join(','),
                  u = `g_${d(this, _a)}_hcm_filter`,
                  h = (s.filter = b(this, tc, Lu).call(this, u));
                b(this, Ru, fg).call(this, c, c, c, h),
                  b(this, WE, a2).call(this, h);
                const f = (p, m) => {
                  const g = o[p] / 255,
                    w = a[p] / 255,
                    y = new Array(m + 1);
                  for (let E = 0; E <= m; E++) y[E] = g + (E / m) * (w - g);
                  return y.join(',');
                };
                return (
                  b(this, Ru, fg).call(this, f(0, 5), f(1, 5), f(2, 5), h),
                  (s.url = b(this, ec, Ou).call(this, u)),
                  s.url
                );
              }
              addAlphaFilter(e) {
                var t, i;
                let r = d(this, Rn).get(e);
                if (r) return r;
                const [s] = b(this, ug, zE).call(this, [e]),
                  o = `alpha_${s}`;
                if (((r = d(this, Rn).get(o)), r))
                  return d(this, Rn).set(e, r), r;
                const a = `g_${d(this, _a)}_alpha_map_${
                    (_(this, ro, ((t = d(this, ro)), (i = t++), t)), i)
                  }`,
                  l = b(this, ec, Ou).call(this, a);
                d(this, Rn).set(e, l), d(this, Rn).set(o, l);
                const c = b(this, tc, Lu).call(this, a);
                return b(this, jE, l2).call(this, s, c), l;
              }
              addLuminosityFilter(e) {
                var t, i;
                let s,
                  o,
                  r = d(this, Rn).get(e || 'luminosity');
                if (r) return r;
                if (
                  (e
                    ? (([s] = b(this, ug, zE).call(this, [e])),
                      (o = `luminosity_${s}`))
                    : (o = 'luminosity'),
                  (r = d(this, Rn).get(o)),
                  r)
                )
                  return d(this, Rn).set(e, r), r;
                const a = `g_${d(this, _a)}_luminosity_map_${
                    (_(this, ro, ((t = d(this, ro)), (i = t++), t)), i)
                  }`,
                  l = b(this, ec, Ou).call(this, a);
                d(this, Rn).set(e, l), d(this, Rn).set(o, l);
                const c = b(this, tc, Lu).call(this, a);
                return (
                  b(this, o2, Rne).call(this, c),
                  e && b(this, jE, l2).call(this, s, c),
                  l
                );
              }
              addHighlightHCMFilter(e, t, i, r, s) {
                const o = `${t}-${i}-${r}-${s}`;
                let a = d(this, Ql).get(e);
                if (
                  a?.key === o ||
                  (a
                    ? (a.filter?.remove(),
                      (a.key = o),
                      (a.url = 'none'),
                      (a.filter = null))
                    : ((a = { key: o, url: 'none', filter: null }),
                      d(this, Ql).set(e, a)),
                  !t || !i)
                )
                  return a.url;
                const [l, c] = [t, i].map(b(this, Fu, pg).bind(this));
                let u = Math.round(
                    0.2126 * l[0] + 0.7152 * l[1] + 0.0722 * l[2]
                  ),
                  h = Math.round(0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2]),
                  [f, p] = [r, s].map(b(this, Fu, pg).bind(this));
                h < u && ([u, h, f, p] = [h, u, p, f]),
                  (d(this, Jl).style.color = '');
                const m = (y, E, A) => {
                    const M = new Array(256),
                      T = (h - u) / A,
                      k = y / 255,
                      P = (E - y) / (255 * A);
                    let O = 0;
                    for (let I = 0; I <= A; I++) {
                      const C = Math.round(u + I * T),
                        R = k + I * P;
                      for (let $ = O; $ <= C; $++) M[$] = R;
                      O = C + 1;
                    }
                    for (let I = O; I < 256; I++) M[I] = M[O - 1];
                    return M.join(',');
                  },
                  g = `g_${d(this, _a)}_hcm_${e}_filter`,
                  w = (a.filter = b(this, tc, Lu).call(this, g));
                return (
                  b(this, WE, a2).call(this, w),
                  b(this, Ru, fg).call(
                    this,
                    m(f[0], p[0], 5),
                    m(f[1], p[1], 5),
                    m(f[2], p[2], 5),
                    w
                  ),
                  (a.url = b(this, ec, Ou).call(this, g)),
                  a.url
                );
              }
              destroy(e = !1) {
                (e && 0 !== d(this, Ql).size) ||
                  (d(this, io) &&
                    (d(this, io).parentNode.parentNode.remove(),
                    _(this, io, null)),
                  d(this, Zl) && (d(this, Zl).clear(), _(this, Zl, null)),
                  _(this, ro, 0));
              }
            },
        ore = kn
          ? class uie extends dg {
              _fetchData(e) {
                return j2(e);
              }
            }
          : d2;
      function are(n = {}) {
        'string' == typeof n || n instanceof URL
          ? (n = { url: n })
          : (n instanceof ArrayBuffer || ArrayBuffer.isView(n)) &&
            (n = { data: n });
        const e = new cc(),
          { docId: t } = e,
          i = n.url
            ? (function lre(n) {
                if (n instanceof URL) return n.href;
                try {
                  return new URL(n, window.location).href;
                } catch {
                  if (kn && 'string' == typeof n) return n;
                }
                throw new Error(
                  'Invalid PDF url data: either string or URL-object is expected in the url property.'
                );
              })(n.url)
            : null,
          r = n.data
            ? (function cre(n) {
                if (kn && typeof Buffer < 'u' && n instanceof Buffer)
                  throw new Error(
                    'Please provide binary data as `Uint8Array`, rather than `Buffer`.'
                  );
                if (
                  n instanceof Uint8Array &&
                  n.byteLength === n.buffer.byteLength
                )
                  return n;
                if ('string' == typeof n) return Iu(n);
                if (
                  n instanceof ArrayBuffer ||
                  ArrayBuffer.isView(n) ||
                  ('object' == typeof n && !isNaN(n?.length))
                )
                  return new Uint8Array(n);
                throw new Error(
                  'Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.'
                );
              })(n.data)
            : null,
          s = n.httpHeaders || null,
          o = !0 === n.withCredentials,
          a = n.password ?? null,
          l = n.range instanceof yV ? n.range : null,
          c =
            Number.isInteger(n.rangeChunkSize) && n.rangeChunkSize > 0
              ? n.rangeChunkSize
              : ere;
        let u = n.worker instanceof zt ? n.worker : null;
        const h = n.verbosity,
          f =
            'string' != typeof n.docBaseUrl || gg(n.docBaseUrl)
              ? null
              : n.docBaseUrl,
          p = 'string' == typeof n.cMapUrl ? n.cMapUrl : null,
          m = !1 !== n.cMapPacked,
          g = n.CMapReaderFactory || rre,
          w =
            'string' == typeof n.standardFontDataUrl
              ? n.standardFontDataUrl
              : null,
          y = n.StandardFontDataFactory || ore,
          E = !0 !== n.stopAtErrors,
          A =
            Number.isInteger(n.maxImageSize) && n.maxImageSize > -1
              ? n.maxImageSize
              : -1,
          M = !1 !== n.isEvalSupported,
          T =
            'boolean' == typeof n.isOffscreenCanvasSupported
              ? n.isOffscreenCanvasSupported
              : !kn,
          k = Number.isInteger(n.canvasMaxAreaInBytes)
            ? n.canvasMaxAreaInBytes
            : -1,
          P = 'boolean' == typeof n.disableFontFace ? n.disableFontFace : kn,
          O = !0 === n.fontExtraProperties,
          I = !0 === n.enableXfa,
          C = n.ownerDocument || globalThis.document,
          R = !0 === n.disableRange,
          $ = !0 === n.disableStream,
          q = !0 === n.disableAutoFetch,
          oe = !0 === n.pdfBug,
          Oe = !0 === n.enableHWA,
          F = l ? l.length : n.length ?? NaN,
          W =
            'boolean' == typeof n.useSystemFonts ? n.useSystemFonts : !kn && !P,
          Q =
            'boolean' == typeof n.useWorkerFetch
              ? n.useWorkerFetch
              : g === c2 &&
                y === d2 &&
                p &&
                w &&
                Vu(p, document.baseURI) &&
                Vu(w, document.baseURI),
          ge = n.canvasFactory || new ire({ ownerDocument: C, enableHWA: Oe }),
          st = n.filterFactory || new sre({ docId: t, ownerDocument: C });
        !(function _ne(n) {
          Number.isInteger(n) && (rg = n);
        })(h);
        const Je = { canvasFactory: ge, filterFactory: st };
        if (
          (Q ||
            ((Je.cMapReaderFactory = new g({ baseUrl: p, isCompressed: m })),
            (Je.standardFontDataFactory = new y({ baseUrl: w }))),
          !u)
        ) {
          const vi = { verbosity: h, port: Ur.workerPort };
          (u = vi.port ? zt.fromPort(vi) : new zt(vi)), (e._worker = u);
        }
        const ft = {
            docId: t,
            apiVersion: '4.5.136',
            data: r,
            password: a,
            disableAutoFetch: q,
            rangeChunkSize: c,
            length: F,
            docBaseUrl: f,
            enableXfa: I,
            evaluatorOptions: {
              maxImageSize: A,
              disableFontFace: P,
              ignoreErrors: E,
              isEvalSupported: M,
              isOffscreenCanvasSupported: T,
              canvasMaxAreaInBytes: k,
              fontExtraProperties: O,
              useSystemFonts: W,
              cMapUrl: Q ? p : null,
              standardFontDataUrl: Q ? w : null,
            },
          },
          nt = {
            disableFontFace: P,
            fontExtraProperties: O,
            ownerDocument: C,
            pdfBug: oe,
            styleElement: null,
            loadingParams: { disableAutoFetch: q, enableXfa: I },
          };
        return (
          u.promise
            .then(function () {
              if (e.destroyed) throw new Error('Loading aborted');
              if (u.destroyed) throw new Error('Worker was destroyed');
              const vi = u.messageHandler.sendWithPromise(
                'GetDocRequest',
                ft,
                r ? [r.buffer] : null
              );
              let yi;
              if (l) yi = new kie(l, { disableRange: R, disableStream: $ });
              else if (!r) {
                if (!i)
                  throw new Error('getDocument - no `url` parameter provided.');
                (Ct = {
                  url: i,
                  length: F,
                  httpHeaders: s,
                  withCredentials: o,
                  rangeChunkSize: c,
                  disableRange: R,
                  disableStream: $,
                }),
                  (yi = kn
                    ? typeof fetch < 'u' &&
                      typeof Response < 'u' &&
                      'body' in Response.prototype &&
                      Vu(Ct.url)
                      ? new uV(Ct)
                      : new zie(Ct)
                    : Vu(Ct.url)
                    ? new uV(Ct)
                    : new Bie(Ct));
              }
              var Ct;
              return vi.then((De) => {
                if (e.destroyed) throw new Error('Loading aborted');
                if (u.destroyed) throw new Error('Worker was destroyed');
                const Ct = new th(t, De, u.port),
                  Ot = new pre(Ct, e, yi, nt, Je);
                (e._transport = Ot), Ct.send('Ready', null);
              });
            })
            .catch(e._capability.reject),
          e
        );
      }
      function bV(n) {
        return (
          'object' == typeof n &&
          Number.isInteger(n?.num) &&
          n.num >= 0 &&
          Number.isInteger(n?.gen) &&
          n.gen >= 0
        );
      }
      class cc {
        constructor() {
          var e, t;
          (this._capability = Promise.withResolvers()),
            (this._transport = null),
            (this._worker = null),
            (this.docId = `d${
              (pa(cc, cc, vV, ((e = de(cc, cc, vV)), (t = e++), e)), t)
            }`),
            (this.destroyed = !1),
            (this.onPassword = null),
            (this.onProgress = null);
        }
        get promise() {
          return this._capability.promise;
        }
        destroy() {
          var e = this;
          return U(function* () {
            e.destroyed = !0;
            try {
              e._worker?.port && (e._worker._pendingDestroy = !0),
                yield e._transport?.destroy();
            } catch (t) {
              throw (e._worker?.port && delete e._worker._pendingDestroy, t);
            }
            (e._transport = null),
              e._worker && (e._worker.destroy(), (e._worker = null));
          })();
        }
      }
      var vV = { writable: !0, value: 0 };
      class yV {
        constructor(e, t, i = !1, r = null) {
          (this.length = e),
            (this.initialData = t),
            (this.progressiveDone = i),
            (this.contentDispositionFilename = r),
            (this._rangeListeners = []),
            (this._progressListeners = []),
            (this._progressiveReadListeners = []),
            (this._progressiveDoneListeners = []),
            (this._readyCapability = Promise.withResolvers());
        }
        addRangeListener(e) {
          this._rangeListeners.push(e);
        }
        addProgressListener(e) {
          this._progressListeners.push(e);
        }
        addProgressiveReadListener(e) {
          this._progressiveReadListeners.push(e);
        }
        addProgressiveDoneListener(e) {
          this._progressiveDoneListeners.push(e);
        }
        onDataRange(e, t) {
          for (const i of this._rangeListeners) i(e, t);
        }
        onDataProgress(e, t) {
          this._readyCapability.promise.then(() => {
            for (const i of this._progressListeners) i(e, t);
          });
        }
        onDataProgressiveRead(e) {
          this._readyCapability.promise.then(() => {
            for (const t of this._progressiveReadListeners) t(e);
          });
        }
        onDataProgressiveDone() {
          this._readyCapability.promise.then(() => {
            for (const e of this._progressiveDoneListeners) e();
          });
        }
        transportReady() {
          this._readyCapability.resolve();
        }
        requestDataRange(e, t) {
          bt('Abstract method PDFDataRangeTransport.requestDataRange');
        }
        abort() {}
      }
      class dre {
        constructor(e, t) {
          (this._pdfInfo = e), (this._transport = t);
        }
        get annotationStorage() {
          return this._transport.annotationStorage;
        }
        get filterFactory() {
          return this._transport.filterFactory;
        }
        get numPages() {
          return this._pdfInfo.numPages;
        }
        get fingerprints() {
          return this._pdfInfo.fingerprints;
        }
        get isPureXfa() {
          return Ye(this, 'isPureXfa', !!this._transport._htmlForXfa);
        }
        get allXfaHtml() {
          return this._transport._htmlForXfa;
        }
        getPage(e) {
          return this._transport.getPage(e);
        }
        getPageIndex(e) {
          return this._transport.getPageIndex(e);
        }
        getDestinations() {
          return this._transport.getDestinations();
        }
        getDestination(e) {
          return this._transport.getDestination(e);
        }
        getPageLabels() {
          return this._transport.getPageLabels();
        }
        getPageLayout() {
          return this._transport.getPageLayout();
        }
        getPageMode() {
          return this._transport.getPageMode();
        }
        getViewerPreferences() {
          return this._transport.getViewerPreferences();
        }
        getOpenAction() {
          return this._transport.getOpenAction();
        }
        getAttachments() {
          return this._transport.getAttachments();
        }
        getJSActions() {
          return this._transport.getDocJSActions();
        }
        getOutline() {
          return this._transport.getOutline();
        }
        getOptionalContentConfig({ intent: e = 'display' } = {}) {
          const { renderingIntent: t } = this._transport.getRenderingIntent(e);
          return this._transport.getOptionalContentConfig(t);
        }
        getPermissions() {
          return this._transport.getPermissions();
        }
        getMetadata() {
          return this._transport.getMetadata();
        }
        getMarkInfo() {
          return this._transport.getMarkInfo();
        }
        getData() {
          return this._transport.getData();
        }
        saveDocument() {
          return this._transport.saveDocument();
        }
        getDownloadInfo() {
          return this._transport.downloadInfoCapability.promise;
        }
        cleanup(e = !1) {
          return this._transport.startCleanup(e || this.isPureXfa);
        }
        destroy() {
          return this.loadingTask.destroy();
        }
        cachedPageNumber(e) {
          return this._transport.cachedPageNumber(e);
        }
        get loadingParams() {
          return this._transport.loadingParams;
        }
        get loadingTask() {
          return this._transport.loadingTask;
        }
        getFieldObjects() {
          return this._transport.getFieldObjects();
        }
        hasJSActions() {
          return this._transport.hasJSActions();
        }
        getCalculationOrderIds() {
          return this._transport.getCalculationOrderIds();
        }
      }
      var dc = new WeakMap(),
        wa = new WeakMap(),
        uc = new WeakSet(),
        zg = new WeakSet();
      class ure {
        constructor(e, t, i, r = !1) {
          S(this, zg),
            S(this, uc),
            v(this, dc, { writable: !0, value: null }),
            v(this, wa, { writable: !0, value: !1 }),
            (this._pageIndex = e),
            (this._pageInfo = t),
            (this._transport = i),
            (this._stats = r ? new u2() : null),
            (this._pdfBug = r),
            (this.commonObjs = i.commonObjs),
            (this.objs = new EV()),
            (this._maybeCleanupAfterRender = !1),
            (this._intentStates = new Map()),
            (this.destroyed = !1);
        }
        get pageNumber() {
          return this._pageIndex + 1;
        }
        get rotate() {
          return this._pageInfo.rotate;
        }
        get ref() {
          return this._pageInfo.ref;
        }
        get userUnit() {
          return this._pageInfo.userUnit;
        }
        get view() {
          return this._pageInfo.view;
        }
        getViewport({
          scale: e,
          rotation: t = this.rotate,
          offsetX: i = 0,
          offsetY: r = 0,
          dontFlip: s = !1,
        } = {}) {
          return new Nu({
            viewBox: this.view,
            scale: e,
            rotation: t,
            offsetX: i,
            offsetY: r,
            dontFlip: s,
          });
        }
        getAnnotations({ intent: e = 'display' } = {}) {
          const { renderingIntent: t } = this._transport.getRenderingIntent(e);
          return this._transport.getAnnotations(this._pageIndex, t);
        }
        getJSActions() {
          return this._transport.getPageJSActions(this._pageIndex);
        }
        get filterFactory() {
          return this._transport.filterFactory;
        }
        get isPureXfa() {
          return Ye(this, 'isPureXfa', !!this._transport._htmlForXfa);
        }
        getXfa() {
          var e = this;
          return U(function* () {
            return e._transport._htmlForXfa?.children[e._pageIndex] || null;
          })();
        }
        render({
          canvasContext: e,
          viewport: t,
          intent: i = 'display',
          annotationMode: r = to.ENABLE,
          transform: s = null,
          background: o = null,
          optionalContentConfigPromise: a = null,
          annotationCanvasMap: l = null,
          pageColors: c = null,
          printAnnotationStorage: u = null,
          isEditing: h = !1,
        }) {
          this._stats?.time('Overall');
          const f = this._transport.getRenderingIntent(i, r, u, h),
            { renderingIntent: p, cacheKey: m } = f;
          _(this, wa, !1),
            b(this, zg, zC).call(this),
            (a ||= this._transport.getOptionalContentConfig(p));
          let g = this._intentStates.get(m);
          g || ((g = Object.create(null)), this._intentStates.set(m, g)),
            g.streamReaderCancelTimeout &&
              (clearTimeout(g.streamReaderCancelTimeout),
              (g.streamReaderCancelTimeout = null));
          const w = !!(4 & p);
          g.displayReadyCapability ||
            ((g.displayReadyCapability = Promise.withResolvers()),
            (g.operatorList = {
              fnArray: [],
              argsArray: [],
              lastChunk: !1,
              separateAnnots: null,
            }),
            this._stats?.time('Page Request'),
            this._pumpOperatorList(f));
          const y = (M) => {
              g.renderTasks.delete(E),
                (this._maybeCleanupAfterRender || w) && _(this, wa, !0),
                b(this, uc, ah).call(this, !w),
                M
                  ? (E.capability.reject(M),
                    this._abortOperatorList({
                      intentState: g,
                      reason: M instanceof Error ? M : new Error(M),
                    }))
                  : E.capability.resolve(),
                this._stats &&
                  (this._stats.timeEnd('Rendering'),
                  this._stats.timeEnd('Overall'),
                  globalThis.Stats?.enabled &&
                    globalThis.Stats.add(this.pageNumber, this._stats));
            },
            E = new $r({
              callback: y,
              params: {
                canvasContext: e,
                viewport: t,
                transform: s,
                background: o,
              },
              objs: this.objs,
              commonObjs: this.commonObjs,
              annotationCanvasMap: l,
              operatorList: g.operatorList,
              pageIndex: this._pageIndex,
              canvasFactory: this._transport.canvasFactory,
              filterFactory: this._transport.filterFactory,
              useRequestAnimationFrame: !w,
              pdfBug: this._pdfBug,
              pageColors: c,
            });
          (g.renderTasks ||= new Set()).add(E);
          const A = E.task;
          return (
            Promise.all([g.displayReadyCapability.promise, a])
              .then(([M, T]) => {
                if (this.destroyed) y();
                else {
                  if (
                    (this._stats?.time('Rendering'), !(T.renderingIntent & p))
                  )
                    throw new Error(
                      'Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.'
                    );
                  E.initializeGraphics({
                    transparency: M,
                    optionalContentConfig: T,
                  }),
                    E.operatorListChanged();
                }
              })
              .catch(y),
            A
          );
        }
        getOperatorList({
          intent: e = 'display',
          annotationMode: t = to.ENABLE,
          printAnnotationStorage: i = null,
          isEditing: r = !1,
        } = {}) {
          const o = this._transport.getRenderingIntent(e, t, i, r, !0);
          let l,
            a = this._intentStates.get(o.cacheKey);
          return (
            a ||
              ((a = Object.create(null)),
              this._intentStates.set(o.cacheKey, a)),
            a.opListReadCapability ||
              ((l = Object.create(null)),
              (l.operatorListChanged = function s() {
                a.operatorList.lastChunk &&
                  (a.opListReadCapability.resolve(a.operatorList),
                  a.renderTasks.delete(l));
              }),
              (a.opListReadCapability = Promise.withResolvers()),
              (a.renderTasks ||= new Set()).add(l),
              (a.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null,
              }),
              this._stats?.time('Page Request'),
              this._pumpOperatorList(o)),
            a.opListReadCapability.promise
          );
        }
        streamTextContent({
          includeMarkedContent: e = !1,
          disableNormalization: t = !1,
        } = {}) {
          return this._transport.messageHandler.sendWithStream(
            'GetTextContent',
            {
              pageIndex: this._pageIndex,
              includeMarkedContent: !0 === e,
              disableNormalization: !0 === t,
            },
            { highWaterMark: 100, size: (r) => r.items.length }
          );
        }
        getTextContent(e = {}) {
          if (this._transport._htmlForXfa)
            return this.getXfa().then((i) => oh.textContent(i));
          const t = this.streamTextContent(e);
          return new Promise(function (i, r) {
            const o = t.getReader(),
              a = { items: [], styles: Object.create(null), lang: null };
            !(function s() {
              o.read().then(function ({ value: l, done: c }) {
                c
                  ? i(a)
                  : ((a.lang ??= l.lang),
                    Object.assign(a.styles, l.styles),
                    a.items.push(...l.items),
                    s());
              }, r);
            })();
          });
        }
        getStructTree() {
          return this._transport.getStructTree(this._pageIndex);
        }
        _destroy() {
          this.destroyed = !0;
          const e = [];
          for (const t of this._intentStates.values())
            if (
              (this._abortOperatorList({
                intentState: t,
                reason: new Error('Page was destroyed.'),
                force: !0,
              }),
              !t.opListReadCapability)
            )
              for (const i of t.renderTasks) e.push(i.completed), i.cancel();
          return (
            this.objs.clear(),
            _(this, wa, !1),
            b(this, zg, zC).call(this),
            Promise.all(e)
          );
        }
        cleanup(e = !1) {
          _(this, wa, !0);
          const t = b(this, uc, ah).call(this, !1);
          return e && t && (this._stats &&= new u2()), t;
        }
        _startRenderPage(e, t) {
          const i = this._intentStates.get(t);
          i &&
            (this._stats?.timeEnd('Page Request'),
            i.displayReadyCapability?.resolve(e));
        }
        _renderPageChunk(e, t) {
          for (let i = 0, r = e.length; i < r; i++)
            t.operatorList.fnArray.push(e.fnArray[i]),
              t.operatorList.argsArray.push(e.argsArray[i]);
          (t.operatorList.lastChunk = e.lastChunk),
            (t.operatorList.separateAnnots = e.separateAnnots);
          for (const i of t.renderTasks) i.operatorListChanged();
          e.lastChunk && b(this, uc, ah).call(this, !0);
        }
        _pumpOperatorList({
          renderingIntent: e,
          cacheKey: t,
          annotationStorageSerializable: i,
          modifiedIds: r,
        }) {
          const { map: s, transfer: o } = i,
            l = this._transport.messageHandler
              .sendWithStream(
                'GetOperatorList',
                {
                  pageIndex: this._pageIndex,
                  intent: e,
                  cacheKey: t,
                  annotationStorage: s,
                  modifiedIds: r,
                },
                o
              )
              .getReader(),
            c = this._intentStates.get(t);
          c.streamReader = l;
          const u = () => {
            l.read().then(
              ({ value: h, done: f }) => {
                f
                  ? (c.streamReader = null)
                  : this._transport.destroyed ||
                    (this._renderPageChunk(h, c), u());
              },
              (h) => {
                if (((c.streamReader = null), !this._transport.destroyed)) {
                  if (c.operatorList) {
                    c.operatorList.lastChunk = !0;
                    for (const f of c.renderTasks) f.operatorListChanged();
                    b(this, uc, ah).call(this, !0);
                  }
                  if (c.displayReadyCapability)
                    c.displayReadyCapability.reject(h);
                  else {
                    if (!c.opListReadCapability) throw h;
                    c.opListReadCapability.reject(h);
                  }
                }
              }
            );
          };
          u();
        }
        _abortOperatorList({ intentState: e, reason: t, force: i = !1 }) {
          if (e.streamReader) {
            if (
              (e.streamReaderCancelTimeout &&
                (clearTimeout(e.streamReaderCancelTimeout),
                (e.streamReaderCancelTimeout = null)),
              !i)
            ) {
              if (e.renderTasks.size > 0) return;
              if (t instanceof GE) {
                let r = 100;
                return (
                  t.extraDelay > 0 && t.extraDelay < 1e3 && (r += t.extraDelay),
                  void (e.streamReaderCancelTimeout = setTimeout(() => {
                    (e.streamReaderCancelTimeout = null),
                      this._abortOperatorList({
                        intentState: e,
                        reason: t,
                        force: !0,
                      });
                  }, r))
                );
              }
            }
            if (
              (e.streamReader.cancel(new ga(t.message)).catch(() => {}),
              (e.streamReader = null),
              !this._transport.destroyed)
            ) {
              for (const [r, s] of this._intentStates)
                if (s === e) {
                  this._intentStates.delete(r);
                  break;
                }
              this.cleanup();
            }
          }
        }
        get stats() {
          return this._stats;
        }
      }
      function ah(n = !1) {
        if ((b(this, zg, zC).call(this), !d(this, wa) || this.destroyed))
          return !1;
        if (n)
          return (
            _(
              this,
              dc,
              setTimeout(() => {
                _(this, dc, null), b(this, uc, ah).call(this, !1);
              }, 5e3)
            ),
            !1
          );
        for (const {
          renderTasks: e,
          operatorList: t,
        } of this._intentStates.values())
          if (e.size > 0 || !t.lastChunk) return !1;
        return (
          this._intentStates.clear(), this.objs.clear(), _(this, wa, !1), !0
        );
      }
      function zC() {
        d(this, dc) && (clearTimeout(d(this, dc)), _(this, dc, null));
      }
      var lh = new WeakMap(),
        wV = new WeakMap();
      class hre {
        constructor() {
          v(this, lh, { writable: !0, value: new Set() }),
            v(this, wV, { writable: !0, value: Promise.resolve() });
        }
        postMessage(e, t) {
          const i = { data: structuredClone(e, t ? { transfer: t } : null) };
          d(this, wV).then(() => {
            for (const r of d(this, lh)) r.call(this, i);
          });
        }
        addEventListener(e, t) {
          d(this, lh).add(t);
        }
        removeEventListener(e, t) {
          d(this, lh).delete(t);
        }
        terminate() {
          d(this, lh).clear();
        }
      }
      const ws = { isWorkerDisabled: !1, fakeWorkerId: 0 };
      kn && ((ws.isWorkerDisabled = !0), (Ur.workerSrc ||= './pdf.worker.mjs')),
        (ws.isSameOrigin = function (n, e) {
          let t;
          try {
            if (((t = new URL(n)), !t.origin || 'null' === t.origin)) return !1;
          } catch {
            return !1;
          }
          const i = new URL(e, t);
          return t.origin === i.origin;
        }),
        (ws.createCDNWrapper = function (n) {
          return URL.createObjectURL(
            new Blob([`await import("${n}");`], { type: 'text/javascript' })
          );
        });
      var Ug = new WeakSet();
      class zt {
        constructor({
          name: e = null,
          port: t = null,
          verbosity: i = bne(),
        } = {}) {
          if (
            (S(this, Ug),
            (this.name = e),
            (this.destroyed = !1),
            (this.verbosity = i),
            (this._readyCapability = Promise.withResolvers()),
            (this._port = null),
            (this._webWorker = null),
            (this._messageHandler = null),
            t)
          ) {
            if (de(zt, zt, ch)?.has(t))
              throw new Error('Cannot use more than one PDFWorker per port.');
            return (
              (de(zt, zt, ch) || pa(zt, zt, ch, new WeakMap())).set(t, this),
              void this._initializeFromPort(t)
            );
          }
          this._initialize();
        }
        get promise() {
          return kn
            ? Promise.all([zr.promise, this._readyCapability.promise])
            : this._readyCapability.promise;
        }
        get port() {
          return this._port;
        }
        get messageHandler() {
          return this._messageHandler;
        }
        _initializeFromPort(e) {
          (this._port = e),
            (this._messageHandler = new th('main', 'worker', e)),
            this._messageHandler.on('ready', function () {}),
            b(this, Ug, UC).call(this);
        }
        _initialize() {
          if (ws.isWorkerDisabled || de(zt, zt, $C))
            return void this._setupFakeWorker();
          let { workerSrc: e } = zt;
          try {
            ws.isSameOrigin(window.location.href, e) ||
              (e = ws.createCDNWrapper(new URL(e, window.location).href));
            const t = new Worker(e, { type: 'module' }),
              i = new th('main', 'worker', t),
              r = () => {
                s.abort(),
                  i.destroy(),
                  t.terminate(),
                  this.destroyed
                    ? this._readyCapability.reject(
                        new Error('Worker was destroyed')
                      )
                    : this._setupFakeWorker();
              },
              s = new AbortController();
            t.addEventListener(
              'error',
              () => {
                this._webWorker || r();
              },
              { signal: s.signal }
            ),
              i.on('test', (a) => {
                s.abort(),
                  !this.destroyed && a
                    ? ((this._messageHandler = i),
                      (this._port = t),
                      (this._webWorker = t),
                      b(this, Ug, UC).call(this))
                    : r();
              }),
              i.on('ready', (a) => {
                if ((s.abort(), this.destroyed)) r();
                else
                  try {
                    o();
                  } catch {
                    this._setupFakeWorker();
                  }
              });
            const o = () => {
              const a = new Uint8Array();
              i.send('test', a, [a.buffer]);
            };
            return void o();
          } catch {
            sg('The worker has been disabled.');
          }
          this._setupFakeWorker();
        }
        _setupFakeWorker() {
          ws.isWorkerDisabled ||
            (Ve('Setting up fake worker.'), (ws.isWorkerDisabled = !0)),
            zt._setupFakeWorkerGlobal
              .then((e) => {
                if (this.destroyed)
                  return void this._readyCapability.reject(
                    new Error('Worker was destroyed')
                  );
                const t = new hre();
                this._port = t;
                const i = 'fake' + ws.fakeWorkerId++,
                  r = new th(i + '_worker', i, t);
                e.setup(r, t),
                  (this._messageHandler = new th(i, i + '_worker', t)),
                  b(this, Ug, UC).call(this);
              })
              .catch((e) => {
                this._readyCapability.reject(
                  new Error(`Setting up fake worker failed: "${e.message}".`)
                );
              });
        }
        destroy() {
          (this.destroyed = !0),
            this._webWorker &&
              (this._webWorker.terminate(), (this._webWorker = null)),
            de(zt, zt, ch)?.delete(this._port),
            (this._port = null),
            this._messageHandler &&
              (this._messageHandler.destroy(), (this._messageHandler = null));
        }
        static fromPort(e) {
          if (!e?.port)
            throw new Error('PDFWorker.fromPort - invalid method signature.');
          const t = de(this, zt, ch)?.get(e.port);
          if (t) {
            if (t._pendingDestroy)
              throw new Error(
                'PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.'
              );
            return t;
          }
          return new zt(e);
        }
        static get workerSrc() {
          if (Ur.workerSrc) return Ur.workerSrc;
          throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
        }
        static get _setupFakeWorkerGlobal() {
          var e = this;
          return Ye(
            this,
            '_setupFakeWorkerGlobal',
            (function () {
              var i = U(function* () {
                return de(e, zt, $C)
                  ? de(e, zt, $C)
                  : (yield import(e.workerSrc)).WorkerMessageHandler;
              });
              return function () {
                return i.apply(this, arguments);
              };
            })()()
          );
        }
      }
      function UC() {
        this._readyCapability.resolve(),
          this._messageHandler.send('configure', { verbosity: this.verbosity });
      }
      var $C = {
          get: function fre() {
            try {
              return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
            } catch {
              return null;
            }
          },
          set: void 0,
        },
        ch = { writable: !0, value: void 0 },
        Ea = new WeakMap(),
        lo = new WeakMap(),
        $g = new WeakMap(),
        Gg = new WeakMap(),
        co = new WeakMap(),
        dh = new WeakSet();
      class pre {
        constructor(e, t, i, r, s) {
          S(this, dh),
            v(this, Ea, { writable: !0, value: new Map() }),
            v(this, lo, { writable: !0, value: new Map() }),
            v(this, $g, { writable: !0, value: new Map() }),
            v(this, Gg, { writable: !0, value: new Map() }),
            v(this, co, { writable: !0, value: null }),
            (this.messageHandler = e),
            (this.loadingTask = t),
            (this.commonObjs = new EV()),
            (this.fontLoader = new oie({
              ownerDocument: r.ownerDocument,
              styleElement: r.styleElement,
            })),
            (this.loadingParams = r.loadingParams),
            (this._params = r),
            (this.canvasFactory = s.canvasFactory),
            (this.filterFactory = s.filterFactory),
            (this.cMapReaderFactory = s.cMapReaderFactory),
            (this.standardFontDataFactory = s.standardFontDataFactory),
            (this.destroyed = !1),
            (this.destroyCapability = null),
            (this._networkStream = i),
            (this._fullReader = null),
            (this._lastProgress = null),
            (this.downloadInfoCapability = Promise.withResolvers()),
            this.setupMessageHandler();
        }
        get annotationStorage() {
          return Ye(this, 'annotationStorage', new pC());
        }
        getRenderingIntent(e, t = to.ENABLE, i = null, r = !1, s = !1) {
          let o = 2,
            a = fC;
          switch (e) {
            case 'any':
              o = 1;
              break;
            case 'display':
              break;
            case 'print':
              o = 4;
              break;
            default:
              Ve(`getRenderingIntent - invalid intent: ${e}`);
          }
          const l = 4 & o && i instanceof W2 ? i : this.annotationStorage;
          switch (t) {
            case to.DISABLE:
              o += 64;
              break;
            case to.ENABLE:
              break;
            case to.ENABLE_FORMS:
              o += 16;
              break;
            case to.ENABLE_STORAGE:
              (o += 32), (a = l.serializable);
              break;
            default:
              Ve(`getRenderingIntent - invalid annotationMode: ${t}`);
          }
          r && (o += 128), s && (o += 256);
          const { ids: c, hash: u } = l.modifiedIds;
          return {
            renderingIntent: o,
            cacheKey: [o, a.hash, u].join('_'),
            annotationStorageSerializable: a,
            modifiedIds: c,
          };
        }
        destroy() {
          if (this.destroyCapability) return this.destroyCapability.promise;
          (this.destroyed = !0),
            (this.destroyCapability = Promise.withResolvers()),
            d(this, co)?.reject(
              new Error('Worker was destroyed during onPassword callback')
            );
          const e = [];
          for (const i of d(this, lo).values()) e.push(i._destroy());
          d(this, lo).clear(),
            d(this, $g).clear(),
            d(this, Gg).clear(),
            this.hasOwnProperty('annotationStorage') &&
              this.annotationStorage.resetModified();
          const t = this.messageHandler.sendWithPromise('Terminate', null);
          return (
            e.push(t),
            Promise.all(e).then(() => {
              this.commonObjs.clear(),
                this.fontLoader.clear(),
                d(this, Ea).clear(),
                this.filterFactory.destroy(),
                We.cleanup(),
                this._networkStream?.cancelAllRequests(
                  new ga('Worker was terminated.')
                ),
                this.messageHandler &&
                  (this.messageHandler.destroy(), (this.messageHandler = null)),
                this.destroyCapability.resolve();
            }, this.destroyCapability.reject),
            this.destroyCapability.promise
          );
        }
        setupMessageHandler() {
          const { messageHandler: e, loadingTask: t } = this;
          e.on('GetReader', (i, r) => {
            cn(
              this._networkStream,
              'GetReader - no `IPDFStream` instance available.'
            ),
              (this._fullReader = this._networkStream.getFullReader()),
              (this._fullReader.onProgress = (s) => {
                this._lastProgress = { loaded: s.loaded, total: s.total };
              }),
              (r.onPull = () => {
                this._fullReader
                  .read()
                  .then(function ({ value: s, done: o }) {
                    o
                      ? r.close()
                      : (cn(
                          s instanceof ArrayBuffer,
                          'GetReader - expected an ArrayBuffer.'
                        ),
                        r.enqueue(new Uint8Array(s), 1, [s]));
                  })
                  .catch((s) => {
                    r.error(s);
                  });
              }),
              (r.onCancel = (s) => {
                this._fullReader.cancel(s),
                  r.ready.catch((o) => {
                    if (!this.destroyed) throw o;
                  });
              });
          }),
            e.on('ReaderHeadersReady', (i) => {
              const r = Promise.withResolvers(),
                s = this._fullReader;
              return (
                s.headersReady.then(() => {
                  (!s.isStreamingSupported || !s.isRangeSupported) &&
                    (this._lastProgress && t.onProgress?.(this._lastProgress),
                    (s.onProgress = (o) => {
                      t.onProgress?.({ loaded: o.loaded, total: o.total });
                    })),
                    r.resolve({
                      isStreamingSupported: s.isStreamingSupported,
                      isRangeSupported: s.isRangeSupported,
                      contentLength: s.contentLength,
                    });
                }, r.reject),
                r.promise
              );
            }),
            e.on('GetRangeReader', (i, r) => {
              cn(
                this._networkStream,
                'GetRangeReader - no `IPDFStream` instance available.'
              );
              const s = this._networkStream.getRangeReader(i.begin, i.end);
              s
                ? ((r.onPull = () => {
                    s.read()
                      .then(function ({ value: o, done: a }) {
                        a
                          ? r.close()
                          : (cn(
                              o instanceof ArrayBuffer,
                              'GetRangeReader - expected an ArrayBuffer.'
                            ),
                            r.enqueue(new Uint8Array(o), 1, [o]));
                      })
                      .catch((o) => {
                        r.error(o);
                      });
                  }),
                  (r.onCancel = (o) => {
                    s.cancel(o),
                      r.ready.catch((a) => {
                        if (!this.destroyed) throw a;
                      });
                  }))
                : r.close();
            }),
            e.on('GetDoc', ({ pdfInfo: i }) => {
              (this._numPages = i.numPages),
                (this._htmlForXfa = i.htmlForXfa),
                delete i.htmlForXfa,
                t._capability.resolve(new dre(i, this));
            }),
            e.on('DocException', function (i) {
              let r;
              switch (i.name) {
                case 'PasswordException':
                  r = new PE(i.message, i.code);
                  break;
                case 'InvalidPDFException':
                  r = new e2(i.message);
                  break;
                case 'MissingPDFException':
                  r = new ma(i.message);
                  break;
                case 'UnexpectedResponseException':
                  r = new og(i.message, i.status);
                  break;
                case 'UnknownErrorException':
                  r = new RE(i.message, i.details);
                  break;
                default:
                  bt('DocException - expected a valid Error.');
              }
              t._capability.reject(r);
            }),
            e.on('PasswordRequest', (i) => {
              if ((_(this, co, Promise.withResolvers()), t.onPassword)) {
                const r = (s) => {
                  s instanceof Error
                    ? d(this, co).reject(s)
                    : d(this, co).resolve({ password: s });
                };
                try {
                  t.onPassword(r, i.code);
                } catch (s) {
                  d(this, co).reject(s);
                }
              } else d(this, co).reject(new PE(i.message, i.code));
              return d(this, co).promise;
            }),
            e.on('DataLoaded', (i) => {
              t.onProgress?.({ loaded: i.length, total: i.length }),
                this.downloadInfoCapability.resolve(i);
            }),
            e.on('StartRenderPage', (i) => {
              this.destroyed ||
                d(this, lo)
                  .get(i.pageIndex)
                  ._startRenderPage(i.transparency, i.cacheKey);
            }),
            e.on('commonobj', ([i, r, s]) => {
              if (this.destroyed || this.commonObjs.has(i)) return null;
              switch (r) {
                case 'Font':
                  const {
                    disableFontFace: o,
                    fontExtraProperties: a,
                    pdfBug: l,
                  } = this._params;
                  if ('error' in s) {
                    const f = s.error;
                    Ve(`Error during font loading: ${f}`),
                      this.commonObjs.resolve(i, f);
                    break;
                  }
                  const c =
                      l && globalThis.FontInspector?.enabled
                        ? (f, p) => globalThis.FontInspector.fontAdded(f, p)
                        : null,
                    u = new aie(s, { disableFontFace: o, inspectFont: c });
                  this.fontLoader
                    .bind(u)
                    .catch(() => e.sendWithPromise('FontFallback', { id: i }))
                    .finally(() => {
                      !a && u.data && (u.data = null),
                        this.commonObjs.resolve(i, u);
                    });
                  break;
                case 'CopyLocalImage':
                  const { imageRef: h } = s;
                  cn(h, 'The imageRef must be defined.');
                  for (const f of d(this, lo).values())
                    for (const [, p] of f.objs)
                      if (p?.ref === h)
                        return p.dataLen
                          ? (this.commonObjs.resolve(i, structuredClone(p)),
                            p.dataLen)
                          : null;
                  break;
                case 'FontPath':
                case 'Image':
                case 'Pattern':
                  this.commonObjs.resolve(i, s);
                  break;
                default:
                  throw new Error(`Got unknown common object type ${r}`);
              }
              return null;
            }),
            e.on('obj', ([i, r, s, o]) => {
              if (this.destroyed) return;
              const a = d(this, lo).get(r);
              if (!a.objs.has(i)) {
                if (0 === a._intentStates.size) return void o?.bitmap?.close();
                switch (s) {
                  case 'Image':
                    a.objs.resolve(i, o),
                      o?.dataLen > 1e7 && (a._maybeCleanupAfterRender = !0);
                    break;
                  case 'Pattern':
                    a.objs.resolve(i, o);
                    break;
                  default:
                    throw new Error(`Got unknown object type ${s}`);
                }
              }
            }),
            e.on('DocProgress', (i) => {
              this.destroyed ||
                t.onProgress?.({ loaded: i.loaded, total: i.total });
            }),
            e.on('FetchBuiltInCMap', (i) =>
              this.destroyed
                ? Promise.reject(new Error('Worker was destroyed.'))
                : this.cMapReaderFactory
                ? this.cMapReaderFactory.fetch(i)
                : Promise.reject(
                    new Error(
                      'CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.'
                    )
                  )
            ),
            e.on('FetchStandardFontData', (i) =>
              this.destroyed
                ? Promise.reject(new Error('Worker was destroyed.'))
                : this.standardFontDataFactory
                ? this.standardFontDataFactory.fetch(i)
                : Promise.reject(
                    new Error(
                      'StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.'
                    )
                  )
            );
        }
        getData() {
          return this.messageHandler.sendWithPromise('GetData', null);
        }
        saveDocument() {
          this.annotationStorage.size <= 0 &&
            Ve(
              'saveDocument called while `annotationStorage` is empty, please use the getData-method instead.'
            );
          const { map: e, transfer: t } = this.annotationStorage.serializable;
          return this.messageHandler
            .sendWithPromise(
              'SaveDocument',
              {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: e,
                filename: this._fullReader?.filename ?? null,
              },
              t
            )
            .finally(() => {
              this.annotationStorage.resetModified();
            });
        }
        getPage(e) {
          if (!Number.isInteger(e) || e <= 0 || e > this._numPages)
            return Promise.reject(new Error('Invalid page request.'));
          const t = e - 1,
            i = d(this, $g).get(t);
          if (i) return i;
          const r = this.messageHandler
            .sendWithPromise('GetPage', { pageIndex: t })
            .then((s) => {
              if (this.destroyed) throw new Error('Transport destroyed');
              s.refStr && d(this, Gg).set(s.refStr, e);
              const o = new ure(t, s, this, this._params.pdfBug);
              return d(this, lo).set(t, o), o;
            });
          return d(this, $g).set(t, r), r;
        }
        getPageIndex(e) {
          return bV(e)
            ? this.messageHandler.sendWithPromise('GetPageIndex', {
                num: e.num,
                gen: e.gen,
              })
            : Promise.reject(new Error('Invalid pageIndex request.'));
        }
        getAnnotations(e, t) {
          return this.messageHandler.sendWithPromise('GetAnnotations', {
            pageIndex: e,
            intent: t,
          });
        }
        getFieldObjects() {
          return b(this, dh, qg).call(this, 'GetFieldObjects');
        }
        hasJSActions() {
          return b(this, dh, qg).call(this, 'HasJSActions');
        }
        getCalculationOrderIds() {
          return this.messageHandler.sendWithPromise(
            'GetCalculationOrderIds',
            null
          );
        }
        getDestinations() {
          return this.messageHandler.sendWithPromise('GetDestinations', null);
        }
        getDestination(e) {
          return 'string' != typeof e
            ? Promise.reject(new Error('Invalid destination request.'))
            : this.messageHandler.sendWithPromise('GetDestination', { id: e });
        }
        getPageLabels() {
          return this.messageHandler.sendWithPromise('GetPageLabels', null);
        }
        getPageLayout() {
          return this.messageHandler.sendWithPromise('GetPageLayout', null);
        }
        getPageMode() {
          return this.messageHandler.sendWithPromise('GetPageMode', null);
        }
        getViewerPreferences() {
          return this.messageHandler.sendWithPromise(
            'GetViewerPreferences',
            null
          );
        }
        getOpenAction() {
          return this.messageHandler.sendWithPromise('GetOpenAction', null);
        }
        getAttachments() {
          return this.messageHandler.sendWithPromise('GetAttachments', null);
        }
        getDocJSActions() {
          return b(this, dh, qg).call(this, 'GetDocJSActions');
        }
        getPageJSActions(e) {
          return this.messageHandler.sendWithPromise('GetPageJSActions', {
            pageIndex: e,
          });
        }
        getStructTree(e) {
          return this.messageHandler.sendWithPromise('GetStructTree', {
            pageIndex: e,
          });
        }
        getOutline() {
          return this.messageHandler.sendWithPromise('GetOutline', null);
        }
        getOptionalContentConfig(e) {
          return b(this, dh, qg)
            .call(this, 'GetOptionalContentConfig')
            .then((t) => new Iie(t, e));
        }
        getPermissions() {
          return this.messageHandler.sendWithPromise('GetPermissions', null);
        }
        getMetadata() {
          const e = 'GetMetadata',
            t = d(this, Ea).get(e);
          if (t) return t;
          const i = this.messageHandler
            .sendWithPromise(e, null)
            .then((r) => ({
              info: r[0],
              metadata: r[1] ? new Die(r[1]) : null,
              contentDispositionFilename: this._fullReader?.filename ?? null,
              contentLength: this._fullReader?.contentLength ?? null,
            }));
          return d(this, Ea).set(e, i), i;
        }
        getMarkInfo() {
          return this.messageHandler.sendWithPromise('GetMarkInfo', null);
        }
        startCleanup(e = !1) {
          var t = this;
          return U(function* () {
            if (!t.destroyed) {
              yield t.messageHandler.sendWithPromise('Cleanup', null);
              for (const i of d(t, lo).values())
                if (!i.cleanup())
                  throw new Error(
                    `startCleanup: Page ${i.pageNumber} is currently rendering.`
                  );
              t.commonObjs.clear(),
                e || t.fontLoader.clear(),
                d(t, Ea).clear(),
                t.filterFactory.destroy(!0),
                We.cleanup();
            }
          })();
        }
        cachedPageNumber(e) {
          if (!bV(e)) return null;
          const t = 0 === e.gen ? `${e.num}R` : `${e.num}R${e.gen}`;
          return d(this, Gg).get(t) ?? null;
        }
      }
      function qg(n, e = null) {
        const t = d(this, Ea).get(n);
        if (t) return t;
        const i = this.messageHandler.sendWithPromise(n, e);
        return d(this, Ea).set(n, i), i;
      }
      const Xg = Symbol('INITIAL_DATA');
      var Es = new WeakMap(),
        GC = new WeakSet();
      QN = Symbol.iterator;
      class EV {
        constructor() {
          S(this, GC),
            v(this, Es, { writable: !0, value: Object.create(null) });
        }
        get(e, t = null) {
          if (t) {
            const r = b(this, GC, CV).call(this, e);
            return r.promise.then(() => t(r.data)), null;
          }
          const i = d(this, Es)[e];
          if (!i || i.data === Xg)
            throw new Error(`Requesting object that isn't resolved yet ${e}.`);
          return i.data;
        }
        has(e) {
          const t = d(this, Es)[e];
          return !!t && t.data !== Xg;
        }
        resolve(e, t = null) {
          const i = b(this, GC, CV).call(this, e);
          (i.data = t), i.resolve();
        }
        clear() {
          for (const e in d(this, Es)) {
            const { data: t } = d(this, Es)[e];
            t?.bitmap?.close();
          }
          _(this, Es, Object.create(null));
        }
        *[QN]() {
          for (const e in d(this, Es)) {
            const { data: t } = d(this, Es)[e];
            t !== Xg && (yield [e, t]);
          }
        }
      }
      function CV(n) {
        return (d(this, Es)[n] ||= { ...Promise.withResolvers(), data: Xg });
      }
      var hc = new WeakMap();
      class mre {
        constructor(e) {
          v(this, hc, { writable: !0, value: null }),
            _(this, hc, e),
            (this.onContinue = null);
        }
        get promise() {
          return d(this, hc).capability.promise;
        }
        cancel(e = 0) {
          d(this, hc).cancel(null, e);
        }
        get separateAnnots() {
          const { separateAnnots: e } = d(this, hc).operatorList;
          if (!e) return !1;
          const { annotationCanvasMap: t } = d(this, hc);
          return e.form || (e.canvas && t?.size > 0);
        }
      }
      var fc = new WeakMap();
      class $r {
        constructor({
          callback: e,
          params: t,
          objs: i,
          commonObjs: r,
          annotationCanvasMap: s,
          operatorList: o,
          pageIndex: a,
          canvasFactory: l,
          filterFactory: c,
          useRequestAnimationFrame: u = !1,
          pdfBug: h = !1,
          pageColors: f = null,
        }) {
          v(this, fc, { writable: !0, value: null }),
            (this.callback = e),
            (this.params = t),
            (this.objs = i),
            (this.commonObjs = r),
            (this.annotationCanvasMap = s),
            (this.operatorListIdx = null),
            (this.operatorList = o),
            (this._pageIndex = a),
            (this.canvasFactory = l),
            (this.filterFactory = c),
            (this._pdfBug = h),
            (this.pageColors = f),
            (this.running = !1),
            (this.graphicsReadyCallback = null),
            (this.graphicsReady = !1),
            (this._useRequestAnimationFrame = !0 === u && typeof window < 'u'),
            (this.cancelled = !1),
            (this.capability = Promise.withResolvers()),
            (this.task = new mre(this)),
            (this._cancelBound = this.cancel.bind(this)),
            (this._continueBound = this._continue.bind(this)),
            (this._scheduleNextBound = this._scheduleNext.bind(this)),
            (this._nextBound = this._next.bind(this)),
            (this._canvas = t.canvasContext.canvas);
        }
        get completed() {
          return this.capability.promise.catch(function () {});
        }
        initializeGraphics({ transparency: e = !1, optionalContentConfig: t }) {
          if (this.cancelled) return;
          if (this._canvas) {
            if (de($r, $r, Yg).has(this._canvas))
              throw new Error(
                'Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.'
              );
            de($r, $r, Yg).add(this._canvas);
          }
          this._pdfBug &&
            globalThis.StepperManager?.enabled &&
            ((this.stepper = globalThis.StepperManager.create(this._pageIndex)),
            this.stepper.init(this.operatorList),
            (this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint()));
          const {
            canvasContext: i,
            viewport: r,
            transform: s,
            background: o,
          } = this.params;
          (this.gfx = new rc(
            i,
            this.commonObjs,
            this.objs,
            this.canvasFactory,
            this.filterFactory,
            { optionalContentConfig: t },
            this.annotationCanvasMap,
            this.pageColors
          )),
            this.gfx.beginDrawing({
              transform: s,
              viewport: r,
              transparency: e,
              background: o,
            }),
            (this.operatorListIdx = 0),
            (this.graphicsReady = !0),
            this.graphicsReadyCallback?.();
        }
        cancel(e = null, t = 0) {
          (this.running = !1),
            (this.cancelled = !0),
            this.gfx?.endDrawing(),
            d(this, fc) &&
              (window.cancelAnimationFrame(d(this, fc)), _(this, fc, null)),
            de($r, $r, Yg).delete(this._canvas),
            this.callback(
              e || new GE(`Rendering cancelled, page ${this._pageIndex + 1}`, t)
            );
        }
        operatorListChanged() {
          this.graphicsReady
            ? (this.stepper?.updateOperatorList(this.operatorList),
              !this.running && this._continue())
            : (this.graphicsReadyCallback ||= this._continueBound);
        }
        _continue() {
          (this.running = !0),
            !this.cancelled &&
              (this.task.onContinue
                ? this.task.onContinue(this._scheduleNextBound)
                : this._scheduleNext());
        }
        _scheduleNext() {
          this._useRequestAnimationFrame
            ? _(
                this,
                fc,
                window.requestAnimationFrame(() => {
                  _(this, fc, null), this._nextBound().catch(this._cancelBound);
                })
              )
            : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
        }
        _next() {
          var e = this;
          return U(function* () {
            e.cancelled ||
              ((e.operatorListIdx = e.gfx.executeOperatorList(
                e.operatorList,
                e.operatorListIdx,
                e._continueBound,
                e.stepper
              )),
              e.operatorListIdx === e.operatorList.argsArray.length &&
                ((e.running = !1),
                e.operatorList.lastChunk &&
                  (e.gfx.endDrawing(),
                  de($r, $r, Yg).delete(e._canvas),
                  e.callback())));
          })();
        }
      }
      var Yg = { writable: !0, value: new WeakSet() };
      const gre = '4.5.136',
        _re = '3a21f03b0';
      function xV(n) {
        return Math.floor(255 * Math.max(0, Math.min(1, n)))
          .toString(16)
          .padStart(2, '0');
      }
      function uh(n) {
        return Math.max(0, Math.min(255, 255 * n));
      }
      class AV {
        static CMYK_G([e, t, i, r]) {
          return ['G', 1 - Math.min(1, 0.3 * e + 0.59 * i + 0.11 * t + r)];
        }
        static G_CMYK([e]) {
          return ['CMYK', 0, 0, 0, 1 - e];
        }
        static G_RGB([e]) {
          return ['RGB', e, e, e];
        }
        static G_rgb([e]) {
          return [(e = uh(e)), e, e];
        }
        static G_HTML([e]) {
          const t = xV(e);
          return `#${t}${t}${t}`;
        }
        static RGB_G([e, t, i]) {
          return ['G', 0.3 * e + 0.59 * t + 0.11 * i];
        }
        static RGB_rgb(e) {
          return e.map(uh);
        }
        static RGB_HTML(e) {
          return `#${e.map(xV).join('')}`;
        }
        static T_HTML() {
          return '#00000000';
        }
        static T_rgb() {
          return [null];
        }
        static CMYK_RGB([e, t, i, r]) {
          return [
            'RGB',
            1 - Math.min(1, e + r),
            1 - Math.min(1, i + r),
            1 - Math.min(1, t + r),
          ];
        }
        static CMYK_rgb([e, t, i, r]) {
          return [
            uh(1 - Math.min(1, e + r)),
            uh(1 - Math.min(1, i + r)),
            uh(1 - Math.min(1, t + r)),
          ];
        }
        static CMYK_HTML(e) {
          const t = this.CMYK_RGB(e).slice(1);
          return this.RGB_HTML(t);
        }
        static RGB_CMYK([e, t, i]) {
          const r = 1 - e,
            s = 1 - t,
            o = 1 - i;
          return ['CMYK', r, s, o, Math.min(r, s, o)];
        }
      }
      class SV {
        static setupStorage(e, t, i, r, s) {
          const o = r.getValue(t, { value: null });
          switch (i.name) {
            case 'textarea':
              if (
                (null !== o.value && (e.textContent = o.value), 'print' === s)
              )
                break;
              e.addEventListener('input', (a) => {
                r.setValue(t, { value: a.target.value });
              });
              break;
            case 'input':
              if (
                'radio' === i.attributes.type ||
                'checkbox' === i.attributes.type
              ) {
                if (
                  (o.value === i.attributes.xfaOn
                    ? e.setAttribute('checked', !0)
                    : o.value === i.attributes.xfaOff &&
                      e.removeAttribute('checked'),
                  'print' === s)
                )
                  break;
                e.addEventListener('change', (a) => {
                  r.setValue(t, {
                    value: a.target.getAttribute(
                      a.target.checked ? 'xfaOn' : 'xfaOff'
                    ),
                  });
                });
              } else {
                if (
                  (null !== o.value && e.setAttribute('value', o.value),
                  'print' === s)
                )
                  break;
                e.addEventListener('input', (a) => {
                  r.setValue(t, { value: a.target.value });
                });
              }
              break;
            case 'select':
              if (null !== o.value) {
                e.setAttribute('value', o.value);
                for (const a of i.children)
                  a.attributes.value === o.value
                    ? (a.attributes.selected = !0)
                    : a.attributes.hasOwnProperty('selected') &&
                      delete a.attributes.selected;
              }
              e.addEventListener('input', (a) => {
                const l = a.target.options;
                r.setValue(t, {
                  value: -1 === l.selectedIndex ? '' : l[l.selectedIndex].value,
                });
              });
          }
        }
        static setAttributes({
          html: e,
          element: t,
          storage: i = null,
          intent: r,
          linkService: s,
        }) {
          const { attributes: o } = t,
            a = e instanceof HTMLAnchorElement;
          'radio' === o.type && (o.name = `${o.name}-${r}`);
          for (const [l, c] of Object.entries(o))
            if (null != c)
              switch (l) {
                case 'class':
                  c.length && e.setAttribute(l, c.join(' '));
                  break;
                case 'dataId':
                  break;
                case 'id':
                  e.setAttribute('data-element-id', c);
                  break;
                case 'style':
                  Object.assign(e.style, c);
                  break;
                case 'textContent':
                  e.textContent = c;
                  break;
                default:
                  (!a || ('href' !== l && 'newWindow' !== l)) &&
                    e.setAttribute(l, c);
              }
          a && s.addLinkAttributes(e, o.href, o.newWindow),
            i && o.dataId && this.setupStorage(e, o.dataId, t, i);
        }
        static render(e) {
          const t = e.annotationStorage,
            i = e.linkService,
            r = e.xfaHtml,
            s = e.intent || 'display',
            o = document.createElement(r.name);
          r.attributes &&
            this.setAttributes({
              html: o,
              element: r,
              intent: s,
              linkService: i,
            });
          const a = 'richText' !== s,
            l = e.div;
          if ((l.append(o), e.viewport)) {
            const h = `matrix(${e.viewport.transform.join(',')})`;
            l.style.transform = h;
          }
          a && l.setAttribute('class', 'xfaLayer xfaFont');
          const c = [];
          if (0 === r.children.length) {
            if (r.value) {
              const h = document.createTextNode(r.value);
              o.append(h), a && oh.shouldBuildText(r.name) && c.push(h);
            }
            return { textDivs: c };
          }
          const u = [[r, -1, o]];
          for (; u.length > 0; ) {
            const [h, f, p] = u.at(-1);
            if (f + 1 === h.children.length) {
              u.pop();
              continue;
            }
            const m = h.children[++u.at(-1)[1]];
            if (null === m) continue;
            const { name: g } = m;
            if ('#text' === g) {
              const y = document.createTextNode(m.value);
              c.push(y), p.append(y);
              continue;
            }
            const w = m?.attributes?.xmlns
              ? document.createElementNS(m.attributes.xmlns, g)
              : document.createElement(g);
            if (
              (p.append(w),
              m.attributes &&
                this.setAttributes({
                  html: w,
                  element: m,
                  storage: t,
                  intent: s,
                  linkService: i,
                }),
              m.children?.length > 0)
            )
              u.push([m, -1, w]);
            else if (m.value) {
              const y = document.createTextNode(m.value);
              a && oh.shouldBuildText(g) && c.push(y), w.append(y);
            }
          }
          for (const h of l.querySelectorAll(
            '.xfaNonInteractive input, .xfaNonInteractive textarea'
          ))
            h.setAttribute('readOnly', !0);
          return { textDivs: c };
        }
        static update(e) {
          const t = `matrix(${e.viewport.transform.join(',')})`;
          (e.div.style.transform = t), (e.div.hidden = !1);
        }
      }
      const hh = 1e3,
        Ca = new WeakSet();
      function Cs(n) {
        return { width: n[2] - n[0], height: n[3] - n[1] };
      }
      class vre {
        static create(e) {
          switch (e.data.annotationType) {
            case 2:
              return new IV(e);
            case 1:
              return new Ere(e);
            case 20:
              switch (e.data.fieldType) {
                case 'Tx':
                  return new Cre(e);
                case 'Btn':
                  return e.data.radioButton
                    ? new kV(e)
                    : e.data.checkBox
                    ? new Are(e)
                    : new Sre(e);
                case 'Ch':
                  return new Mre(e);
                case 'Sig':
                  return new xre(e);
              }
              return new Aa(e);
            case 16:
              return new XC(e);
            case 3:
              return new BV(e);
            case 4:
              return new Ore(e);
            case 5:
              return new Lre(e);
            case 6:
              return new Nre(e);
            case 8:
              return new HV(e);
            case 14:
              return new Bre(e);
            case 15:
              return new WV(e);
            case 7:
              return new Vre(e);
            case 9:
              return new Hre(e);
            case 10:
              return new Wre(e);
            case 11:
              return new jre(e);
            case 12:
              return new zre(e);
            case 13:
              return new jV(e);
            case 17:
              return new Ure(e);
            default:
              return new Ut(e);
          }
        }
      }
      var pc = new WeakMap(),
        Kg = new WeakMap(),
        Zg = new WeakMap(),
        qC = new WeakSet();
      class Ut {
        constructor(
          e,
          {
            isRenderable: t = !1,
            ignoreBorder: i = !1,
            createQuadrilaterals: r = !1,
          } = {}
        ) {
          S(this, qC),
            v(this, pc, { writable: !0, value: null }),
            v(this, Kg, { writable: !0, value: !1 }),
            v(this, Zg, { writable: !0, value: null }),
            (this.isRenderable = t),
            (this.data = e.data),
            (this.layer = e.layer),
            (this.linkService = e.linkService),
            (this.downloadManager = e.downloadManager),
            (this.imageResourcesPath = e.imageResourcesPath),
            (this.renderForms = e.renderForms),
            (this.svgFactory = e.svgFactory),
            (this.annotationStorage = e.annotationStorage),
            (this.enableScripting = e.enableScripting),
            (this.hasJSActions = e.hasJSActions),
            (this._fieldObjects = e.fieldObjects),
            (this.parent = e.parent),
            t && (this.container = this._createContainer(i)),
            r && this._createQuadrilaterals();
        }
        static _hasPopupData({ titleObj: e, contentsObj: t, richText: i }) {
          return !!(e?.str || t?.str || i?.str);
        }
        get _isEditable() {
          return this.data.isEditable;
        }
        get hasPopupData() {
          return Ut._hasPopupData(this.data);
        }
        updateEdited(e) {
          if (!this.container) return;
          d(this, pc) || _(this, pc, { rect: this.data.rect.slice(0) });
          const { rect: t } = e;
          t && b(this, qC, MV).call(this, t),
            d(this, Zg)?.popup.updateEdited(e);
        }
        resetEdited() {
          d(this, pc) &&
            (b(this, qC, MV).call(this, d(this, pc).rect),
            d(this, Zg)?.popup.resetEdited(),
            _(this, pc, null));
        }
        _createContainer(e) {
          const {
              data: t,
              parent: { page: i, viewport: r },
            } = this,
            s = document.createElement('section');
          s.setAttribute('data-annotation-id', t.id),
            this instanceof Aa || (s.tabIndex = hh);
          const { style: o } = s;
          if (
            ((o.zIndex = this.parent.zIndex++),
            t.popupRef && s.setAttribute('aria-haspopup', 'dialog'),
            t.alternativeText && (s.title = t.alternativeText),
            t.noRotate && s.classList.add('norotate'),
            !t.rect || this instanceof XC)
          ) {
            const { rotation: g } = t;
            return !t.hasOwnCanvas && 0 !== g && this.setRotation(g, s), s;
          }
          const { width: a, height: l } = Cs(t.rect);
          if (!e && t.borderStyle.width > 0) {
            o.borderWidth = `${t.borderStyle.width}px`;
            const g = t.borderStyle.horizontalCornerRadius,
              w = t.borderStyle.verticalCornerRadius;
            switch (
              (g > 0 || w > 0
                ? (o.borderRadius = `calc(${g}px * var(--scale-factor)) / calc(${w}px * var(--scale-factor))`)
                : this instanceof kV &&
                  (o.borderRadius = `calc(${a}px * var(--scale-factor)) / calc(${l}px * var(--scale-factor))`),
              t.borderStyle.style)
            ) {
              case 1:
                o.borderStyle = 'solid';
                break;
              case 2:
                o.borderStyle = 'dashed';
                break;
              case 3:
                Ve('Unimplemented border style: beveled');
                break;
              case 4:
                Ve('Unimplemented border style: inset');
                break;
              case 5:
                o.borderBottomStyle = 'solid';
            }
            const y = t.borderColor || null;
            y
              ? (_(this, Kg, !0),
                (o.borderColor = te.makeHexColor(0 | y[0], 0 | y[1], 0 | y[2])))
              : (o.borderWidth = 0);
          }
          const c = te.normalizeRect([
              t.rect[0],
              i.view[3] - t.rect[1] + i.view[1],
              t.rect[2],
              i.view[3] - t.rect[3] + i.view[1],
            ]),
            { pageWidth: u, pageHeight: h, pageX: f, pageY: p } = r.rawDims;
          (o.left = (100 * (c[0] - f)) / u + '%'),
            (o.top = (100 * (c[1] - p)) / h + '%');
          const { rotation: m } = t;
          return (
            t.hasOwnCanvas || 0 === m
              ? ((o.width = (100 * a) / u + '%'),
                (o.height = (100 * l) / h + '%'))
              : this.setRotation(m, s),
            s
          );
        }
        setRotation(e, t = this.container) {
          if (!this.data.rect) return;
          const { pageWidth: i, pageHeight: r } = this.parent.viewport.rawDims,
            { width: s, height: o } = Cs(this.data.rect);
          let a, l;
          e % 180 == 0
            ? ((a = (100 * s) / i), (l = (100 * o) / r))
            : ((a = (100 * o) / i), (l = (100 * s) / r)),
            (t.style.width = `${a}%`),
            (t.style.height = `${l}%`),
            t.setAttribute('data-main-rotation', (360 - e) % 360);
        }
        get _commonActions() {
          const e = (t, i, r) => {
            const s = r.detail[t],
              o = s[0],
              a = s.slice(1);
            (r.target.style[i] = AV[`${o}_HTML`](a)),
              this.annotationStorage.setValue(this.data.id, {
                [i]: AV[`${o}_rgb`](a),
              });
          };
          return Ye(this, '_commonActions', {
            display: (t) => {
              const { display: i } = t.detail,
                r = i % 2 == 1;
              (this.container.style.visibility = r ? 'hidden' : 'visible'),
                this.annotationStorage.setValue(this.data.id, {
                  noView: r,
                  noPrint: 1 === i || 2 === i,
                });
            },
            print: (t) => {
              this.annotationStorage.setValue(this.data.id, {
                noPrint: !t.detail.print,
              });
            },
            hidden: (t) => {
              const { hidden: i } = t.detail;
              (this.container.style.visibility = i ? 'hidden' : 'visible'),
                this.annotationStorage.setValue(this.data.id, {
                  noPrint: i,
                  noView: i,
                });
            },
            focus: (t) => {
              setTimeout(() => t.target.focus({ preventScroll: !1 }), 0);
            },
            userName: (t) => {
              t.target.title = t.detail.userName;
            },
            readonly: (t) => {
              t.target.disabled = t.detail.readonly;
            },
            required: (t) => {
              this._setRequired(t.target, t.detail.required);
            },
            bgColor: (t) => {
              e('bgColor', 'backgroundColor', t);
            },
            fillColor: (t) => {
              e('fillColor', 'backgroundColor', t);
            },
            fgColor: (t) => {
              e('fgColor', 'color', t);
            },
            textColor: (t) => {
              e('textColor', 'color', t);
            },
            borderColor: (t) => {
              e('borderColor', 'borderColor', t);
            },
            strokeColor: (t) => {
              e('strokeColor', 'borderColor', t);
            },
            rotation: (t) => {
              const i = t.detail.rotation;
              this.setRotation(i),
                this.annotationStorage.setValue(this.data.id, { rotation: i });
            },
          });
        }
        _dispatchEventFromSandbox(e, t) {
          const i = this._commonActions;
          for (const r of Object.keys(t.detail)) (e[r] || i[r])?.(t);
        }
        _setDefaultPropertiesFromJS(e) {
          if (!this.enableScripting) return;
          const t = this.annotationStorage.getRawValue(this.data.id);
          if (!t) return;
          const i = this._commonActions;
          for (const [r, s] of Object.entries(t)) {
            const o = i[r];
            o && (o({ detail: { [r]: s }, target: e }), delete t[r]);
          }
        }
        _createQuadrilaterals() {
          if (!this.container) return;
          const { quadPoints: e } = this.data;
          if (!e) return;
          const [t, i, r, s] = this.data.rect.map((g) => Math.fround(g));
          if (8 === e.length) {
            const [g, w, y, E] = e.subarray(2, 6);
            if (r === g && s === w && t === y && i === E) return;
          }
          const { style: o } = this.container;
          let a;
          if (d(this, Kg)) {
            const { borderColor: g, borderWidth: w } = o;
            (o.borderWidth = 0),
              (a = [
                "url('data:image/svg+xml;utf8,",
                '<svg xmlns="http://www.w3.org/2000/svg"',
                ' preserveAspectRatio="none" viewBox="0 0 1 1">',
                `<g fill="transparent" stroke="${g}" stroke-width="${w}">`,
              ]),
              this.container.classList.add('hasBorder');
          }
          const l = r - t,
            c = s - i,
            { svgFactory: u } = this,
            h = u.createElement('svg');
          h.classList.add('quadrilateralsContainer'),
            h.setAttribute('width', 0),
            h.setAttribute('height', 0);
          const f = u.createElement('defs');
          h.append(f);
          const p = u.createElement('clipPath'),
            m = `clippath_${this.data.id}`;
          p.setAttribute('id', m),
            p.setAttribute('clipPathUnits', 'objectBoundingBox'),
            f.append(p);
          for (let g = 2, w = e.length; g < w; g += 8) {
            const y = e[g],
              E = e[g + 1],
              A = e[g + 2],
              M = e[g + 3],
              T = u.createElement('rect'),
              k = (A - t) / l,
              P = (s - E) / c,
              O = (y - A) / l,
              I = (E - M) / c;
            T.setAttribute('x', k),
              T.setAttribute('y', P),
              T.setAttribute('width', O),
              T.setAttribute('height', I),
              p.append(T),
              a?.push(
                `<rect vector-effect="non-scaling-stroke" x="${k}" y="${P}" width="${O}" height="${I}"/>`
              );
          }
          d(this, Kg) &&
            (a.push("</g></svg>')"), (o.backgroundImage = a.join(''))),
            this.container.append(h),
            (this.container.style.clipPath = `url(#${m})`);
        }
        _createPopup() {
          const { container: e, data: t } = this;
          e.setAttribute('aria-haspopup', 'dialog');
          const i = _(
            this,
            Zg,
            new XC({
              data: {
                color: t.color,
                titleObj: t.titleObj,
                modificationDate: t.modificationDate,
                contentsObj: t.contentsObj,
                richText: t.richText,
                parentRect: t.rect,
                borderStyle: 0,
                id: `popup_${t.id}`,
                rotation: t.rotation,
              },
              parent: this.parent,
              elements: [this],
            })
          );
          this.parent.div.append(i.render());
        }
        render() {
          bt('Abstract method `AnnotationElement.render` called');
        }
        _getElementsByName(e, t = null) {
          const i = [];
          if (this._fieldObjects) {
            const r = this._fieldObjects[e];
            if (r)
              for (const { page: s, id: o, exportValues: a } of r) {
                if (-1 === s || o === t) continue;
                const l = 'string' == typeof a ? a : null,
                  c = document.querySelector(`[data-element-id="${o}"]`);
                !c || Ca.has(c)
                  ? i.push({ id: o, exportValue: l, domElement: c })
                  : Ve(`_getElementsByName - element not allowed: ${o}`);
              }
            return i;
          }
          for (const r of document.getElementsByName(e)) {
            const { exportValue: s } = r,
              o = r.getAttribute('data-element-id');
            o !== t &&
              Ca.has(r) &&
              i.push({ id: o, exportValue: s, domElement: r });
          }
          return i;
        }
        show() {
          this.container && (this.container.hidden = !1),
            this.popup?.maybeShow();
        }
        hide() {
          this.container && (this.container.hidden = !0),
            this.popup?.forceHide();
        }
        getElementsToTriggerPopup() {
          return this.container;
        }
        addHighlightArea() {
          const e = this.getElementsToTriggerPopup();
          if (Array.isArray(e))
            for (const t of e) t.classList.add('highlightArea');
          else e.classList.add('highlightArea');
        }
        _editOnDoubleClick() {
          if (!this._isEditable) return;
          const {
            annotationEditorType: e,
            data: { id: t },
          } = this;
          this.container.addEventListener('dblclick', () => {
            this.linkService.eventBus?.dispatch('switchannotationeditormode', {
              source: this,
              mode: e,
              editId: t,
            });
          });
        }
      }
      function MV(n) {
        const {
          container: { style: e },
          data: { rect: t, rotation: i },
          parent: {
            viewport: {
              rawDims: { pageWidth: r, pageHeight: s, pageX: o, pageY: a },
            },
          },
        } = this;
        t?.splice(0, 4, ...n);
        const { width: l, height: c } = Cs(n);
        (e.left = (100 * (n[0] - o)) / r + '%'),
          (e.top = (100 * (s - n[3] + a)) / s + '%'),
          0 === i
            ? ((e.width = (100 * l) / r + '%'),
              (e.height = (100 * c) / s + '%'))
            : this.setRotation(i);
      }
      var xa = new WeakSet(),
        DV = new WeakSet(),
        TV = new WeakSet();
      class IV extends Ut {
        constructor(e, t = null) {
          super(e, {
            isRenderable: !0,
            ignoreBorder: !!t?.ignoreBorder,
            createQuadrilaterals: !0,
          }),
            S(this, TV),
            S(this, DV),
            S(this, xa),
            (this.isTooltipOnly = e.data.isTooltipOnly);
        }
        render() {
          const { data: e, linkService: t } = this,
            i = document.createElement('a');
          i.setAttribute('data-element-id', e.id);
          let r = !1;
          return (
            e.url
              ? (t.addLinkAttributes(i, e.url, e.newWindow), (r = !0))
              : e.action
              ? (this._bindNamedAction(i, e.action), (r = !0))
              : e.attachment
              ? (b(this, DV, yre).call(this, i, e.attachment, e.attachmentDest),
                (r = !0))
              : e.setOCGState
              ? (b(this, TV, wre).call(this, i, e.setOCGState), (r = !0))
              : e.dest
              ? (this._bindLink(i, e.dest), (r = !0))
              : (e.actions &&
                  (e.actions.Action ||
                    e.actions['Mouse Up'] ||
                    e.actions['Mouse Down']) &&
                  this.enableScripting &&
                  this.hasJSActions &&
                  (this._bindJSAction(i, e), (r = !0)),
                e.resetForm
                  ? (this._bindResetFormAction(i, e.resetForm), (r = !0))
                  : this.isTooltipOnly &&
                    !r &&
                    (this._bindLink(i, ''), (r = !0))),
            this.container.classList.add('linkAnnotation'),
            r && this.container.append(i),
            this.container
          );
        }
        _bindLink(e, t) {
          (e.href = this.linkService.getDestinationHash(t)),
            (e.onclick = () => (t && this.linkService.goToDestination(t), !1)),
            (t || '' === t) && b(this, xa, mc).call(this);
        }
        _bindNamedAction(e, t) {
          (e.href = this.linkService.getAnchorUrl('')),
            (e.onclick = () => (this.linkService.executeNamedAction(t), !1)),
            b(this, xa, mc).call(this);
        }
        _bindJSAction(e, t) {
          e.href = this.linkService.getAnchorUrl('');
          const i = new Map([
            ['Action', 'onclick'],
            ['Mouse Up', 'onmouseup'],
            ['Mouse Down', 'onmousedown'],
          ]);
          for (const r of Object.keys(t.actions)) {
            const s = i.get(r);
            s &&
              (e[s] = () => (
                this.linkService.eventBus?.dispatch('dispatcheventinsandbox', {
                  source: this,
                  detail: { id: t.id, name: r },
                }),
                !1
              ));
          }
          e.onclick || (e.onclick = () => !1), b(this, xa, mc).call(this);
        }
        _bindResetFormAction(e, t) {
          const i = e.onclick;
          if (
            (i || (e.href = this.linkService.getAnchorUrl('')),
            b(this, xa, mc).call(this),
            !this._fieldObjects)
          )
            return (
              Ve(
                '_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'
              ),
              void (i || (e.onclick = () => !1))
            );
          e.onclick = () => {
            i?.();
            const { fields: r, refs: s, include: o } = t,
              a = [];
            if (0 !== r.length || 0 !== s.length) {
              const u = new Set(s);
              for (const h of r) {
                const f = this._fieldObjects[h] || [];
                for (const { id: p } of f) u.add(p);
              }
              for (const h of Object.values(this._fieldObjects))
                for (const f of h) u.has(f.id) === o && a.push(f);
            } else
              for (const u of Object.values(this._fieldObjects)) a.push(...u);
            const l = this.annotationStorage,
              c = [];
            for (const u of a) {
              const { id: h } = u;
              switch ((c.push(h), u.type)) {
                case 'text':
                case 'combobox':
                case 'listbox':
                  l.setValue(h, { value: u.defaultValue || '' });
                  break;
                case 'checkbox':
                case 'radiobutton':
                  l.setValue(h, { value: u.defaultValue === u.exportValues });
                  break;
                default:
                  continue;
              }
              const f = document.querySelector(`[data-element-id="${h}"]`);
              f &&
                (Ca.has(f)
                  ? f.dispatchEvent(new Event('resetform'))
                  : Ve(`_bindResetFormAction - element not allowed: ${h}`));
            }
            return (
              this.enableScripting &&
                this.linkService.eventBus?.dispatch('dispatcheventinsandbox', {
                  source: this,
                  detail: { id: 'app', ids: c, name: 'ResetForm' },
                }),
              !1
            );
          };
        }
      }
      function mc() {
        this.container.setAttribute('data-internal-link', '');
      }
      function yre(n, e, t = null) {
        (n.href = this.linkService.getAnchorUrl('')),
          e.description && (n.title = e.description),
          (n.onclick = () => (
            this.downloadManager?.openOrDownloadData(e.content, e.filename, t),
            !1
          )),
          b(this, xa, mc).call(this);
      }
      function wre(n, e) {
        (n.href = this.linkService.getAnchorUrl('')),
          (n.onclick = () => (this.linkService.executeSetOCGState(e), !1)),
          b(this, xa, mc).call(this);
      }
      class Ere extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0 });
        }
        render() {
          this.container.classList.add('textAnnotation');
          const e = document.createElement('img');
          return (
            (e.src =
              this.imageResourcesPath +
              'annotation-' +
              this.data.name.toLowerCase() +
              '.svg'),
            e.setAttribute('data-l10n-id', 'pdfjs-text-annotation-type'),
            e.setAttribute(
              'data-l10n-args',
              JSON.stringify({ type: this.data.name })
            ),
            !this.data.popupRef && this.hasPopupData && this._createPopup(),
            this.container.append(e),
            this.container
          );
        }
      }
      class Aa extends Ut {
        render() {
          return this.container;
        }
        showElementAndHideCanvas(e) {
          this.data.hasOwnCanvas &&
            ('CANVAS' === e.previousSibling?.nodeName &&
              (e.previousSibling.hidden = !0),
            (e.hidden = !1));
        }
        _getKeyModifier(e) {
          return ui.platform.isMac ? e.metaKey : e.ctrlKey;
        }
        _setEventListener(e, t, i, r, s) {
          i.includes('mouse')
            ? e.addEventListener(i, (o) => {
                this.linkService.eventBus?.dispatch('dispatcheventinsandbox', {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: r,
                    value: s(o),
                    shift: o.shiftKey,
                    modifier: this._getKeyModifier(o),
                  },
                });
              })
            : e.addEventListener(i, (o) => {
                if ('blur' === i) {
                  if (!t.focused || !o.relatedTarget) return;
                  t.focused = !1;
                } else if ('focus' === i) {
                  if (t.focused) return;
                  t.focused = !0;
                }
                s &&
                  this.linkService.eventBus?.dispatch(
                    'dispatcheventinsandbox',
                    {
                      source: this,
                      detail: { id: this.data.id, name: r, value: s(o) },
                    }
                  );
              });
        }
        _setEventListeners(e, t, i, r) {
          for (const [s, o] of i)
            ('Action' === o || this.data.actions?.[o]) &&
              (('Focus' === o || 'Blur' === o) && (t ||= { focused: !1 }),
              this._setEventListener(e, t, s, o, r),
              'Focus' !== o || this.data.actions?.Blur
                ? 'Blur' === o &&
                  !this.data.actions?.Focus &&
                  this._setEventListener(e, t, 'focus', 'Focus', null)
                : this._setEventListener(e, t, 'blur', 'Blur', null));
        }
        _setBackgroundColor(e) {
          const t = this.data.backgroundColor || null;
          e.style.backgroundColor =
            null === t ? 'transparent' : te.makeHexColor(t[0], t[1], t[2]);
        }
        _setTextStyle(e) {
          const { fontColor: i } = this.data.defaultAppearanceData,
            r = this.data.defaultAppearanceData.fontSize || 9,
            s = e.style;
          let o;
          const l = (c) => Math.round(10 * c) / 10;
          if (this.data.multiLine) {
            const c = Math.abs(this.data.rect[3] - this.data.rect[1] - 2),
              u = Math.round(c / (1.35 * r)) || 1;
            o = Math.min(r, l(c / u / 1.35));
          } else {
            const c = Math.abs(this.data.rect[3] - this.data.rect[1] - 2);
            o = Math.min(r, l(c / 1.35));
          }
          (s.fontSize = `calc(${o}px * var(--scale-factor))`),
            (s.color = te.makeHexColor(i[0], i[1], i[2])),
            null !== this.data.textAlignment &&
              (s.textAlign = ['left', 'center', 'right'][
                this.data.textAlignment
              ]);
        }
        _setRequired(e, t) {
          t ? e.setAttribute('required', !0) : e.removeAttribute('required'),
            e.setAttribute('aria-required', t);
        }
      }
      class Cre extends Aa {
        constructor(e) {
          super(e, {
            isRenderable:
              e.renderForms ||
              e.data.hasOwnCanvas ||
              (!e.data.hasAppearance && !!e.data.fieldValue),
          });
        }
        setPropertyOnSiblings(e, t, i, r) {
          const s = this.annotationStorage;
          for (const o of this._getElementsByName(e.name, e.id))
            o.domElement && (o.domElement[t] = i), s.setValue(o.id, { [r]: i });
        }
        render() {
          const e = this.annotationStorage,
            t = this.data.id;
          this.container.classList.add('textWidgetAnnotation');
          let i = null;
          if (this.renderForms) {
            const r = e.getValue(t, { value: this.data.fieldValue });
            let s = r.value || '';
            const o = e.getValue(t, { charLimit: this.data.maxLen }).charLimit;
            o && s.length > o && (s = s.slice(0, o));
            let a =
              r.formattedValue || this.data.textContent?.join('\n') || null;
            a && this.data.comb && (a = a.replaceAll(/\s+/g, ''));
            const l = {
              userValue: s,
              formattedValue: a,
              lastCommittedValue: null,
              commitKey: 1,
              focused: !1,
            };
            this.data.multiLine
              ? ((i = document.createElement('textarea')),
                (i.textContent = a ?? s),
                this.data.doNotScroll && (i.style.overflowY = 'hidden'))
              : ((i = document.createElement('input')),
                (i.type = 'text'),
                i.setAttribute('value', a ?? s),
                this.data.doNotScroll && (i.style.overflowX = 'hidden')),
              this.data.hasOwnCanvas && (i.hidden = !0),
              Ca.add(i),
              i.setAttribute('data-element-id', t),
              (i.disabled = this.data.readOnly),
              (i.name = this.data.fieldName),
              (i.tabIndex = hh),
              this._setRequired(i, this.data.required),
              o && (i.maxLength = o),
              i.addEventListener('input', (u) => {
                e.setValue(t, { value: u.target.value }),
                  this.setPropertyOnSiblings(
                    i,
                    'value',
                    u.target.value,
                    'value'
                  ),
                  (l.formattedValue = null);
              }),
              i.addEventListener('resetform', (u) => {
                (i.value = l.userValue = this.data.defaultFieldValue ?? ''),
                  (l.formattedValue = null);
              });
            let c = (u) => {
              const { formattedValue: h } = l;
              null != h && (u.target.value = h), (u.target.scrollLeft = 0);
            };
            if (this.enableScripting && this.hasJSActions) {
              i.addEventListener('focus', (h) => {
                if (l.focused) return;
                const { target: f } = h;
                l.userValue && (f.value = l.userValue),
                  (l.lastCommittedValue = f.value),
                  (l.commitKey = 1),
                  this.data.actions?.Focus || (l.focused = !0);
              }),
                i.addEventListener('updatefromsandbox', (h) => {
                  this.showElementAndHideCanvas(h.target),
                    this._dispatchEventFromSandbox(
                      {
                        value(p) {
                          (l.userValue = p.detail.value ?? ''),
                            e.setValue(t, { value: l.userValue.toString() }),
                            (p.target.value = l.userValue);
                        },
                        formattedValue(p) {
                          const { formattedValue: m } = p.detail;
                          (l.formattedValue = m),
                            null != m &&
                              p.target !== document.activeElement &&
                              (p.target.value = m),
                            e.setValue(t, { formattedValue: m });
                        },
                        selRange(p) {
                          p.target.setSelectionRange(...p.detail.selRange);
                        },
                        charLimit: (p) => {
                          const { charLimit: m } = p.detail,
                            { target: g } = p;
                          if (0 === m)
                            return void g.removeAttribute('maxLength');
                          g.setAttribute('maxLength', m);
                          let w = l.userValue;
                          !w ||
                            w.length <= m ||
                            ((w = w.slice(0, m)),
                            (g.value = l.userValue = w),
                            e.setValue(t, { value: w }),
                            this.linkService.eventBus?.dispatch(
                              'dispatcheventinsandbox',
                              {
                                source: this,
                                detail: {
                                  id: t,
                                  name: 'Keystroke',
                                  value: w,
                                  willCommit: !0,
                                  commitKey: 1,
                                  selStart: g.selectionStart,
                                  selEnd: g.selectionEnd,
                                },
                              }
                            ));
                        },
                      },
                      h
                    );
                }),
                i.addEventListener('keydown', (h) => {
                  l.commitKey = 1;
                  let f = -1;
                  if (
                    ('Escape' === h.key
                      ? (f = 0)
                      : 'Enter' !== h.key || this.data.multiLine
                      ? 'Tab' === h.key && (l.commitKey = 3)
                      : (f = 2),
                    -1 === f)
                  )
                    return;
                  const { value: p } = h.target;
                  l.lastCommittedValue !== p &&
                    ((l.lastCommittedValue = p),
                    (l.userValue = p),
                    this.linkService.eventBus?.dispatch(
                      'dispatcheventinsandbox',
                      {
                        source: this,
                        detail: {
                          id: t,
                          name: 'Keystroke',
                          value: p,
                          willCommit: !0,
                          commitKey: f,
                          selStart: h.target.selectionStart,
                          selEnd: h.target.selectionEnd,
                        },
                      }
                    ));
                });
              const u = c;
              (c = null),
                i.addEventListener('blur', (h) => {
                  if (!l.focused || !h.relatedTarget) return;
                  this.data.actions?.Blur || (l.focused = !1);
                  const { value: f } = h.target;
                  (l.userValue = f),
                    l.lastCommittedValue !== f &&
                      this.linkService.eventBus?.dispatch(
                        'dispatcheventinsandbox',
                        {
                          source: this,
                          detail: {
                            id: t,
                            name: 'Keystroke',
                            value: f,
                            willCommit: !0,
                            commitKey: l.commitKey,
                            selStart: h.target.selectionStart,
                            selEnd: h.target.selectionEnd,
                          },
                        }
                      ),
                    u(h);
                }),
                this.data.actions?.Keystroke &&
                  i.addEventListener('beforeinput', (h) => {
                    l.lastCommittedValue = null;
                    const { data: f, target: p } = h,
                      { value: m, selectionStart: g, selectionEnd: w } = p;
                    let y = g,
                      E = w;
                    switch (h.inputType) {
                      case 'deleteWordBackward': {
                        const A = m.substring(0, g).match(/\w*[^\w]*$/);
                        A && (y -= A[0].length);
                        break;
                      }
                      case 'deleteWordForward': {
                        const A = m.substring(g).match(/^[^\w]*\w*/);
                        A && (E += A[0].length);
                        break;
                      }
                      case 'deleteContentBackward':
                        g === w && (y -= 1);
                        break;
                      case 'deleteContentForward':
                        g === w && (E += 1);
                    }
                    h.preventDefault(),
                      this.linkService.eventBus?.dispatch(
                        'dispatcheventinsandbox',
                        {
                          source: this,
                          detail: {
                            id: t,
                            name: 'Keystroke',
                            value: m,
                            change: f || '',
                            willCommit: !1,
                            selStart: y,
                            selEnd: E,
                          },
                        }
                      );
                  }),
                this._setEventListeners(
                  i,
                  l,
                  [
                    ['focus', 'Focus'],
                    ['blur', 'Blur'],
                    ['mousedown', 'Mouse Down'],
                    ['mouseenter', 'Mouse Enter'],
                    ['mouseleave', 'Mouse Exit'],
                    ['mouseup', 'Mouse Up'],
                  ],
                  (h) => h.target.value
                );
            }
            if ((c && i.addEventListener('blur', c), this.data.comb)) {
              const h = (this.data.rect[2] - this.data.rect[0]) / o;
              i.classList.add('comb'),
                (i.style.letterSpacing = `calc(${h}px * var(--scale-factor) - 1ch)`);
            }
          } else
            (i = document.createElement('div')),
              (i.textContent = this.data.fieldValue),
              (i.style.verticalAlign = 'middle'),
              (i.style.display = 'table-cell'),
              this.data.hasOwnCanvas && (i.hidden = !0);
          return (
            this._setTextStyle(i),
            this._setBackgroundColor(i),
            this._setDefaultPropertiesFromJS(i),
            this.container.append(i),
            this.container
          );
        }
      }
      class xre extends Aa {
        constructor(e) {
          super(e, { isRenderable: !!e.data.hasOwnCanvas });
        }
      }
      class Are extends Aa {
        constructor(e) {
          super(e, { isRenderable: e.renderForms });
        }
        render() {
          const e = this.annotationStorage,
            t = this.data,
            i = t.id;
          let r = e.getValue(i, {
            value: t.exportValue === t.fieldValue,
          }).value;
          'string' == typeof r &&
            ((r = 'Off' !== r), e.setValue(i, { value: r })),
            this.container.classList.add('buttonWidgetAnnotation', 'checkBox');
          const s = document.createElement('input');
          return (
            Ca.add(s),
            s.setAttribute('data-element-id', i),
            (s.disabled = t.readOnly),
            this._setRequired(s, this.data.required),
            (s.type = 'checkbox'),
            (s.name = t.fieldName),
            r && s.setAttribute('checked', !0),
            s.setAttribute('exportValue', t.exportValue),
            (s.tabIndex = hh),
            s.addEventListener('change', (o) => {
              const { name: a, checked: l } = o.target;
              for (const c of this._getElementsByName(a, i)) {
                const u = l && c.exportValue === t.exportValue;
                c.domElement && (c.domElement.checked = u),
                  e.setValue(c.id, { value: u });
              }
              e.setValue(i, { value: l });
            }),
            s.addEventListener('resetform', (o) => {
              o.target.checked =
                (t.defaultFieldValue || 'Off') === t.exportValue;
            }),
            this.enableScripting &&
              this.hasJSActions &&
              (s.addEventListener('updatefromsandbox', (o) => {
                this._dispatchEventFromSandbox(
                  {
                    value(l) {
                      (l.target.checked = 'Off' !== l.detail.value),
                        e.setValue(i, { value: l.target.checked });
                    },
                  },
                  o
                );
              }),
              this._setEventListeners(
                s,
                null,
                [
                  ['change', 'Validate'],
                  ['change', 'Action'],
                  ['focus', 'Focus'],
                  ['blur', 'Blur'],
                  ['mousedown', 'Mouse Down'],
                  ['mouseenter', 'Mouse Enter'],
                  ['mouseleave', 'Mouse Exit'],
                  ['mouseup', 'Mouse Up'],
                ],
                (o) => o.target.checked
              )),
            this._setBackgroundColor(s),
            this._setDefaultPropertiesFromJS(s),
            this.container.append(s),
            this.container
          );
        }
      }
      class kV extends Aa {
        constructor(e) {
          super(e, { isRenderable: e.renderForms });
        }
        render() {
          this.container.classList.add('buttonWidgetAnnotation', 'radioButton');
          const e = this.annotationStorage,
            t = this.data,
            i = t.id;
          let r = e.getValue(i, {
            value: t.fieldValue === t.buttonValue,
          }).value;
          if (
            ('string' == typeof r &&
              ((r = r !== t.buttonValue), e.setValue(i, { value: r })),
            r)
          )
            for (const o of this._getElementsByName(t.fieldName, i))
              e.setValue(o.id, { value: !1 });
          const s = document.createElement('input');
          if (
            (Ca.add(s),
            s.setAttribute('data-element-id', i),
            (s.disabled = t.readOnly),
            this._setRequired(s, this.data.required),
            (s.type = 'radio'),
            (s.name = t.fieldName),
            r && s.setAttribute('checked', !0),
            (s.tabIndex = hh),
            s.addEventListener('change', (o) => {
              const { name: a, checked: l } = o.target;
              for (const c of this._getElementsByName(a, i))
                e.setValue(c.id, { value: !1 });
              e.setValue(i, { value: l });
            }),
            s.addEventListener('resetform', (o) => {
              const a = t.defaultFieldValue;
              o.target.checked = null != a && a === t.buttonValue;
            }),
            this.enableScripting && this.hasJSActions)
          ) {
            const o = t.buttonValue;
            s.addEventListener('updatefromsandbox', (a) => {
              this._dispatchEventFromSandbox(
                {
                  value: (c) => {
                    const u = o === c.detail.value;
                    for (const h of this._getElementsByName(c.target.name)) {
                      const f = u && h.id === i;
                      h.domElement && (h.domElement.checked = f),
                        e.setValue(h.id, { value: f });
                    }
                  },
                },
                a
              );
            }),
              this._setEventListeners(
                s,
                null,
                [
                  ['change', 'Validate'],
                  ['change', 'Action'],
                  ['focus', 'Focus'],
                  ['blur', 'Blur'],
                  ['mousedown', 'Mouse Down'],
                  ['mouseenter', 'Mouse Enter'],
                  ['mouseleave', 'Mouse Exit'],
                  ['mouseup', 'Mouse Up'],
                ],
                (a) => a.target.checked
              );
          }
          return (
            this._setBackgroundColor(s),
            this._setDefaultPropertiesFromJS(s),
            this.container.append(s),
            this.container
          );
        }
      }
      class Sre extends IV {
        constructor(e) {
          super(e, { ignoreBorder: e.data.hasAppearance });
        }
        render() {
          const e = super.render();
          e.classList.add('buttonWidgetAnnotation', 'pushButton');
          const t = e.lastChild;
          return (
            this.enableScripting &&
              this.hasJSActions &&
              t &&
              (this._setDefaultPropertiesFromJS(t),
              t.addEventListener('updatefromsandbox', (i) => {
                this._dispatchEventFromSandbox({}, i);
              })),
            e
          );
        }
      }
      class Mre extends Aa {
        constructor(e) {
          super(e, { isRenderable: e.renderForms });
        }
        render() {
          this.container.classList.add('choiceWidgetAnnotation');
          const e = this.annotationStorage,
            t = this.data.id,
            i = e.getValue(t, { value: this.data.fieldValue }),
            r = document.createElement('select');
          Ca.add(r),
            r.setAttribute('data-element-id', t),
            (r.disabled = this.data.readOnly),
            this._setRequired(r, this.data.required),
            (r.name = this.data.fieldName),
            (r.tabIndex = hh);
          let s = this.data.combo && this.data.options.length > 0;
          this.data.combo ||
            ((r.size = this.data.options.length),
            this.data.multiSelect && (r.multiple = !0)),
            r.addEventListener('resetform', (u) => {
              const h = this.data.defaultFieldValue;
              for (const f of r.options) f.selected = f.value === h;
            });
          for (const u of this.data.options) {
            const h = document.createElement('option');
            (h.textContent = u.displayValue),
              (h.value = u.exportValue),
              i.value.includes(u.exportValue) &&
                (h.setAttribute('selected', !0), (s = !1)),
              r.append(h);
          }
          let o = null;
          if (s) {
            const u = document.createElement('option');
            (u.value = ' '),
              u.setAttribute('hidden', !0),
              u.setAttribute('selected', !0),
              r.prepend(u),
              (o = () => {
                u.remove(), r.removeEventListener('input', o), (o = null);
              }),
              r.addEventListener('input', o);
          }
          const a = (u) => {
            const h = u ? 'value' : 'textContent',
              { options: f, multiple: p } = r;
            return p
              ? Array.prototype.filter
                  .call(f, (m) => m.selected)
                  .map((m) => m[h])
              : -1 === f.selectedIndex
              ? null
              : f[f.selectedIndex][h];
          };
          let l = a(!1);
          const c = (u) =>
            Array.prototype.map.call(u.target.options, (f) => ({
              displayValue: f.textContent,
              exportValue: f.value,
            }));
          return (
            this.enableScripting && this.hasJSActions
              ? (r.addEventListener('updatefromsandbox', (u) => {
                  this._dispatchEventFromSandbox(
                    {
                      value(f) {
                        o?.();
                        const p = f.detail.value,
                          m = new Set(Array.isArray(p) ? p : [p]);
                        for (const g of r.options) g.selected = m.has(g.value);
                        e.setValue(t, { value: a(!0) }), (l = a(!1));
                      },
                      multipleSelection(f) {
                        r.multiple = !0;
                      },
                      remove(f) {
                        const p = r.options,
                          m = f.detail.remove;
                        (p[m].selected = !1),
                          r.remove(m),
                          p.length > 0 &&
                            -1 ===
                              Array.prototype.findIndex.call(
                                p,
                                (w) => w.selected
                              ) &&
                            (p[0].selected = !0),
                          e.setValue(t, { value: a(!0), items: c(f) }),
                          (l = a(!1));
                      },
                      clear(f) {
                        for (; 0 !== r.length; ) r.remove(0);
                        e.setValue(t, { value: null, items: [] }), (l = a(!1));
                      },
                      insert(f) {
                        const {
                            index: p,
                            displayValue: m,
                            exportValue: g,
                          } = f.detail.insert,
                          w = r.children[p],
                          y = document.createElement('option');
                        (y.textContent = m),
                          (y.value = g),
                          w ? w.before(y) : r.append(y),
                          e.setValue(t, { value: a(!0), items: c(f) }),
                          (l = a(!1));
                      },
                      items(f) {
                        const { items: p } = f.detail;
                        for (; 0 !== r.length; ) r.remove(0);
                        for (const m of p) {
                          const { displayValue: g, exportValue: w } = m,
                            y = document.createElement('option');
                          (y.textContent = g), (y.value = w), r.append(y);
                        }
                        r.options.length > 0 && (r.options[0].selected = !0),
                          e.setValue(t, { value: a(!0), items: c(f) }),
                          (l = a(!1));
                      },
                      indices(f) {
                        const p = new Set(f.detail.indices);
                        for (const m of f.target.options)
                          m.selected = p.has(m.index);
                        e.setValue(t, { value: a(!0) }), (l = a(!1));
                      },
                      editable(f) {
                        f.target.disabled = !f.detail.editable;
                      },
                    },
                    u
                  );
                }),
                r.addEventListener('input', (u) => {
                  const h = a(!0),
                    f = a(!1);
                  e.setValue(t, { value: h }),
                    u.preventDefault(),
                    this.linkService.eventBus?.dispatch(
                      'dispatcheventinsandbox',
                      {
                        source: this,
                        detail: {
                          id: t,
                          name: 'Keystroke',
                          value: l,
                          change: f,
                          changeEx: h,
                          willCommit: !1,
                          commitKey: 1,
                          keyDown: !1,
                        },
                      }
                    );
                }),
                this._setEventListeners(
                  r,
                  null,
                  [
                    ['focus', 'Focus'],
                    ['blur', 'Blur'],
                    ['mousedown', 'Mouse Down'],
                    ['mouseenter', 'Mouse Enter'],
                    ['mouseleave', 'Mouse Exit'],
                    ['mouseup', 'Mouse Up'],
                    ['input', 'Action'],
                    ['input', 'Validate'],
                  ],
                  (u) => u.target.value
                ))
              : r.addEventListener('input', function (u) {
                  e.setValue(t, { value: a(!0) });
                }),
            this.data.combo && this._setTextStyle(r),
            this._setBackgroundColor(r),
            this._setDefaultPropertiesFromJS(r),
            this.container.append(r),
            this.container
          );
        }
      }
      class XC extends Ut {
        constructor(e) {
          const { data: t, elements: i } = e;
          super(e, { isRenderable: Ut._hasPopupData(t) }),
            (this.elements = i),
            (this.popup = null);
        }
        render() {
          this.container.classList.add('popupAnnotation');
          const e = (this.popup = new Dre({
              container: this.container,
              color: this.data.color,
              titleObj: this.data.titleObj,
              modificationDate: this.data.modificationDate,
              contentsObj: this.data.contentsObj,
              richText: this.data.richText,
              rect: this.data.rect,
              parentRect: this.data.parentRect || null,
              parent: this.parent,
              elements: this.elements,
              open: this.data.open,
            })),
            t = [];
          for (const i of this.elements)
            (i.popup = e), t.push(i.data.id), i.addHighlightArea();
          return (
            this.container.setAttribute(
              'aria-controls',
              t.map((i) => `${s2}${i}`).join(',')
            ),
            this.container
          );
        }
      }
      var Qg = new WeakMap(),
        PV = new WeakMap(),
        RV = new WeakMap(),
        Jg = new WeakMap(),
        fh = new WeakMap(),
        Jt = new WeakMap(),
        Sa = new WeakMap(),
        ph = new WeakMap(),
        YC = new WeakMap(),
        KC = new WeakMap(),
        e_ = new WeakMap(),
        Ma = new WeakMap(),
        xs = new WeakMap(),
        Da = new WeakMap(),
        ZC = new WeakMap(),
        Ta = new WeakMap(),
        QC = new WeakMap(),
        gc = new WeakMap(),
        mh = new WeakMap(),
        t_ = new WeakMap(),
        JC = new WeakMap(),
        FV = new WeakMap(),
        OV = new WeakSet(),
        LV = new WeakSet(),
        NV = new WeakSet(),
        n_ = new WeakSet(),
        i_ = new WeakSet(),
        ex = new WeakSet();
      class Dre {
        constructor({
          container: e,
          color: t,
          elements: i,
          titleObj: r,
          modificationDate: s,
          contentsObj: o,
          richText: a,
          parent: l,
          rect: c,
          parentRect: u,
          open: h,
        }) {
          S(this, ex),
            S(this, i_),
            S(this, n_),
            S(this, NV),
            S(this, LV),
            S(this, OV),
            v(this, FV, { get: kre, set: void 0 }),
            v(this, JC, { get: Ire, set: void 0 }),
            v(this, t_, { get: Tre, set: void 0 }),
            v(this, Qg, { writable: !0, value: b(this, LV, Rre).bind(this) }),
            v(this, PV, { writable: !0, value: b(this, ex, VV).bind(this) }),
            v(this, RV, { writable: !0, value: b(this, i_, nx).bind(this) }),
            v(this, Jg, { writable: !0, value: b(this, n_, tx).bind(this) }),
            v(this, fh, { writable: !0, value: null }),
            v(this, Jt, { writable: !0, value: null }),
            v(this, Sa, { writable: !0, value: null }),
            v(this, ph, { writable: !0, value: null }),
            v(this, YC, { writable: !0, value: null }),
            v(this, KC, { writable: !0, value: null }),
            v(this, e_, { writable: !0, value: null }),
            v(this, Ma, { writable: !0, value: !1 }),
            v(this, xs, { writable: !0, value: null }),
            v(this, Da, { writable: !0, value: null }),
            v(this, ZC, { writable: !0, value: null }),
            v(this, Ta, { writable: !0, value: null }),
            v(this, QC, { writable: !0, value: null }),
            v(this, gc, { writable: !0, value: null }),
            v(this, mh, { writable: !0, value: !1 }),
            _(this, Jt, e),
            _(this, QC, r),
            _(this, Sa, o),
            _(this, Ta, a),
            _(this, KC, l),
            _(this, fh, t),
            _(this, ZC, c),
            _(this, e_, u),
            _(this, YC, i),
            _(this, ph, f2.toDateObject(s)),
            (this.trigger = i.flatMap((f) => f.getElementsToTriggerPopup()));
          for (const f of this.trigger)
            f.addEventListener('click', d(this, Jg)),
              f.addEventListener('mouseenter', d(this, RV)),
              f.addEventListener('mouseleave', d(this, PV)),
              f.classList.add('popupTriggerArea');
          for (const f of i)
            f.container?.addEventListener('keydown', d(this, Qg));
          (d(this, Jt).hidden = !0), h && b(this, n_, tx).call(this);
        }
        render() {
          if (d(this, xs)) return;
          const e = _(this, xs, document.createElement('div'));
          if (((e.className = 'popup'), d(this, fh))) {
            const s = (e.style.outlineColor = te.makeHexColor(...d(this, fh)));
            e.style.backgroundColor = CSS.supports(
              'background-color',
              'color-mix(in srgb, red 30%, white)'
            )
              ? `color-mix(in srgb, ${s} 30%, white)`
              : te.makeHexColor(
                  ...d(this, fh).map((a) => Math.floor(0.7 * (255 - a) + a))
                );
          }
          const t = document.createElement('span');
          t.className = 'header';
          const i = document.createElement('h1');
          if (
            (t.append(i),
            ({ dir: i.dir, str: i.textContent } = d(this, QC)),
            e.append(t),
            d(this, ph))
          ) {
            const s = document.createElement('span');
            s.classList.add('popupDate'),
              s.setAttribute('data-l10n-id', 'pdfjs-annotation-date-string'),
              s.setAttribute(
                'data-l10n-args',
                JSON.stringify({
                  date: d(this, ph).toLocaleDateString(),
                  time: d(this, ph).toLocaleTimeString(),
                })
              ),
              t.append(s);
          }
          const r = d(this, t_);
          if (r)
            SV.render({ xfaHtml: r, intent: 'richText', div: e }),
              e.lastChild.classList.add('richText', 'popupContent');
          else {
            const s = this._formatContents(d(this, Sa));
            e.append(s);
          }
          d(this, Jt).append(e);
        }
        _formatContents({ str: e, dir: t }) {
          const i = document.createElement('p');
          i.classList.add('popupContent'), (i.dir = t);
          const r = e.split(/(?:\r\n?|\n)/);
          for (let s = 0, o = r.length; s < o; ++s)
            i.append(document.createTextNode(r[s])),
              s < o - 1 && i.append(document.createElement('br'));
          return i;
        }
        updateEdited({ rect: e, popupContent: t }) {
          d(this, gc) ||
            _(this, gc, { contentsObj: d(this, Sa), richText: d(this, Ta) }),
            e && _(this, Da, null),
            t &&
              (_(this, Ta, b(this, OV, Pre).call(this, t)), _(this, Sa, null)),
            d(this, xs)?.remove(),
            _(this, xs, null);
        }
        resetEdited() {
          d(this, gc) &&
            (({
              contentsObj: eg(this, Sa).value,
              richText: eg(this, Ta).value,
            } = d(this, gc)),
            _(this, gc, null),
            d(this, xs)?.remove(),
            _(this, xs, null),
            _(this, Da, null));
        }
        forceHide() {
          _(this, mh, this.isVisible), d(this, mh) && (d(this, Jt).hidden = !0);
        }
        maybeShow() {
          d(this, mh) &&
            (d(this, xs) || b(this, i_, nx).call(this),
            _(this, mh, !1),
            (d(this, Jt).hidden = !1));
        }
        get isVisible() {
          return !1 === d(this, Jt).hidden;
        }
      }
      function Tre() {
        const n = d(this, Ta),
          e = d(this, Sa);
        return (
          (n?.str && (!e?.str || e.str === n.str) && d(this, Ta).html) || null
        );
      }
      function Ire() {
        return d(this, t_)?.attributes?.style?.fontSize || 0;
      }
      function kre() {
        return d(this, t_)?.attributes?.style?.color || null;
      }
      function Pre(n) {
        const e = [],
          t = {
            str: n,
            html: {
              name: 'div',
              attributes: { dir: 'auto' },
              children: [{ name: 'p', children: e }],
            },
          },
          i = {
            style: {
              color: d(this, FV),
              fontSize: d(this, JC)
                ? `calc(${d(this, JC)}px * var(--scale-factor))`
                : '',
            },
          };
        for (const r of n.split('\n'))
          e.push({ name: 'span', value: r, attributes: i });
        return t;
      }
      function Rre(n) {
        n.altKey ||
          n.shiftKey ||
          n.ctrlKey ||
          n.metaKey ||
          (('Enter' === n.key || ('Escape' === n.key && d(this, Ma))) &&
            b(this, n_, tx).call(this));
      }
      function Fre() {
        if (null !== d(this, Da)) return;
        const {
          page: { view: n },
          viewport: {
            rawDims: { pageWidth: e, pageHeight: t, pageX: i, pageY: r },
          },
        } = d(this, KC);
        let s = !!d(this, e_),
          o = d(this, s ? e_ : ZC);
        for (const p of d(this, YC))
          if (!o || null !== te.intersect(p.data.rect, o)) {
            (o = p.data.rect), (s = !0);
            break;
          }
        const a = te.normalizeRect([
          o[0],
          n[3] - o[1] + n[1],
          o[2],
          n[3] - o[3] + n[1],
        ]);
        _(this, Da, [
          (100 * (a[0] + (s ? o[2] - o[0] + 5 : 0) - i)) / e,
          (100 * (a[1] - r)) / t,
        ]);
        const { style: f } = d(this, Jt);
        (f.left = `${d(this, Da)[0]}%`), (f.top = `${d(this, Da)[1]}%`);
      }
      function tx() {
        _(this, Ma, !d(this, Ma)),
          d(this, Ma)
            ? (b(this, i_, nx).call(this),
              d(this, Jt).addEventListener('click', d(this, Jg)),
              d(this, Jt).addEventListener('keydown', d(this, Qg)))
            : (b(this, ex, VV).call(this),
              d(this, Jt).removeEventListener('click', d(this, Jg)),
              d(this, Jt).removeEventListener('keydown', d(this, Qg)));
      }
      function nx() {
        d(this, xs) || this.render(),
          this.isVisible
            ? d(this, Ma) && d(this, Jt).classList.add('focused')
            : (b(this, NV, Fre).call(this),
              (d(this, Jt).hidden = !1),
              (d(this, Jt).style.zIndex =
                parseInt(d(this, Jt).style.zIndex) + 1e3));
      }
      function VV() {
        d(this, Jt).classList.remove('focused'),
          !d(this, Ma) &&
            this.isVisible &&
            ((d(this, Jt).hidden = !0),
            (d(this, Jt).style.zIndex =
              parseInt(d(this, Jt).style.zIndex) - 1e3));
      }
      class BV extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0, ignoreBorder: !0 }),
            (this.textContent = e.data.textContent),
            (this.textPosition = e.data.textPosition),
            (this.annotationEditorType = $e.FREETEXT);
        }
        render() {
          if (
            (this.container.classList.add('freeTextAnnotation'),
            this.textContent)
          ) {
            const e = document.createElement('div');
            e.classList.add('annotationTextContent'),
              e.setAttribute('role', 'comment');
            for (const t of this.textContent) {
              const i = document.createElement('span');
              (i.textContent = t), e.append(i);
            }
            this.container.append(e);
          }
          return (
            !this.data.popupRef && this.hasPopupData && this._createPopup(),
            this._editOnDoubleClick(),
            this.container
          );
        }
      }
      var ix = new WeakMap();
      class Ore extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0, ignoreBorder: !0 }),
            v(this, ix, { writable: !0, value: null });
        }
        render() {
          this.container.classList.add('lineAnnotation');
          const e = this.data,
            { width: t, height: i } = Cs(e.rect),
            r = this.svgFactory.create(t, i, !0),
            s = _(this, ix, this.svgFactory.createElement('svg:line'));
          return (
            s.setAttribute('x1', e.rect[2] - e.lineCoordinates[0]),
            s.setAttribute('y1', e.rect[3] - e.lineCoordinates[1]),
            s.setAttribute('x2', e.rect[2] - e.lineCoordinates[2]),
            s.setAttribute('y2', e.rect[3] - e.lineCoordinates[3]),
            s.setAttribute('stroke-width', e.borderStyle.width || 1),
            s.setAttribute('stroke', 'transparent'),
            s.setAttribute('fill', 'transparent'),
            r.append(s),
            this.container.append(r),
            !e.popupRef && this.hasPopupData && this._createPopup(),
            this.container
          );
        }
        getElementsToTriggerPopup() {
          return d(this, ix);
        }
        addHighlightArea() {
          this.container.classList.add('highlightArea');
        }
      }
      var rx = new WeakMap();
      class Lre extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0, ignoreBorder: !0 }),
            v(this, rx, { writable: !0, value: null });
        }
        render() {
          this.container.classList.add('squareAnnotation');
          const e = this.data,
            { width: t, height: i } = Cs(e.rect),
            r = this.svgFactory.create(t, i, !0),
            s = e.borderStyle.width,
            o = _(this, rx, this.svgFactory.createElement('svg:rect'));
          return (
            o.setAttribute('x', s / 2),
            o.setAttribute('y', s / 2),
            o.setAttribute('width', t - s),
            o.setAttribute('height', i - s),
            o.setAttribute('stroke-width', s || 1),
            o.setAttribute('stroke', 'transparent'),
            o.setAttribute('fill', 'transparent'),
            r.append(o),
            this.container.append(r),
            !e.popupRef && this.hasPopupData && this._createPopup(),
            this.container
          );
        }
        getElementsToTriggerPopup() {
          return d(this, rx);
        }
        addHighlightArea() {
          this.container.classList.add('highlightArea');
        }
      }
      var sx = new WeakMap();
      class Nre extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0, ignoreBorder: !0 }),
            v(this, sx, { writable: !0, value: null });
        }
        render() {
          this.container.classList.add('circleAnnotation');
          const e = this.data,
            { width: t, height: i } = Cs(e.rect),
            r = this.svgFactory.create(t, i, !0),
            s = e.borderStyle.width,
            o = _(this, sx, this.svgFactory.createElement('svg:ellipse'));
          return (
            o.setAttribute('cx', t / 2),
            o.setAttribute('cy', i / 2),
            o.setAttribute('rx', t / 2 - s / 2),
            o.setAttribute('ry', i / 2 - s / 2),
            o.setAttribute('stroke-width', s || 1),
            o.setAttribute('stroke', 'transparent'),
            o.setAttribute('fill', 'transparent'),
            r.append(o),
            this.container.append(r),
            !e.popupRef && this.hasPopupData && this._createPopup(),
            this.container
          );
        }
        getElementsToTriggerPopup() {
          return d(this, sx);
        }
        addHighlightArea() {
          this.container.classList.add('highlightArea');
        }
      }
      var ox = new WeakMap();
      class HV extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0, ignoreBorder: !0 }),
            v(this, ox, { writable: !0, value: null }),
            (this.containerClassName = 'polylineAnnotation'),
            (this.svgElementName = 'svg:polyline');
        }
        render() {
          this.container.classList.add(this.containerClassName);
          const {
            data: { rect: e, vertices: t, borderStyle: i, popupRef: r },
          } = this;
          if (!t) return this.container;
          const { width: s, height: o } = Cs(e),
            a = this.svgFactory.create(s, o, !0);
          let l = [];
          for (let u = 0, h = t.length; u < h; u += 2)
            l.push(`${t[u] - e[0]},${e[3] - t[u + 1]}`);
          l = l.join(' ');
          const c = _(
            this,
            ox,
            this.svgFactory.createElement(this.svgElementName)
          );
          return (
            c.setAttribute('points', l),
            c.setAttribute('stroke-width', i.width || 1),
            c.setAttribute('stroke', 'transparent'),
            c.setAttribute('fill', 'transparent'),
            a.append(c),
            this.container.append(a),
            !r && this.hasPopupData && this._createPopup(),
            this.container
          );
        }
        getElementsToTriggerPopup() {
          return d(this, ox);
        }
        addHighlightArea() {
          this.container.classList.add('highlightArea');
        }
      }
      class Vre extends HV {
        constructor(e) {
          super(e),
            (this.containerClassName = 'polygonAnnotation'),
            (this.svgElementName = 'svg:polygon');
        }
      }
      class Bre extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0, ignoreBorder: !0 });
        }
        render() {
          return (
            this.container.classList.add('caretAnnotation'),
            !this.data.popupRef && this.hasPopupData && this._createPopup(),
            this.container
          );
        }
      }
      var ax = new WeakMap();
      class WV extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0, ignoreBorder: !0 }),
            v(this, ax, { writable: !0, value: [] }),
            (this.containerClassName = 'inkAnnotation'),
            (this.svgElementName = 'svg:polyline'),
            (this.annotationEditorType = $e.INK);
        }
        render() {
          this.container.classList.add(this.containerClassName);
          const {
              data: { rect: e, inkLists: t, borderStyle: i, popupRef: r },
            } = this,
            { width: s, height: o } = Cs(e),
            a = this.svgFactory.create(s, o, !0);
          for (const l of t) {
            let c = [];
            for (let h = 0, f = l.length; h < f; h += 2)
              c.push(`${l[h] - e[0]},${e[3] - l[h + 1]}`);
            c = c.join(' ');
            const u = this.svgFactory.createElement(this.svgElementName);
            d(this, ax).push(u),
              u.setAttribute('points', c),
              u.setAttribute('stroke-width', i.width || 1),
              u.setAttribute('stroke', 'transparent'),
              u.setAttribute('fill', 'transparent'),
              !r && this.hasPopupData && this._createPopup(),
              a.append(u);
          }
          return this.container.append(a), this.container;
        }
        getElementsToTriggerPopup() {
          return d(this, ax);
        }
        addHighlightArea() {
          this.container.classList.add('highlightArea');
        }
      }
      class Hre extends Ut {
        constructor(e) {
          super(e, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0,
          });
        }
        render() {
          return (
            !this.data.popupRef && this.hasPopupData && this._createPopup(),
            this.container.classList.add('highlightAnnotation'),
            this.container
          );
        }
      }
      class Wre extends Ut {
        constructor(e) {
          super(e, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0,
          });
        }
        render() {
          return (
            !this.data.popupRef && this.hasPopupData && this._createPopup(),
            this.container.classList.add('underlineAnnotation'),
            this.container
          );
        }
      }
      class jre extends Ut {
        constructor(e) {
          super(e, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0,
          });
        }
        render() {
          return (
            !this.data.popupRef && this.hasPopupData && this._createPopup(),
            this.container.classList.add('squigglyAnnotation'),
            this.container
          );
        }
      }
      class zre extends Ut {
        constructor(e) {
          super(e, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0,
          });
        }
        render() {
          return (
            !this.data.popupRef && this.hasPopupData && this._createPopup(),
            this.container.classList.add('strikeoutAnnotation'),
            this.container
          );
        }
      }
      class jV extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0, ignoreBorder: !0 });
        }
        render() {
          return (
            this.container.classList.add('stampAnnotation'),
            !this.data.popupRef && this.hasPopupData && this._createPopup(),
            this.container
          );
        }
      }
      var lx = new WeakMap(),
        cx = new WeakSet();
      class Ure extends Ut {
        constructor(e) {
          super(e, { isRenderable: !0 }),
            S(this, cx),
            v(this, lx, { writable: !0, value: null });
          const { file: t } = this.data;
          (this.filename = t.filename),
            (this.content = t.content),
            this.linkService.eventBus?.dispatch('fileattachmentannotation', {
              source: this,
              ...t,
            });
        }
        render() {
          this.container.classList.add('fileAttachmentAnnotation');
          const { container: e, data: t } = this;
          let i;
          t.hasAppearance || 0 === t.fillAlpha
            ? (i = document.createElement('div'))
            : ((i = document.createElement('img')),
              (i.src = `${this.imageResourcesPath}annotation-${
                /paperclip/i.test(t.name) ? 'paperclip' : 'pushpin'
              }.svg`),
              t.fillAlpha &&
                t.fillAlpha < 1 &&
                (i.style = `filter: opacity(${Math.round(
                  100 * t.fillAlpha
                )}%);`)),
            i.addEventListener('dblclick', b(this, cx, zV).bind(this)),
            _(this, lx, i);
          const { isMac: r } = ui.platform;
          return (
            e.addEventListener('keydown', (s) => {
              'Enter' === s.key &&
                (r ? s.metaKey : s.ctrlKey) &&
                b(this, cx, zV).call(this);
            }),
            !t.popupRef && this.hasPopupData
              ? this._createPopup()
              : i.classList.add('popupTriggerArea'),
            e.append(i),
            e
          );
        }
        getElementsToTriggerPopup() {
          return d(this, lx);
        }
        addHighlightArea() {
          this.container.classList.add('highlightArea');
        }
      }
      function zV() {
        this.downloadManager?.openOrDownloadData(this.content, this.filename);
      }
      var dx = new WeakMap(),
        gh = new WeakMap(),
        _h = new WeakMap(),
        UV = new WeakSet(),
        ux = new WeakSet();
      class $re {
        constructor({
          div: e,
          accessibilityManager: t,
          annotationCanvasMap: i,
          annotationEditorUIManager: r,
          page: s,
          viewport: o,
        }) {
          S(this, ux),
            S(this, UV),
            v(this, dx, { writable: !0, value: null }),
            v(this, gh, { writable: !0, value: null }),
            v(this, _h, { writable: !0, value: new Map() }),
            (this.div = e),
            _(this, dx, t),
            _(this, gh, i),
            (this.page = s),
            (this.viewport = o),
            (this.zIndex = 0),
            (this._annotationEditorUIManager = r);
        }
        hasEditableAnnotations() {
          return d(this, _h).size > 0;
        }
        render(e) {
          var t = this;
          return U(function* () {
            const { annotations: i } = e,
              r = t.div;
            ba(r, t.viewport);
            const s = new Map(),
              o = {
                data: null,
                layer: r,
                linkService: e.linkService,
                downloadManager: e.downloadManager,
                imageResourcesPath: e.imageResourcesPath || '',
                renderForms: !1 !== e.renderForms,
                svgFactory: new $E(),
                annotationStorage: e.annotationStorage || new pC(),
                enableScripting: !0 === e.enableScripting,
                hasJSActions: e.hasJSActions,
                fieldObjects: e.fieldObjects,
                parent: t,
                elements: null,
              };
            for (const a of i) {
              if (a.noHTML) continue;
              const l = 16 === a.annotationType;
              if (l) {
                const h = s.get(a.id);
                if (!h) continue;
                o.elements = h;
              } else {
                const { width: h, height: f } = Cs(a.rect);
                if (h <= 0 || f <= 0) continue;
              }
              o.data = a;
              const c = vre.create(o);
              if (!c.isRenderable) continue;
              if (!l && a.popupRef) {
                const h = s.get(a.popupRef);
                h ? h.push(c) : s.set(a.popupRef, [c]);
              }
              const u = c.render();
              a.hidden && (u.style.visibility = 'hidden'),
                b(t, UV, Gre).call(t, u, a.id),
                c._isEditable &&
                  (d(t, _h).set(c.data.id, c),
                  t._annotationEditorUIManager?.renderAnnotationElement(c));
            }
            b(t, ux, $V).call(t);
          })();
        }
        update({ viewport: e }) {
          const t = this.div;
          (this.viewport = e),
            ba(t, { rotation: e.rotation }),
            b(this, ux, $V).call(this),
            (t.hidden = !1);
        }
        getEditableAnnotations() {
          return Array.from(d(this, _h).values());
        }
        getEditableAnnotation(e) {
          return d(this, _h).get(e);
        }
      }
      function Gre(n, e) {
        const t = n.firstChild || n;
        (t.id = `${s2}${e}`),
          this.div.append(n),
          d(this, dx)?.moveElementInDOM(this.div, n, t, !1);
      }
      function $V() {
        if (!d(this, gh)) return;
        const n = this.div;
        for (const [e, t] of d(this, gh)) {
          const i = n.querySelector(`[data-annotation-id="${e}"]`);
          if (!i) continue;
          t.className = 'annotationContent';
          const { firstChild: r } = i;
          r
            ? 'CANVAS' === r.nodeName
              ? r.replaceWith(t)
              : r.classList.contains('annotationContent')
              ? r.after(t)
              : r.before(t)
            : i.append(t);
        }
        d(this, gh).clear();
      }
      const r_ = /\r\n?|\n/g;
      var hx = new WeakMap(),
        fx = new WeakMap(),
        px = new WeakMap(),
        mx = new WeakMap(),
        gx = new WeakMap(),
        As = new WeakMap(),
        pr = new WeakMap(),
        _x = new WeakMap(),
        mr = new WeakMap(),
        s_ = new WeakMap(),
        GV = new WeakSet(),
        qV = new WeakSet(),
        XV = new WeakSet(),
        o_ = new WeakSet(),
        a_ = new WeakSet(),
        YV = new WeakSet(),
        KV = new WeakSet();
      class Ge extends re {
        static get _keyboardManager() {
          const e = Ge.prototype,
            t = (s) => s.isEmpty(),
            i = Uu.TRANSLATE_SMALL,
            r = Uu.TRANSLATE_BIG;
          return Ye(
            this,
            '_keyboardManager',
            new zu([
              [
                ['ctrl+s', 'mac+meta+s', 'ctrl+p', 'mac+meta+p'],
                e.commitOrRemove,
                { bubbles: !0 },
              ],
              [
                ['ctrl+Enter', 'mac+meta+Enter', 'Escape', 'mac+Escape'],
                e.commitOrRemove,
              ],
              [
                ['ArrowLeft', 'mac+ArrowLeft'],
                e._translateEmpty,
                { args: [-i, 0], checker: t },
              ],
              [
                ['ctrl+ArrowLeft', 'mac+shift+ArrowLeft'],
                e._translateEmpty,
                { args: [-r, 0], checker: t },
              ],
              [
                ['ArrowRight', 'mac+ArrowRight'],
                e._translateEmpty,
                { args: [i, 0], checker: t },
              ],
              [
                ['ctrl+ArrowRight', 'mac+shift+ArrowRight'],
                e._translateEmpty,
                { args: [r, 0], checker: t },
              ],
              [
                ['ArrowUp', 'mac+ArrowUp'],
                e._translateEmpty,
                { args: [0, -i], checker: t },
              ],
              [
                ['ctrl+ArrowUp', 'mac+shift+ArrowUp'],
                e._translateEmpty,
                { args: [0, -r], checker: t },
              ],
              [
                ['ArrowDown', 'mac+ArrowDown'],
                e._translateEmpty,
                { args: [0, i], checker: t },
              ],
              [
                ['ctrl+ArrowDown', 'mac+shift+ArrowDown'],
                e._translateEmpty,
                { args: [0, r], checker: t },
              ],
            ])
          );
        }
        constructor(e) {
          super({ ...e, name: 'freeTextEditor' }),
            S(this, KV),
            S(this, YV),
            S(this, a_),
            S(this, o_),
            S(this, XV),
            S(this, qV),
            S(this, GV),
            v(this, hx, { writable: !0, value: this.editorDivBlur.bind(this) }),
            v(this, fx, {
              writable: !0,
              value: this.editorDivFocus.bind(this),
            }),
            v(this, px, {
              writable: !0,
              value: this.editorDivInput.bind(this),
            }),
            v(this, mx, {
              writable: !0,
              value: this.editorDivKeydown.bind(this),
            }),
            v(this, gx, {
              writable: !0,
              value: this.editorDivPaste.bind(this),
            }),
            v(this, As, { writable: !0, value: void 0 }),
            v(this, pr, { writable: !0, value: '' }),
            v(this, _x, { writable: !0, value: `${this.id}-editor` }),
            v(this, mr, { writable: !0, value: void 0 }),
            v(this, s_, { writable: !0, value: null }),
            _(this, As, e.color || Ge._defaultColor || re._defaultLineColor),
            _(this, mr, e.fontSize || Ge._defaultFontSize);
        }
        static initialize(e, t) {
          re.initialize(e, t, { strings: ['pdfjs-free-text-default-content'] });
          const i = getComputedStyle(document.documentElement);
          this._internalPadding = parseFloat(
            i.getPropertyValue('--freetext-padding')
          );
        }
        static updateDefaultParams(e, t) {
          switch (e) {
            case Ee.FREETEXT_SIZE:
              Ge._defaultFontSize = t;
              break;
            case Ee.FREETEXT_COLOR:
              Ge._defaultColor = t;
          }
        }
        updateParams(e, t) {
          switch (e) {
            case Ee.FREETEXT_SIZE:
              b(this, GV, qre).call(this, t);
              break;
            case Ee.FREETEXT_COLOR:
              b(this, qV, Xre).call(this, t);
          }
        }
        static get defaultPropertiesToUpdate() {
          return [
            [Ee.FREETEXT_SIZE, Ge._defaultFontSize],
            [Ee.FREETEXT_COLOR, Ge._defaultColor || re._defaultLineColor],
          ];
        }
        get propertiesToUpdate() {
          return [
            [Ee.FREETEXT_SIZE, d(this, mr)],
            [Ee.FREETEXT_COLOR, d(this, As)],
          ];
        }
        _translateEmpty(e, t) {
          this._uiManager.translateSelectedEditors(e, t, !0);
        }
        getInitialTranslation() {
          const e = this.parentScale;
          return [
            -Ge._internalPadding * e,
            -(Ge._internalPadding + d(this, mr)) * e,
          ];
        }
        rebuild() {
          this.parent &&
            (super.rebuild(),
            null !== this.div &&
              (this.isAttachedToDOM || this.parent.add(this)));
        }
        enableEditMode() {
          if (this.isInEditMode()) return;
          this.parent.setEditingState(!1),
            this.parent.updateToolbar($e.FREETEXT),
            super.enableEditMode(),
            this.overlayDiv.classList.remove('enabled'),
            (this.editorDiv.contentEditable = !0),
            (this._isDraggable = !1),
            this.div.removeAttribute('aria-activedescendant');
          const e = this._uiManager._signal;
          this.editorDiv.addEventListener('keydown', d(this, mx), {
            signal: e,
          }),
            this.editorDiv.addEventListener('focus', d(this, fx), {
              signal: e,
            }),
            this.editorDiv.addEventListener('blur', d(this, hx), { signal: e }),
            this.editorDiv.addEventListener('input', d(this, px), {
              signal: e,
            }),
            this.editorDiv.addEventListener('paste', d(this, gx), {
              signal: e,
            });
        }
        disableEditMode() {
          this.isInEditMode() &&
            (this.parent.setEditingState(!0),
            super.disableEditMode(),
            this.overlayDiv.classList.add('enabled'),
            (this.editorDiv.contentEditable = !1),
            this.div.setAttribute('aria-activedescendant', d(this, _x)),
            (this._isDraggable = !0),
            this.editorDiv.removeEventListener('keydown', d(this, mx)),
            this.editorDiv.removeEventListener('focus', d(this, fx)),
            this.editorDiv.removeEventListener('blur', d(this, hx)),
            this.editorDiv.removeEventListener('input', d(this, px)),
            this.editorDiv.removeEventListener('paste', d(this, gx)),
            this.div.focus({ preventScroll: !0 }),
            (this.isEditing = !1),
            this.parent.div.classList.add('freetextEditing'));
        }
        focusin(e) {
          this._focusEventsAllowed &&
            (super.focusin(e),
            e.target !== this.editorDiv && this.editorDiv.focus());
        }
        onceAdded() {
          this.width ||
            (this.enableEditMode(),
            this.editorDiv.focus(),
            this._initialOptions?.isCentered && this.center(),
            (this._initialOptions = null));
        }
        isEmpty() {
          return !this.editorDiv || '' === this.editorDiv.innerText.trim();
        }
        remove() {
          (this.isEditing = !1),
            this.parent &&
              (this.parent.setEditingState(!0),
              this.parent.div.classList.add('freetextEditing')),
            super.remove();
        }
        commit() {
          if (!this.isInEditMode()) return;
          super.commit(), this.disableEditMode();
          const e = d(this, pr),
            t = _(this, pr, b(this, XV, Yre).call(this).trimEnd());
          if (e === t) return;
          const i = (r) => {
            _(this, pr, r),
              r
                ? (b(this, a_, yx).call(this),
                  this._uiManager.rebuild(this),
                  b(this, o_, bx).call(this))
                : this.remove();
          };
          this.addCommands({
            cmd: () => {
              i(t);
            },
            undo: () => {
              i(e);
            },
            mustExec: !1,
          }),
            b(this, o_, bx).call(this);
        }
        shouldGetKeyboardEvents() {
          return this.isInEditMode();
        }
        enterInEditMode() {
          this.enableEditMode(), this.editorDiv.focus();
        }
        dblclick(e) {
          this.enterInEditMode();
        }
        keydown(e) {
          e.target === this.div &&
            'Enter' === e.key &&
            (this.enterInEditMode(), e.preventDefault());
        }
        editorDivKeydown(e) {
          Ge._keyboardManager.exec(this, e);
        }
        editorDivFocus(e) {
          this.isEditing = !0;
        }
        editorDivBlur(e) {
          this.isEditing = !1;
        }
        editorDivInput(e) {
          this.parent.div.classList.toggle('freetextEditing', this.isEmpty());
        }
        disableEditing() {
          this.editorDiv.setAttribute('role', 'comment'),
            this.editorDiv.removeAttribute('aria-multiline');
        }
        enableEditing() {
          this.editorDiv.setAttribute('role', 'textbox'),
            this.editorDiv.setAttribute('aria-multiline', !0);
        }
        render() {
          if (this.div) return this.div;
          let e, t;
          this.width && ((e = this.x), (t = this.y)),
            super.render(),
            (this.editorDiv = document.createElement('div')),
            (this.editorDiv.className = 'internal'),
            this.editorDiv.setAttribute('id', d(this, _x)),
            this.editorDiv.setAttribute('data-l10n-id', 'pdfjs-free-text'),
            this.enableEditing(),
            re._l10nPromise
              .get('pdfjs-free-text-default-content')
              .then((r) => this.editorDiv?.setAttribute('default-content', r)),
            (this.editorDiv.contentEditable = !0);
          const { style: i } = this.editorDiv;
          if (
            ((i.fontSize = `calc(${d(this, mr)}px * var(--scale-factor))`),
            (i.color = d(this, As)),
            this.div.append(this.editorDiv),
            (this.overlayDiv = document.createElement('div')),
            this.overlayDiv.classList.add('overlay', 'enabled'),
            this.div.append(this.overlayDiv),
            vg(this, this.div, ['dblclick', 'keydown']),
            this.width)
          ) {
            const [r, s] = this.parentDimensions;
            if (this.annotationElementId) {
              const { position: o } = d(this, s_);
              let [a, l] = this.getInitialTranslation();
              [a, l] = this.pageTranslationToScreen(a, l);
              const [c, u] = this.pageDimensions,
                [h, f] = this.pageTranslation;
              let p, m;
              switch (this.rotation) {
                case 0:
                  (p = e + (o[0] - h) / c),
                    (m = t + this.height - (o[1] - f) / u);
                  break;
                case 90:
                  (p = e + (o[0] - h) / c),
                    (m = t - (o[1] - f) / u),
                    ([a, l] = [l, -a]);
                  break;
                case 180:
                  (p = e - this.width + (o[0] - h) / c),
                    (m = t - (o[1] - f) / u),
                    ([a, l] = [-a, -l]);
                  break;
                case 270:
                  (p = e + (o[0] - h - this.height * u) / c),
                    (m = t + (o[1] - f - this.width * c) / u),
                    ([a, l] = [-l, a]);
              }
              this.setAt(p * r, m * s, a, l);
            } else this.setAt(e * r, t * s, this.width * r, this.height * s);
            b(this, a_, yx).call(this),
              (this._isDraggable = !0),
              (this.editorDiv.contentEditable = !1);
          } else
            (this._isDraggable = !1), (this.editorDiv.contentEditable = !0);
          return this.div;
        }
        editorDivPaste(e) {
          const t = e.clipboardData || window.clipboardData,
            { types: i } = t;
          if (1 === i.length && 'text/plain' === i[0]) return;
          e.preventDefault();
          const r = we(Ge, Ge, ZV)
            .call(Ge, t.getData('text') || '')
            .replaceAll(r_, '\n');
          if (!r) return;
          const s = window.getSelection();
          if (!s.rangeCount) return;
          this.editorDiv.normalize(), s.deleteFromDocument();
          const o = s.getRangeAt(0);
          if (!r.includes('\n'))
            return (
              o.insertNode(document.createTextNode(r)),
              this.editorDiv.normalize(),
              void s.collapseToStart()
            );
          const { startContainer: a, startOffset: l } = o,
            c = [],
            u = [];
          if (a.nodeType === Node.TEXT_NODE) {
            const p = a.parentElement;
            if (
              (u.push(a.nodeValue.slice(l).replaceAll(r_, '')),
              p !== this.editorDiv)
            ) {
              let m = c;
              for (const g of this.editorDiv.childNodes)
                g !== p ? m.push(we(Ge, Ge, vx).call(Ge, g)) : (m = u);
            }
            c.push(a.nodeValue.slice(0, l).replaceAll(r_, ''));
          } else if (a === this.editorDiv) {
            let p = c,
              m = 0;
            for (const g of this.editorDiv.childNodes)
              m++ === l && (p = u), p.push(we(Ge, Ge, vx).call(Ge, g));
          }
          _(this, pr, `${c.join('\n')}${r}${u.join('\n')}`),
            b(this, a_, yx).call(this);
          const h = new Range();
          let f = c.reduce((p, m) => p + m.length, 0);
          for (const { firstChild: p } of this.editorDiv.childNodes)
            if (p.nodeType === Node.TEXT_NODE) {
              const m = p.nodeValue.length;
              if (f <= m) {
                h.setStart(p, f), h.setEnd(p, f);
                break;
              }
              f -= m;
            }
          s.removeAllRanges(), s.addRange(h);
        }
        get contentDiv() {
          return this.editorDiv;
        }
        static deserialize(e, t, i) {
          let r = null;
          if (e instanceof BV) {
            const {
              data: {
                defaultAppearanceData: { fontSize: o, fontColor: a },
                rect: l,
                rotation: c,
                id: u,
              },
              textContent: h,
              textPosition: f,
              parent: {
                page: { pageNumber: p },
              },
            } = e;
            if (!h || 0 === h.length) return null;
            r = e = {
              annotationType: $e.FREETEXT,
              color: Array.from(a),
              fontSize: o,
              value: h.join('\n'),
              position: f,
              pageIndex: p - 1,
              rect: l.slice(0),
              rotation: c,
              id: u,
              deleted: !1,
            };
          }
          const s = super.deserialize(e, t, i);
          return (
            _(s, mr, e.fontSize),
            _(s, As, te.makeHexColor(...e.color)),
            _(s, pr, we(Ge, Ge, ZV).call(Ge, e.value)),
            (s.annotationElementId = e.id || null),
            _(s, s_, r),
            s
          );
        }
        serialize(e = !1) {
          if (this.isEmpty()) return null;
          if (this.deleted)
            return {
              pageIndex: this.pageIndex,
              id: this.annotationElementId,
              deleted: !0,
            };
          const t = Ge._internalPadding * this.parentScale,
            i = this.getRect(t, t),
            r = re._colorManager.convert(
              this.isAttachedToDOM
                ? getComputedStyle(this.editorDiv).color
                : d(this, As)
            ),
            s = {
              annotationType: $e.FREETEXT,
              color: r,
              fontSize: d(this, mr),
              value: b(this, YV, Kre).call(this),
              pageIndex: this.pageIndex,
              rect: i,
              rotation: this.rotation,
              structTreeParentId: this._structTreeParentId,
            };
          return e
            ? s
            : this.annotationElementId && !b(this, KV, Zre).call(this, s)
            ? null
            : ((s.id = this.annotationElementId), s);
        }
        renderAnnotationElement(e) {
          const t = super.renderAnnotationElement(e);
          if (this.deleted) return t;
          const { style: i } = t;
          (i.fontSize = `calc(${d(this, mr)}px * var(--scale-factor))`),
            (i.color = d(this, As)),
            t.replaceChildren();
          for (const s of d(this, pr).split('\n')) {
            const o = document.createElement('div');
            o.append(
              s ? document.createTextNode(s) : document.createElement('br')
            ),
              t.append(o);
          }
          const r = Ge._internalPadding * this.parentScale;
          return (
            e.updateEdited({
              rect: this.getRect(r, r),
              popupContent: d(this, pr),
            }),
            t
          );
        }
        resetAnnotationElement(e) {
          super.resetAnnotationElement(e), e.resetEdited();
        }
      }
      function qre(n) {
        const e = (i) => {
            (this.editorDiv.style.fontSize = `calc(${i}px * var(--scale-factor))`),
              this.translate(0, -(i - d(this, mr)) * this.parentScale),
              _(this, mr, i),
              b(this, o_, bx).call(this);
          },
          t = d(this, mr);
        this.addCommands({
          cmd: e.bind(this, n),
          undo: e.bind(this, t),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: !0,
          type: Ee.FREETEXT_SIZE,
          overwriteIfSameType: !0,
          keepUndo: !0,
        });
      }
      function Xre(n) {
        const e = (i) => {
            _(this, As, (this.editorDiv.style.color = i));
          },
          t = d(this, As);
        this.addCommands({
          cmd: e.bind(this, n),
          undo: e.bind(this, t),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: !0,
          type: Ee.FREETEXT_COLOR,
          overwriteIfSameType: !0,
          keepUndo: !0,
        });
      }
      function Yre() {
        const n = [];
        this.editorDiv.normalize();
        for (const e of this.editorDiv.childNodes)
          n.push(we(Ge, Ge, vx).call(Ge, e));
        return n.join('\n');
      }
      function bx() {
        const [n, e] = this.parentDimensions;
        let t;
        if (this.isAttachedToDOM) t = this.div.getBoundingClientRect();
        else {
          const { currentLayer: i, div: r } = this,
            s = r.style.display,
            o = r.classList.contains('hidden');
          r.classList.remove('hidden'),
            (r.style.display = 'hidden'),
            i.div.append(this.div),
            (t = r.getBoundingClientRect()),
            r.remove(),
            (r.style.display = s),
            r.classList.toggle('hidden', o);
        }
        this.rotation % 180 == this.parentRotation % 180
          ? ((this.width = t.width / n), (this.height = t.height / e))
          : ((this.width = t.height / n), (this.height = t.width / e)),
          this.fixAndSetPosition();
      }
      function vx(n) {
        return (
          n.nodeType === Node.TEXT_NODE ? n.nodeValue : n.innerText
        ).replaceAll(r_, '');
      }
      function yx() {
        if ((this.editorDiv.replaceChildren(), d(this, pr)))
          for (const n of d(this, pr).split('\n')) {
            const e = document.createElement('div');
            e.append(
              n ? document.createTextNode(n) : document.createElement('br')
            ),
              this.editorDiv.append(e);
          }
      }
      function Kre() {
        return d(this, pr).replaceAll('\xa0', ' ');
      }
      function ZV(n) {
        return n.replaceAll(' ', '\xa0');
      }
      function Zre(n) {
        const { value: e, fontSize: t, color: i, pageIndex: r } = d(this, s_);
        return (
          this._hasBeenMoved ||
          n.value !== e ||
          n.fontSize !== t ||
          n.color.some((s, o) => s !== i[o]) ||
          n.pageIndex !== r
        );
      }
      Se(Ge, '_freeTextDefaultContent', ''),
        Se(Ge, '_internalPadding', 0),
        Se(Ge, '_defaultColor', null),
        Se(Ge, '_defaultFontSize', 10),
        Se(Ge, '_type', 'freetext'),
        Se(Ge, '_editorType', $e.FREETEXT);
      var wx = new WeakMap(),
        _c = new WeakMap(),
        Ss = new WeakMap(),
        QV = new WeakSet(),
        l_ = new WeakSet(),
        JV = new WeakSet(),
        eB = new WeakSet(),
        Ex = new WeakSet();
      class tB {
        constructor(e, t = 0, i = 0, r = !0) {
          S(this, Ex),
            S(this, eB),
            S(this, JV),
            S(this, l_),
            S(this, QV),
            v(this, wx, { writable: !0, value: void 0 }),
            v(this, _c, { writable: !0, value: [] }),
            v(this, Ss, { writable: !0, value: [] });
          let s = 1 / 0,
            o = -1 / 0,
            a = 1 / 0,
            l = -1 / 0;
          const u = 10 ** -4;
          for (const { x: y, y: E, width: A, height: M } of e) {
            const T = Math.floor((y - t) / u) * u,
              k = Math.ceil((y + A + t) / u) * u,
              P = Math.floor((E - t) / u) * u,
              O = Math.ceil((E + M + t) / u) * u,
              I = [T, P, O, !0],
              C = [k, P, O, !1];
            d(this, _c).push(I, C),
              (s = Math.min(s, T)),
              (o = Math.max(o, k)),
              (a = Math.min(a, P)),
              (l = Math.max(l, O));
          }
          const h = o - s + 2 * i,
            f = l - a + 2 * i,
            p = s - i,
            m = a - i,
            g = d(this, _c).at(r ? -1 : -2),
            w = [g[0], g[2]];
          for (const y of d(this, _c)) {
            const [E, A, M] = y;
            (y[0] = (E - p) / h), (y[1] = (A - m) / f), (y[2] = (M - m) / f);
          }
          _(this, wx, { x: p, y: m, width: h, height: f, lastPoint: w });
        }
        getOutlines() {
          d(this, _c).sort((t, i) => t[0] - i[0] || t[1] - i[1] || t[2] - i[2]);
          const e = [];
          for (const t of d(this, _c))
            t[3]
              ? (e.push(...b(this, Ex, nB).call(this, t)),
                b(this, JV, Jre).call(this, t))
              : (b(this, eB, ese).call(this, t),
                e.push(...b(this, Ex, nB).call(this, t)));
          return b(this, QV, Qre).call(this, e);
        }
      }
      function Qre(n) {
        const e = [],
          t = new Set();
        for (const s of n) {
          const [o, a, l] = s;
          e.push([o, a, s], [o, l, s]);
        }
        e.sort((s, o) => s[1] - o[1] || s[0] - o[0]);
        for (let s = 0, o = e.length; s < o; s += 2) {
          const a = e[s][2],
            l = e[s + 1][2];
          a.push(l), l.push(a), t.add(a), t.add(l);
        }
        const i = [];
        let r;
        for (; t.size > 0; ) {
          const s = t.values().next().value;
          let [o, a, l, c, u] = s;
          t.delete(s);
          let h = o,
            f = a;
          for (r = [o, l], i.push(r); ; ) {
            let p;
            if (t.has(c)) p = c;
            else {
              if (!t.has(u)) break;
              p = u;
            }
            t.delete(p),
              ([o, a, l, c, u] = p),
              h !== o && (r.push(h, f, o, f === a ? a : l), (h = o)),
              (f = f === a ? l : a);
          }
          r.push(h, f);
        }
        return new tse(i, d(this, wx));
      }
      function Cx(n) {
        const e = d(this, Ss);
        let t = 0,
          i = e.length - 1;
        for (; t <= i; ) {
          const r = (t + i) >> 1,
            s = e[r][0];
          if (s === n) return r;
          s < n ? (t = r + 1) : (i = r - 1);
        }
        return i + 1;
      }
      function Jre([, n, e]) {
        const t = b(this, l_, Cx).call(this, n);
        d(this, Ss).splice(t, 0, [n, e]);
      }
      function ese([, n, e]) {
        const t = b(this, l_, Cx).call(this, n);
        for (let i = t; i < d(this, Ss).length; i++) {
          const [r, s] = d(this, Ss)[i];
          if (r !== n) break;
          if (r === n && s === e) return void d(this, Ss).splice(i, 1);
        }
        for (let i = t - 1; i >= 0; i--) {
          const [r, s] = d(this, Ss)[i];
          if (r !== n) break;
          if (r === n && s === e) return void d(this, Ss).splice(i, 1);
        }
      }
      function nB(n) {
        const [e, t, i] = n,
          r = [[e, t, i]],
          s = b(this, l_, Cx).call(this, i);
        for (let o = 0; o < s; o++) {
          const [a, l] = d(this, Ss)[o];
          for (let c = 0, u = r.length; c < u; c++) {
            const [, h, f] = r[c];
            if (!(l <= h || f <= a)) {
              if (h >= a) {
                if (f > l) r[c][1] = l;
                else {
                  if (1 === u) return [];
                  r.splice(c, 1), c--, u--;
                }
                continue;
              }
              (r[c][2] = a), f > l && r.push([e, l, f]);
            }
          }
        }
        return r;
      }
      class iB {
        toSVGPath() {
          throw new Error('Abstract method `toSVGPath` must be implemented.');
        }
        get box() {
          throw new Error('Abstract getter `box` must be implemented.');
        }
        serialize(e, t) {
          throw new Error('Abstract method `serialize` must be implemented.');
        }
        get free() {
          return this instanceof Ix;
        }
      }
      var xx = new WeakMap(),
        c_ = new WeakMap();
      class tse extends iB {
        constructor(e, t) {
          super(),
            v(this, xx, { writable: !0, value: void 0 }),
            v(this, c_, { writable: !0, value: void 0 }),
            _(this, c_, e),
            _(this, xx, t);
        }
        toSVGPath() {
          const e = [];
          for (const t of d(this, c_)) {
            let [i, r] = t;
            e.push(`M${i} ${r}`);
            for (let s = 2; s < t.length; s += 2) {
              const o = t[s],
                a = t[s + 1];
              o === i
                ? (e.push(`V${a}`), (r = a))
                : a === r && (e.push(`H${o}`), (i = o));
            }
            e.push('Z');
          }
          return e.join(' ');
        }
        serialize([e, t, i, r], s) {
          const o = [],
            a = i - e,
            l = r - t;
          for (const c of d(this, c_)) {
            const u = new Array(c.length);
            for (let h = 0; h < c.length; h += 2)
              (u[h] = e + c[h] * a), (u[h + 1] = r - c[h + 1] * l);
            o.push(u);
          }
          return o;
        }
        get box() {
          return d(this, xx);
        }
      }
      var uo = new WeakMap(),
        Ia = new WeakMap(),
        d_ = new WeakMap(),
        u_ = new WeakMap(),
        ho = new WeakMap(),
        Qe = new WeakMap(),
        bh = new WeakMap(),
        vh = new WeakMap(),
        Ax = new WeakMap(),
        Sx = new WeakMap(),
        h_ = new WeakMap(),
        f_ = new WeakMap(),
        bc = new WeakMap(),
        Mx = new WeakSet();
      class gr {
        constructor({ x: e, y: t }, i, r, s, o, a = 0) {
          S(this, Mx),
            v(this, uo, { writable: !0, value: void 0 }),
            v(this, Ia, { writable: !0, value: [] }),
            v(this, d_, { writable: !0, value: void 0 }),
            v(this, u_, { writable: !0, value: void 0 }),
            v(this, ho, { writable: !0, value: [] }),
            v(this, Qe, { writable: !0, value: new Float64Array(18) }),
            v(this, bh, { writable: !0, value: void 0 }),
            v(this, vh, { writable: !0, value: void 0 }),
            v(this, Ax, { writable: !0, value: void 0 }),
            v(this, Sx, { writable: !0, value: void 0 }),
            v(this, h_, { writable: !0, value: void 0 }),
            v(this, f_, { writable: !0, value: void 0 }),
            v(this, bc, { writable: !0, value: [] }),
            _(this, uo, i),
            _(this, f_, s * r),
            _(this, u_, o),
            d(this, Qe).set([NaN, NaN, NaN, NaN, e, t], 6),
            _(this, d_, a),
            _(this, Sx, de(gr, gr, sB) * r),
            _(this, Ax, de(gr, gr, ise) * r),
            _(this, h_, r),
            d(this, bc).push(e, t);
        }
        get free() {
          return !0;
        }
        isEmpty() {
          return isNaN(d(this, Qe)[8]);
        }
        add({ x: e, y: t }) {
          _(this, bh, e), _(this, vh, t);
          const [i, r, s, o] = d(this, uo);
          let [a, l, c, u] = d(this, Qe).subarray(8, 12);
          const h = e - c,
            f = t - u,
            p = Math.hypot(h, f);
          if (p < d(this, Ax)) return !1;
          const m = p - d(this, Sx),
            g = m / p,
            w = g * h,
            y = g * f;
          let E = a,
            A = l;
          (a = c), (l = u), (c += w), (u += y), d(this, bc)?.push(e, t);
          const T = w / m,
            k = (-y / m) * d(this, f_),
            P = T * d(this, f_);
          return (
            d(this, Qe).set(d(this, Qe).subarray(2, 8), 0),
            d(this, Qe).set([c + k, u + P], 4),
            d(this, Qe).set(d(this, Qe).subarray(14, 18), 12),
            d(this, Qe).set([c - k, u - P], 16),
            isNaN(d(this, Qe)[6])
              ? (0 === d(this, ho).length &&
                  (d(this, Qe).set([a + k, l + P], 2),
                  d(this, ho).push(
                    NaN,
                    NaN,
                    NaN,
                    NaN,
                    (a + k - i) / s,
                    (l + P - r) / o
                  ),
                  d(this, Qe).set([a - k, l - P], 14),
                  d(this, Ia).push(
                    NaN,
                    NaN,
                    NaN,
                    NaN,
                    (a - k - i) / s,
                    (l - P - r) / o
                  )),
                d(this, Qe).set([E, A, a, l, c, u], 6),
                !this.isEmpty())
              : (d(this, Qe).set([E, A, a, l, c, u], 6),
                Math.abs(Math.atan2(A - l, E - a) - Math.atan2(y, w)) <
                Math.PI / 2
                  ? (([a, l, c, u] = d(this, Qe).subarray(2, 6)),
                    d(this, ho).push(
                      NaN,
                      NaN,
                      NaN,
                      NaN,
                      ((a + c) / 2 - i) / s,
                      ((l + u) / 2 - r) / o
                    ),
                    ([a, l, E, A] = d(this, Qe).subarray(14, 18)),
                    d(this, Ia).push(
                      NaN,
                      NaN,
                      NaN,
                      NaN,
                      ((E + a) / 2 - i) / s,
                      ((A + l) / 2 - r) / o
                    ),
                    !0)
                  : (([E, A, a, l, c, u] = d(this, Qe).subarray(0, 6)),
                    d(this, ho).push(
                      ((E + 5 * a) / 6 - i) / s,
                      ((A + 5 * l) / 6 - r) / o,
                      ((5 * a + c) / 6 - i) / s,
                      ((5 * l + u) / 6 - r) / o,
                      ((a + c) / 2 - i) / s,
                      ((l + u) / 2 - r) / o
                    ),
                    ([c, u, a, l, E, A] = d(this, Qe).subarray(12, 18)),
                    d(this, Ia).push(
                      ((E + 5 * a) / 6 - i) / s,
                      ((A + 5 * l) / 6 - r) / o,
                      ((5 * a + c) / 6 - i) / s,
                      ((5 * l + u) / 6 - r) / o,
                      ((a + c) / 2 - i) / s,
                      ((l + u) / 2 - r) / o
                    ),
                    !0))
          );
        }
        toSVGPath() {
          if (this.isEmpty()) return '';
          const e = d(this, ho),
            t = d(this, Ia),
            i = d(this, Qe).subarray(4, 6),
            r = d(this, Qe).subarray(16, 18),
            [s, o, a, l] = d(this, uo),
            [c, u, h, f] = b(this, Mx, rB).call(this);
          if (isNaN(d(this, Qe)[6]) && !this.isEmpty())
            return `M${(d(this, Qe)[2] - s) / a} ${(d(this, Qe)[3] - o) / l} L${
              (d(this, Qe)[4] - s) / a
            } ${(d(this, Qe)[5] - o) / l} L${c} ${u} L${h} ${f} L${
              (d(this, Qe)[16] - s) / a
            } ${(d(this, Qe)[17] - o) / l} L${(d(this, Qe)[14] - s) / a} ${
              (d(this, Qe)[15] - o) / l
            } Z`;
          const p = [];
          p.push(`M${e[4]} ${e[5]}`);
          for (let m = 6; m < e.length; m += 6)
            isNaN(e[m])
              ? p.push(`L${e[m + 4]} ${e[m + 5]}`)
              : p.push(
                  `C${e[m]} ${e[m + 1]} ${e[m + 2]} ${e[m + 3]} ${e[m + 4]} ${
                    e[m + 5]
                  }`
                );
          p.push(
            `L${(i[0] - s) / a} ${(i[1] - o) / l} L${c} ${u} L${h} ${f} L${
              (r[0] - s) / a
            } ${(r[1] - o) / l}`
          );
          for (let m = t.length - 6; m >= 6; m -= 6)
            isNaN(t[m])
              ? p.push(`L${t[m + 4]} ${t[m + 5]}`)
              : p.push(
                  `C${t[m]} ${t[m + 1]} ${t[m + 2]} ${t[m + 3]} ${t[m + 4]} ${
                    t[m + 5]
                  }`
                );
          return p.push(`L${t[4]} ${t[5]} Z`), p.join(' ');
        }
        getOutlines() {
          const e = d(this, ho),
            t = d(this, Ia),
            i = d(this, Qe),
            r = i.subarray(4, 6),
            s = i.subarray(16, 18),
            [o, a, l, c] = d(this, uo),
            u = new Float64Array((d(this, bc)?.length ?? 0) + 2);
          for (let y = 0, E = u.length - 2; y < E; y += 2)
            (u[y] = (d(this, bc)[y] - o) / l),
              (u[y + 1] = (d(this, bc)[y + 1] - a) / c);
          (u[u.length - 2] = (d(this, bh) - o) / l),
            (u[u.length - 1] = (d(this, vh) - a) / c);
          const [h, f, p, m] = b(this, Mx, rB).call(this);
          if (isNaN(i[6]) && !this.isEmpty()) {
            const y = new Float64Array(36);
            return (
              y.set(
                [
                  NaN,
                  NaN,
                  NaN,
                  NaN,
                  (i[2] - o) / l,
                  (i[3] - a) / c,
                  NaN,
                  NaN,
                  NaN,
                  NaN,
                  (i[4] - o) / l,
                  (i[5] - a) / c,
                  NaN,
                  NaN,
                  NaN,
                  NaN,
                  h,
                  f,
                  NaN,
                  NaN,
                  NaN,
                  NaN,
                  p,
                  m,
                  NaN,
                  NaN,
                  NaN,
                  NaN,
                  (i[16] - o) / l,
                  (i[17] - a) / c,
                  NaN,
                  NaN,
                  NaN,
                  NaN,
                  (i[14] - o) / l,
                  (i[15] - a) / c,
                ],
                0
              ),
              new Ix(y, u, d(this, uo), d(this, h_), d(this, d_), d(this, u_))
            );
          }
          const g = new Float64Array(
            d(this, ho).length + 24 + d(this, Ia).length
          );
          let w = e.length;
          for (let y = 0; y < w; y += 2)
            isNaN(e[y])
              ? (g[y] = g[y + 1] = NaN)
              : ((g[y] = e[y]), (g[y + 1] = e[y + 1]));
          g.set(
            [
              NaN,
              NaN,
              NaN,
              NaN,
              (r[0] - o) / l,
              (r[1] - a) / c,
              NaN,
              NaN,
              NaN,
              NaN,
              h,
              f,
              NaN,
              NaN,
              NaN,
              NaN,
              p,
              m,
              NaN,
              NaN,
              NaN,
              NaN,
              (s[0] - o) / l,
              (s[1] - a) / c,
            ],
            w
          ),
            (w += 24);
          for (let y = t.length - 6; y >= 6; y -= 6)
            for (let E = 0; E < 6; E += 2)
              isNaN(t[y + E])
                ? ((g[w] = g[w + 1] = NaN), (w += 2))
                : ((g[w] = t[y + E]), (g[w + 1] = t[y + E + 1]), (w += 2));
          return (
            g.set([NaN, NaN, NaN, NaN, t[4], t[5]], w),
            new Ix(g, u, d(this, uo), d(this, h_), d(this, d_), d(this, u_))
          );
        }
      }
      function rB() {
        const n = d(this, Qe).subarray(4, 6),
          e = d(this, Qe).subarray(16, 18),
          [t, i, r, s] = d(this, uo);
        return [
          (d(this, bh) + (n[0] - e[0]) / 2 - t) / r,
          (d(this, vh) + (n[1] - e[1]) / 2 - i) / s,
          (d(this, bh) + (e[0] - n[0]) / 2 - t) / r,
          (d(this, vh) + (e[1] - n[1]) / 2 - i) / s,
        ];
      }
      var sB = { writable: !0, value: 8 },
        ise = {
          writable: !0,
          value: de(gr, gr, sB) + de(gr, gr, { writable: !0, value: 2 }),
        },
        p_ = new WeakMap(),
        yh = new WeakMap(),
        ka = new WeakMap(),
        Dx = new WeakMap(),
        _r = new WeakMap(),
        Tx = new WeakMap(),
        dn = new WeakMap(),
        wh = new WeakSet(),
        Eh = new WeakSet(),
        oB = new WeakSet();
      class Ix extends iB {
        constructor(e, t, i, r, s, o) {
          super(),
            S(this, oB),
            S(this, Eh),
            S(this, wh),
            v(this, p_, { writable: !0, value: void 0 }),
            v(this, yh, { writable: !0, value: null }),
            v(this, ka, { writable: !0, value: void 0 }),
            v(this, Dx, { writable: !0, value: void 0 }),
            v(this, _r, { writable: !0, value: void 0 }),
            v(this, Tx, { writable: !0, value: void 0 }),
            v(this, dn, { writable: !0, value: void 0 }),
            _(this, dn, e),
            _(this, _r, t),
            _(this, p_, i),
            _(this, Tx, r),
            _(this, ka, s),
            _(this, Dx, o),
            b(this, oB, rse).call(this, o);
          const { x: a, y: l, width: c, height: u } = d(this, yh);
          for (let h = 0, f = e.length; h < f; h += 2)
            (e[h] = (e[h] - a) / c), (e[h + 1] = (e[h + 1] - l) / u);
          for (let h = 0, f = t.length; h < f; h += 2)
            (t[h] = (t[h] - a) / c), (t[h + 1] = (t[h + 1] - l) / u);
        }
        toSVGPath() {
          const e = [`M${d(this, dn)[4]} ${d(this, dn)[5]}`];
          for (let t = 6, i = d(this, dn).length; t < i; t += 6)
            isNaN(d(this, dn)[t])
              ? e.push(`L${d(this, dn)[t + 4]} ${d(this, dn)[t + 5]}`)
              : e.push(
                  `C${d(this, dn)[t]} ${d(this, dn)[t + 1]} ${
                    d(this, dn)[t + 2]
                  } ${d(this, dn)[t + 3]} ${d(this, dn)[t + 4]} ${
                    d(this, dn)[t + 5]
                  }`
                );
          return e.push('Z'), e.join(' ');
        }
        serialize([e, t, i, r], s) {
          const o = i - e,
            a = r - t;
          let l, c;
          switch (s) {
            case 0:
              (l = b(this, wh, m_).call(this, d(this, dn), e, r, o, -a)),
                (c = b(this, wh, m_).call(this, d(this, _r), e, r, o, -a));
              break;
            case 90:
              (l = b(this, Eh, g_).call(this, d(this, dn), e, t, o, a)),
                (c = b(this, Eh, g_).call(this, d(this, _r), e, t, o, a));
              break;
            case 180:
              (l = b(this, wh, m_).call(this, d(this, dn), i, t, -o, a)),
                (c = b(this, wh, m_).call(this, d(this, _r), i, t, -o, a));
              break;
            case 270:
              (l = b(this, Eh, g_).call(this, d(this, dn), i, r, -o, -a)),
                (c = b(this, Eh, g_).call(this, d(this, _r), i, r, -o, -a));
          }
          return { outline: Array.from(l), points: [Array.from(c)] };
        }
        get box() {
          return d(this, yh);
        }
        getNewOutline(e, t) {
          const { x: i, y: r, width: s, height: o } = d(this, yh),
            [a, l, c, u] = d(this, p_),
            h = s * c,
            f = o * u,
            p = i * c + a,
            m = r * u + l,
            g = new gr(
              { x: d(this, _r)[0] * h + p, y: d(this, _r)[1] * f + m },
              d(this, p_),
              d(this, Tx),
              e,
              d(this, Dx),
              t ?? d(this, ka)
            );
          for (let w = 2; w < d(this, _r).length; w += 2)
            g.add({ x: d(this, _r)[w] * h + p, y: d(this, _r)[w + 1] * f + m });
          return g.getOutlines();
        }
      }
      function m_(n, e, t, i, r) {
        const s = new Float64Array(n.length);
        for (let o = 0, a = n.length; o < a; o += 2)
          (s[o] = e + n[o] * i), (s[o + 1] = t + n[o + 1] * r);
        return s;
      }
      function g_(n, e, t, i, r) {
        const s = new Float64Array(n.length);
        for (let o = 0, a = n.length; o < a; o += 2)
          (s[o] = e + n[o + 1] * i), (s[o + 1] = t + n[o] * r);
        return s;
      }
      function rse(n) {
        const e = d(this, dn);
        let t = e[4],
          i = e[5],
          r = t,
          s = i,
          o = t,
          a = i,
          l = t,
          c = i;
        const u = n ? Math.max : Math.min;
        for (let g = 6, w = e.length; g < w; g += 6) {
          if (isNaN(e[g]))
            (r = Math.min(r, e[g + 4])),
              (s = Math.min(s, e[g + 5])),
              (o = Math.max(o, e[g + 4])),
              (a = Math.max(a, e[g + 5])),
              c < e[g + 5]
                ? ((l = e[g + 4]), (c = e[g + 5]))
                : c === e[g + 5] && (l = u(l, e[g + 4]));
          else {
            const y = te.bezierBoundingBox(t, i, ...e.slice(g, g + 6));
            (r = Math.min(r, y[0])),
              (s = Math.min(s, y[1])),
              (o = Math.max(o, y[2])),
              (a = Math.max(a, y[3])),
              c < y[3]
                ? ((l = y[2]), (c = y[3]))
                : c === y[3] && (l = u(l, y[2]));
          }
          (t = e[g + 4]), (i = e[g + 5]);
        }
        const h = r - d(this, ka),
          f = s - d(this, ka),
          p = o - r + 2 * d(this, ka),
          m = a - s + 2 * d(this, ka);
        _(this, yh, { x: h, y: f, width: p, height: m, lastPoint: [l, c] });
      }
      var kx = new WeakMap(),
        Px = new WeakMap(),
        Ms = new WeakMap(),
        Ch = new WeakMap(),
        __ = new WeakMap(),
        En = new WeakMap(),
        Rx = new WeakMap(),
        b_ = new WeakMap(),
        Fx = new WeakMap(),
        Ox = new WeakMap(),
        Ds = new WeakMap(),
        v_ = new WeakMap(),
        Lx = new WeakSet(),
        Nx = new WeakSet(),
        aB = new WeakSet(),
        Pa = new WeakSet(),
        lB = new WeakSet(),
        fo = new WeakMap();
      class Gr {
        static get _keyboardManager() {
          return Ye(
            this,
            '_keyboardManager',
            new zu([
              [
                ['Escape', 'mac+Escape'],
                Gr.prototype._hideDropdownFromKeyboard,
              ],
              [[' ', 'mac+ '], Gr.prototype._colorSelectFromKeyboard],
              [
                ['ArrowDown', 'ArrowRight', 'mac+ArrowDown', 'mac+ArrowRight'],
                Gr.prototype._moveToNext,
              ],
              [
                ['ArrowUp', 'ArrowLeft', 'mac+ArrowUp', 'mac+ArrowLeft'],
                Gr.prototype._moveToPrevious,
              ],
              [['Home', 'mac+Home'], Gr.prototype._moveToBeginning],
              [['End', 'mac+End'], Gr.prototype._moveToEnd],
            ])
          );
        }
        constructor({ editor: e = null, uiManager: t = null }) {
          v(this, fo, { get: ase, set: void 0 }),
            S(this, lB),
            S(this, Pa),
            S(this, aB),
            S(this, Nx),
            S(this, Lx),
            v(this, kx, { writable: !0, value: b(this, aB, sse).bind(this) }),
            v(this, Px, { writable: !0, value: b(this, lB, ose).bind(this) }),
            v(this, Ms, { writable: !0, value: null }),
            v(this, Ch, { writable: !0, value: null }),
            v(this, __, { writable: !0, value: void 0 }),
            v(this, En, { writable: !0, value: null }),
            v(this, Rx, { writable: !0, value: !1 }),
            v(this, b_, { writable: !0, value: !1 }),
            v(this, Fx, { writable: !0, value: null }),
            v(this, Ox, { writable: !0, value: void 0 }),
            v(this, Ds, { writable: !0, value: null }),
            v(this, v_, { writable: !0, value: void 0 }),
            e
              ? (_(this, b_, !1),
                _(this, v_, Ee.HIGHLIGHT_COLOR),
                _(this, Fx, e))
              : (_(this, b_, !0), _(this, v_, Ee.HIGHLIGHT_DEFAULT_COLOR)),
            _(this, Ds, e?._uiManager || t),
            _(this, Ox, d(this, Ds)._eventBus),
            _(
              this,
              __,
              e?.color ||
                d(this, Ds)?.highlightColors.values().next().value ||
                '#FFFF98'
            );
        }
        renderButton() {
          const e = _(this, Ms, document.createElement('button'));
          (e.className = 'colorPicker'),
            (e.tabIndex = '0'),
            e.setAttribute('data-l10n-id', 'pdfjs-editor-colorpicker-button'),
            e.setAttribute('aria-haspopup', !0);
          const t = d(this, Ds)._signal;
          e.addEventListener('click', b(this, Pa, vc).bind(this), {
            signal: t,
          }),
            e.addEventListener('keydown', d(this, kx), { signal: t });
          const i = _(this, Ch, document.createElement('span'));
          return (
            (i.className = 'swatch'),
            i.setAttribute('aria-hidden', !0),
            (i.style.backgroundColor = d(this, __)),
            e.append(i),
            e
          );
        }
        renderMainDropdown() {
          const e = _(this, En, b(this, Lx, cB).call(this));
          return (
            e.setAttribute('aria-orientation', 'horizontal'),
            e.setAttribute('aria-labelledby', 'highlightColorPickerLabel'),
            e
          );
        }
        _colorSelectFromKeyboard(e) {
          if (e.target === d(this, Ms))
            return void b(this, Pa, vc).call(this, e);
          const t = e.target.getAttribute('data-color');
          t && b(this, Nx, dB).call(this, t, e);
        }
        _moveToNext(e) {
          d(this, fo)
            ? e.target !== d(this, Ms)
              ? e.target.nextSibling?.focus()
              : d(this, En).firstChild?.focus()
            : b(this, Pa, vc).call(this, e);
        }
        _moveToPrevious(e) {
          e.target !== d(this, En)?.firstChild && e.target !== d(this, Ms)
            ? (d(this, fo) || b(this, Pa, vc).call(this, e),
              e.target.previousSibling?.focus())
            : d(this, fo) && this._hideDropdownFromKeyboard();
        }
        _moveToBeginning(e) {
          d(this, fo)
            ? d(this, En).firstChild?.focus()
            : b(this, Pa, vc).call(this, e);
        }
        _moveToEnd(e) {
          d(this, fo)
            ? d(this, En).lastChild?.focus()
            : b(this, Pa, vc).call(this, e);
        }
        hideDropdown() {
          d(this, En)?.classList.add('hidden'),
            window.removeEventListener('pointerdown', d(this, Px));
        }
        _hideDropdownFromKeyboard() {
          if (!d(this, b_)) {
            if (!d(this, fo)) return void d(this, Fx)?.unselect();
            this.hideDropdown(),
              d(this, Ms).focus({
                preventScroll: !0,
                focusVisible: d(this, Rx),
              });
          }
        }
        updateColor(e) {
          if (
            (d(this, Ch) && (d(this, Ch).style.backgroundColor = e),
            !d(this, En))
          )
            return;
          const t = d(this, Ds).highlightColors.values();
          for (const i of d(this, En).children)
            i.setAttribute('aria-selected', t.next().value === e);
        }
        destroy() {
          d(this, Ms)?.remove(),
            _(this, Ms, null),
            _(this, Ch, null),
            d(this, En)?.remove(),
            _(this, En, null);
        }
      }
      function cB() {
        const n = document.createElement('div'),
          e = d(this, Ds)._signal;
        n.addEventListener('contextmenu', fi, { signal: e }),
          (n.className = 'dropdown'),
          (n.role = 'listbox'),
          n.setAttribute('aria-multiselectable', !1),
          n.setAttribute('aria-orientation', 'vertical'),
          n.setAttribute('data-l10n-id', 'pdfjs-editor-colorpicker-dropdown');
        for (const [t, i] of d(this, Ds).highlightColors) {
          const r = document.createElement('button');
          (r.tabIndex = '0'),
            (r.role = 'option'),
            r.setAttribute('data-color', i),
            (r.title = t),
            r.setAttribute('data-l10n-id', `pdfjs-editor-colorpicker-${t}`);
          const s = document.createElement('span');
          r.append(s),
            (s.className = 'swatch'),
            (s.style.backgroundColor = i),
            r.setAttribute('aria-selected', i === d(this, __)),
            r.addEventListener('click', b(this, Nx, dB).bind(this, i), {
              signal: e,
            }),
            n.append(r);
        }
        return n.addEventListener('keydown', d(this, kx), { signal: e }), n;
      }
      function dB(n, e) {
        e.stopPropagation(),
          d(this, Ox).dispatch('switchannotationeditorparams', {
            source: this,
            type: d(this, v_),
            value: n,
          });
      }
      function sse(n) {
        Gr._keyboardManager.exec(this, n);
      }
      function vc(n) {
        if (d(this, fo)) return void this.hideDropdown();
        if (
          (_(this, Rx, 0 === n.detail),
          window.addEventListener('pointerdown', d(this, Px), {
            signal: d(this, Ds)._signal,
          }),
          d(this, En))
        )
          return void d(this, En).classList.remove('hidden');
        const e = _(this, En, b(this, Lx, cB).call(this));
        d(this, Ms).append(e);
      }
      function ose(n) {
        d(this, En)?.contains(n.target) || this.hideDropdown();
      }
      function ase() {
        return d(this, En) && !d(this, En).classList.contains('hidden');
      }
      var y_ = new WeakMap(),
        Vx = new WeakMap(),
        yc = new WeakMap(),
        xh = new WeakMap(),
        w_ = new WeakMap(),
        qr = new WeakMap(),
        Bx = new WeakMap(),
        Hx = new WeakMap(),
        Ah = new WeakMap(),
        Ts = new WeakMap(),
        Vi = new WeakMap(),
        br = new WeakMap(),
        uB = new WeakMap(),
        E_ = new WeakMap(),
        Sh = new WeakMap(),
        Cn = new WeakMap(),
        C_ = new WeakMap(),
        po = new WeakMap(),
        Wx = new WeakMap(),
        jx = new WeakSet(),
        zx = new WeakSet(),
        hB = new WeakSet(),
        fB = new WeakSet(),
        pB = new WeakSet(),
        Ux = new WeakSet(),
        Mh = new WeakSet(),
        mB = new WeakSet(),
        x_ = new WeakSet(),
        Dh = new WeakSet(),
        gB = new WeakSet(),
        _B = new WeakSet();
      class Re extends re {
        static get _keyboardManager() {
          const e = Re.prototype;
          return Ye(
            this,
            '_keyboardManager',
            new zu([
              [['ArrowLeft', 'mac+ArrowLeft'], e._moveCaret, { args: [0] }],
              [['ArrowRight', 'mac+ArrowRight'], e._moveCaret, { args: [1] }],
              [['ArrowUp', 'mac+ArrowUp'], e._moveCaret, { args: [2] }],
              [['ArrowDown', 'mac+ArrowDown'], e._moveCaret, { args: [3] }],
            ])
          );
        }
        constructor(e) {
          super({ ...e, name: 'highlightEditor' }),
            S(this, _B),
            S(this, gB),
            S(this, Dh),
            S(this, x_),
            S(this, mB),
            S(this, Mh),
            S(this, Ux),
            S(this, pB),
            S(this, fB),
            S(this, hB),
            S(this, zx),
            S(this, jx),
            v(this, y_, { writable: !0, value: null }),
            v(this, Vx, { writable: !0, value: 0 }),
            v(this, yc, { writable: !0, value: void 0 }),
            v(this, xh, { writable: !0, value: null }),
            v(this, w_, { writable: !0, value: null }),
            v(this, qr, { writable: !0, value: null }),
            v(this, Bx, { writable: !0, value: null }),
            v(this, Hx, { writable: !0, value: 0 }),
            v(this, Ah, { writable: !0, value: null }),
            v(this, Ts, { writable: !0, value: null }),
            v(this, Vi, { writable: !0, value: null }),
            v(this, br, { writable: !0, value: !1 }),
            v(this, uB, { writable: !0, value: b(this, mB, use).bind(this) }),
            v(this, E_, { writable: !0, value: null }),
            v(this, Sh, { writable: !0, value: void 0 }),
            v(this, Cn, { writable: !0, value: null }),
            v(this, C_, { writable: !0, value: '' }),
            v(this, po, { writable: !0, value: void 0 }),
            v(this, Wx, { writable: !0, value: '' }),
            (this.color = e.color || Re._defaultColor),
            _(this, po, e.thickness || Re._defaultThickness),
            _(this, Sh, e.opacity || Re._defaultOpacity),
            _(this, yc, e.boxes || null),
            _(this, Wx, e.methodOfCreation || ''),
            _(this, C_, e.text || ''),
            (this._isDraggable = !1),
            e.highlightId > -1
              ? (_(this, br, !0),
                b(this, zx, vB).call(this, e),
                b(this, Mh, A_).call(this))
              : (_(this, y_, e.anchorNode),
                _(this, Vx, e.anchorOffset),
                _(this, Bx, e.focusNode),
                _(this, Hx, e.focusOffset),
                b(this, jx, bB).call(this),
                b(this, Mh, A_).call(this),
                this.rotate(this.rotation));
        }
        get telemetryInitialData() {
          return {
            action: 'added',
            type: d(this, br) ? 'free_highlight' : 'highlight',
            color: this._uiManager.highlightColorNames.get(this.color),
            thickness: d(this, po),
            methodOfCreation: d(this, Wx),
          };
        }
        get telemetryFinalData() {
          return {
            type: 'highlight',
            color: this._uiManager.highlightColorNames.get(this.color),
          };
        }
        static computeTelemetryFinalData(e) {
          return { numberOfColors: e.get('color').size };
        }
        static initialize(e, t) {
          re.initialize(e, t),
            (Re._defaultColor ||=
              t.highlightColors?.values().next().value || '#fff066');
        }
        static updateDefaultParams(e, t) {
          switch (e) {
            case Ee.HIGHLIGHT_DEFAULT_COLOR:
              Re._defaultColor = t;
              break;
            case Ee.HIGHLIGHT_THICKNESS:
              Re._defaultThickness = t;
          }
        }
        translateInPage(e, t) {}
        get toolbarPosition() {
          return d(this, E_);
        }
        updateParams(e, t) {
          switch (e) {
            case Ee.HIGHLIGHT_COLOR:
              b(this, hB, lse).call(this, t);
              break;
            case Ee.HIGHLIGHT_THICKNESS:
              b(this, fB, cse).call(this, t);
          }
        }
        static get defaultPropertiesToUpdate() {
          return [
            [Ee.HIGHLIGHT_DEFAULT_COLOR, Re._defaultColor],
            [Ee.HIGHLIGHT_THICKNESS, Re._defaultThickness],
          ];
        }
        get propertiesToUpdate() {
          return [
            [Ee.HIGHLIGHT_COLOR, this.color || Re._defaultColor],
            [Ee.HIGHLIGHT_THICKNESS, d(this, po) || Re._defaultThickness],
            [Ee.HIGHLIGHT_FREE, d(this, br)],
          ];
        }
        addEditToolbar() {
          var e = () => super.addEditToolbar,
            t = this;
          return U(function* () {
            const i = yield e().call(t);
            return i
              ? (t._uiManager.highlightColors &&
                  (_(t, w_, new Gr({ editor: t })), i.addColorPicker(d(t, w_))),
                i)
              : null;
          })();
        }
        disableEditing() {
          super.disableEditing(), this.div.classList.toggle('disabled', !0);
        }
        enableEditing() {
          super.enableEditing(), this.div.classList.toggle('disabled', !1);
        }
        fixAndSetPosition() {
          return super.fixAndSetPosition(b(this, Dh, S_).call(this));
        }
        getBaseTranslation() {
          return [0, 0];
        }
        getRect(e, t) {
          return super.getRect(e, t, b(this, Dh, S_).call(this));
        }
        onceAdded() {
          this.parent.addUndoableEditor(this), this.div.focus();
        }
        remove() {
          b(this, Ux, yB).call(this),
            this._reportTelemetry({ action: 'deleted' }),
            super.remove();
        }
        rebuild() {
          this.parent &&
            (super.rebuild(),
            null !== this.div &&
              (b(this, Mh, A_).call(this),
              this.isAttachedToDOM || this.parent.add(this)));
        }
        setParent(e) {
          let t = !1;
          this.parent && !e
            ? b(this, Ux, yB).call(this)
            : e &&
              (b(this, Mh, A_).call(this, e),
              (t =
                !this.parent &&
                this.div?.classList.contains('selectedEditor'))),
            super.setParent(e),
            this.show(this._isVisible),
            t && this.select();
        }
        rotate(e) {
          const { drawLayer: t } = this.parent;
          let i;
          d(this, br)
            ? ((e = (e - this.rotation + 360) % 360),
              (i = we(Re, Re, Th).call(Re, d(this, Ts).box, e)))
            : (i = we(Re, Re, Th).call(Re, this, e)),
            t.rotate(d(this, Vi), e),
            t.rotate(d(this, Cn), e),
            t.updateBox(d(this, Vi), i),
            t.updateBox(
              d(this, Cn),
              we(Re, Re, Th).call(Re, d(this, qr).box, e)
            );
        }
        render() {
          if (this.div) return this.div;
          const e = super.render();
          d(this, C_) &&
            (e.setAttribute('aria-label', d(this, C_)),
            e.setAttribute('role', 'mark')),
            d(this, br)
              ? e.classList.add('free')
              : this.div.addEventListener('keydown', d(this, uB), {
                  signal: this._uiManager._signal,
                });
          const t = _(this, Ah, document.createElement('div'));
          e.append(t),
            t.setAttribute('aria-hidden', 'true'),
            (t.className = 'internal'),
            (t.style.clipPath = d(this, xh));
          const [i, r] = this.parentDimensions;
          return (
            this.setDims(this.width * i, this.height * r),
            vg(this, d(this, Ah), ['pointerover', 'pointerleave']),
            this.enableEditing(),
            e
          );
        }
        pointerover() {
          this.parent.drawLayer.addClass(d(this, Cn), 'hovered');
        }
        pointerleave() {
          this.parent.drawLayer.removeClass(d(this, Cn), 'hovered');
        }
        _moveCaret(e) {
          switch ((this.parent.unselect(this), e)) {
            case 0:
            case 2:
              b(this, x_, $x).call(this, !0);
              break;
            case 1:
            case 3:
              b(this, x_, $x).call(this, !1);
          }
        }
        select() {
          super.select(),
            d(this, Cn) &&
              (this.parent?.drawLayer.removeClass(d(this, Cn), 'hovered'),
              this.parent?.drawLayer.addClass(d(this, Cn), 'selected'));
        }
        unselect() {
          super.unselect(),
            d(this, Cn) &&
              (this.parent?.drawLayer.removeClass(d(this, Cn), 'selected'),
              d(this, br) || b(this, x_, $x).call(this, !1));
        }
        get _mustFixPosition() {
          return !d(this, br);
        }
        show(e = this._isVisible) {
          super.show(e),
            this.parent &&
              (this.parent.drawLayer.show(d(this, Vi), e),
              this.parent.drawLayer.show(d(this, Cn), e));
        }
        static startHighlighting(e, t, { target: i, x: r, y: s }) {
          const { x: o, y: a, width: l, height: c } = i.getBoundingClientRect(),
            u = (g) => {
              we(this, Re, pse).call(this, e, g);
            },
            h = e._signal,
            f = { capture: !0, passive: !1, signal: h },
            p = (g) => {
              g.preventDefault(), g.stopPropagation();
            },
            m = (g) => {
              i.removeEventListener('pointermove', u),
                window.removeEventListener('blur', m),
                window.removeEventListener('pointerup', m),
                window.removeEventListener('pointerdown', p, f),
                window.removeEventListener('contextmenu', fi),
                we(this, Re, mse).call(this, e, g);
            };
          window.addEventListener('blur', m, { signal: h }),
            window.addEventListener('pointerup', m, { signal: h }),
            window.addEventListener('pointerdown', p, f),
            window.addEventListener('contextmenu', fi, { signal: h }),
            i.addEventListener('pointermove', u, { signal: h }),
            (this._freeHighlight = new gr(
              { x: r, y: s },
              [o, a, l, c],
              e.scale,
              this._defaultThickness / 2,
              t,
              0.001
            )),
            ({
              id: this._freeHighlightId,
              clipPathId: this._freeHighlightClipId,
            } = e.drawLayer.highlight(
              this._freeHighlight,
              this._defaultColor,
              this._defaultOpacity,
              !0
            ));
        }
        static deserialize(e, t, i) {
          const r = super.deserialize(e, t, i),
            {
              rect: [s, o, a, l],
              color: c,
              quadPoints: u,
            } = e;
          (r.color = te.makeHexColor(...c)), _(r, Sh, e.opacity);
          const [h, f] = r.pageDimensions;
          (r.width = (a - s) / h), (r.height = (l - o) / f);
          const p = _(r, yc, []);
          for (let m = 0; m < u.length; m += 8)
            p.push({
              x: (u[4] - a) / h,
              y: (l - (1 - u[m + 5])) / f,
              width: (u[m + 2] - u[m]) / h,
              height: (u[m + 5] - u[m + 1]) / f,
            });
          return b(r, jx, bB).call(r), r;
        }
        serialize(e = !1) {
          if (this.isEmpty() || e) return null;
          const t = this.getRect(0, 0),
            i = re._colorManager.convert(this.color);
          return {
            annotationType: $e.HIGHLIGHT,
            color: i,
            opacity: d(this, Sh),
            thickness: d(this, po),
            quadPoints: b(this, gB, hse).call(this),
            outlines: b(this, _B, fse).call(this, t),
            pageIndex: this.pageIndex,
            rect: t,
            rotation: b(this, Dh, S_).call(this),
            structTreeParentId: this._structTreeParentId,
          };
        }
        static canCreateNewEmptyEditor() {
          return !1;
        }
      }
      function bB() {
        const n = new tB(d(this, yc), 0.001);
        _(this, Ts, n.getOutlines()),
          ({
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
          } = d(this, Ts).box);
        const e = new tB(
          d(this, yc),
          0.0025,
          0.001,
          'ltr' === this._uiManager.direction
        );
        _(this, qr, e.getOutlines());
        const { lastPoint: t } = d(this, qr).box;
        _(this, E_, [
          (t[0] - this.x) / this.width,
          (t[1] - this.y) / this.height,
        ]);
      }
      function vB({ highlightOutlines: n, highlightId: e, clipPathId: t }) {
        if (
          (_(this, Ts, n),
          _(this, qr, n.getNewOutline(d(this, po) / 2 + 1.5, 0.0025)),
          e >= 0)
        )
          _(this, Vi, e),
            _(this, xh, t),
            this.parent.drawLayer.finalizeLine(e, n),
            _(this, Cn, this.parent.drawLayer.highlightOutline(d(this, qr)));
        else if (this.parent) {
          const c = this.parent.viewport.rotation;
          this.parent.drawLayer.updateLine(d(this, Vi), n),
            this.parent.drawLayer.updateBox(
              d(this, Vi),
              we(Re, Re, Th).call(
                Re,
                d(this, Ts).box,
                (c - this.rotation + 360) % 360
              )
            ),
            this.parent.drawLayer.updateLine(d(this, Cn), d(this, qr)),
            this.parent.drawLayer.updateBox(
              d(this, Cn),
              we(Re, Re, Th).call(Re, d(this, qr).box, c)
            );
        }
        const { x: r, y: s, width: o, height: a } = n.box;
        switch (this.rotation) {
          case 0:
            (this.x = r), (this.y = s), (this.width = o), (this.height = a);
            break;
          case 90: {
            const [c, u] = this.parentDimensions;
            (this.x = s),
              (this.y = 1 - r),
              (this.width = (o * u) / c),
              (this.height = (a * c) / u);
            break;
          }
          case 180:
            (this.x = 1 - r),
              (this.y = 1 - s),
              (this.width = o),
              (this.height = a);
            break;
          case 270: {
            const [c, u] = this.parentDimensions;
            (this.x = 1 - s),
              (this.y = r),
              (this.width = (o * u) / c),
              (this.height = (a * c) / u);
            break;
          }
        }
        const { lastPoint: l } = d(this, qr).box;
        _(this, E_, [(l[0] - r) / o, (l[1] - s) / a]);
      }
      function lse(n) {
        const e = (i) => {
            (this.color = i),
              this.parent?.drawLayer.changeColor(d(this, Vi), i),
              d(this, w_)?.updateColor(i);
          },
          t = this.color;
        this.addCommands({
          cmd: e.bind(this, n),
          undo: e.bind(this, t),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: !0,
          type: Ee.HIGHLIGHT_COLOR,
          overwriteIfSameType: !0,
          keepUndo: !0,
        }),
          this._reportTelemetry(
            {
              action: 'color_changed',
              color: this._uiManager.highlightColorNames.get(n),
            },
            !0
          );
      }
      function cse(n) {
        const e = d(this, po),
          t = (i) => {
            _(this, po, i), b(this, pB, dse).call(this, i);
          };
        this.addCommands({
          cmd: t.bind(this, n),
          undo: t.bind(this, e),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: !0,
          type: Ee.INK_THICKNESS,
          overwriteIfSameType: !0,
          keepUndo: !0,
        }),
          this._reportTelemetry(
            { action: 'thickness_changed', thickness: n },
            !0
          );
      }
      function dse(n) {
        if (!d(this, br)) return;
        b(this, zx, vB).call(this, {
          highlightOutlines: d(this, Ts).getNewOutline(n / 2),
        }),
          this.fixAndSetPosition();
        const [e, t] = this.parentDimensions;
        this.setDims(this.width * e, this.height * t);
      }
      function yB() {
        null === d(this, Vi) ||
          !this.parent ||
          (this.parent.drawLayer.remove(d(this, Vi)),
          _(this, Vi, null),
          this.parent.drawLayer.remove(d(this, Cn)),
          _(this, Cn, null));
      }
      function A_(n = this.parent) {
        null === d(this, Vi) &&
          (({ id: eg(this, Vi).value, clipPathId: eg(this, xh).value } =
            n.drawLayer.highlight(d(this, Ts), this.color, d(this, Sh))),
          _(this, Cn, n.drawLayer.highlightOutline(d(this, qr))),
          d(this, Ah) && (d(this, Ah).style.clipPath = d(this, xh)));
      }
      function Th({ x: n, y: e, width: t, height: i }, r) {
        switch (r) {
          case 90:
            return { x: 1 - e - i, y: n, width: i, height: t };
          case 180:
            return { x: 1 - n - t, y: 1 - e - i, width: t, height: i };
          case 270:
            return { x: e, y: 1 - n - t, width: i, height: t };
        }
        return { x: n, y: e, width: t, height: i };
      }
      function use(n) {
        Re._keyboardManager.exec(this, n);
      }
      function $x(n) {
        if (!d(this, y_)) return;
        const e = window.getSelection();
        n
          ? e.setPosition(d(this, y_), d(this, Vx))
          : e.setPosition(d(this, Bx), d(this, Hx));
      }
      function S_() {
        return d(this, br) ? this.rotation : 0;
      }
      function hse() {
        if (d(this, br)) return null;
        const [n, e] = this.pageDimensions,
          [t, i] = this.pageTranslation,
          r = d(this, yc),
          s = new Float32Array(8 * r.length);
        let o = 0;
        for (const { x: a, y: l, width: c, height: u } of r) {
          const h = a * n + t,
            f = (1 - l - u) * e + i;
          (s[o] = s[o + 4] = h),
            (s[o + 1] = s[o + 3] = f),
            (s[o + 2] = s[o + 6] = h + c * n),
            (s[o + 5] = s[o + 7] = f + u * e),
            (o += 8);
        }
        return s;
      }
      function fse(n) {
        return d(this, Ts).serialize(n, b(this, Dh, S_).call(this));
      }
      function pse(n, e) {
        this._freeHighlight.add(e) &&
          n.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
      }
      function mse(n, e) {
        this._freeHighlight.isEmpty()
          ? n.drawLayer.removeFreeHighlight(this._freeHighlightId)
          : n.createAndAddNewEditor(e, !1, {
              highlightId: this._freeHighlightId,
              highlightOutlines: this._freeHighlight.getOutlines(),
              clipPathId: this._freeHighlightClipId,
              methodOfCreation: 'main_toolbar',
            }),
          (this._freeHighlightId = -1),
          (this._freeHighlight = null),
          (this._freeHighlightClipId = '');
      }
      Se(Re, '_defaultColor', null),
        Se(Re, '_defaultOpacity', 1),
        Se(Re, '_defaultThickness', 12),
        Se(Re, '_l10nPromise', void 0),
        Se(Re, '_type', 'highlight'),
        Se(Re, '_editorType', $e.HIGHLIGHT),
        Se(Re, '_freeHighlightId', -1),
        Se(Re, '_freeHighlight', null),
        Se(Re, '_freeHighlightClipId', '');
      var Ih = new WeakMap(),
        kh = new WeakMap(),
        Gx = new WeakMap(),
        qx = new WeakMap(),
        Xx = new WeakMap(),
        Ph = new WeakMap(),
        mo = new WeakMap(),
        Ra = new WeakMap(),
        Xr = new WeakMap(),
        Rh = new WeakMap(),
        Fh = new WeakMap(),
        Fa = new WeakMap(),
        Oh = new WeakMap(),
        Lh = new WeakMap(),
        wc = new WeakMap(),
        wB = new WeakSet(),
        EB = new WeakSet(),
        CB = new WeakSet(),
        xB = new WeakSet(),
        Yx = new WeakSet(),
        AB = new WeakSet(),
        Kx = new WeakSet(),
        SB = new WeakSet(),
        MB = new WeakSet(),
        DB = new WeakSet(),
        TB = new WeakSet(),
        IB = new WeakSet(),
        Oa = new WeakSet(),
        Zx = new WeakSet(),
        M_ = new WeakSet(),
        D_ = new WeakSet(),
        Ec = new WeakSet(),
        Qx = new WeakSet(),
        T_ = new WeakSet(),
        kB = new WeakSet(),
        Jx = new WeakSet(),
        I_ = new WeakSet(),
        Nh = new WeakSet();
      class gt extends re {
        constructor(e) {
          super({ ...e, name: 'inkEditor' }),
            S(this, Nh),
            S(this, I_),
            S(this, Jx),
            S(this, kB),
            S(this, T_),
            S(this, Qx),
            S(this, Ec),
            S(this, D_),
            S(this, M_),
            S(this, Zx),
            S(this, Oa),
            S(this, IB),
            S(this, TB),
            S(this, DB),
            S(this, MB),
            S(this, SB),
            S(this, Kx),
            S(this, AB),
            S(this, Yx),
            S(this, xB),
            S(this, CB),
            S(this, EB),
            S(this, wB),
            v(this, Ih, { writable: !0, value: 0 }),
            v(this, kh, { writable: !0, value: 0 }),
            v(this, Gx, {
              writable: !0,
              value: this.canvasPointermove.bind(this),
            }),
            v(this, qx, {
              writable: !0,
              value: this.canvasPointerleave.bind(this),
            }),
            v(this, Xx, {
              writable: !0,
              value: this.canvasPointerup.bind(this),
            }),
            v(this, Ph, {
              writable: !0,
              value: this.canvasPointerdown.bind(this),
            }),
            v(this, mo, { writable: !0, value: null }),
            v(this, Ra, { writable: !0, value: new Path2D() }),
            v(this, Xr, { writable: !0, value: !1 }),
            v(this, Rh, { writable: !0, value: !1 }),
            v(this, Fh, { writable: !0, value: !1 }),
            v(this, Fa, { writable: !0, value: null }),
            v(this, Oh, { writable: !0, value: 0 }),
            v(this, Lh, { writable: !0, value: 0 }),
            v(this, wc, { writable: !0, value: null }),
            (this.color = e.color || null),
            (this.thickness = e.thickness || null),
            (this.opacity = e.opacity || null),
            (this.paths = []),
            (this.bezierPath2D = []),
            (this.allRawPaths = []),
            (this.currentPath = []),
            (this.scaleFactor = 1),
            (this.translationX = this.translationY = 0),
            (this.x = 0),
            (this.y = 0),
            (this._willKeepAspectRatio = !0);
        }
        static initialize(e, t) {
          re.initialize(e, t);
        }
        static updateDefaultParams(e, t) {
          switch (e) {
            case Ee.INK_THICKNESS:
              gt._defaultThickness = t;
              break;
            case Ee.INK_COLOR:
              gt._defaultColor = t;
              break;
            case Ee.INK_OPACITY:
              gt._defaultOpacity = t / 100;
          }
        }
        updateParams(e, t) {
          switch (e) {
            case Ee.INK_THICKNESS:
              b(this, wB, gse).call(this, t);
              break;
            case Ee.INK_COLOR:
              b(this, EB, _se).call(this, t);
              break;
            case Ee.INK_OPACITY:
              b(this, CB, bse).call(this, t);
          }
        }
        static get defaultPropertiesToUpdate() {
          return [
            [Ee.INK_THICKNESS, gt._defaultThickness],
            [Ee.INK_COLOR, gt._defaultColor || re._defaultLineColor],
            [Ee.INK_OPACITY, Math.round(100 * gt._defaultOpacity)],
          ];
        }
        get propertiesToUpdate() {
          return [
            [Ee.INK_THICKNESS, this.thickness || gt._defaultThickness],
            [
              Ee.INK_COLOR,
              this.color || gt._defaultColor || re._defaultLineColor,
            ],
            [
              Ee.INK_OPACITY,
              Math.round(100 * (this.opacity ?? gt._defaultOpacity)),
            ],
          ];
        }
        rebuild() {
          this.parent &&
            (super.rebuild(),
            null !== this.div &&
              (this.canvas ||
                (b(this, M_, eA).call(this), b(this, D_, tA).call(this)),
              this.isAttachedToDOM ||
                (this.parent.add(this), b(this, Ec, Vh).call(this)),
              b(this, Nh, k_).call(this)));
        }
        remove() {
          null !== this.canvas &&
            (this.isEmpty() || this.commit(),
            (this.canvas.width = this.canvas.height = 0),
            this.canvas.remove(),
            (this.canvas = null),
            d(this, mo) && (clearTimeout(d(this, mo)), _(this, mo, null)),
            d(this, Fa)?.disconnect(),
            _(this, Fa, null),
            super.remove());
        }
        setParent(e) {
          !this.parent && e
            ? this._uiManager.removeShouldRescale(this)
            : this.parent &&
              null === e &&
              this._uiManager.addShouldRescale(this),
            super.setParent(e);
        }
        onScaleChanging() {
          const [e, t] = this.parentDimensions;
          this.setDimensions(this.width * e, this.height * t);
        }
        enableEditMode() {
          d(this, Xr) ||
            null === this.canvas ||
            (super.enableEditMode(),
            (this._isDraggable = !1),
            this.canvas.addEventListener('pointerdown', d(this, Ph), {
              signal: this._uiManager._signal,
            }));
        }
        disableEditMode() {
          !this.isInEditMode() ||
            null === this.canvas ||
            (super.disableEditMode(),
            (this._isDraggable = !this.isEmpty()),
            this.div.classList.remove('editing'),
            this.canvas.removeEventListener('pointerdown', d(this, Ph)));
        }
        onceAdded() {
          this._isDraggable = !this.isEmpty();
        }
        isEmpty() {
          return (
            0 === this.paths.length ||
            (1 === this.paths.length && 0 === this.paths[0].length)
          );
        }
        commit() {
          d(this, Xr) ||
            (super.commit(),
            (this.isEditing = !1),
            this.disableEditMode(),
            this.setInForeground(),
            _(this, Xr, !0),
            this.div.classList.add('disabled'),
            b(this, Nh, k_).call(this, !0),
            this.select(),
            this.parent.addInkEditorIfNeeded(!0),
            this.moveInDOM(),
            this.div.focus({ preventScroll: !0 }));
        }
        focusin(e) {
          this._focusEventsAllowed && (super.focusin(e), this.enableEditMode());
        }
        canvasPointerdown(e) {
          0 !== e.button ||
            !this.isInEditMode() ||
            d(this, Xr) ||
            (this.setInForeground(),
            e.preventDefault(),
            this.div.contains(document.activeElement) ||
              this.div.focus({ preventScroll: !0 }),
            b(this, AB, yse).call(this, e.offsetX, e.offsetY));
        }
        canvasPointermove(e) {
          e.preventDefault(), b(this, Kx, RB).call(this, e.offsetX, e.offsetY);
        }
        canvasPointerup(e) {
          e.preventDefault(), b(this, Zx, FB).call(this, e);
        }
        canvasPointerleave(e) {
          b(this, Zx, FB).call(this, e);
        }
        get isResizable() {
          return !this.isEmpty() && d(this, Xr);
        }
        render() {
          if (this.div) return this.div;
          let e, t;
          this.width && ((e = this.x), (t = this.y)),
            super.render(),
            this.div.setAttribute('data-l10n-id', 'pdfjs-ink');
          const [i, r, s, o] = b(this, xB, vse).call(this);
          if (
            (this.setAt(i, r, 0, 0),
            this.setDims(s, o),
            b(this, M_, eA).call(this),
            this.width)
          ) {
            const [a, l] = this.parentDimensions;
            this.setAspectRatio(this.width * a, this.height * l),
              this.setAt(e * a, t * l, this.width * a, this.height * l),
              _(this, Fh, !0),
              b(this, Ec, Vh).call(this),
              this.setDims(this.width * a, this.height * l),
              b(this, Oa, Cc).call(this),
              this.div.classList.add('disabled');
          } else this.div.classList.add('editing'), this.enableEditMode();
          return b(this, D_, tA).call(this), this.div;
        }
        setDimensions(e, t) {
          const i = Math.round(e),
            r = Math.round(t);
          if (d(this, Oh) === i && d(this, Lh) === r) return;
          _(this, Oh, i),
            _(this, Lh, r),
            (this.canvas.style.visibility = 'hidden');
          const [s, o] = this.parentDimensions;
          (this.width = e / s),
            (this.height = t / o),
            this.fixAndSetPosition(),
            d(this, Xr) && b(this, Qx, OB).call(this, e, t),
            b(this, Ec, Vh).call(this),
            b(this, Oa, Cc).call(this),
            (this.canvas.style.visibility = 'visible'),
            this.fixDims();
        }
        static deserialize(e, t, i) {
          if (e instanceof WV) return null;
          const r = super.deserialize(e, t, i);
          (r.thickness = e.thickness),
            (r.color = te.makeHexColor(...e.color)),
            (r.opacity = e.opacity);
          const [s, o] = r.pageDimensions,
            a = r.width * s,
            l = r.height * o,
            c = r.parentScale,
            u = e.thickness / 2;
          _(r, Xr, !0), _(r, Oh, Math.round(a)), _(r, Lh, Math.round(l));
          const { paths: h, rect: f, rotation: p } = e;
          for (let { bezier: g } of h) {
            g = we(gt, gt, Mse).call(gt, g, f, p);
            const w = [];
            r.paths.push(w);
            let y = c * (g[0] - u),
              E = c * (g[1] - u);
            for (let M = 2, T = g.length; M < T; M += 6) {
              const C = c * (g[M + 4] - u),
                R = c * (g[M + 5] - u);
              w.push([
                [y, E],
                [c * (g[M] - u), c * (g[M + 1] - u)],
                [c * (g[M + 2] - u), c * (g[M + 3] - u)],
                [C, R],
              ]),
                (y = C),
                (E = R);
            }
            const A = we(this, gt, Sse).call(this, w);
            r.bezierPath2D.push(A);
          }
          const m = b(r, Jx, NB).call(r);
          return (
            _(r, kh, Math.max(re.MIN_SIZE, m[2] - m[0])),
            _(r, Ih, Math.max(re.MIN_SIZE, m[3] - m[1])),
            b(r, Qx, OB).call(r, a, l),
            r
          );
        }
        serialize() {
          if (this.isEmpty()) return null;
          const e = this.getRect(0, 0),
            t = re._colorManager.convert(this.ctx.strokeStyle);
          return {
            annotationType: $e.INK,
            color: t,
            thickness: this.thickness,
            opacity: this.opacity,
            paths: b(this, kB, Dse).call(
              this,
              this.scaleFactor / this.parentScale,
              this.translationX,
              this.translationY,
              e
            ),
            pageIndex: this.pageIndex,
            rect: e,
            rotation: this.rotation,
            structTreeParentId: this._structTreeParentId,
          };
        }
      }
      function gse(n) {
        const e = (i) => {
            (this.thickness = i), b(this, Nh, k_).call(this);
          },
          t = this.thickness;
        this.addCommands({
          cmd: e.bind(this, n),
          undo: e.bind(this, t),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: !0,
          type: Ee.INK_THICKNESS,
          overwriteIfSameType: !0,
          keepUndo: !0,
        });
      }
      function _se(n) {
        const e = (i) => {
            (this.color = i), b(this, Oa, Cc).call(this);
          },
          t = this.color;
        this.addCommands({
          cmd: e.bind(this, n),
          undo: e.bind(this, t),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: !0,
          type: Ee.INK_COLOR,
          overwriteIfSameType: !0,
          keepUndo: !0,
        });
      }
      function bse(n) {
        const e = (i) => {
            (this.opacity = i), b(this, Oa, Cc).call(this);
          },
          t = this.opacity;
        this.addCommands({
          cmd: e.bind(this, (n /= 100)),
          undo: e.bind(this, t),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: !0,
          type: Ee.INK_OPACITY,
          overwriteIfSameType: !0,
          keepUndo: !0,
        });
      }
      function vse() {
        const {
          parentRotation: n,
          parentDimensions: [e, t],
        } = this;
        switch (n) {
          case 90:
            return [0, t, t, e];
          case 180:
            return [e, t, e, t];
          case 270:
            return [e, 0, t, e];
          default:
            return [0, 0, e, t];
        }
      }
      function PB() {
        const {
          ctx: n,
          color: e,
          opacity: t,
          thickness: i,
          parentScale: r,
          scaleFactor: s,
        } = this;
        (n.lineWidth = (i * r) / s),
          (n.lineCap = 'round'),
          (n.lineJoin = 'round'),
          (n.miterLimit = 10),
          (n.strokeStyle = `${e}${(function Xne(n) {
            return Math.round(Math.min(255, Math.max(1, 255 * n)))
              .toString(16)
              .padStart(2, '0');
          })(t)}`);
      }
      function yse(n, e) {
        const t = this._uiManager._signal;
        this.canvas.addEventListener('contextmenu', fi, { signal: t }),
          this.canvas.addEventListener('pointerleave', d(this, qx), {
            signal: t,
          }),
          this.canvas.addEventListener('pointermove', d(this, Gx), {
            signal: t,
          }),
          this.canvas.addEventListener('pointerup', d(this, Xx), { signal: t }),
          this.canvas.removeEventListener('pointerdown', d(this, Ph)),
          (this.isEditing = !0),
          d(this, Fh) ||
            (_(this, Fh, !0),
            b(this, Ec, Vh).call(this),
            (this.thickness ||= gt._defaultThickness),
            (this.color ||= gt._defaultColor || re._defaultLineColor),
            (this.opacity ??= gt._defaultOpacity)),
          this.currentPath.push([n, e]),
          _(this, Rh, !1),
          b(this, Yx, PB).call(this),
          _(this, wc, () => {
            b(this, DB, Cse).call(this),
              d(this, wc) && window.requestAnimationFrame(d(this, wc));
          }),
          window.requestAnimationFrame(d(this, wc));
      }
      function RB(n, e) {
        const [t, i] = this.currentPath.at(-1);
        if (this.currentPath.length > 1 && n === t && e === i) return;
        const r = this.currentPath;
        let s = d(this, Ra);
        if ((r.push([n, e]), _(this, Rh, !0), r.length <= 2))
          return s.moveTo(...r[0]), void s.lineTo(n, e);
        3 === r.length && (_(this, Ra, (s = new Path2D())), s.moveTo(...r[0])),
          b(this, TB, xse).call(this, s, ...r.at(-3), ...r.at(-2), n, e);
      }
      function wse() {
        if (0 === this.currentPath.length) return;
        const n = this.currentPath.at(-1);
        d(this, Ra).lineTo(...n);
      }
      function Ese(n, e) {
        let t;
        if (
          (_(this, wc, null),
          (n = Math.min(Math.max(n, 0), this.canvas.width)),
          (e = Math.min(Math.max(e, 0), this.canvas.height)),
          b(this, Kx, RB).call(this, n, e),
          b(this, SB, wse).call(this),
          1 !== this.currentPath.length)
        )
          t = b(this, IB, Ase).call(this);
        else {
          const a = [n, e];
          t = [[a, a.slice(), a.slice(), a]];
        }
        const i = d(this, Ra),
          r = this.currentPath;
        (this.currentPath = []),
          _(this, Ra, new Path2D()),
          this.addCommands({
            cmd: () => {
              this.allRawPaths.push(r),
                this.paths.push(t),
                this.bezierPath2D.push(i),
                this._uiManager.rebuild(this);
            },
            undo: () => {
              this.allRawPaths.pop(),
                this.paths.pop(),
                this.bezierPath2D.pop(),
                0 === this.paths.length
                  ? this.remove()
                  : (this.canvas ||
                      (b(this, M_, eA).call(this), b(this, D_, tA).call(this)),
                    b(this, Nh, k_).call(this));
            },
            mustExec: !0,
          });
      }
      function Cse() {
        if (!d(this, Rh)) return;
        _(this, Rh, !1);
        Math.ceil(this.thickness * this.parentScale);
        const e = this.currentPath.slice(-3),
          t = e.map((c) => c[0]),
          i = e.map((c) => c[1]),
          { ctx: l } =
            (Math.min(...t),
            Math.max(...t),
            Math.min(...i),
            Math.max(...i),
            this);
        l.save(), l.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (const c of this.bezierPath2D) l.stroke(c);
        l.stroke(d(this, Ra)), l.restore();
      }
      function xse(n, e, t, i, r, s, o) {
        const a = (e + i) / 2,
          l = (t + r) / 2,
          c = (i + s) / 2,
          u = (r + o) / 2;
        n.bezierCurveTo(
          a + (2 * (i - a)) / 3,
          l + (2 * (r - l)) / 3,
          c + (2 * (i - c)) / 3,
          u + (2 * (r - u)) / 3,
          c,
          u
        );
      }
      function Ase() {
        const n = this.currentPath;
        if (n.length <= 2) return [[n[0], n[0], n.at(-1), n.at(-1)]];
        const e = [];
        let t,
          [i, r] = n[0];
        for (t = 1; t < n.length - 2; t++) {
          const [h, f] = n[t],
            [p, m] = n[t + 1],
            g = (h + p) / 2,
            w = (f + m) / 2;
          e.push([
            [i, r],
            [i + (2 * (h - i)) / 3, r + (2 * (f - r)) / 3],
            [g + (2 * (h - g)) / 3, w + (2 * (f - w)) / 3],
            [g, w],
          ]),
            ([i, r] = [g, w]);
        }
        const [s, o] = n[t],
          [a, l] = n[t + 1];
        return (
          e.push([
            [i, r],
            [i + (2 * (s - i)) / 3, r + (2 * (o - r)) / 3],
            [a + (2 * (s - a)) / 3, l + (2 * (o - l)) / 3],
            [a, l],
          ]),
          e
        );
      }
      function Cc() {
        if (this.isEmpty()) return void b(this, T_, nA).call(this);
        b(this, Yx, PB).call(this);
        const { canvas: n, ctx: e } = this;
        e.setTransform(1, 0, 0, 1, 0, 0),
          e.clearRect(0, 0, n.width, n.height),
          b(this, T_, nA).call(this);
        for (const t of this.bezierPath2D) e.stroke(t);
      }
      function FB(n) {
        this.canvas.removeEventListener('pointerleave', d(this, qx)),
          this.canvas.removeEventListener('pointermove', d(this, Gx)),
          this.canvas.removeEventListener('pointerup', d(this, Xx)),
          this.canvas.addEventListener('pointerdown', d(this, Ph), {
            signal: this._uiManager._signal,
          }),
          d(this, mo) && clearTimeout(d(this, mo)),
          _(
            this,
            mo,
            setTimeout(() => {
              _(this, mo, null),
                this.canvas.removeEventListener('contextmenu', fi);
            }, 10)
          ),
          b(this, MB, Ese).call(this, n.offsetX, n.offsetY),
          this.addToAnnotationStorage(),
          this.setInBackground();
      }
      function eA() {
        (this.canvas = document.createElement('canvas')),
          (this.canvas.width = this.canvas.height = 0),
          (this.canvas.className = 'inkEditorCanvas'),
          this.canvas.setAttribute('data-l10n-id', 'pdfjs-ink-canvas'),
          this.div.append(this.canvas),
          (this.ctx = this.canvas.getContext('2d'));
      }
      function tA() {
        _(
          this,
          Fa,
          new ResizeObserver((n) => {
            const e = n[0].contentRect;
            e.width && e.height && this.setDimensions(e.width, e.height);
          })
        ),
          d(this, Fa).observe(this.div),
          this._uiManager._signal.addEventListener(
            'abort',
            () => {
              d(this, Fa)?.disconnect(), _(this, Fa, null);
            },
            { once: !0 }
          );
      }
      function Vh() {
        if (!d(this, Fh)) return;
        const [n, e] = this.parentDimensions;
        (this.canvas.width = Math.ceil(this.width * n)),
          (this.canvas.height = Math.ceil(this.height * e)),
          b(this, T_, nA).call(this);
      }
      function OB(n, e) {
        const t = b(this, I_, iA).call(this),
          i = (n - t) / d(this, kh),
          r = (e - t) / d(this, Ih);
        this.scaleFactor = Math.min(i, r);
      }
      function nA() {
        const n = b(this, I_, iA).call(this) / 2;
        this.ctx.setTransform(
          this.scaleFactor,
          0,
          0,
          this.scaleFactor,
          this.translationX * this.scaleFactor + n,
          this.translationY * this.scaleFactor + n
        );
      }
      function Sse(n) {
        const e = new Path2D();
        for (let t = 0, i = n.length; t < i; t++) {
          const [r, s, o, a] = n[t];
          0 === t && e.moveTo(...r),
            e.bezierCurveTo(s[0], s[1], o[0], o[1], a[0], a[1]);
        }
        return e;
      }
      function LB(n, e, t) {
        const [i, r, s, o] = e;
        switch (t) {
          case 0:
            for (let a = 0, l = n.length; a < l; a += 2)
              (n[a] += i), (n[a + 1] = o - n[a + 1]);
            break;
          case 90:
            for (let a = 0, l = n.length; a < l; a += 2) {
              const c = n[a];
              (n[a] = n[a + 1] + i), (n[a + 1] = c + r);
            }
            break;
          case 180:
            for (let a = 0, l = n.length; a < l; a += 2)
              (n[a] = s - n[a]), (n[a + 1] += r);
            break;
          case 270:
            for (let a = 0, l = n.length; a < l; a += 2) {
              const c = n[a];
              (n[a] = s - n[a + 1]), (n[a + 1] = o - c);
            }
            break;
          default:
            throw new Error('Invalid rotation');
        }
        return n;
      }
      function Mse(n, e, t) {
        const [i, r, s, o] = e;
        switch (t) {
          case 0:
            for (let a = 0, l = n.length; a < l; a += 2)
              (n[a] -= i), (n[a + 1] = o - n[a + 1]);
            break;
          case 90:
            for (let a = 0, l = n.length; a < l; a += 2) {
              const c = n[a];
              (n[a] = n[a + 1] - r), (n[a + 1] = c - i);
            }
            break;
          case 180:
            for (let a = 0, l = n.length; a < l; a += 2)
              (n[a] = s - n[a]), (n[a + 1] -= r);
            break;
          case 270:
            for (let a = 0, l = n.length; a < l; a += 2) {
              const c = n[a];
              (n[a] = o - n[a + 1]), (n[a + 1] = s - c);
            }
            break;
          default:
            throw new Error('Invalid rotation');
        }
        return n;
      }
      function Dse(n, e, t, i) {
        const r = [],
          s = this.thickness / 2,
          o = n * e + s,
          a = n * t + s;
        for (const l of this.paths) {
          const c = [],
            u = [];
          for (let h = 0, f = l.length; h < f; h++) {
            const [p, m, g, w] = l[h];
            if (p[0] === w[0] && p[1] === w[1] && 1 === f) {
              const I = n * p[0] + o,
                C = n * p[1] + a;
              c.push(I, C), u.push(I, C);
              break;
            }
            const y = n * p[0] + o,
              E = n * p[1] + a,
              A = n * m[0] + o,
              M = n * m[1] + a,
              T = n * g[0] + o,
              k = n * g[1] + a,
              P = n * w[0] + o,
              O = n * w[1] + a;
            0 === h && (c.push(y, E), u.push(y, E)),
              c.push(A, M, T, k, P, O),
              u.push(A, M),
              h === f - 1 && u.push(P, O);
          }
          r.push({
            bezier: we(gt, gt, LB).call(gt, c, i, this.rotation),
            points: we(gt, gt, LB).call(gt, u, i, this.rotation),
          });
        }
        return r;
      }
      function NB() {
        let n = 1 / 0,
          e = -1 / 0,
          t = 1 / 0,
          i = -1 / 0;
        for (const r of this.paths)
          for (const [s, o, a, l] of r) {
            const c = te.bezierBoundingBox(...s, ...o, ...a, ...l);
            (n = Math.min(n, c[0])),
              (t = Math.min(t, c[1])),
              (e = Math.max(e, c[2])),
              (i = Math.max(i, c[3]));
          }
        return [n, t, e, i];
      }
      function iA() {
        return d(this, Xr) ? Math.ceil(this.thickness * this.parentScale) : 0;
      }
      function k_(n = !1) {
        if (this.isEmpty()) return;
        if (!d(this, Xr)) return void b(this, Oa, Cc).call(this);
        const e = b(this, Jx, NB).call(this),
          t = b(this, I_, iA).call(this);
        _(this, kh, Math.max(re.MIN_SIZE, e[2] - e[0])),
          _(this, Ih, Math.max(re.MIN_SIZE, e[3] - e[1]));
        const i = Math.ceil(t + d(this, kh) * this.scaleFactor),
          r = Math.ceil(t + d(this, Ih) * this.scaleFactor),
          [s, o] = this.parentDimensions;
        (this.width = i / s), (this.height = r / o), this.setAspectRatio(i, r);
        const a = this.translationX,
          l = this.translationY;
        (this.translationX = -e[0]),
          (this.translationY = -e[1]),
          b(this, Ec, Vh).call(this),
          b(this, Oa, Cc).call(this),
          _(this, Oh, i),
          _(this, Lh, r),
          this.setDims(i, r);
        const c = n ? t / this.scaleFactor / 2 : 0;
        this.translate(a - this.translationX - c, l - this.translationY - c);
      }
      Se(gt, '_defaultColor', null),
        Se(gt, '_defaultOpacity', 1),
        Se(gt, '_defaultThickness', 1),
        Se(gt, '_type', 'ink'),
        Se(gt, '_editorType', $e.INK);
      var Yn = new WeakMap(),
        Kn = new WeakMap(),
        xc = new WeakMap(),
        La = new WeakMap(),
        Ac = new WeakMap(),
        P_ = new WeakMap(),
        go = new WeakMap(),
        rA = new WeakMap(),
        Na = new WeakMap(),
        _o = new WeakMap(),
        Is = new WeakMap(),
        sA = new WeakMap(),
        Bh = new WeakSet(),
        Hh = new WeakSet(),
        R_ = new WeakSet(),
        oA = new WeakSet(),
        VB = new WeakSet(),
        BB = new WeakSet(),
        HB = new WeakSet(),
        aA = new WeakSet(),
        F_ = new WeakSet(),
        WB = new WeakSet();
      class O_ extends re {
        constructor(e) {
          super({ ...e, name: 'stampEditor' }),
            S(this, WB),
            S(this, F_),
            S(this, aA),
            S(this, HB),
            S(this, BB),
            S(this, VB),
            S(this, oA),
            S(this, R_),
            S(this, Hh),
            S(this, Bh),
            v(this, Yn, { writable: !0, value: null }),
            v(this, Kn, { writable: !0, value: null }),
            v(this, xc, { writable: !0, value: null }),
            v(this, La, { writable: !0, value: null }),
            v(this, Ac, { writable: !0, value: null }),
            v(this, P_, { writable: !0, value: '' }),
            v(this, go, { writable: !0, value: null }),
            v(this, rA, { writable: !0, value: !1 }),
            v(this, Na, { writable: !0, value: null }),
            v(this, _o, { writable: !0, value: null }),
            v(this, Is, { writable: !0, value: !1 }),
            v(this, sA, { writable: !0, value: !1 }),
            _(this, La, e.bitmapUrl),
            _(this, Ac, e.bitmapFile);
        }
        static initialize(e, t) {
          re.initialize(e, t);
        }
        static get supportedTypes() {
          return Ye(
            this,
            'supportedTypes',
            [
              'apng',
              'avif',
              'bmp',
              'gif',
              'jpeg',
              'png',
              'svg+xml',
              'webp',
              'x-icon',
            ].map((t) => `image/${t}`)
          );
        }
        static get supportedTypesStr() {
          return Ye(this, 'supportedTypesStr', this.supportedTypes.join(','));
        }
        static isHandlingMimeForPasting(e) {
          return this.supportedTypes.includes(e);
        }
        static paste(e, t) {
          t.pasteEditor($e.STAMP, { bitmapFile: e.getAsFile() });
        }
        remove() {
          d(this, Kn) &&
            (_(this, Yn, null),
            this._uiManager.imageManager.deleteId(d(this, Kn)),
            d(this, go)?.remove(),
            _(this, go, null),
            d(this, Na)?.disconnect(),
            _(this, Na, null),
            d(this, _o) && (clearTimeout(d(this, _o)), _(this, _o, null))),
            super.remove();
        }
        rebuild() {
          this.parent
            ? (super.rebuild(),
              null !== this.div &&
                (d(this, Kn) &&
                  null === d(this, go) &&
                  b(this, R_, lA).call(this),
                this.isAttachedToDOM || this.parent.add(this)))
            : d(this, Kn) && b(this, R_, lA).call(this);
        }
        onceAdded() {
          (this._isDraggable = !0), this.div.focus();
        }
        isEmpty() {
          return !(
            d(this, xc) ||
            d(this, Yn) ||
            d(this, La) ||
            d(this, Ac) ||
            d(this, Kn)
          );
        }
        get isResizable() {
          return !0;
        }
        render() {
          if (this.div) return this.div;
          let e, t;
          if (
            (this.width && ((e = this.x), (t = this.y)),
            super.render(),
            (this.div.hidden = !0),
            this.addAltTextButton(),
            d(this, Yn)
              ? b(this, oA, jB).call(this)
              : b(this, R_, lA).call(this),
            this.width)
          ) {
            const [i, r] = this.parentDimensions;
            this.setAt(e * i, t * r, this.width * i, this.height * r);
          }
          return this.div;
        }
        getImageForAltText() {
          return d(this, go);
        }
        static deserialize(e, t, i) {
          if (e instanceof jV) return null;
          const r = super.deserialize(e, t, i),
            {
              rect: s,
              bitmapUrl: o,
              bitmapId: a,
              isSvg: l,
              accessibilityData: c,
            } = e;
          a && i.imageManager.isValidId(a) ? _(r, Kn, a) : _(r, La, o),
            _(r, Is, l);
          const [u, h] = r.pageDimensions;
          return (
            (r.width = (s[2] - s[0]) / u),
            (r.height = (s[3] - s[1]) / h),
            c && (r.altTextData = c),
            r
          );
        }
        serialize(e = !1, t = null) {
          if (this.isEmpty()) return null;
          const i = {
            annotationType: $e.STAMP,
            bitmapId: d(this, Kn),
            pageIndex: this.pageIndex,
            rect: this.getRect(0, 0),
            rotation: this.rotation,
            isSvg: d(this, Is),
            structTreeParentId: this._structTreeParentId,
          };
          if (e)
            return (
              (i.bitmapUrl = b(this, F_, dA).call(this, !0)),
              (i.accessibilityData = this.altTextData),
              i
            );
          const { decorative: r, altText: s } = this.altTextData;
          if (
            (!r && s && (i.accessibilityData = { type: 'Figure', alt: s }),
            null === t)
          )
            return i;
          t.stamps ||= new Map();
          const o = d(this, Is)
            ? (i.rect[2] - i.rect[0]) * (i.rect[3] - i.rect[1])
            : null;
          if (t.stamps.has(d(this, Kn))) {
            if (d(this, Is)) {
              const a = t.stamps.get(d(this, Kn));
              o > a.area &&
                ((a.area = o),
                a.serialized.bitmap.close(),
                (a.serialized.bitmap = b(this, F_, dA).call(this, !1)));
            }
          } else
            t.stamps.set(d(this, Kn), { area: o, serialized: i }),
              (i.bitmap = b(this, F_, dA).call(this, !1));
          return i;
        }
      }
      function L_(n, e = !1) {
        n
          ? (_(this, Yn, n.bitmap),
            e || (_(this, Kn, n.id), _(this, Is, n.isSvg)),
            n.file && _(this, P_, n.file.name),
            b(this, oA, jB).call(this))
          : this.remove();
      }
      function N_() {
        _(this, xc, null),
          this._uiManager.enableWaiting(!1),
          d(this, go) && this.div.focus();
      }
      function lA() {
        var n = this;
        if (d(this, Kn))
          return (
            this._uiManager.enableWaiting(!0),
            void this._uiManager.imageManager
              .getFromId(d(this, Kn))
              .then((i) => b(this, Bh, L_).call(this, i, !0))
              .finally(() => b(this, Hh, N_).call(this))
          );
        if (d(this, La)) {
          const i = d(this, La);
          return (
            _(this, La, null),
            this._uiManager.enableWaiting(!0),
            void _(
              this,
              xc,
              this._uiManager.imageManager
                .getFromUrl(i)
                .then((r) => b(this, Bh, L_).call(this, r))
                .finally(() => b(this, Hh, N_).call(this))
            )
          );
        }
        if (d(this, Ac)) {
          const i = d(this, Ac);
          return (
            _(this, Ac, null),
            this._uiManager.enableWaiting(!0),
            void _(
              this,
              xc,
              this._uiManager.imageManager
                .getFromFile(i)
                .then((r) => b(this, Bh, L_).call(this, r))
                .finally(() => b(this, Hh, N_).call(this))
            )
          );
        }
        const e = document.createElement('input');
        (e.type = 'file'), (e.accept = O_.supportedTypesStr);
        const t = this._uiManager._signal;
        _(
          this,
          xc,
          new Promise((i) => {
            e.addEventListener(
              'change',
              U(function* () {
                if (e.files && 0 !== e.files.length) {
                  n._uiManager.enableWaiting(!0);
                  const r = yield n._uiManager.imageManager.getFromFile(
                    e.files[0]
                  );
                  b(n, Bh, L_).call(n, r);
                } else n.remove();
                i();
              }),
              { signal: t }
            ),
              e.addEventListener(
                'cancel',
                () => {
                  this.remove(), i();
                },
                { signal: t }
              );
          }).finally(() => b(this, Hh, N_).call(this))
        ),
          e.click();
      }
      function jB() {
        const { div: n } = this;
        let { width: e, height: t } = d(this, Yn);
        const [i, r] = this.pageDimensions,
          s = 0.75;
        if (this.width) (e = this.width * i), (t = this.height * r);
        else if (e > s * i || t > s * r) {
          const c = Math.min((s * i) / e, (s * r) / t);
          (e *= c), (t *= c);
        }
        const [o, a] = this.parentDimensions;
        this.setDims((e * o) / i, (t * a) / r),
          this._uiManager.enableWaiting(!1);
        const l = _(this, go, document.createElement('canvas'));
        n.append(l),
          (n.hidden = !1),
          b(this, aA, zB).call(this, e, t),
          b(this, WB, Pse).call(this),
          d(this, sA) || (this.parent.addUndoableEditor(this), _(this, sA, !0)),
          this._reportTelemetry({ action: 'inserted_image' }),
          d(this, P_) && l.setAttribute('aria-label', d(this, P_));
      }
      function Tse(n, e) {
        const [t, i] = this.parentDimensions;
        (this.width = n / t),
          (this.height = e / i),
          this.setDims(n, e),
          this._initialOptions?.isCentered
            ? this.center()
            : this.fixAndSetPosition(),
          (this._initialOptions = null),
          null !== d(this, _o) && clearTimeout(d(this, _o)),
          _(
            this,
            _o,
            setTimeout(() => {
              _(this, _o, null), b(this, aA, zB).call(this, n, e);
            }, 200)
          );
      }
      function Ise(n, e) {
        const { width: t, height: i } = d(this, Yn);
        let r = t,
          s = i,
          o = d(this, Yn);
        for (; r > 2 * n || s > 2 * e; ) {
          const a = r,
            l = s;
          r > 2 * n &&
            (r = r >= 16384 ? Math.floor(r / 2) - 1 : Math.ceil(r / 2)),
            s > 2 * e &&
              (s = s >= 16384 ? Math.floor(s / 2) - 1 : Math.ceil(s / 2));
          const c = new OffscreenCanvas(r, s);
          c.getContext('2d').drawImage(o, 0, 0, a, l, 0, 0, r, s),
            (o = c.transferToImageBitmap());
        }
        return o;
      }
      function kse(n, e, t) {
        return cA.apply(this, arguments);
      }
      function cA() {
        return (cA = U(function* (n, e, t) {
          if (
            d(this, rA) ||
            (_(this, rA, !0),
            !(yield this._uiManager.isMLEnabledFor('altText')) ||
              this.hasAltText())
          )
            return;
          const s = new OffscreenCanvas(e, t).getContext('2d', {
            willReadFrequently: !0,
          });
          s.drawImage(n, 0, 0, n.width, n.height, 0, 0, e, t);
          const a =
            (yield this._uiManager.mlGuess({
              service: 'moz-image-to-text',
              request: {
                data: s.getImageData(0, 0, e, t).data,
                width: e,
                height: t,
                channels: 4,
              },
            }))?.output || '';
          this.parent &&
            a &&
            !this.hasAltText() &&
            (this.altTextData = { altText: a, decorative: !1 });
        })).apply(this, arguments);
      }
      function zB(n, e) {
        (n = Math.ceil(n)), (e = Math.ceil(e));
        const t = d(this, go);
        if (!t || (t.width === n && t.height === e)) return;
        (t.width = n), (t.height = e);
        const i = d(this, Is) ? d(this, Yn) : b(this, BB, Ise).call(this, n, e);
        b(this, HB, kse).call(this, i, n, e);
        const r = t.getContext('2d');
        (r.filter = this._uiManager.hcmFilter),
          r.drawImage(i, 0, 0, i.width, i.height, 0, 0, n, e);
      }
      function dA(n) {
        if (n) {
          if (d(this, Is)) {
            const i = this._uiManager.imageManager.getSvgUrl(d(this, Kn));
            if (i) return i;
          }
          const e = document.createElement('canvas');
          return (
            ({ width: e.width, height: e.height } = d(this, Yn)),
            e.getContext('2d').drawImage(d(this, Yn), 0, 0),
            e.toDataURL()
          );
        }
        if (d(this, Is)) {
          const [e, t] = this.pageDimensions,
            i = Math.round(this.width * e * ur.PDF_TO_CSS_UNITS),
            r = Math.round(this.height * t * ur.PDF_TO_CSS_UNITS),
            s = new OffscreenCanvas(i, r);
          return (
            s
              .getContext('2d')
              .drawImage(
                d(this, Yn),
                0,
                0,
                d(this, Yn).width,
                d(this, Yn).height,
                0,
                0,
                i,
                r
              ),
            s.transferToImageBitmap()
          );
        }
        return structuredClone(d(this, Yn));
      }
      function Pse() {
        this._uiManager._signal &&
          (_(
            this,
            Na,
            new ResizeObserver((n) => {
              const e = n[0].contentRect;
              e.width &&
                e.height &&
                b(this, VB, Tse).call(this, e.width, e.height);
            })
          ),
          d(this, Na).observe(this.div),
          this._uiManager._signal.addEventListener(
            'abort',
            () => {
              d(this, Na)?.disconnect(), _(this, Na, null);
            },
            { once: !0 }
          ));
      }
      Se(O_, '_type', 'stamp'), Se(O_, '_editorType', $e.STAMP);
      let Rse = (() => {
        var n = new WeakMap(),
          e = new WeakMap(),
          t = new WeakMap(),
          i = new WeakMap(),
          r = new WeakMap(),
          s = new WeakMap(),
          o = new WeakMap(),
          a = new WeakMap(),
          l = new WeakMap(),
          c = new WeakMap(),
          u = new WeakMap(),
          h = new WeakMap(),
          f = new WeakMap(),
          p = new WeakSet(),
          m = new WeakMap(),
          g = new WeakSet(),
          w = new WeakSet(),
          y = new WeakSet();
        class E {
          constructor({
            uiManager: C,
            pageIndex: R,
            div: $,
            accessibilityManager: q,
            annotationLayer: oe,
            drawLayer: Oe,
            textLayer: F,
            viewport: W,
            l10n: Q,
          }) {
            S(this, y),
              S(this, w),
              S(this, g),
              v(this, m, { get: M, set: void 0 }),
              S(this, p),
              v(this, n, { writable: !0, value: void 0 }),
              v(this, e, { writable: !0, value: !1 }),
              v(this, t, { writable: !0, value: null }),
              v(this, i, { writable: !0, value: null }),
              v(this, r, { writable: !0, value: null }),
              v(this, s, { writable: !0, value: null }),
              v(this, o, { writable: !0, value: null }),
              v(this, a, { writable: !0, value: new Map() }),
              v(this, l, { writable: !0, value: !1 }),
              v(this, c, { writable: !0, value: !1 }),
              v(this, u, { writable: !0, value: !1 }),
              v(this, h, { writable: !0, value: null }),
              v(this, f, { writable: !0, value: void 0 });
            const ge = [...de(E, E, O).values()];
            if (!E._initialized) {
              E._initialized = !0;
              for (const st of ge) st.initialize(Q, C);
            }
            C.registerEditorTypes(ge),
              _(this, f, C),
              (this.pageIndex = R),
              (this.div = $),
              _(this, n, q),
              _(this, t, oe),
              (this.viewport = W),
              _(this, h, F),
              (this.drawLayer = Oe),
              d(this, f).addLayer(this);
          }
          get isEmpty() {
            return 0 === d(this, a).size;
          }
          get isInvisible() {
            return this.isEmpty && d(this, f).getMode() === $e.NONE;
          }
          updateToolbar(C) {
            d(this, f).updateToolbar(C);
          }
          updateMode(C = d(this, f).getMode()) {
            switch ((b(this, y, P).call(this), C)) {
              case $e.NONE:
                return (
                  this.disableTextSelection(),
                  this.togglePointerEvents(!1),
                  this.toggleAnnotationLayerPointerEvents(!0),
                  void this.disableClick()
                );
              case $e.INK:
                this.addInkEditorIfNeeded(!1),
                  this.disableTextSelection(),
                  this.togglePointerEvents(!0),
                  this.disableClick();
                break;
              case $e.HIGHLIGHT:
                this.enableTextSelection(),
                  this.togglePointerEvents(!1),
                  this.disableClick();
                break;
              default:
                this.disableTextSelection(),
                  this.togglePointerEvents(!0),
                  this.enableClick();
            }
            this.toggleAnnotationLayerPointerEvents(!1);
            const { classList: R } = this.div;
            for (const $ of de(E, E, O).values())
              R.toggle(`${$._type}Editing`, C === $._editorType);
            this.div.hidden = !1;
          }
          hasTextLayer(C) {
            return C === d(this, h)?.div;
          }
          addInkEditorIfNeeded(C) {
            if (d(this, f).getMode() === $e.INK) {
              if (!C)
                for (const $ of d(this, a).values())
                  if ($.isEmpty()) return void $.setInBackground();
              this.createAndAddNewEditor(
                { offsetX: 0, offsetY: 0 },
                !1
              ).setInBackground();
            }
          }
          setEditingState(C) {
            d(this, f).setEditingState(C);
          }
          addCommands(C) {
            d(this, f).addCommands(C);
          }
          toggleDrawing(C = !1) {
            this.div.classList.toggle('drawing', !C);
          }
          togglePointerEvents(C = !1) {
            this.div.classList.toggle('disabled', !C);
          }
          toggleAnnotationLayerPointerEvents(C = !1) {
            d(this, t)?.div.classList.toggle('disabled', !C);
          }
          enable() {
            (this.div.tabIndex = 0), this.togglePointerEvents(!0);
            const C = new Set();
            for (const $ of d(this, a).values())
              $.enableEditing(),
                $.show(!0),
                $.annotationElementId &&
                  (d(this, f).removeChangedExistingAnnotation($),
                  C.add($.annotationElementId));
            if (!d(this, t)) return;
            const R = d(this, t).getEditableAnnotations();
            for (const $ of R) {
              if (
                ($.hide(),
                d(this, f).isDeletedAnnotationElement($.data.id) ||
                  C.has($.data.id))
              )
                continue;
              const q = this.deserialize($);
              q && (this.addOrRebuild(q), q.enableEditing());
            }
          }
          disable() {
            _(this, u, !0),
              (this.div.tabIndex = -1),
              this.togglePointerEvents(!1);
            const C = new Map(),
              R = new Map();
            for (const q of d(this, a).values())
              if ((q.disableEditing(), q.annotationElementId)) {
                if (null !== q.serialize()) {
                  C.set(q.annotationElementId, q);
                  continue;
                }
                R.set(q.annotationElementId, q),
                  this.getEditableAnnotation(q.annotationElementId)?.show(),
                  q.remove();
              }
            if (d(this, t)) {
              const q = d(this, t).getEditableAnnotations();
              for (const oe of q) {
                const { id: Oe } = oe.data;
                if (d(this, f).isDeletedAnnotationElement(Oe)) continue;
                let F = R.get(Oe);
                F
                  ? (F.resetAnnotationElement(oe), F.show(!1), oe.show())
                  : ((F = C.get(Oe)),
                    F &&
                      (d(this, f).addChangedExistingAnnotation(F),
                      F.renderAnnotationElement(oe),
                      F.show(!1)),
                    oe.show());
              }
            }
            b(this, y, P).call(this), this.isEmpty && (this.div.hidden = !0);
            const { classList: $ } = this.div;
            for (const q of de(E, E, O).values()) $.remove(`${q._type}Editing`);
            this.disableTextSelection(),
              this.toggleAnnotationLayerPointerEvents(!0),
              _(this, u, !1);
          }
          getEditableAnnotation(C) {
            return d(this, t)?.getEditableAnnotation(C) || null;
          }
          setActiveEditor(C) {
            d(this, f).getActive() !== C && d(this, f).setActiveEditor(C);
          }
          enableTextSelection() {
            (this.div.tabIndex = -1),
              d(this, h)?.div &&
                !d(this, s) &&
                (_(this, s, b(this, p, A).bind(this)),
                d(this, h).div.addEventListener('pointerdown', d(this, s), {
                  signal: d(this, f)._signal,
                }),
                d(this, h).div.classList.add('highlighting'));
          }
          disableTextSelection() {
            (this.div.tabIndex = 0),
              d(this, h)?.div &&
                d(this, s) &&
                (d(this, h).div.removeEventListener('pointerdown', d(this, s)),
                _(this, s, null),
                d(this, h).div.classList.remove('highlighting'));
          }
          enableClick() {
            if (d(this, r)) return;
            const C = d(this, f)._signal;
            _(this, r, this.pointerdown.bind(this)),
              _(this, i, this.pointerup.bind(this)),
              this.div.addEventListener('pointerdown', d(this, r), {
                signal: C,
              }),
              this.div.addEventListener('pointerup', d(this, i), { signal: C });
          }
          disableClick() {
            d(this, r) &&
              (this.div.removeEventListener('pointerdown', d(this, r)),
              this.div.removeEventListener('pointerup', d(this, i)),
              _(this, r, null),
              _(this, i, null));
          }
          attach(C) {
            d(this, a).set(C.id, C);
            const { annotationElementId: R } = C;
            R &&
              d(this, f).isDeletedAnnotationElement(R) &&
              d(this, f).removeDeletedAnnotationElement(C);
          }
          detach(C) {
            d(this, a).delete(C.id),
              d(this, n)?.removePointerInTextLayer(C.contentDiv),
              !d(this, u) &&
                C.annotationElementId &&
                d(this, f).addDeletedAnnotationElement(C);
          }
          remove(C) {
            this.detach(C),
              d(this, f).removeEditor(C),
              C.div.remove(),
              (C.isAttachedToDOM = !1),
              d(this, c) || this.addInkEditorIfNeeded(!1);
          }
          changeParent(C) {
            C.parent !== this &&
              (C.parent &&
                C.annotationElementId &&
                (d(this, f).addDeletedAnnotationElement(C.annotationElementId),
                re.deleteAnnotationElement(C),
                (C.annotationElementId = null)),
              this.attach(C),
              C.parent?.detach(C),
              C.setParent(this),
              C.div &&
                C.isAttachedToDOM &&
                (C.div.remove(), this.div.append(C.div)));
          }
          add(C) {
            if (C.parent !== this || !C.isAttachedToDOM) {
              if (
                (this.changeParent(C),
                d(this, f).addEditor(C),
                this.attach(C),
                !C.isAttachedToDOM)
              ) {
                const R = C.render();
                this.div.append(R), (C.isAttachedToDOM = !0);
              }
              C.fixAndSetPosition(),
                C.onceAdded(),
                d(this, f).addToAnnotationStorage(C),
                C._reportTelemetry(C.telemetryInitialData);
            }
          }
          moveEditorInDOM(C) {
            if (!C.isAttachedToDOM) return;
            const { activeElement: R } = document;
            C.div.contains(R) &&
              !d(this, o) &&
              ((C._focusEventsAllowed = !1),
              _(
                this,
                o,
                setTimeout(() => {
                  _(this, o, null),
                    C.div.contains(document.activeElement)
                      ? (C._focusEventsAllowed = !0)
                      : (C.div.addEventListener(
                          'focusin',
                          () => {
                            C._focusEventsAllowed = !0;
                          },
                          { once: !0, signal: d(this, f)._signal }
                        ),
                        R.focus());
                }, 0)
              )),
              (C._structTreeParentId = d(this, n)?.moveElementInDOM(
                this.div,
                C.div,
                C.contentDiv,
                !0
              ));
          }
          addOrRebuild(C) {
            C.needsToBeRebuilt()
              ? ((C.parent ||= this), C.rebuild(), C.show())
              : this.add(C);
          }
          addUndoableEditor(C) {
            this.addCommands({
              cmd: () => C._uiManager.rebuild(C),
              undo: () => {
                C.remove();
              },
              mustExec: !1,
            });
          }
          getNextId() {
            return d(this, f).getId();
          }
          get _signal() {
            return d(this, f)._signal;
          }
          canCreateNewEmptyEditor() {
            return d(this, m)?.canCreateNewEmptyEditor();
          }
          pasteEditor(C, R) {
            d(this, f).updateToolbar(C), d(this, f).updateMode(C);
            const { offsetX: $, offsetY: q } = b(this, w, k).call(this),
              oe = this.getNextId(),
              Oe = b(this, g, T).call(this, {
                parent: this,
                id: oe,
                x: $,
                y: q,
                uiManager: d(this, f),
                isCentered: !0,
                ...R,
              });
            Oe && this.add(Oe);
          }
          deserialize(C) {
            return (
              de(E, E, O)
                .get(C.annotationType ?? C.annotationEditorType)
                ?.deserialize(C, this, d(this, f)) || null
            );
          }
          createAndAddNewEditor(C, R, $ = {}) {
            const q = this.getNextId(),
              oe = b(this, g, T).call(this, {
                parent: this,
                id: q,
                x: C.offsetX,
                y: C.offsetY,
                uiManager: d(this, f),
                isCentered: R,
                ...$,
              });
            return oe && this.add(oe), oe;
          }
          addNewEditor() {
            this.createAndAddNewEditor(b(this, w, k).call(this), !0);
          }
          setSelected(C) {
            d(this, f).setSelected(C);
          }
          toggleSelected(C) {
            d(this, f).toggleSelected(C);
          }
          isSelected(C) {
            return d(this, f).isSelected(C);
          }
          unselect(C) {
            d(this, f).unselect(C);
          }
          pointerup(C) {
            const { isMac: R } = ui.platform;
            if (
              !(0 !== C.button || (C.ctrlKey && R)) &&
              C.target === this.div &&
              d(this, l)
            ) {
              if ((_(this, l, !1), !d(this, e))) return void _(this, e, !0);
              if (d(this, f).getMode() === $e.STAMP)
                return void d(this, f).unselectAll();
              this.createAndAddNewEditor(C, !1);
            }
          }
          pointerdown(C) {
            if (
              (d(this, f).getMode() === $e.HIGHLIGHT &&
                this.enableTextSelection(),
              d(this, l))
            )
              return void _(this, l, !1);
            const { isMac: R } = ui.platform;
            if (0 !== C.button || (C.ctrlKey && R) || C.target !== this.div)
              return;
            _(this, l, !0);
            const $ = d(this, f).getActive();
            _(this, e, !$ || $.isEmpty());
          }
          findNewParent(C, R, $) {
            const q = d(this, f).findParent(R, $);
            return null !== q && q !== this && (q.changeParent(C), !0);
          }
          destroy() {
            d(this, f).getActive()?.parent === this &&
              (d(this, f).commitOrRemove(), d(this, f).setActiveEditor(null)),
              d(this, o) && (clearTimeout(d(this, o)), _(this, o, null));
            for (const C of d(this, a).values())
              d(this, n)?.removePointerInTextLayer(C.contentDiv),
                C.setParent(null),
                (C.isAttachedToDOM = !1),
                C.div.remove();
            (this.div = null), d(this, a).clear(), d(this, f).removeLayer(this);
          }
          render({ viewport: C }) {
            (this.viewport = C), ba(this.div, C);
            for (const R of d(this, f).getEditors(this.pageIndex))
              this.add(R), R.rebuild();
            this.updateMode();
          }
          update({ viewport: C }) {
            d(this, f).commitOrRemove(), b(this, y, P).call(this);
            const R = this.viewport.rotation,
              $ = C.rotation;
            if (((this.viewport = C), ba(this.div, { rotation: $ }), R !== $))
              for (const q of d(this, a).values()) q.rotate($);
            this.addInkEditorIfNeeded(!1);
          }
          get pageDimensions() {
            const { pageWidth: C, pageHeight: R } = this.viewport.rawDims;
            return [C, R];
          }
          get scale() {
            return d(this, f).viewParameters.realScale;
          }
        }
        function A(I) {
          d(this, f).unselectAll();
          const { target: C } = I;
          if (
            C === d(this, h).div ||
            (C.classList.contains('endOfContent') && d(this, h).div.contains(C))
          ) {
            const { isMac: R } = ui.platform;
            if (0 !== I.button || (I.ctrlKey && R)) return;
            d(this, f).showAllEditors('highlight', !0, !0),
              d(this, h).div.classList.add('free'),
              this.toggleDrawing(),
              Re.startHighlighting(this, 'ltr' === d(this, f).direction, I),
              d(this, h).div.addEventListener(
                'pointerup',
                () => {
                  d(this, h).div.classList.remove('free'),
                    this.toggleDrawing(!0);
                },
                { once: !0, signal: d(this, f)._signal }
              ),
              I.preventDefault();
          }
        }
        function M() {
          return de(E, E, O).get(d(this, f).getMode());
        }
        function T(I) {
          const C = d(this, m);
          return C ? new C.prototype.constructor(I) : null;
        }
        function k() {
          const {
              x: I,
              y: C,
              width: R,
              height: $,
            } = this.div.getBoundingClientRect(),
            q = Math.max(0, I),
            oe = Math.max(0, C),
            W = (q + Math.min(window.innerWidth, I + R)) / 2 - I,
            Q = (oe + Math.min(window.innerHeight, C + $)) / 2 - C,
            [ge, st] = this.viewport.rotation % 180 == 0 ? [W, Q] : [Q, W];
          return { offsetX: ge, offsetY: st };
        }
        function P() {
          _(this, c, !0);
          for (const I of d(this, a).values()) I.isEmpty() && I.remove();
          _(this, c, !1);
        }
        Se(E, '_initialized', !1);
        var O = {
          writable: !0,
          value: new Map([Ge, gt, O_, Re].map((I) => [I._editorType, I])),
        };
        return E;
      })();
      var bo = new WeakMap(),
        Wh = new WeakMap(),
        xn = new WeakMap(),
        Sc = new WeakMap(),
        uA = new WeakSet(),
        UB = new WeakSet();
      class en {
        constructor({ pageIndex: e }) {
          S(this, UB),
            S(this, uA),
            v(this, bo, { writable: !0, value: null }),
            v(this, Wh, { writable: !0, value: 0 }),
            v(this, xn, { writable: !0, value: new Map() }),
            v(this, Sc, { writable: !0, value: new Map() }),
            (this.pageIndex = e);
        }
        setParent(e) {
          if (d(this, bo)) {
            if (d(this, bo) !== e) {
              if (d(this, xn).size > 0)
                for (const t of d(this, xn).values()) t.remove(), e.append(t);
              _(this, bo, e);
            }
          } else _(this, bo, e);
        }
        static get _svgFactory() {
          return Ye(this, '_svgFactory', new $E());
        }
        highlight(e, t, i, r = !1) {
          var s, o;
          const a = (_(this, Wh, ((s = d(this, Wh)), (o = s++), s)), o),
            l = b(this, uA, GB).call(this, e.box);
          l.classList.add('highlight'), e.free && l.classList.add('free');
          const c = en._svgFactory.createElement('defs');
          l.append(c);
          const u = en._svgFactory.createElement('path');
          c.append(u);
          const h = `path_p${this.pageIndex}_${a}`;
          u.setAttribute('id', h),
            u.setAttribute('d', e.toSVGPath()),
            r && d(this, Sc).set(a, u);
          const f = b(this, UB, Fse).call(this, c, h),
            p = en._svgFactory.createElement('use');
          return (
            l.append(p),
            l.setAttribute('fill', t),
            l.setAttribute('fill-opacity', i),
            p.setAttribute('href', `#${h}`),
            d(this, xn).set(a, l),
            { id: a, clipPathId: `url(#${f})` }
          );
        }
        highlightOutline(e) {
          var t, i;
          const r = (_(this, Wh, ((t = d(this, Wh)), (i = t++), t)), i),
            s = b(this, uA, GB).call(this, e.box);
          s.classList.add('highlightOutline');
          const o = en._svgFactory.createElement('defs');
          s.append(o);
          const a = en._svgFactory.createElement('path');
          o.append(a);
          const l = `path_p${this.pageIndex}_${r}`;
          let c;
          if (
            (a.setAttribute('id', l),
            a.setAttribute('d', e.toSVGPath()),
            a.setAttribute('vector-effect', 'non-scaling-stroke'),
            e.free)
          ) {
            s.classList.add('free');
            const f = en._svgFactory.createElement('mask');
            o.append(f),
              (c = `mask_p${this.pageIndex}_${r}`),
              f.setAttribute('id', c),
              f.setAttribute('maskUnits', 'objectBoundingBox');
            const p = en._svgFactory.createElement('rect');
            f.append(p),
              p.setAttribute('width', '1'),
              p.setAttribute('height', '1'),
              p.setAttribute('fill', 'white');
            const m = en._svgFactory.createElement('use');
            f.append(m),
              m.setAttribute('href', `#${l}`),
              m.setAttribute('stroke', 'none'),
              m.setAttribute('fill', 'black'),
              m.setAttribute('fill-rule', 'nonzero'),
              m.classList.add('mask');
          }
          const u = en._svgFactory.createElement('use');
          s.append(u),
            u.setAttribute('href', `#${l}`),
            c && u.setAttribute('mask', `url(#${c})`);
          const h = u.cloneNode();
          return (
            s.append(h),
            u.classList.add('mainOutline'),
            h.classList.add('secondaryOutline'),
            d(this, xn).set(r, s),
            r
          );
        }
        finalizeLine(e, t) {
          const i = d(this, Sc).get(e);
          d(this, Sc).delete(e),
            this.updateBox(e, t.box),
            i.setAttribute('d', t.toSVGPath());
        }
        updateLine(e, t) {
          d(this, xn)
            .get(e)
            .firstChild.firstChild.setAttribute('d', t.toSVGPath());
        }
        removeFreeHighlight(e) {
          this.remove(e), d(this, Sc).delete(e);
        }
        updatePath(e, t) {
          d(this, Sc).get(e).setAttribute('d', t.toSVGPath());
        }
        updateBox(e, t) {
          we(en, en, $B).call(en, d(this, xn).get(e), t);
        }
        show(e, t) {
          d(this, xn).get(e).classList.toggle('hidden', !t);
        }
        rotate(e, t) {
          d(this, xn).get(e).setAttribute('data-main-rotation', t);
        }
        changeColor(e, t) {
          d(this, xn).get(e).setAttribute('fill', t);
        }
        changeOpacity(e, t) {
          d(this, xn).get(e).setAttribute('fill-opacity', t);
        }
        addClass(e, t) {
          d(this, xn).get(e).classList.add(t);
        }
        removeClass(e, t) {
          d(this, xn).get(e).classList.remove(t);
        }
        remove(e) {
          null !== d(this, bo) &&
            (d(this, xn).get(e).remove(), d(this, xn).delete(e));
        }
        destroy() {
          _(this, bo, null);
          for (const e of d(this, xn).values()) e.remove();
          d(this, xn).clear();
        }
      }
      function $B(n, { x: e = 0, y: t = 0, width: i = 1, height: r = 1 } = {}) {
        const { style: s } = n;
        (s.top = 100 * t + '%'),
          (s.left = 100 * e + '%'),
          (s.width = 100 * i + '%'),
          (s.height = 100 * r + '%');
      }
      function GB(n) {
        const e = en._svgFactory.create(1, 1, !0);
        return (
          d(this, bo).append(e),
          e.setAttribute('aria-hidden', !0),
          we(en, en, $B).call(en, e, n),
          e
        );
      }
      function Fse(n, e) {
        const t = en._svgFactory.createElement('clipPath');
        n.append(t);
        const i = `clip_${e}`;
        t.setAttribute('id', i),
          t.setAttribute('clipPathUnits', 'objectBoundingBox');
        const r = en._svgFactory.createElement('use');
        return (
          t.append(r),
          r.setAttribute('href', `#${e}`),
          r.classList.add('clip'),
          i
        );
      }
      var Ose = Me.AbortException,
        Lse = Me.AnnotationEditorLayer,
        Nse = Me.AnnotationEditorParamsType,
        qB = Me.AnnotationEditorType,
        Vse = Me.AnnotationEditorUIManager,
        Bse = Me.AnnotationLayer,
        Hse = Me.AnnotationMode,
        Wse = Me.CMapCompressionType,
        jse = Me.ColorPicker,
        zse = Me.DOMSVGFactory,
        Use = Me.DrawLayer,
        $se = Me.FeatureTest,
        XB = Me.GlobalWorkerOptions,
        Gse = Me.ImageKind,
        qse = Me.InvalidPDFException,
        Xse = Me.MissingPDFException,
        Yse = Me.OPS,
        Kse = Me.PDFDataRangeTransport,
        Zse = Me.PDFDateString,
        Qse = Me.PDFWorker,
        Jse = Me.PasswordResponses,
        eoe = Me.PermissionFlag,
        toe = Me.PixelsPerInch,
        noe = Me.RenderingCancelledException,
        ioe = Me.TextLayer,
        roe = Me.UnexpectedResponseException,
        soe = Me.Util,
        YB = Me.VerbosityLevel,
        ooe = Me.XfaLayer,
        aoe = Me.build,
        loe = Me.createValidAbsoluteUrl,
        coe = Me.fetchData,
        KB = Me.getDocument,
        doe = Me.getFilenameFromUrl,
        uoe = Me.getPdfFilenameFromUrl,
        hoe = Me.getXfaPageViewport,
        foe = Me.isDataScheme,
        poe = Me.isPdfFile,
        moe = Me.noContextMenu,
        goe = Me.normalizeUnicode,
        _oe = Me.setLayerDimensions,
        boe = Me.shadow,
        V_ = Me.version;
      function ZB(n, e) {
        (this.v = n), (this.k = e);
      }
      function QB(n) {
        return new ZB(n, 0);
      }
      function jh(n) {
        var e, t;
        function i(s, o) {
          try {
            var a = n[s](o),
              l = a.value,
              c = l instanceof ZB;
            Promise.resolve(c ? l.v : l).then(
              function (u) {
                if (c) {
                  var h = 'return' === s ? 'return' : 'next';
                  if (!l.k || u.done) return i(h, u);
                  u = n[h](u).value;
                }
                r(a.done ? 'return' : 'normal', u);
              },
              function (u) {
                i('throw', u);
              }
            );
          } catch (u) {
            r('throw', u);
          }
        }
        function r(s, o) {
          switch (s) {
            case 'return':
              e.resolve({ value: o, done: !0 });
              break;
            case 'throw':
              e.reject(o);
              break;
            default:
              e.resolve({ value: o, done: !1 });
          }
          (e = e.next) ? i(e.key, e.arg) : (t = null);
        }
        (this._invoke = function (s, o) {
          return new Promise(function (a, l) {
            var c = { key: s, arg: o, resolve: a, reject: l, next: null };
            t ? (t = t.next = c) : ((e = t = c), i(s, o));
          });
        }),
          'function' != typeof n.return && (this.return = void 0);
      }
      function JB(n) {
        return function () {
          return new jh(n.apply(this, arguments));
        };
      }
      function B_(n) {
        function e(t) {
          if (Object(t) !== t)
            return Promise.reject(new TypeError(t + ' is not an object.'));
          var i = t.done;
          return Promise.resolve(t.value).then(function (r) {
            return { value: r, done: i };
          });
        }
        return (
          ((B_ = function (i) {
            (this.s = i), (this.n = i.next);
          }).prototype = {
            s: null,
            n: null,
            next: function () {
              return e(this.n.apply(this.s, arguments));
            },
            return: function (i) {
              var r = this.s.return;
              return void 0 === r
                ? Promise.resolve({ value: i, done: !0 })
                : e(r.apply(this.s, arguments));
            },
            throw: function (i) {
              var r = this.s.return;
              return void 0 === r
                ? Promise.reject(i)
                : e(r.apply(this.s, arguments));
            },
          }),
          new B_(n)
        );
      }
      let eH;
      (jh.prototype[
        ('function' == typeof Symbol && Symbol.asyncIterator) ||
          '@@asyncIterator'
      ] = function () {
        return this;
      }),
        (jh.prototype.next = function (n) {
          return this._invoke('next', n);
        }),
        (jh.prototype.throw = function (n) {
          return this._invoke('throw', n);
        }),
        (jh.prototype.return = function (n) {
          return this._invoke('return', n);
        });
      var zh = {
          d: (n, e) => {
            for (var t in e)
              zh.o(e, t) &&
                !zh.o(n, t) &&
                Object.defineProperty(n, t, { enumerable: !0, get: e[t] });
          },
          o: (n, e) => Object.prototype.hasOwnProperty.call(n, e),
        },
        Ft = (globalThis.pdfjsViewer = {});
      zh.d(Ft, {
        AnnotationLayerBuilder: () => PH,
        DownloadManager: () => Sae,
        EventBus: () => LH,
        FindState: () => vo,
        GenericL10n: () => Zn,
        LinkTarget: () => Va,
        PDFFindController: () => nae,
        PDFHistory: () => Sle,
        PDFLinkService: () => Rc,
        PDFPageView: () => wW,
        PDFScriptingManager: () => Yle,
        PDFSinglePageViewer: () => lce,
        PDFViewer: () => zW,
        ProgressBar: () => Roe,
        RenderingStates: () => Bt,
        ScrollMode: () => Ke,
        SimpleLinkService: () => AA,
        SpreadMode: () => Ln,
        StructTreeLayerBuilder: () => fW,
        TextLayerBuilder: () => Tt,
        XfaLayerBuilder: () => bW,
        parseQueryString: () => H_,
      });
      const Coe = 1.25,
        iH = 40,
        rH = 5,
        Bt = { INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3 },
        Ke = { UNKNOWN: -1, VERTICAL: 0, HORIZONTAL: 1, WRAPPED: 2, PAGE: 3 },
        Ln = { UNKNOWN: -1, NONE: 0, ODD: 1, EVEN: 2 };
      class xoe {
        constructor() {
          const e = window.devicePixelRatio || 1;
          (this.sx = e), (this.sy = e);
        }
        get scaled() {
          return 1 !== this.sx || 1 !== this.sy;
        }
      }
      function sH(n, e, t = !1) {
        let i = n.offsetParent;
        if (!i)
          return void console.error('offsetParent is not set -- cannot scroll');
        let r = n.offsetTop + n.clientTop,
          s = n.offsetLeft + n.clientLeft;
        for (
          ;
          (i.clientHeight === i.scrollHeight &&
            i.clientWidth === i.scrollWidth) ||
          (t &&
            (i.classList.contains('markedContent') ||
              'hidden' === getComputedStyle(i).overflow));

        )
          if (
            ((r += i.offsetTop), (s += i.offsetLeft), (i = i.offsetParent), !i)
          )
            return;
        e &&
          (void 0 !== e.top && (r += e.top),
          void 0 !== e.left && ((s += e.left), (i.scrollLeft = s))),
          (i.scrollTop = r);
      }
      function H_(n) {
        const e = new Map();
        for (const [t, i] of new URLSearchParams(n)) e.set(t.toLowerCase(), i);
        return e;
      }
      const oH = /[\x00-\x1F]/g;
      function W_(n, e = !1) {
        return oH.test(n)
          ? e
            ? n.replaceAll(oH, (t) => ('\0' === t ? '' : ' '))
            : n.replaceAll('\0', '')
          : n;
      }
      function Uh(n, e, t = 0) {
        let i = t,
          r = n.length - 1;
        if (r < 0 || !e(n[r])) return n.length;
        if (e(n[i])) return i;
        for (; i < r; ) {
          const s = (i + r) >> 1;
          e(n[s]) ? (r = s) : (i = s + 1);
        }
        return i;
      }
      function aH(n) {
        if (Math.floor(n) === n) return [n, 1];
        const e = 1 / n;
        if (e > 8) return [1, 8];
        if (Math.floor(e) === e) return [1, e];
        const i = n > 1 ? e : n;
        let l,
          r = 0,
          s = 1,
          o = 1,
          a = 1;
        for (;;) {
          const c = r + o,
            u = s + a;
          if (u > 8) break;
          i <= c / u ? ((o = c), (a = u)) : ((r = c), (s = u));
        }
        return (
          (l =
            i - r / s < o / a - i
              ? i === n
                ? [r, s]
                : [s, r]
              : i === n
              ? [o, a]
              : [a, o]),
          l
        );
      }
      function j_(n, e) {
        return n - (n % e);
      }
      function lH(n) {
        return Number.isInteger(n) && n % 90 == 0;
      }
      function cH(n) {
        return n.width <= n.height;
      }
      new Promise(function (n) {
        window.requestAnimationFrame(n);
      });
      const koe = document.documentElement.style;
      var Tc = new WeakMap(),
        $h = new WeakMap(),
        Ic = new WeakMap(),
        z_ = new WeakMap(),
        Gh = new WeakMap();
      class Roe {
        constructor(e) {
          v(this, Tc, { writable: !0, value: null }),
            v(this, $h, { writable: !0, value: null }),
            v(this, Ic, { writable: !0, value: 0 }),
            v(this, z_, { writable: !0, value: null }),
            v(this, Gh, { writable: !0, value: !0 }),
            _(this, Tc, e.classList),
            _(this, z_, e.style);
        }
        get percent() {
          return d(this, Ic);
        }
        set percent(e) {
          _(
            this,
            Ic,
            (function Poe(n, e, t) {
              return Math.min(Math.max(n, e), t);
            })(e, 0, 100)
          ),
            isNaN(e)
              ? d(this, Tc).add('indeterminate')
              : (d(this, Tc).remove('indeterminate'),
                d(this, z_).setProperty(
                  '--progressBar-percent',
                  `${d(this, Ic)}%`
                ));
        }
        setWidth(e) {
          if (!e) return;
          const i = e.parentNode.offsetWidth - e.offsetWidth;
          i > 0 &&
            d(this, z_).setProperty('--progressBar-end-offset', `${i}px`);
        }
        setDisableAutoFetch(e = 5e3) {
          100 === d(this, Ic) ||
            isNaN(d(this, Ic)) ||
            (d(this, $h) && clearTimeout(d(this, $h)),
            this.show(),
            _(
              this,
              $h,
              setTimeout(() => {
                _(this, $h, null), this.hide();
              }, e)
            ));
        }
        hide() {
          d(this, Gh) && (_(this, Gh, !1), d(this, Tc).add('hidden'));
        }
        show() {
          d(this, Gh) || (_(this, Gh, !0), d(this, Tc).remove('hidden'));
        }
      }
      const vr = {
        SPACE: 0,
        ALPHA_LETTER: 1,
        PUNCT: 2,
        HAN_LETTER: 3,
        KATAKANA_LETTER: 4,
        HIRAGANA_LETTER: 5,
        HALFWIDTH_KATAKANA_LETTER: 6,
        THAI_LETTER: 7,
      };
      function U_(n) {
        return (function Ooe(n) {
          return n < 11904;
        })(n)
          ? (function Loe(n) {
              return 0 == (65408 & n);
            })(n)
            ? (function Boe(n) {
                return 32 === n || 9 === n || 13 === n || 10 === n;
              })(n)
              ? vr.SPACE
              : (function Noe(n) {
                  return (n >= 97 && n <= 122) || (n >= 65 && n <= 90);
                })(n) ||
                (function Voe(n) {
                  return n >= 48 && n <= 57;
                })(n) ||
                95 === n
              ? vr.ALPHA_LETTER
              : vr.PUNCT
            : (function Uoe(n) {
                return 3584 == (65408 & n);
              })(n)
            ? vr.THAI_LETTER
            : 160 === n
            ? vr.SPACE
            : vr.ALPHA_LETTER
          : (function Hoe(n) {
              return (n >= 13312 && n <= 40959) || (n >= 63744 && n <= 64255);
            })(n)
          ? vr.HAN_LETTER
          : (function Woe(n) {
              return n >= 12448 && n <= 12543;
            })(n)
          ? vr.KATAKANA_LETTER
          : (function joe(n) {
              return n >= 12352 && n <= 12447;
            })(n)
          ? vr.HIRAGANA_LETTER
          : (function zoe(n) {
              return n >= 65376 && n <= 65439;
            })(n)
          ? vr.HALFWIDTH_KATAKANA_LETTER
          : vr.ALPHA_LETTER;
      }
      let dH;
      const vo = { FOUND: 0, NOT_FOUND: 1, WRAPPED: 2, PENDING: 3 },
        uH = {
          '\u2010': '-',
          '\u2018': "'",
          '\u2019': "'",
          '\u201a': "'",
          '\u201b': "'",
          '\u201c': '"',
          '\u201d': '"',
          '\u201e': '"',
          '\u201f': '"',
          '\xbc': '1/4',
          '\xbd': '1/2',
          '\xbe': '3/4',
        },
        hH = new Set([
          12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387,
          3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098,
          6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347,
          43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968,
          3956,
        ]);
      let fH;
      const Yoe = /\p{M}+/gu,
        Koe = /([.*+?^${}()|[\]\\])|(\p{P})|(\s+)|(\p{M})|(\p{L})/gu,
        Zoe = /([^\p{M}])\p{M}*$/u,
        Qoe = /^\p{M}*([^\p{M}])/u,
        Joe = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g,
        pH = new Map(),
        eae =
          '[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]',
        mH = new Map();
      let fA = null,
        pA = null;
      function mA(n) {
        const e = [];
        let t, i;
        for (; null !== (t = Joe.exec(n)); ) {
          let { index: p } = t;
          for (const m of t[0]) {
            let g = pH.get(m);
            g || ((g = m.normalize('NFD').length), pH.set(m, g)),
              e.push([g, p++]);
          }
        }
        if (0 === e.length && fA) i = fA;
        else if (e.length > 0 && pA) i = pA;
        else {
          const y = `([${Object.keys(uH).join('')}])|([${(function $oe() {
            return (
              (dH ||=
                '\xa0\xa8\xaa\xaf\xb2-\xb5\xb8-\xba\xbc-\xbe\u0132-\u0133\u013f-\u0140\u0149\u017f\u01c4-\u01cc\u01f1-\u01f3\u02b0-\u02b8\u02d8-\u02dd\u02e0-\u02e4\u0374\u037a\u037e\u0384-\u0385\u0387\u03d0-\u03d6\u03f0-\u03f2\u03f4-\u03f5\u03f9\u0587\u0675-\u0678\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e33\u0eb3\u0edc-\u0edd\u0f0c\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u10fc\u1d2c-\u1d2e\u1d30-\u1d3a\u1d3c-\u1d4d\u1d4f-\u1d6a\u1d78\u1d9b-\u1dbf\u1e9a-\u1e9b\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbd-\u1fc1\u1fc9\u1fcb\u1fcd-\u1fcf\u1fd3\u1fdb\u1fdd-\u1fdf\u1fe3\u1feb\u1fed-\u1fef\u1ff9\u1ffb\u1ffd-\u1ffe\u2000-\u200a\u2011\u2017\u2024-\u2026\u202f\u2033-\u2034\u2036-\u2037\u203c\u203e\u2047-\u2049\u2057\u205f\u2070-\u2071\u2074-\u208e\u2090-\u209c\u20a8\u2100-\u2103\u2105-\u2107\u2109-\u2113\u2115-\u2116\u2119-\u211d\u2120-\u2122\u2124\u2126\u2128\u212a-\u212d\u212f-\u2131\u2133-\u2139\u213b-\u2140\u2145-\u2149\u2150-\u217f\u2189\u222c-\u222d\u222f-\u2230\u2329-\u232a\u2460-\u24ea\u2a0c\u2a74-\u2a76\u2adc\u2c7c-\u2c7d\u2d6f\u2e9f\u2ef3\u2f00-\u2fd5\u3000\u3036\u3038-\u303a\u309b-\u309c\u309f\u30ff\u3131-\u318e\u3192-\u319f\u3200-\u321e\u3220-\u3247\u3250-\u327e\u3280-\u33ff\ua69c-\ua69d\ua770\ua7f2-\ua7f4\ua7f8-\ua7f9\uab5c-\uab5f\uab69\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfc\ufe10-\ufe19\ufe30-\ufe44\ufe47-\ufe52\ufe54-\ufe66\ufe68-\ufe6b\ufe70-\ufe72\ufe74\ufe76-\ufefc\uff01-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc\uffe0-\uffe6'),
              dH
            );
          })()}])|((?:\u3099|\u309a)\\n)|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|((?:\\p{Ideographic}|[\u3040-\u30ff])\\n)|(\\n)`;
          i =
            0 === e.length
              ? (fA = new RegExp(y + '|(\\u0000)', 'gum'))
              : (pA = new RegExp(y + `|(${eae})`, 'gum'));
        }
        const r = [];
        for (; null !== (t = Yoe.exec(n)); ) r.push([t[0].length, t.index]);
        let s = n.normalize('NFD');
        const o = [[0, 0]];
        let a = 0,
          l = 0,
          c = 0,
          u = 0,
          h = 0,
          f = !1;
        return (
          (s = s.replace(i, (p, m, g, w, y, E, A, M, T, k) => {
            if (((k -= u), m)) {
              const P = uH[m],
                O = P.length;
              for (let I = 1; I < O; I++) o.push([k - c + I, c - I]);
              return (c -= O - 1), P;
            }
            if (g) {
              let P = mH.get(g);
              P || ((P = g.normalize('NFKC')), mH.set(g, P));
              const O = P.length;
              for (let I = 1; I < O; I++) o.push([k - c + I, c - I]);
              return (c -= O - 1), P;
            }
            if (w)
              return (
                (f = !0),
                k + h === r[a]?.[1]
                  ? ++a
                  : (o.push([k - 1 - c + 1, c - 1]), (c -= 1), (u += 1)),
                o.push([k - c + 1, c]),
                (u += 1),
                (h += 1),
                w.charAt(0)
              );
            if (y) {
              const P = y.endsWith('\n'),
                O = P ? y.length - 2 : y.length;
              f = !0;
              let I = O;
              k + h === r[a]?.[1] && ((I -= r[a][0]), ++a);
              for (let C = 1; C <= I; C++) o.push([k - 1 - c + C, c - C]);
              return (
                (c -= I),
                (u += I),
                P
                  ? (o.push([(k += O - 1) - c + 1, 1 + c]),
                    (c += 1),
                    (u += 1),
                    (h += 1),
                    y.slice(0, O))
                  : y
              );
            }
            if (E)
              return (
                o.push([k - c + (E.length - 2), 1 + c]),
                (c += 1),
                (u += 1),
                (h += 1),
                E.slice(0, -2)
              );
            if (A)
              return (
                o.push([k - c + (A.length - 1), c]),
                (u += 1),
                (h += 1),
                A.slice(0, -1)
              );
            if (M)
              return (
                o.push([k - c + 1, c - 1]), (c -= 1), (u += 1), (h += 1), ' '
              );
            if (k + h === e[l]?.[1]) {
              const P = e[l][0] - 1;
              ++l;
              for (let O = 1; O <= P; O++) o.push([k - (c - O), c - O]);
              (c -= P), (u += P);
            }
            return T;
          })),
          o.push([s.length, c]),
          [s, o, f]
        );
      }
      function tae(n, e, t) {
        if (!n) return [e, t];
        const i = e,
          r = e + t - 1;
        let s = Uh(n, (u) => u[0] >= i);
        n[s][0] > i && --s;
        let o = Uh(n, (u) => u[0] >= r, s);
        n[o][0] > r && --o;
        const a = i + n[s][1];
        return [a, r + n[o][1] + 1 - a];
      }
      var Nn = new WeakMap(),
        $_ = new WeakMap(),
        kc = new WeakMap(),
        gH = new WeakSet(),
        gA = new WeakSet(),
        _A = new WeakMap(),
        _H = new WeakSet(),
        bH = new WeakSet(),
        vH = new WeakSet(),
        bA = new WeakSet(),
        yH = new WeakSet(),
        wH = new WeakSet(),
        G_ = new WeakSet(),
        qh = new WeakSet(),
        Pc = new WeakSet(),
        EH = new WeakSet(),
        vA = new WeakSet(),
        yA = new WeakSet(),
        q_ = new WeakSet(),
        CH = new WeakSet(),
        wA = new WeakSet(),
        EA = new WeakSet(),
        Xh = new WeakSet();
      class nae {
        constructor({
          linkService: e,
          eventBus: t,
          updateMatchesCountOnProgress: i = !0,
        }) {
          S(this, Xh),
            S(this, EA),
            S(this, wA),
            S(this, CH),
            S(this, q_),
            S(this, yA),
            S(this, vA),
            S(this, EH),
            S(this, Pc),
            S(this, qh),
            S(this, G_),
            S(this, wH),
            S(this, yH),
            S(this, bA),
            S(this, vH),
            S(this, bH),
            S(this, _H),
            v(this, _A, { get: rae, set: void 0 }),
            S(this, gA),
            S(this, gH),
            v(this, Nn, { writable: !0, value: null }),
            v(this, $_, { writable: !0, value: !0 }),
            v(this, kc, { writable: !0, value: 0 }),
            (this._linkService = e),
            (this._eventBus = t),
            _(this, $_, i),
            (this.onIsPageVisible = null),
            b(this, gA, xH).call(this),
            t._on('find', b(this, gH, iae).bind(this)),
            t._on('findbarclose', b(this, CH, uae).bind(this));
        }
        get highlightMatches() {
          return this._highlightMatches;
        }
        get pageMatches() {
          return this._pageMatches;
        }
        get pageMatchesLength() {
          return this._pageMatchesLength;
        }
        get selected() {
          return this._selected;
        }
        get state() {
          return d(this, Nn);
        }
        setDocument(e) {
          this._pdfDocument && b(this, gA, xH).call(this),
            e && ((this._pdfDocument = e), this._firstPageCapability.resolve());
        }
        scrollMatchIntoView({
          element: e = null,
          selectedLeft: t = 0,
          pageIndex: i = -1,
          matchIndex: r = -1,
        }) {
          this._scrollMatches &&
            e &&
            -1 !== r &&
            r === this._selected.matchIdx &&
            -1 !== i &&
            i === this._selected.pageIdx &&
            ((this._scrollMatches = !1),
            sH(e, { top: -50, left: t + -400 }, !0));
        }
      }
      function iae(n) {
        if (!n) return;
        const e = this._pdfDocument,
          { type: t } = n;
        (null === d(this, Nn) || b(this, _H, sae).call(this, n)) &&
          (this._dirtyMatch = !0),
          _(this, Nn, n),
          'highlightallchange' !== t && b(this, Xh, Y_).call(this, vo.PENDING),
          this._firstPageCapability.promise.then(() => {
            if (!this._pdfDocument || (e && this._pdfDocument !== e)) return;
            b(this, wH, cae).call(this);
            const i = !this._highlightMatches,
              r = !!this._findTimeout;
            this._findTimeout &&
              (clearTimeout(this._findTimeout), (this._findTimeout = null)),
              t
                ? this._dirtyMatch
                  ? b(this, Pc, Yh).call(this)
                  : 'again' === t
                  ? (b(this, Pc, Yh).call(this),
                    i && d(this, Nn).highlightAll && b(this, qh, X_).call(this))
                  : 'highlightallchange' === t
                  ? (r
                      ? b(this, Pc, Yh).call(this)
                      : (this._highlightMatches = !0),
                    b(this, qh, X_).call(this))
                  : b(this, Pc, Yh).call(this)
                : (this._findTimeout = setTimeout(() => {
                    b(this, Pc, Yh).call(this), (this._findTimeout = null);
                  }, 250));
          });
      }
      function xH() {
        (this._highlightMatches = !1),
          (this._scrollMatches = !1),
          (this._pdfDocument = null),
          (this._pageMatches = []),
          (this._pageMatchesLength = []),
          _(this, kc, 0),
          _(this, Nn, null),
          (this._selected = { pageIdx: -1, matchIdx: -1 }),
          (this._offset = { pageIdx: null, matchIdx: null, wrapped: !1 }),
          (this._extractTextPromises = []),
          (this._pageContents = []),
          (this._pageDiffs = []),
          (this._hasDiacritics = []),
          (this._matchesCountTotal = 0),
          (this._pagesToSearch = null),
          (this._pendingFindMatches = new Set()),
          (this._resumePageIdx = null),
          (this._dirtyMatch = !1),
          clearTimeout(this._findTimeout),
          (this._findTimeout = null),
          (this._firstPageCapability = Promise.withResolvers());
      }
      function rae() {
        const { query: n } = d(this, Nn);
        return 'string' == typeof n
          ? (n !== this._rawQuery &&
              ((this._rawQuery = n), ([this._normalizedQuery] = mA(n))),
            this._normalizedQuery)
          : (n || []).filter((e) => !!e).map((e) => mA(e)[0]);
      }
      function sae(n) {
        const e = n.query,
          t = d(this, Nn).query,
          i = typeof e;
        if (i !== typeof t) return !0;
        if ('string' === i) {
          if (e !== t) return !0;
        } else if (JSON.stringify(e) !== JSON.stringify(t)) return !0;
        switch (n.type) {
          case 'again':
            const s = this._selected.pageIdx + 1,
              o = this._linkService;
            return (
              s >= 1 &&
              s <= o.pagesCount &&
              s !== o.page &&
              !(this.onIsPageVisible?.(s) ?? 1)
            );
          case 'highlightallchange':
            return !1;
        }
        return !0;
      }
      function oae(n, e, t) {
        let i = n.slice(0, e).match(Zoe);
        if (i) {
          const r = n.charCodeAt(e),
            s = i[1].charCodeAt(0);
          if (U_(r) === U_(s)) return !1;
        }
        if (((i = n.slice(e + t).match(Qoe)), i)) {
          const r = n.charCodeAt(e + t - 1),
            s = i[1].charCodeAt(0);
          if (U_(r) === U_(s)) return !1;
        }
        return !0;
      }
      function aae(n, e, t, i) {
        const r = (this._pageMatches[t] = []),
          s = (this._pageMatchesLength[t] = []);
        if (!n) return;
        const o = this._pageDiffs[t];
        let a;
        for (; null !== (a = n.exec(i)); ) {
          if (e && !b(this, bH, oae).call(this, i, a.index, a[0].length))
            continue;
          const [l, c] = tae(o, a.index, a[0].length);
          c && (r.push(l), s.push(c));
        }
      }
      function AH(n, e) {
        const { matchDiacritics: t } = d(this, Nn);
        let i = !1;
        return (
          (n = n.replaceAll(Koe, (s, o, a, l, c, u) =>
            o
              ? `[ ]*\\${o}[ ]*`
              : a
              ? `[ ]*${a}[ ]*`
              : l
              ? '[ ]+'
              : t
              ? c || u
              : c
              ? hH.has(c.charCodeAt(0))
                ? c
                : ''
              : e
              ? ((i = !0), `${u}\\p{M}*`)
              : u
          )).endsWith('[ ]*') && (n = n.slice(0, n.length - 4)),
          t &&
            e &&
            ((fH ||= String.fromCharCode(...hH)),
            (i = !0),
            (n = `${n}(?=[${fH}]|[^\\p{M}]|$)`)),
          [i, n]
        );
      }
      function lae(n) {
        var e;
        let t = d(this, _A);
        if (0 === t.length) return;
        const { caseSensitive: i, entireWord: r } = d(this, Nn),
          s = this._pageContents[n],
          o = this._hasDiacritics[n];
        let a = !1;
        'string' == typeof t
          ? ([a, t] = b(this, bA, AH).call(this, t, o))
          : (t = t
              .sort()
              .reverse()
              .map((u) => {
                const [h, f] = b(this, bA, AH).call(this, u, o);
                return (a ||= h), `(${f})`;
              })
              .join('|')),
          (t = t ? new RegExp(t, `g${a ? 'u' : ''}${i ? '' : 'i'}`) : null),
          b(this, vH, aae).call(this, t, r, n, s),
          d(this, Nn).highlightAll && b(this, G_, CA).call(this, n),
          this._resumePageIdx === n &&
            ((this._resumePageIdx = null), b(this, vA, SH).call(this));
        const c = this._pageMatches[n].length;
        (this._matchesCountTotal += c),
          d(this, $_)
            ? c > 0 && b(this, EA, TH).call(this)
            : _(this, kc, ((e = d(this, kc)), ++e)) ===
                this._linkService.pagesCount && b(this, EA, TH).call(this);
      }
      function cae() {
        if (this._extractTextPromises.length > 0) return;
        let n = Promise.resolve();
        const e = { disableNormalization: !0 };
        for (let t = 0, i = this._linkService.pagesCount; t < i; t++) {
          const { promise: r, resolve: s } = Promise.withResolvers();
          (this._extractTextPromises[t] = r),
            (n = n.then(() =>
              this._pdfDocument
                .getPage(t + 1)
                .then((o) => o.getTextContent(e))
                .then(
                  (o) => {
                    const a = [];
                    for (const l of o.items)
                      a.push(l.str), l.hasEOL && a.push('\n');
                    ([
                      this._pageContents[t],
                      this._pageDiffs[t],
                      this._hasDiacritics[t],
                    ] = mA(a.join(''))),
                      s();
                  },
                  (o) => {
                    console.error(
                      `Unable to get text content for page ${t + 1}`,
                      o
                    ),
                      (this._pageContents[t] = ''),
                      (this._pageDiffs[t] = null),
                      (this._hasDiacritics[t] = !1),
                      s();
                  }
                )
            ));
        }
      }
      function CA(n) {
        this._scrollMatches &&
          this._selected.pageIdx === n &&
          (this._linkService.page = n + 1),
          this._eventBus.dispatch('updatetextlayermatches', {
            source: this,
            pageIndex: n,
          });
      }
      function X_() {
        this._eventBus.dispatch('updatetextlayermatches', {
          source: this,
          pageIndex: -1,
        });
      }
      function Yh() {
        const n = d(this, Nn).findPrevious,
          e = this._linkService.page - 1,
          t = this._linkService.pagesCount;
        if (((this._highlightMatches = !0), this._dirtyMatch)) {
          (this._dirtyMatch = !1),
            (this._selected.pageIdx = this._selected.matchIdx = -1),
            (this._offset.pageIdx = e),
            (this._offset.matchIdx = null),
            (this._offset.wrapped = !1),
            (this._resumePageIdx = null),
            (this._pageMatches.length = 0),
            (this._pageMatchesLength.length = 0),
            _(this, kc, 0),
            (this._matchesCountTotal = 0),
            b(this, qh, X_).call(this);
          for (let s = 0; s < t; s++)
            this._pendingFindMatches.has(s) ||
              (this._pendingFindMatches.add(s),
              this._extractTextPromises[s].then(() => {
                this._pendingFindMatches.delete(s),
                  b(this, yH, lae).call(this, s);
              }));
        }
        if (0 === d(this, _A).length)
          return void b(this, Xh, Y_).call(this, vo.FOUND);
        if (this._resumePageIdx) return;
        const r = this._offset;
        if (((this._pagesToSearch = t), null !== r.matchIdx)) {
          if (
            (!n && r.matchIdx + 1 < this._pageMatches[r.pageIdx].length) ||
            (n && r.matchIdx > 0)
          )
            return (
              (r.matchIdx = n ? r.matchIdx - 1 : r.matchIdx + 1),
              void b(this, q_, xA).call(this, !0)
            );
          b(this, yA, MH).call(this, n);
        }
        b(this, vA, SH).call(this);
      }
      function dae(n) {
        const e = this._offset,
          t = n.length,
          i = d(this, Nn).findPrevious;
        return t
          ? ((e.matchIdx = i ? t - 1 : 0), b(this, q_, xA).call(this, !0), !0)
          : (b(this, yA, MH).call(this, i),
            !!(e.wrapped && ((e.matchIdx = null), this._pagesToSearch < 0)) &&
              (b(this, q_, xA).call(this, !1), !0));
      }
      function SH() {
        null !== this._resumePageIdx &&
          console.error('There can only be one pending page.');
        let n = null;
        do {
          const e = this._offset.pageIdx;
          if (((n = this._pageMatches[e]), !n)) {
            this._resumePageIdx = e;
            break;
          }
        } while (!b(this, EH, dae).call(this, n));
      }
      function MH(n) {
        const e = this._offset,
          t = this._linkService.pagesCount;
        (e.pageIdx = n ? e.pageIdx - 1 : e.pageIdx + 1),
          (e.matchIdx = null),
          this._pagesToSearch--,
          (e.pageIdx >= t || e.pageIdx < 0) &&
            ((e.pageIdx = n ? t - 1 : 0), (e.wrapped = !0));
      }
      function xA(n = !1) {
        let e = vo.NOT_FOUND;
        const t = this._offset.wrapped;
        if (((this._offset.wrapped = !1), n)) {
          const i = this._selected.pageIdx;
          (this._selected.pageIdx = this._offset.pageIdx),
            (this._selected.matchIdx = this._offset.matchIdx),
            (e = t ? vo.WRAPPED : vo.FOUND),
            -1 !== i &&
              i !== this._selected.pageIdx &&
              b(this, G_, CA).call(this, i);
        }
        b(this, Xh, Y_).call(this, e, d(this, Nn).findPrevious),
          -1 !== this._selected.pageIdx &&
            ((this._scrollMatches = !0),
            b(this, G_, CA).call(this, this._selected.pageIdx));
      }
      function uae(n) {
        const e = this._pdfDocument;
        this._firstPageCapability.promise.then(() => {
          !this._pdfDocument ||
            (e && this._pdfDocument !== e) ||
            (this._findTimeout &&
              (clearTimeout(this._findTimeout), (this._findTimeout = null)),
            this._resumePageIdx &&
              ((this._resumePageIdx = null), (this._dirtyMatch = !0)),
            b(this, Xh, Y_).call(this, vo.FOUND),
            (this._highlightMatches = !1),
            b(this, qh, X_).call(this));
        });
      }
      function DH() {
        const { pageIdx: n, matchIdx: e } = this._selected;
        let t = 0,
          i = this._matchesCountTotal;
        if (-1 !== e) {
          for (let r = 0; r < n; r++) t += this._pageMatches[r]?.length || 0;
          t += e + 1;
        }
        return (t < 1 || t > i) && (t = i = 0), { current: t, total: i };
      }
      function TH() {
        this._eventBus.dispatch('updatefindmatchescount', {
          source: this,
          matchesCount: b(this, wA, DH).call(this),
        });
      }
      function Y_(n, e = !1) {
        (!d(this, $_) &&
          (d(this, kc) !== this._linkService.pagesCount || n === vo.PENDING)) ||
          this._eventBus.dispatch('updatefindcontrolstate', {
            source: this,
            state: n,
            previous: e,
            entireWord: d(this, Nn)?.entireWord ?? null,
            matchesCount: b(this, wA, DH).call(this),
            rawQuery: d(this, Nn)?.query ?? null,
          });
      }
      const Va = { NONE: 0, SELF: 1, BLANK: 2, PARENT: 3, TOP: 4 };
      class Rc {
        constructor({
          eventBus: e,
          externalLinkTarget: t = null,
          externalLinkRel: i = null,
          ignoreDestinationZoom: r = !1,
        } = {}) {
          Se(this, 'externalLinkEnabled', !0),
            (this.eventBus = e),
            (this.externalLinkTarget = t),
            (this.externalLinkRel = i),
            (this._ignoreDestinationZoom = r),
            (this.baseUrl = null),
            (this.pdfDocument = null),
            (this.pdfViewer = null),
            (this.pdfHistory = null);
        }
        setDocument(e, t = null) {
          (this.baseUrl = t), (this.pdfDocument = e);
        }
        setViewer(e) {
          this.pdfViewer = e;
        }
        setHistory(e) {
          this.pdfHistory = e;
        }
        get pagesCount() {
          return this.pdfDocument ? this.pdfDocument.numPages : 0;
        }
        get page() {
          return this.pdfDocument ? this.pdfViewer.currentPageNumber : 1;
        }
        set page(e) {
          this.pdfDocument && (this.pdfViewer.currentPageNumber = e);
        }
        get rotation() {
          return this.pdfDocument ? this.pdfViewer.pagesRotation : 0;
        }
        set rotation(e) {
          this.pdfDocument && (this.pdfViewer.pagesRotation = e);
        }
        get isInPresentationMode() {
          return !!this.pdfDocument && this.pdfViewer.isInPresentationMode;
        }
        goToDestination(e) {
          var t = this;
          return U(function* () {
            if (!t.pdfDocument) return;
            let i, r, s;
            if (
              ('string' == typeof e
                ? ((i = e), (r = yield t.pdfDocument.getDestination(e)))
                : ((i = null), (r = yield e)),
              !Array.isArray(r))
            )
              return void console.error(
                `goToDestination: "${r}" is not a valid destination array, for dest="${e}".`
              );
            const [o] = r;
            if (o && 'object' == typeof o) {
              if (((s = t.pdfDocument.cachedPageNumber(o)), !s))
                try {
                  s = (yield t.pdfDocument.getPageIndex(o)) + 1;
                } catch {
                  return void console.error(
                    `goToDestination: "${o}" is not a valid page reference, for dest="${e}".`
                  );
                }
            } else Number.isInteger(o) && (s = o + 1);
            !s || s < 1 || s > t.pagesCount
              ? console.error(
                  `goToDestination: "${s}" is not a valid page number, for dest="${e}".`
                )
              : (t.pdfHistory &&
                  (t.pdfHistory.pushCurrentPosition(),
                  t.pdfHistory.push({
                    namedDest: i,
                    explicitDest: r,
                    pageNumber: s,
                  })),
                t.pdfViewer.scrollPageIntoView({
                  pageNumber: s,
                  destArray: r,
                  ignoreDestinationZoom: t._ignoreDestinationZoom,
                }));
          })();
        }
        goToPage(e) {
          if (!this.pdfDocument) return;
          const t =
            ('string' == typeof e && this.pdfViewer.pageLabelToPageNumber(e)) ||
            0 | e;
          Number.isInteger(t) && t > 0 && t <= this.pagesCount
            ? (this.pdfHistory &&
                (this.pdfHistory.pushCurrentPosition(),
                this.pdfHistory.pushPage(t)),
              this.pdfViewer.scrollPageIntoView({ pageNumber: t }))
            : console.error(
                `PDFLinkService.goToPage: "${e}" is not a valid page.`
              );
        }
        addLinkAttributes(e, t, i = !1) {
          if (!t || 'string' != typeof t)
            throw new Error('A valid "url" parameter must provided.');
          const r = i ? Va.BLANK : this.externalLinkTarget,
            s = this.externalLinkRel;
          this.externalLinkEnabled
            ? (e.href = e.title = t)
            : ((e.href = ''),
              (e.title = `Disabled: ${t}`),
              (e.onclick = () => !1));
          let o = '';
          switch (r) {
            case Va.NONE:
              break;
            case Va.SELF:
              o = '_self';
              break;
            case Va.BLANK:
              o = '_blank';
              break;
            case Va.PARENT:
              o = '_parent';
              break;
            case Va.TOP:
              o = '_top';
          }
          (e.target = o),
            (e.rel = 'string' == typeof s ? s : 'noopener noreferrer nofollow');
        }
        getDestinationHash(e) {
          if ('string' == typeof e) {
            if (e.length > 0) return this.getAnchorUrl('#' + escape(e));
          } else if (Array.isArray(e)) {
            const t = JSON.stringify(e);
            if (t.length > 0) return this.getAnchorUrl('#' + escape(t));
          }
          return this.getAnchorUrl('');
        }
        getAnchorUrl(e) {
          return this.baseUrl ? this.baseUrl + e : e;
        }
        setHash(e) {
          if (!this.pdfDocument) return;
          let t, i;
          if (e.includes('=')) {
            const r = H_(e);
            if (r.has('search')) {
              const s = r.get('search').replaceAll('"', ''),
                o = 'true' === r.get('phrase');
              this.eventBus.dispatch('findfromurlhash', {
                source: this,
                query: o ? s : s.match(/\S+/g),
              });
            }
            if (
              (r.has('page') && (t = 0 | r.get('page') || 1), r.has('zoom'))
            ) {
              const s = r.get('zoom').split(','),
                o = s[0],
                a = parseFloat(o);
              o.includes('Fit')
                ? 'Fit' === o || 'FitB' === o
                  ? (i = [null, { name: o }])
                  : 'FitH' === o ||
                    'FitBH' === o ||
                    'FitV' === o ||
                    'FitBV' === o
                  ? (i = [null, { name: o }, s.length > 1 ? 0 | s[1] : null])
                  : 'FitR' === o
                  ? 5 !== s.length
                    ? console.error(
                        'PDFLinkService.setHash: Not enough parameters for "FitR".'
                      )
                    : (i = [
                        null,
                        { name: o },
                        0 | s[1],
                        0 | s[2],
                        0 | s[3],
                        0 | s[4],
                      ])
                  : console.error(
                      `PDFLinkService.setHash: "${o}" is not a valid zoom value.`
                    )
                : (i = [
                    null,
                    { name: 'XYZ' },
                    s.length > 1 ? 0 | s[1] : null,
                    s.length > 2 ? 0 | s[2] : null,
                    a ? a / 100 : o,
                  ]);
            }
            return (
              i
                ? this.pdfViewer.scrollPageIntoView({
                    pageNumber: t || this.page,
                    destArray: i,
                    allowNegativeOffset: !0,
                  })
                : t && (this.page = t),
              r.has('pagemode') &&
                this.eventBus.dispatch('pagemode', {
                  source: this,
                  mode: r.get('pagemode'),
                }),
              void (
                r.has('nameddest') && this.goToDestination(r.get('nameddest'))
              )
            );
          }
          i = unescape(e);
          try {
            (i = JSON.parse(i)), Array.isArray(i) || (i = i.toString());
          } catch {}
          'string' == typeof i || we(Rc, Rc, fae).call(Rc, i)
            ? this.goToDestination(i)
            : console.error(
                `PDFLinkService.setHash: "${unescape(
                  e
                )}" is not a valid destination.`
              );
        }
        executeNamedAction(e) {
          if (this.pdfDocument) {
            switch (e) {
              case 'GoBack':
                this.pdfHistory?.back();
                break;
              case 'GoForward':
                this.pdfHistory?.forward();
                break;
              case 'NextPage':
                this.pdfViewer.nextPage();
                break;
              case 'PrevPage':
                this.pdfViewer.previousPage();
                break;
              case 'LastPage':
                this.page = this.pagesCount;
                break;
              case 'FirstPage':
                this.page = 1;
            }
            this.eventBus.dispatch('namedaction', { source: this, action: e });
          }
        }
        executeSetOCGState(e) {
          var t = this;
          return U(function* () {
            if (!t.pdfDocument) return;
            const i = t.pdfDocument,
              r = yield t.pdfViewer.optionalContentConfigPromise;
            i === t.pdfDocument &&
              (r.setOCGState(e),
              (t.pdfViewer.optionalContentConfigPromise = Promise.resolve(r)));
          })();
        }
      }
      function fae(n) {
        if (!Array.isArray(n) || n.length < 2) return !1;
        const [e, t, ...i] = n;
        if (
          (('object' != typeof e ||
            !Number.isInteger(e?.num) ||
            !Number.isInteger(e?.gen)) &&
            !Number.isInteger(e)) ||
          'object' != typeof t ||
          'string' != typeof t?.name
        )
          return !1;
        const r = i.length;
        let s = !0;
        switch (t.name) {
          case 'XYZ':
            if (r < 2 || r > 3) return !1;
            break;
          case 'Fit':
          case 'FitB':
            return 0 === r;
          case 'FitH':
          case 'FitBH':
          case 'FitV':
          case 'FitBV':
            if (r > 1) return !1;
            break;
          case 'FitR':
            if (4 !== r) return !1;
            s = !1;
            break;
          default:
            return !1;
        }
        for (const o of i)
          if (!('number' == typeof o || (s && null === o))) return !1;
        return !0;
      }
      class AA extends Rc {
        setDocument(e, t = null) {}
      }
      const {
        AbortException: pae,
        AnnotationEditorLayer: mae,
        AnnotationEditorType: yr,
        AnnotationEditorUIManager: gae,
        AnnotationLayer: _ae,
        AnnotationMode: ks,
        createValidAbsoluteUrl: bae,
        DrawLayer: vae,
        fetchData: IH,
        getPdfFilenameFromUrl: yae,
        isPdfFile: wae,
        normalizeUnicode: Eae,
        PermissionFlag: K_,
        PixelsPerInch: Ps,
        RenderingCancelledException: SA,
        setLayerDimensions: Cae,
        shadow: Z_,
        TextLayer: xae,
        version: kH,
        XfaLayer: MA,
      } = globalThis.pdfjsLib;
      var DA = new WeakMap(),
        Fc = new WeakMap(),
        TA = new WeakSet();
      class PH {
        constructor({
          pdfPage: e,
          linkService: t,
          downloadManager: i,
          annotationStorage: r = null,
          imageResourcesPath: s = '',
          renderForms: o = !0,
          enableScripting: a = !1,
          hasJSActionsPromise: l = null,
          fieldObjectsPromise: c = null,
          annotationCanvasMap: u = null,
          accessibilityManager: h = null,
          annotationEditorUIManager: f = null,
          onAppend: p = null,
        }) {
          S(this, TA),
            v(this, DA, { writable: !0, value: null }),
            v(this, Fc, { writable: !0, value: null }),
            (this.pdfPage = e),
            (this.linkService = t),
            (this.downloadManager = i),
            (this.imageResourcesPath = s),
            (this.renderForms = o),
            (this.annotationStorage = r),
            (this.enableScripting = a),
            (this._hasJSActionsPromise = l || Promise.resolve(!1)),
            (this._fieldObjectsPromise = c || Promise.resolve(null)),
            (this._annotationCanvasMap = u),
            (this._accessibilityManager = h),
            (this._annotationEditorUIManager = f),
            _(this, DA, p),
            (this.annotationLayer = null),
            (this.div = null),
            (this._cancelled = !1),
            (this._eventBus = t.eventBus);
        }
        render(e, t = 'display') {
          var i = this;
          return U(function* () {
            if (i.div) {
              if (i._cancelled || !i.annotationLayer) return;
              return void i.annotationLayer.update({
                viewport: e.clone({ dontFlip: !0 }),
              });
            }
            const [r, s, o] = yield Promise.all([
              i.pdfPage.getAnnotations({ intent: t }),
              i._hasJSActionsPromise,
              i._fieldObjectsPromise,
            ]);
            if (i._cancelled) return;
            const a = (i.div = document.createElement('div'));
            (a.className = 'annotationLayer'),
              d(i, DA)?.call(i, a),
              0 !== r.length
                ? ((i.annotationLayer = new _ae({
                    div: a,
                    accessibilityManager: i._accessibilityManager,
                    annotationCanvasMap: i._annotationCanvasMap,
                    annotationEditorUIManager: i._annotationEditorUIManager,
                    page: i.pdfPage,
                    viewport: e.clone({ dontFlip: !0 }),
                  })),
                  yield i.annotationLayer.render({
                    annotations: r,
                    imageResourcesPath: i.imageResourcesPath,
                    renderForms: i.renderForms,
                    linkService: i.linkService,
                    downloadManager: i.downloadManager,
                    annotationStorage: i.annotationStorage,
                    enableScripting: i.enableScripting,
                    hasJSActions: s,
                    fieldObjects: o,
                  }),
                  i.linkService.isInPresentationMode && b(i, TA, RH).call(i, 3),
                  d(i, Fc) ||
                    (_(i, Fc, new AbortController()),
                    i._eventBus?._on(
                      'presentationmodechanged',
                      (l) => {
                        b(i, TA, RH).call(i, l.state);
                      },
                      { signal: d(i, Fc).signal }
                    )))
                : i.hide();
          })();
        }
        cancel() {
          (this._cancelled = !0), d(this, Fc)?.abort(), _(this, Fc, null);
        }
        hide() {
          this.div && (this.div.hidden = !0);
        }
        hasEditableAnnotations() {
          return !!this.annotationLayer?.hasEditableAnnotations();
        }
      }
      function RH(n) {
        if (!this.div) return;
        let e = !1;
        switch (n) {
          case 3:
            e = !0;
            break;
          case 1:
            break;
          default:
            return;
        }
        for (const t of this.div.childNodes)
          t.hasAttribute('data-internal-link') || (t.inert = e);
      }
      function FH(n, e) {
        const t = document.createElement('a');
        if (!t.click)
          throw new Error('DownloadManager: "a.click()" is not supported.');
        (t.href = n),
          (t.target = '_parent'),
          'download' in t && (t.download = e),
          (document.body || document.documentElement).append(t),
          t.click(),
          t.remove();
      }
      var Aae = new WeakMap();
      class Sae {
        constructor() {
          v(this, Aae, { writable: !0, value: new WeakMap() });
        }
        downloadData(e, t, i) {
          FH(URL.createObjectURL(new Blob([e], { type: i })), t);
        }
        openOrDownloadData(e, t, i = null) {
          const s = wae(t) ? 'application/pdf' : '';
          return this.downloadData(e, t, s), !1;
        }
        download(e, t, i, r) {
          let s;
          if (e)
            s = URL.createObjectURL(new Blob([e], { type: 'application/pdf' }));
          else {
            if (!bae(t, 'http://example.com'))
              return void console.error(`download - not a valid URL: ${t}`);
            s = t + '#pdfjs.action=download';
          }
          FH(s, i);
        }
      }
      const OH = { EVENT: 'event', TIMEOUT: 'timeout' };
      function IA() {
        return (IA = U(function* ({ target: n, name: e, delay: t = 0 }) {
          if (
            'object' != typeof n ||
            !e ||
            'string' != typeof e ||
            !(Number.isInteger(t) && t >= 0)
          )
            throw new Error('waitOnEventOrTimeout - invalid parameters.');
          const { promise: i, resolve: r } = Promise.withResolvers(),
            s = new AbortController();
          function o(c) {
            s.abort(), clearTimeout(l), r(c);
          }
          n[n instanceof LH ? '_on' : 'addEventListener'](
            e,
            o.bind(null, OH.EVENT),
            { signal: s.signal }
          );
          const l = setTimeout(o.bind(null, OH.TIMEOUT), t);
          return i;
        })).apply(this, arguments);
      }
      var Q_ = new WeakMap();
      class LH {
        constructor() {
          v(this, Q_, { writable: !0, value: Object.create(null) });
        }
        on(e, t, i = null) {
          this._on(e, t, { external: !0, once: i?.once, signal: i?.signal });
        }
        off(e, t, i = null) {
          this._off(e, t);
        }
        dispatch(e, t) {
          const i = d(this, Q_)[e];
          if (!i || 0 === i.length) return;
          let r;
          for (const { listener: s, external: o, once: a } of i.slice(0))
            a && this._off(e, s), o ? (r ||= []).push(s) : s(t);
          if (r) {
            for (const s of r) s(t);
            r = null;
          }
        }
        _on(e, t, i = null) {
          let r = null;
          if (i?.signal instanceof AbortSignal) {
            const { signal: o } = i;
            if (o.aborted)
              return void console.error('Cannot use an `aborted` signal.');
            const a = () => this._off(e, t);
            (r = () => o.removeEventListener('abort', a)),
              o.addEventListener('abort', a);
          }
          (d(this, Q_)[e] ||= []).push({
            listener: t,
            external: !0 === i?.external,
            once: !0 === i?.once,
            rmAbort: r,
          });
        }
        _off(e, t, i = null) {
          const r = d(this, Q_)[e];
          if (r)
            for (let s = 0, o = r.length; s < o; s++) {
              const a = r[s];
              if (a.listener === t) return a.rmAbort?.(), void r.splice(s, 1);
            }
        }
      }
      class J_ {
        constructor(e) {
          this.value = e;
        }
        valueOf() {
          return this.value;
        }
      }
      class tn extends J_ {
        constructor(e = '???') {
          super(e);
        }
        toString(e) {
          return `{${this.value}}`;
        }
      }
      class Rs extends J_ {
        constructor(e, t = {}) {
          super(e), (this.opts = t);
        }
        toString(e) {
          try {
            return e
              .memoizeIntlObject(Intl.NumberFormat, this.opts)
              .format(this.value);
          } catch (t) {
            return e.reportError(t), this.value.toString(10);
          }
        }
      }
      class Kh extends J_ {
        constructor(e, t = {}) {
          super(e), (this.opts = t);
        }
        toString(e) {
          try {
            return e
              .memoizeIntlObject(Intl.DateTimeFormat, this.opts)
              .format(this.value);
          } catch (t) {
            return e.reportError(t), new Date(this.value).toISOString();
          }
        }
      }
      const HH = 100,
        Dae = '\u2068',
        Tae = '\u2069';
      function Iae(n, e, t) {
        return (
          t === e ||
          (t instanceof Rs && e instanceof Rs && t.value === e.value) ||
          (e instanceof Rs &&
            'string' == typeof t &&
            t === n.memoizeIntlObject(Intl.PluralRules, e.opts).select(e.value))
        );
      }
      function WH(n, e, t) {
        return e[t]
          ? Oc(n, e[t].value)
          : (n.reportError(new RangeError('No default')), new tn());
      }
      function kA(n, e) {
        const t = [],
          i = Object.create(null);
        for (const r of e)
          'narg' === r.type ? (i[r.name] = Zh(n, r.value)) : t.push(Zh(n, r));
        return { positional: t, named: i };
      }
      function Zh(n, e) {
        switch (e.type) {
          case 'str':
            return e.value;
          case 'num':
            return new Rs(e.value, { minimumFractionDigits: e.precision });
          case 'var':
            return (function kae(n, { name: e }) {
              let t;
              if (n.params) {
                if (!Object.prototype.hasOwnProperty.call(n.params, e))
                  return new tn(`$${e}`);
                t = n.params[e];
              } else {
                if (!n.args || !Object.prototype.hasOwnProperty.call(n.args, e))
                  return (
                    n.reportError(
                      new ReferenceError(`Unknown variable: $${e}`)
                    ),
                    new tn(`$${e}`)
                  );
                t = n.args[e];
              }
              if (t instanceof J_) return t;
              switch (typeof t) {
                case 'string':
                  return t;
                case 'number':
                  return new Rs(t);
                case 'object':
                  if (t instanceof Date) return new Kh(t.getTime());
                default:
                  return (
                    n.reportError(
                      new TypeError(
                        `Variable type not supported: $${e}, ${typeof t}`
                      )
                    ),
                    new tn(`$${e}`)
                  );
              }
            })(n, e);
          case 'mesg':
            return (function Pae(n, { name: e, attr: t }) {
              const i = n.bundle._messages.get(e);
              if (!i)
                return (
                  n.reportError(new ReferenceError(`Unknown message: ${e}`)),
                  new tn(e)
                );
              if (t) {
                const r = i.attributes[t];
                return r
                  ? Oc(n, r)
                  : (n.reportError(
                      new ReferenceError(`Unknown attribute: ${t}`)
                    ),
                    new tn(`${e}.${t}`));
              }
              return i.value
                ? Oc(n, i.value)
                : (n.reportError(new ReferenceError(`No value: ${e}`)),
                  new tn(e));
            })(n, e);
          case 'term':
            return (function Rae(n, { name: e, attr: t, args: i }) {
              const r = `-${e}`,
                s = n.bundle._terms.get(r);
              if (!s)
                return (
                  n.reportError(new ReferenceError(`Unknown term: ${r}`)),
                  new tn(r)
                );
              if (t) {
                const a = s.attributes[t];
                if (a) {
                  n.params = kA(n, i).named;
                  const l = Oc(n, a);
                  return (n.params = null), l;
                }
                return (
                  n.reportError(new ReferenceError(`Unknown attribute: ${t}`)),
                  new tn(`${r}.${t}`)
                );
              }
              n.params = kA(n, i).named;
              const o = Oc(n, s.value);
              return (n.params = null), o;
            })(n, e);
          case 'func':
            return (function Fae(n, { name: e, args: t }) {
              let i = n.bundle._functions[e];
              if (!i)
                return (
                  n.reportError(new ReferenceError(`Unknown function: ${e}()`)),
                  new tn(`${e}()`)
                );
              if ('function' != typeof i)
                return (
                  n.reportError(
                    new TypeError(`Function ${e}() is not callable`)
                  ),
                  new tn(`${e}()`)
                );
              try {
                let r = kA(n, t);
                return i(r.positional, r.named);
              } catch (r) {
                return n.reportError(r), new tn(`${e}()`);
              }
            })(n, e);
          case 'select':
            return (function Oae(n, { selector: e, variants: t, star: i }) {
              let r = Zh(n, e);
              if (r instanceof tn) return WH(n, t, i);
              for (const s of t)
                if (Iae(n, r, Zh(n, s.key))) return Oc(n, s.value);
              return WH(n, t, i);
            })(n, e);
          default:
            return new tn();
        }
      }
      function jH(n, e) {
        if (n.dirty.has(e))
          return n.reportError(new RangeError('Cyclic reference')), new tn();
        n.dirty.add(e);
        const t = [],
          i = n.bundle._useIsolating && e.length > 1;
        for (const r of e)
          if ('string' != typeof r) {
            if ((n.placeables++, n.placeables > HH))
              throw (
                (n.dirty.delete(e),
                new RangeError(
                  `Too many placeables expanded: ${n.placeables}, max allowed is ${HH}`
                ))
              );
            i && t.push(Dae), t.push(Zh(n, r).toString(n)), i && t.push(Tae);
          } else t.push(n.bundle._transform(r));
        return n.dirty.delete(e), t.join('');
      }
      function Oc(n, e) {
        return 'string' == typeof e ? n.bundle._transform(e) : jH(n, e);
      }
      class Lae {
        constructor(e, t, i) {
          (this.dirty = new WeakSet()),
            (this.params = null),
            (this.placeables = 0),
            (this.bundle = e),
            (this.errors = t),
            (this.args = i);
        }
        reportError(e) {
          if (!(this.errors && e instanceof Error)) throw e;
          this.errors.push(e);
        }
        memoizeIntlObject(e, t) {
          let i = this.bundle._intls.get(e);
          i || ((i = {}), this.bundle._intls.set(e, i));
          let r = JSON.stringify(t);
          return i[r] || (i[r] = new e(this.bundle.locales, t)), i[r];
        }
      }
      function eb(n, e) {
        const t = Object.create(null);
        for (const [i, r] of Object.entries(n))
          e.includes(i) && (t[i] = r.valueOf());
        return t;
      }
      const zH = [
        'unitDisplay',
        'currencyDisplay',
        'useGrouping',
        'minimumIntegerDigits',
        'minimumFractionDigits',
        'maximumFractionDigits',
        'minimumSignificantDigits',
        'maximumSignificantDigits',
      ];
      function Nae(n, e) {
        let t = n[0];
        if (t instanceof tn) return new tn(`NUMBER(${t.valueOf()})`);
        if (t instanceof Rs)
          return new Rs(t.valueOf(), { ...t.opts, ...eb(e, zH) });
        if (t instanceof Kh) return new Rs(t.valueOf(), { ...eb(e, zH) });
        throw new TypeError('Invalid argument to NUMBER');
      }
      const UH = [
        'dateStyle',
        'timeStyle',
        'fractionalSecondDigits',
        'dayPeriod',
        'hour12',
        'weekday',
        'era',
        'year',
        'month',
        'day',
        'hour',
        'minute',
        'second',
        'timeZoneName',
      ];
      function Vae(n, e) {
        let t = n[0];
        if (t instanceof tn) return new tn(`DATETIME(${t.valueOf()})`);
        if (t instanceof Kh)
          return new Kh(t.valueOf(), { ...t.opts, ...eb(e, UH) });
        if (t instanceof Rs) return new Kh(t.valueOf(), { ...eb(e, UH) });
        throw new TypeError('Invalid argument to DATETIME');
      }
      const $H = new Map();
      class Hae {
        constructor(
          e,
          { functions: t, useIsolating: i = !0, transform: r = (s) => s } = {}
        ) {
          (this._terms = new Map()),
            (this._messages = new Map()),
            (this.locales = Array.isArray(e) ? e : [e]),
            (this._functions = { NUMBER: Nae, DATETIME: Vae, ...t }),
            (this._useIsolating = i),
            (this._transform = r),
            (this._intls = (function Bae(n) {
              const e = Array.isArray(n) ? n.join(' ') : n;
              let t = $H.get(e);
              return void 0 === t && ((t = new Map()), $H.set(e, t)), t;
            })(e));
        }
        hasMessage(e) {
          return this._messages.has(e);
        }
        getMessage(e) {
          return this._messages.get(e);
        }
        addResource(e, { allowOverrides: t = !1 } = {}) {
          const i = [];
          for (let r = 0; r < e.body.length; r++) {
            let s = e.body[r];
            if (s.id.startsWith('-')) {
              if (!1 === t && this._terms.has(s.id)) {
                i.push(
                  new Error(`Attempt to override an existing term: "${s.id}"`)
                );
                continue;
              }
              this._terms.set(s.id, s);
            } else {
              if (!1 === t && this._messages.has(s.id)) {
                i.push(
                  new Error(
                    `Attempt to override an existing message: "${s.id}"`
                  )
                );
                continue;
              }
              this._messages.set(s.id, s);
            }
          }
          return i;
        }
        formatPattern(e, t = null, i = null) {
          if ('string' == typeof e) return this._transform(e);
          let r = new Lae(this, i, t);
          try {
            return jH(r, e).toString(r);
          } catch (s) {
            if (r.errors && s instanceof Error)
              return r.errors.push(s), new tn().toString(r);
            throw s;
          }
        }
      }
      const PA = /^(-?[a-zA-Z][\w-]*) *= */gm,
        GH = /\.([a-zA-Z][\w-]*) *= */y,
        Wae = /\*?\[/y,
        RA = /(-?[0-9]+(?:\.([0-9]+))?)/y,
        jae = /([a-zA-Z][\w-]*)/y,
        qH = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y,
        zae = /^[A-Z][A-Z0-9_-]*$/,
        tb = /([^{}\n\r]+)/y,
        Uae = /([^\\"\n\r]*)/y,
        XH = /\\([\\"])/y,
        YH = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y,
        $ae = /^\n+/,
        KH = / +$/,
        Gae = / *\r?\n/g,
        qae = /( *)$/,
        Xae = /{\s*/y,
        ZH = /\s*}/y,
        Yae = /\[\s*/y,
        Kae = /\s*] */y,
        Zae = /\s*\(\s*/y,
        Qae = /\s*->\s*/y,
        Jae = /\s*:\s*/y,
        ele = /\s*,?\s*/y,
        tle = /\s+/y;
      class nle {
        constructor(e) {
          (this.body = []), (PA.lastIndex = 0);
          let t = 0;
          for (;;) {
            let I = PA.exec(e);
            if (null === I) break;
            t = PA.lastIndex;
            try {
              this.body.push(l(I[1]));
            } catch (C) {
              if (C instanceof SyntaxError) continue;
              throw C;
            }
          }
          function i(I) {
            return (I.lastIndex = t), I.test(e);
          }
          function r(I, C) {
            if (e[t] === I) return t++, !0;
            if (C) throw new C(`Expected ${I}`);
            return !1;
          }
          function s(I, C) {
            if (i(I)) return (t = I.lastIndex), !0;
            if (C) throw new C(`Expected ${I.toString()}`);
            return !1;
          }
          function o(I) {
            I.lastIndex = t;
            let C = I.exec(e);
            if (null === C) throw new SyntaxError(`Expected ${I.toString()}`);
            return (t = I.lastIndex), C;
          }
          function a(I) {
            return o(I)[1];
          }
          function l(I) {
            let C = u(),
              R = (function c() {
                let I = Object.create(null);
                for (; i(GH); ) {
                  let C = a(GH),
                    R = u();
                  if (null === R)
                    throw new SyntaxError('Expected attribute value');
                  I[C] = R;
                }
                return I;
              })();
            if (null === C && 0 === Object.keys(R).length)
              throw new SyntaxError('Expected message value or attributes');
            return { id: I, value: C, attributes: R };
          }
          function u() {
            let I;
            if ((i(tb) && (I = a(tb)), '{' === e[t] || '}' === e[t]))
              return h(I ? [I] : [], 1 / 0);
            let C = k();
            return C
              ? I
                ? h([I, C], C.length)
                : ((C.value = P(C.value, $ae)), h([C], C.length))
              : I
              ? P(I, KH)
              : null;
          }
          function h(I = [], C) {
            for (;;) {
              if (i(tb)) {
                I.push(a(tb));
                continue;
              }
              if ('{' === e[t]) {
                I.push(f());
                continue;
              }
              if ('}' === e[t])
                throw new SyntaxError('Unbalanced closing brace');
              let oe = k();
              if (!oe) break;
              I.push(oe), (C = Math.min(C, oe.length));
            }
            let R = I.length - 1,
              $ = I[R];
            'string' == typeof $ && (I[R] = P($, KH));
            let q = [];
            for (let oe of I)
              oe instanceof QH && (oe = oe.value.slice(0, oe.value.length - C)),
                oe && q.push(oe);
            return q;
          }
          function f() {
            s(Xae, SyntaxError);
            let I = p();
            if (s(ZH)) return I;
            if (s(Qae)) {
              let C = (function w() {
                let R,
                  I = [],
                  C = 0;
                for (; i(Wae); ) {
                  r('*') && (R = C);
                  let $ = y(),
                    q = u();
                  if (null === q)
                    throw new SyntaxError('Expected variant value');
                  I[C++] = { key: $, value: q };
                }
                if (0 === C) return null;
                if (void 0 === R)
                  throw new SyntaxError('Expected default variant');
                return { variants: I, star: R };
              })();
              return s(ZH, SyntaxError), { type: 'select', selector: I, ...C };
            }
            throw new SyntaxError('Unclosed placeable');
          }
          function p() {
            if ('{' === e[t]) return f();
            if (i(qH)) {
              let [, I, C, R = null] = o(qH);
              if ('$' === I) return { type: 'var', name: C };
              if (s(Zae)) {
                let $ = (function m() {
                  let I = [];
                  for (;;) {
                    switch (e[t]) {
                      case ')':
                        return t++, I;
                      case void 0:
                        throw new SyntaxError('Unclosed argument list');
                    }
                    I.push(g()), s(ele);
                  }
                })();
                if ('-' === I)
                  return { type: 'term', name: C, attr: R, args: $ };
                if (zae.test(C)) return { type: 'func', name: C, args: $ };
                throw new SyntaxError('Function names must be all upper-case');
              }
              return '-' === I
                ? { type: 'term', name: C, attr: R, args: [] }
                : { type: 'mesg', name: C, attr: R };
            }
            return E();
          }
          function g() {
            let I = p();
            return 'mesg' !== I.type
              ? I
              : s(Jae)
              ? { type: 'narg', name: I.name, value: E() }
              : I;
          }
          function y() {
            let I;
            return (
              s(Yae, SyntaxError),
              (I = i(RA) ? A() : { type: 'str', value: a(jae) }),
              s(Kae, SyntaxError),
              I
            );
          }
          function E() {
            if (i(RA)) return A();
            if ('"' === e[t])
              return (function M() {
                r('"', SyntaxError);
                let I = '';
                for (;;) {
                  if (((I += a(Uae)), '\\' !== e[t])) {
                    if (r('"')) return { type: 'str', value: I };
                    throw new SyntaxError('Unclosed string literal');
                  }
                  I += T();
                }
              })();
            throw new SyntaxError('Invalid expression');
          }
          function A() {
            let [, I, C = ''] = o(RA),
              R = C.length;
            return { type: 'num', value: parseFloat(I), precision: R };
          }
          function T() {
            if (i(XH)) return a(XH);
            if (i(YH)) {
              let [, I, C] = o(YH),
                R = parseInt(I || C, 16);
              return R <= 55295 || 57344 <= R
                ? String.fromCodePoint(R)
                : '\ufffd';
            }
            throw new SyntaxError('Unknown escape sequence');
          }
          function k() {
            let I = t;
            switch ((s(tle), e[t])) {
              case '.':
              case '[':
              case '*':
              case '}':
              case void 0:
                return !1;
              case '{':
                return O(e.slice(I, t));
            }
            return ' ' === e[t - 1] && O(e.slice(I, t));
          }
          function P(I, C) {
            return I.replace(C, '');
          }
          function O(I) {
            let C = I.replace(Gae, '\n'),
              R = qae.exec(I)[1].length;
            return new QH(C, R);
          }
        }
      }
      class QH {
        constructor(e, t) {
          (this.value = e), (this.length = t);
        }
      }
      const ile = /<|&#?\w+;/,
        rle = {
          'http://www.w3.org/1999/xhtml': [
            'em',
            'strong',
            'small',
            's',
            'cite',
            'q',
            'dfn',
            'abbr',
            'data',
            'time',
            'code',
            'var',
            'samp',
            'kbd',
            'sub',
            'sup',
            'i',
            'b',
            'u',
            'mark',
            'bdi',
            'bdo',
            'span',
            'br',
            'wbr',
          ],
        },
        sle = {
          'http://www.w3.org/1999/xhtml': {
            global: ['title', 'aria-label', 'aria-valuetext'],
            a: ['download'],
            area: ['download', 'alt'],
            input: ['alt', 'placeholder'],
            menuitem: ['label'],
            menu: ['label'],
            optgroup: ['label'],
            option: ['label'],
            track: ['label'],
            img: ['alt'],
            textarea: ['placeholder'],
            th: ['abbr'],
          },
          'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul': {
            global: [
              'accesskey',
              'aria-label',
              'aria-valuetext',
              'label',
              'title',
              'tooltiptext',
            ],
            description: ['value'],
            key: ['key', 'keycode'],
            label: ['value'],
            textbox: ['placeholder', 'value'],
          },
        };
      function ole(n, e) {
        const { value: t } = e;
        if ('string' == typeof t)
          if (
            'title' === n.localName &&
            'http://www.w3.org/1999/xhtml' === n.namespaceURI
          )
            n.textContent = t;
          else if (ile.test(t)) {
            const i = n.ownerDocument.createElementNS(
              'http://www.w3.org/1999/xhtml',
              'template'
            );
            (i.innerHTML = t),
              (function ale(n, e) {
                for (const t of n.childNodes)
                  if (t.nodeType !== t.TEXT_NODE) {
                    if (t.hasAttribute('data-l10n-name')) {
                      const i = cle(e, t);
                      n.replaceChild(i, t);
                      continue;
                    }
                    if (ule(t)) {
                      const i = dle(t);
                      n.replaceChild(i, t);
                      continue;
                    }
                    console.warn(
                      `An element of forbidden type "${t.localName}" was found in the translation. Only safe text-level elements and elements with data-l10n-name are allowed.`
                    ),
                      n.replaceChild(FA(t), t);
                  }
                (e.textContent = ''), e.appendChild(n);
              })(i.content, n);
          } else n.textContent = t;
        JH(e, n);
      }
      function lle(n, e) {
        if (!n) return !1;
        for (let t of n) if (t.name === e) return !0;
        return !1;
      }
      function JH(n, e) {
        const t = e.hasAttribute('data-l10n-attrs')
          ? e
              .getAttribute('data-l10n-attrs')
              .split(',')
              .map((i) => i.trim())
          : null;
        for (const i of Array.from(e.attributes))
          eW(i.name, e, t) &&
            !lle(n.attributes, i.name) &&
            e.removeAttribute(i.name);
        if (n.attributes)
          for (const i of Array.from(n.attributes))
            eW(i.name, e, t) &&
              e.getAttribute(i.name) !== i.value &&
              e.setAttribute(i.name, i.value);
      }
      function cle(n, e) {
        const t = e.getAttribute('data-l10n-name'),
          i = n.querySelector(`[data-l10n-name="${t}"]`);
        return i
          ? i.localName !== e.localName
            ? (console.warn(
                `An element named "${t}" was found in the translation but its type ${e.localName} didn't match the element found in the source (${i.localName}).`
              ),
              FA(e))
            : (n.removeChild(i), tW(e, i.cloneNode(!1)))
          : (console.warn(
              `An element named "${t}" wasn't found in the source.`
            ),
            FA(e));
      }
      function dle(n) {
        const e = n.ownerDocument.createElement(n.localName);
        return tW(n, e);
      }
      function FA(n) {
        return n.ownerDocument.createTextNode(n.textContent);
      }
      function ule(n) {
        const e = rle[n.namespaceURI];
        return e && e.includes(n.localName);
      }
      function eW(n, e, t = null) {
        if (t && t.includes(n)) return !0;
        const i = sle[e.namespaceURI];
        if (!i) return !1;
        const r = n.toLowerCase(),
          s = e.localName;
        if (i.global.includes(r)) return !0;
        if (!i[s]) return !1;
        if (i[s].includes(r)) return !0;
        if (
          'http://www.w3.org/1999/xhtml' === e.namespaceURI &&
          'input' === s &&
          'value' === r
        ) {
          const o = e.type.toLowerCase();
          if ('submit' === o || 'button' === o || 'reset' === o) return !0;
        }
        return !1;
      }
      function tW(n, e) {
        return (e.textContent = n.textContent), JH(n, e), e;
      }
      class nW extends Array {
        static from(e) {
          return e instanceof this ? e : new this(e);
        }
      }
      Symbol;
      class hle extends nW {
        constructor(e) {
          if ((super(), Symbol.asyncIterator in Object(e)))
            this.iterator = e[Symbol.asyncIterator]();
          else {
            if (!(Symbol.iterator in Object(e)))
              throw new TypeError(
                'Argument must implement the iteration protocol.'
              );
            this.iterator = e[Symbol.iterator]();
          }
        }
        [Symbol.asyncIterator]() {
          const e = this;
          let t = 0;
          return {
            next: () =>
              U(function* () {
                return e.length <= t && e.push(e.iterator.next()), e[t++];
              })(),
          };
        }
        touchNext(e = 1) {
          var t = this;
          return U(function* () {
            let i = 0;
            for (; i++ < e; ) {
              const r = t[t.length - 1];
              if (r && (yield r).done) break;
              t.push(t.iterator.next());
            }
            return t[t.length - 1];
          })();
        }
      }
      class fle {
        constructor(e = [], t) {
          (this.resourceIds = e), (this.generateBundles = t), this.onChange(!0);
        }
        addResourceIds(e, t = !1) {
          return (
            this.resourceIds.push(...e),
            this.onChange(t),
            this.resourceIds.length
          );
        }
        removeResourceIds(e) {
          return (
            (this.resourceIds = this.resourceIds.filter((t) => !e.includes(t))),
            this.onChange(),
            this.resourceIds.length
          );
        }
        formatWithFallback(e, t) {
          var i = this;
          return U(function* () {
            const r = [];
            let s = !1;
            var l,
              o = !1,
              a = !1;
            try {
              for (
                var u,
                  c = (function voe(n) {
                    var e,
                      t,
                      i,
                      r = 2;
                    for (
                      typeof Symbol < 'u' &&
                      ((t = Symbol.asyncIterator), (i = Symbol.iterator));
                      r--;

                    ) {
                      if (t && null != (e = n[t])) return e.call(n);
                      if (i && null != (e = n[i])) return new B_(e.call(n));
                      (t = '@@asyncIterator'), (i = '@@iterator');
                    }
                    throw new TypeError('Object is not async iterable');
                  })(i.bundles);
                (o = !(u = yield c.next()).done);
                o = !1
              ) {
                const h = u.value;
                {
                  s = !0;
                  const f = gle(t, h, e, r);
                  if (0 === f.size) break;
                  if (typeof console < 'u') {
                    const p = h.locales[0],
                      m = Array.from(f).join(', ');
                    console.warn(`[fluent] Missing translations in ${p}: ${m}`);
                  }
                }
              }
            } catch (h) {
              (a = !0), (l = h);
            } finally {
              try {
                o && null != c.return && (yield c.return());
              } finally {
                if (a) throw l;
              }
            }
            return (
              !s &&
                typeof console < 'u' &&
                console.warn(
                  `[fluent] Request for keys failed because no resource bundles got generated.\n  keys: ${JSON.stringify(
                    e
                  )}.\n  resourceIds: ${JSON.stringify(i.resourceIds)}.`
                ),
              r
            );
          })();
        }
        formatMessages(e) {
          return this.formatWithFallback(e, mle);
        }
        formatValues(e) {
          return this.formatWithFallback(e, ple);
        }
        formatValue(e, t) {
          var i = this;
          return U(function* () {
            const [r] = yield i.formatValues([{ id: e, args: t }]);
            return r;
          })();
        }
        handleEvent() {
          this.onChange();
        }
        onChange(e = !1) {
          (this.bundles = hle.from(this.generateBundles(this.resourceIds))),
            e && this.bundles.touchNext(2);
        }
      }
      function ple(n, e, t, i) {
        return t.value ? n.formatPattern(t.value, i, e) : null;
      }
      function mle(n, e, t, i) {
        const r = { value: null, attributes: null };
        t.value && (r.value = n.formatPattern(t.value, i, e));
        let s = Object.keys(t.attributes);
        if (s.length > 0) {
          r.attributes = new Array(s.length);
          for (let [o, a] of s.entries()) {
            let l = n.formatPattern(t.attributes[a], i, e);
            r.attributes[o] = { name: a, value: l };
          }
        }
        return r;
      }
      function gle(n, e, t, i) {
        const r = [],
          s = new Set();
        return (
          t.forEach(({ id: o, args: a }, l) => {
            if (void 0 !== i[l]) return;
            let c = e.getMessage(o);
            if (c) {
              if (
                ((r.length = 0),
                (i[l] = n(e, r, c, a)),
                r.length > 0 && typeof console < 'u')
              ) {
                const u = e.locales[0],
                  h = r.join(', ');
                console.warn(`[fluent][resolver] errors in ${u}/${o}: ${h}.`);
              }
            } else s.add(o);
          }),
          s
        );
      }
      const Ba = 'data-l10n-id',
        Qh = 'data-l10n-args',
        _le = `[${Ba}]`;
      class ble extends fle {
        constructor(e, t) {
          super(e, t),
            (this.roots = new Set()),
            (this.pendingrAF = null),
            (this.pendingElements = new Set()),
            (this.windowElement = null),
            (this.mutationObserver = null),
            (this.observerConfig = {
              attributes: !0,
              characterData: !1,
              childList: !0,
              subtree: !0,
              attributeFilter: [Ba, Qh],
            });
        }
        onChange(e = !1) {
          super.onChange(e), this.roots && this.translateRoots();
        }
        setAttributes(e, t, i) {
          return (
            e.setAttribute(Ba, t),
            i ? e.setAttribute(Qh, JSON.stringify(i)) : e.removeAttribute(Qh),
            e
          );
        }
        getAttributes(e) {
          return {
            id: e.getAttribute(Ba),
            args: JSON.parse(e.getAttribute(Qh) || null),
          };
        }
        connectRoot(e) {
          for (const t of this.roots)
            if (t === e || t.contains(e) || e.contains(t))
              throw new Error(
                'Cannot add a root that overlaps with existing root.'
              );
          if (this.windowElement) {
            if (this.windowElement !== e.ownerDocument.defaultView)
              throw new Error(
                'Cannot connect a root:\n          DOMLocalization already has a root from a different window.'
              );
          } else
            (this.windowElement = e.ownerDocument.defaultView),
              (this.mutationObserver = new this.windowElement.MutationObserver(
                (t) => this.translateMutations(t)
              ));
          this.roots.add(e),
            this.mutationObserver.observe(e, this.observerConfig);
        }
        disconnectRoot(e) {
          return (
            this.roots.delete(e),
            this.pauseObserving(),
            0 === this.roots.size
              ? ((this.mutationObserver = null),
                this.windowElement &&
                  this.pendingrAF &&
                  this.windowElement.cancelAnimationFrame(this.pendingrAF),
                (this.windowElement = null),
                (this.pendingrAF = null),
                this.pendingElements.clear(),
                !0)
              : (this.resumeObserving(), !1)
          );
        }
        translateRoots() {
          const e = Array.from(this.roots);
          return Promise.all(e.map((t) => this.translateFragment(t)));
        }
        pauseObserving() {
          this.mutationObserver &&
            (this.translateMutations(this.mutationObserver.takeRecords()),
            this.mutationObserver.disconnect());
        }
        resumeObserving() {
          if (this.mutationObserver)
            for (const e of this.roots)
              this.mutationObserver.observe(e, this.observerConfig);
        }
        translateMutations(e) {
          for (const t of e)
            switch (t.type) {
              case 'attributes':
                t.target.hasAttribute('data-l10n-id') &&
                  this.pendingElements.add(t.target);
                break;
              case 'childList':
                for (const i of t.addedNodes)
                  if (i.nodeType === i.ELEMENT_NODE)
                    if (i.childElementCount)
                      for (const r of this.getTranslatables(i))
                        this.pendingElements.add(r);
                    else i.hasAttribute(Ba) && this.pendingElements.add(i);
            }
          this.pendingElements.size > 0 &&
            null === this.pendingrAF &&
            (this.pendingrAF = this.windowElement.requestAnimationFrame(() => {
              this.translateElements(Array.from(this.pendingElements)),
                this.pendingElements.clear(),
                (this.pendingrAF = null);
            }));
        }
        translateFragment(e) {
          return this.translateElements(this.getTranslatables(e));
        }
        translateElements(e) {
          var t = this;
          return U(function* () {
            if (!e.length) return;
            const i = e.map(t.getKeysForElement),
              r = yield t.formatMessages(i);
            return t.applyTranslations(e, r);
          })();
        }
        applyTranslations(e, t) {
          this.pauseObserving();
          for (let i = 0; i < e.length; i++) void 0 !== t[i] && ole(e[i], t[i]);
          this.resumeObserving();
        }
        getTranslatables(e) {
          const t = Array.from(e.querySelectorAll(_le));
          return (
            'function' == typeof e.hasAttribute &&
              e.hasAttribute(Ba) &&
              t.push(e),
            t
          );
        }
        getKeysForElement(e) {
          return {
            id: e.getAttribute(Ba),
            args: JSON.parse(e.getAttribute(Qh) || null),
          };
        }
      }
      var OA = new WeakMap(),
        nb = new WeakMap(),
        ib = new WeakMap(),
        wr = new WeakMap();
      class yo {
        constructor({ lang: e, isRTL: t }, i = null) {
          v(this, OA, { writable: !0, value: void 0 }),
            v(this, nb, { writable: !0, value: new Set() }),
            v(this, ib, { writable: !0, value: void 0 }),
            v(this, wr, { writable: !0, value: void 0 }),
            _(this, ib, we(yo, yo, vle).call(yo, e)),
            _(this, wr, i),
            _(
              this,
              OA,
              t ?? we(yo, yo, yle).call(yo, d(this, ib)) ? 'rtl' : 'ltr'
            );
        }
        _setL10n(e) {
          _(this, wr, e);
        }
        getLanguage() {
          return d(this, ib);
        }
        getDirection() {
          return d(this, OA);
        }
        get(e, t = null, i) {
          var r = this;
          return U(function* () {
            return Array.isArray(e)
              ? ((e = e.map((a) => ({ id: a }))),
                (yield d(r, wr).formatMessages(e)).map((a) => a.value))
              : (yield d(r, wr).formatMessages([{ id: e, args: t }]))?.[0]
                  .value || i;
          })();
        }
        translate(e) {
          var t = this;
          return U(function* () {
            d(t, nb).add(e);
            try {
              d(t, wr).connectRoot(e), yield d(t, wr).translateRoots();
            } catch {}
          })();
        }
        destroy() {
          var e = this;
          return U(function* () {
            for (const t of d(e, nb)) d(e, wr).disconnectRoot(t);
            d(e, nb).clear(), d(e, wr).pauseObserving();
          })();
        }
        pause() {
          d(this, wr).pauseObserving();
        }
        resume() {
          d(this, wr).resumeObserving();
        }
      }
      function vle(n) {
        return (
          {
            en: 'en-us',
            es: 'es-es',
            fy: 'fy-nl',
            ga: 'ga-ie',
            gu: 'gu-in',
            hi: 'hi-in',
            hy: 'hy-am',
            nb: 'nb-no',
            ne: 'ne-np',
            nn: 'nn-no',
            pa: 'pa-in',
            pt: 'pt-pt',
            sv: 'sv-se',
            zh: 'zh-cn',
          }[(n = n?.toLowerCase() || 'en-us')] || n
        );
      }
      function yle(n) {
        const e = n.split('-', 1)[0];
        return ['ar', 'he', 'fa', 'ps', 'ur'].includes(e);
      }
      function iW(n, e) {
        const t = new nle(e),
          i = new Hae(n),
          r = i.addResource(t);
        return r.length && console.error('L10n errors', r), i;
      }
      class Zn extends yo {
        constructor(e) {
          super({ lang: e });
          const t = e
            ? we(Zn, Zn, wle).bind(Zn, 'en-us', this.getLanguage())
            : we(Zn, Zn, xle).bind(Zn, this.getLanguage());
          this._setL10n(new ble([], t));
        }
      }
      function wle(n, e) {
        var t = this;
        return JB(function* () {
          const { baseURL: i, paths: r } = yield QB(we(t, Zn, Cle).call(t)),
            s = [e];
          if (n !== e) {
            const o = e.split('-', 1)[0];
            o !== e && s.push(o), s.push(n);
          }
          for (const o of s) {
            const a = yield QB(we(t, Zn, Ele).call(t, o, i, r));
            a ? yield a : 'en-us' === o && (yield we(t, Zn, rW).call(t, o));
          }
        })();
      }
      function Ele(n, e, t) {
        return LA.apply(this, arguments);
      }
      function LA() {
        return (LA = U(function* (n, e, t) {
          const i = t[n];
          if (!i) return null;
          const r = new URL(i, e);
          return iW(n, yield IH(r, 'text'));
        })).apply(this, arguments);
      }
      function Cle() {
        return NA.apply(this, arguments);
      }
      function NA() {
        return (NA = U(function* () {
          try {
            const { href: n } = document.querySelector(
                'link[type="application/l10n"]'
              ),
              e = yield IH(n, 'json');
            return { baseURL: n.replace(/[^/]*$/, '') || './', paths: e };
          } catch {}
          return { baseURL: './', paths: Object.create(null) };
        })).apply(this, arguments);
      }
      function xle(n) {
        var e = this;
        return JB(function* () {
          yield we(e, Zn, rW).call(e, n);
        })();
      }
      function rW(n) {
        return VA.apply(this, arguments);
      }
      function VA() {
        return (VA = U(function* (n) {
          return iW(
            n,
            'pdfjs-previous-button =\n    .title = Previous Page\npdfjs-previous-button-label = Previous\npdfjs-next-button =\n    .title = Next Page\npdfjs-next-button-label = Next\npdfjs-page-input =\n    .title = Page\npdfjs-of-pages = of { $pagesCount }\npdfjs-page-of-pages = ({ $pageNumber } of { $pagesCount })\npdfjs-zoom-out-button =\n    .title = Zoom Out\npdfjs-zoom-out-button-label = Zoom Out\npdfjs-zoom-in-button =\n    .title = Zoom In\npdfjs-zoom-in-button-label = Zoom In\npdfjs-zoom-select =\n    .title = Zoom\npdfjs-presentation-mode-button =\n    .title = Switch to Presentation Mode\npdfjs-presentation-mode-button-label = Presentation Mode\npdfjs-open-file-button =\n    .title = Open File\npdfjs-open-file-button-label = Open\npdfjs-print-button =\n    .title = Print\npdfjs-print-button-label = Print\npdfjs-save-button =\n    .title = Save\npdfjs-save-button-label = Save\npdfjs-download-button =\n    .title = Download\npdfjs-download-button-label = Download\npdfjs-bookmark-button =\n    .title = Current Page (View URL from Current Page)\npdfjs-bookmark-button-label = Current Page\npdfjs-tools-button =\n    .title = Tools\npdfjs-tools-button-label = Tools\npdfjs-first-page-button =\n    .title = Go to First Page\npdfjs-first-page-button-label = Go to First Page\npdfjs-last-page-button =\n    .title = Go to Last Page\npdfjs-last-page-button-label = Go to Last Page\npdfjs-page-rotate-cw-button =\n    .title = Rotate Clockwise\npdfjs-page-rotate-cw-button-label = Rotate Clockwise\npdfjs-page-rotate-ccw-button =\n    .title = Rotate Counterclockwise\npdfjs-page-rotate-ccw-button-label = Rotate Counterclockwise\npdfjs-cursor-text-select-tool-button =\n    .title = Enable Text Selection Tool\npdfjs-cursor-text-select-tool-button-label = Text Selection Tool\npdfjs-cursor-hand-tool-button =\n    .title = Enable Hand Tool\npdfjs-cursor-hand-tool-button-label = Hand Tool\npdfjs-scroll-page-button =\n    .title = Use Page Scrolling\npdfjs-scroll-page-button-label = Page Scrolling\npdfjs-scroll-vertical-button =\n    .title = Use Vertical Scrolling\npdfjs-scroll-vertical-button-label = Vertical Scrolling\npdfjs-scroll-horizontal-button =\n    .title = Use Horizontal Scrolling\npdfjs-scroll-horizontal-button-label = Horizontal Scrolling\npdfjs-scroll-wrapped-button =\n    .title = Use Wrapped Scrolling\npdfjs-scroll-wrapped-button-label = Wrapped Scrolling\npdfjs-spread-none-button =\n    .title = Do not join page spreads\npdfjs-spread-none-button-label = No Spreads\npdfjs-spread-odd-button =\n    .title = Join page spreads starting with odd-numbered pages\npdfjs-spread-odd-button-label = Odd Spreads\npdfjs-spread-even-button =\n    .title = Join page spreads starting with even-numbered pages\npdfjs-spread-even-button-label = Even Spreads\npdfjs-document-properties-button =\n    .title = Document Properties\u2026\npdfjs-document-properties-button-label = Document Properties\u2026\npdfjs-document-properties-file-name = File name:\npdfjs-document-properties-file-size = File size:\npdfjs-document-properties-kb = { $size_kb } KB ({ $size_b } bytes)\npdfjs-document-properties-mb = { $size_mb } MB ({ $size_b } bytes)\npdfjs-document-properties-title = Title:\npdfjs-document-properties-author = Author:\npdfjs-document-properties-subject = Subject:\npdfjs-document-properties-keywords = Keywords:\npdfjs-document-properties-creation-date = Creation Date:\npdfjs-document-properties-modification-date = Modification Date:\npdfjs-document-properties-date-string = { $date }, { $time }\npdfjs-document-properties-creator = Creator:\npdfjs-document-properties-producer = PDF Producer:\npdfjs-document-properties-version = PDF Version:\npdfjs-document-properties-page-count = Page Count:\npdfjs-document-properties-page-size = Page Size:\npdfjs-document-properties-page-size-unit-inches = in\npdfjs-document-properties-page-size-unit-millimeters = mm\npdfjs-document-properties-page-size-orientation-portrait = portrait\npdfjs-document-properties-page-size-orientation-landscape = landscape\npdfjs-document-properties-page-size-name-a-three = A3\npdfjs-document-properties-page-size-name-a-four = A4\npdfjs-document-properties-page-size-name-letter = Letter\npdfjs-document-properties-page-size-name-legal = Legal\npdfjs-document-properties-page-size-dimension-string = { $width } \xd7 { $height } { $unit } ({ $orientation })\npdfjs-document-properties-page-size-dimension-name-string = { $width } \xd7 { $height } { $unit } ({ $name }, { $orientation })\npdfjs-document-properties-linearized = Fast Web View:\npdfjs-document-properties-linearized-yes = Yes\npdfjs-document-properties-linearized-no = No\npdfjs-document-properties-close-button = Close\npdfjs-print-progress-message = Preparing document for printing\u2026\npdfjs-print-progress-percent = { $progress }%\npdfjs-print-progress-close-button = Cancel\npdfjs-printing-not-supported = Warning: Printing is not fully supported by this browser.\npdfjs-printing-not-ready = Warning: The PDF is not fully loaded for printing.\npdfjs-toggle-sidebar-button =\n    .title = Toggle Sidebar\npdfjs-toggle-sidebar-notification-button =\n    .title = Toggle Sidebar (document contains outline/attachments/layers)\npdfjs-toggle-sidebar-button-label = Toggle Sidebar\npdfjs-document-outline-button =\n    .title = Show Document Outline (double-click to expand/collapse all items)\npdfjs-document-outline-button-label = Document Outline\npdfjs-attachments-button =\n    .title = Show Attachments\npdfjs-attachments-button-label = Attachments\npdfjs-layers-button =\n    .title = Show Layers (double-click to reset all layers to the default state)\npdfjs-layers-button-label = Layers\npdfjs-thumbs-button =\n    .title = Show Thumbnails\npdfjs-thumbs-button-label = Thumbnails\npdfjs-current-outline-item-button =\n    .title = Find Current Outline Item\npdfjs-current-outline-item-button-label = Current Outline Item\npdfjs-findbar-button =\n    .title = Find in Document\npdfjs-findbar-button-label = Find\npdfjs-additional-layers = Additional Layers\npdfjs-thumb-page-title =\n    .title = Page { $page }\npdfjs-thumb-page-canvas =\n    .aria-label = Thumbnail of Page { $page }\npdfjs-find-input =\n    .title = Find\n    .placeholder = Find in document\u2026\npdfjs-find-previous-button =\n    .title = Find the previous occurrence of the phrase\npdfjs-find-previous-button-label = Previous\npdfjs-find-next-button =\n    .title = Find the next occurrence of the phrase\npdfjs-find-next-button-label = Next\npdfjs-find-highlight-checkbox = Highlight All\npdfjs-find-match-case-checkbox-label = Match Case\npdfjs-find-match-diacritics-checkbox-label = Match Diacritics\npdfjs-find-entire-word-checkbox-label = Whole Words\npdfjs-find-reached-top = Reached top of document, continued from bottom\npdfjs-find-reached-bottom = Reached end of document, continued from top\npdfjs-find-match-count =\n    { $total ->\n        [one] { $current } of { $total } match\n       *[other] { $current } of { $total } matches\n    }\npdfjs-find-match-count-limit =\n    { $limit ->\n        [one] More than { $limit } match\n       *[other] More than { $limit } matches\n    }\npdfjs-find-not-found = Phrase not found\npdfjs-page-scale-width = Page Width\npdfjs-page-scale-fit = Page Fit\npdfjs-page-scale-auto = Automatic Zoom\npdfjs-page-scale-actual = Actual Size\npdfjs-page-scale-percent = { $scale }%\npdfjs-page-landmark =\n    .aria-label = Page { $page }\npdfjs-loading-error = An error occurred while loading the PDF.\npdfjs-invalid-file-error = Invalid or corrupted PDF file.\npdfjs-missing-file-error = Missing PDF file.\npdfjs-unexpected-response-error = Unexpected server response.\npdfjs-rendering-error = An error occurred while rendering the page.\npdfjs-annotation-date-string = { $date }, { $time }\npdfjs-text-annotation-type =\n    .alt = [{ $type } Annotation]\npdfjs-password-label = Enter the password to open this PDF file.\npdfjs-password-invalid = Invalid password. Please try again.\npdfjs-password-ok-button = OK\npdfjs-password-cancel-button = Cancel\npdfjs-web-fonts-disabled = Web fonts are disabled: unable to use embedded PDF fonts.\npdfjs-editor-free-text-button =\n    .title = Text\npdfjs-editor-free-text-button-label = Text\npdfjs-editor-ink-button =\n    .title = Draw\npdfjs-editor-ink-button-label = Draw\npdfjs-editor-stamp-button =\n    .title = Add or edit images\npdfjs-editor-stamp-button-label = Add or edit images\npdfjs-editor-highlight-button =\n    .title = Highlight\npdfjs-editor-highlight-button-label = Highlight\npdfjs-highlight-floating-button1 =\n    .title = Highlight\n    .aria-label = Highlight\npdfjs-highlight-floating-button-label = Highlight\npdfjs-editor-remove-ink-button =\n    .title = Remove drawing\npdfjs-editor-remove-freetext-button =\n    .title = Remove text\npdfjs-editor-remove-stamp-button =\n    .title = Remove image\npdfjs-editor-remove-highlight-button =\n    .title = Remove highlight\npdfjs-editor-free-text-color-input = Color\npdfjs-editor-free-text-size-input = Size\npdfjs-editor-ink-color-input = Color\npdfjs-editor-ink-thickness-input = Thickness\npdfjs-editor-ink-opacity-input = Opacity\npdfjs-editor-stamp-add-image-button =\n    .title = Add image\npdfjs-editor-stamp-add-image-button-label = Add image\npdfjs-editor-free-highlight-thickness-input = Thickness\npdfjs-editor-free-highlight-thickness-title =\n    .title = Change thickness when highlighting items other than text\npdfjs-free-text =\n    .aria-label = Text Editor\npdfjs-free-text-default-content = Start typing\u2026\npdfjs-ink =\n    .aria-label = Draw Editor\npdfjs-ink-canvas =\n    .aria-label = User-created image\npdfjs-editor-alt-text-button-label = Alt text\npdfjs-editor-alt-text-edit-button-label = Edit alt text\npdfjs-editor-alt-text-dialog-label = Choose an option\npdfjs-editor-alt-text-dialog-description = Alt text (alternative text) helps when people can\u2019t see the image or when it doesn\u2019t load.\npdfjs-editor-alt-text-add-description-label = Add a description\npdfjs-editor-alt-text-add-description-description = Aim for 1-2 sentences that describe the subject, setting, or actions.\npdfjs-editor-alt-text-mark-decorative-label = Mark as decorative\npdfjs-editor-alt-text-mark-decorative-description = This is used for ornamental images, like borders or watermarks.\npdfjs-editor-alt-text-cancel-button = Cancel\npdfjs-editor-alt-text-save-button = Save\npdfjs-editor-alt-text-decorative-tooltip = Marked as decorative\npdfjs-editor-alt-text-textarea =\n    .placeholder = For example, \u201cA young man sits down at a table to eat a meal\u201d\npdfjs-editor-resizer-label-top-left = Top left corner \u2014 resize\npdfjs-editor-resizer-label-top-middle = Top middle \u2014 resize\npdfjs-editor-resizer-label-top-right = Top right corner \u2014 resize\npdfjs-editor-resizer-label-middle-right = Middle right \u2014 resize\npdfjs-editor-resizer-label-bottom-right = Bottom right corner \u2014 resize\npdfjs-editor-resizer-label-bottom-middle = Bottom middle \u2014 resize\npdfjs-editor-resizer-label-bottom-left = Bottom left corner \u2014 resize\npdfjs-editor-resizer-label-middle-left = Middle left \u2014 resize\npdfjs-editor-highlight-colorpicker-label = Highlight color\npdfjs-editor-colorpicker-button =\n    .title = Change color\npdfjs-editor-colorpicker-dropdown =\n    .aria-label = Color choices\npdfjs-editor-colorpicker-yellow =\n    .title = Yellow\npdfjs-editor-colorpicker-green =\n    .title = Green\npdfjs-editor-colorpicker-blue =\n    .title = Blue\npdfjs-editor-colorpicker-pink =\n    .title = Pink\npdfjs-editor-colorpicker-red =\n    .title = Red\npdfjs-editor-highlight-show-all-button-label = Show all\npdfjs-editor-highlight-show-all-button =\n    .title = Show all'
          );
        })).apply(this, arguments);
      }
      const Ale = 1e3,
        BA = 50,
        sW = 1e3;
      function HA() {
        return document.location.hash;
      }
      var Lc = new WeakMap(),
        Fs = new WeakSet(),
        rb = new WeakSet(),
        sb = new WeakSet(),
        Jh = new WeakSet(),
        ob = new WeakSet(),
        WA = new WeakSet(),
        oW = new WeakSet(),
        aW = new WeakSet(),
        jA = new WeakSet(),
        lW = new WeakSet(),
        cW = new WeakSet();
      class Sle {
        constructor({ linkService: e, eventBus: t }) {
          S(this, cW),
            S(this, lW),
            S(this, jA),
            S(this, aW),
            S(this, oW),
            S(this, WA),
            S(this, ob),
            S(this, Jh),
            S(this, sb),
            S(this, rb),
            S(this, Fs),
            v(this, Lc, { writable: !0, value: null }),
            (this.linkService = e),
            (this.eventBus = t),
            (this._initialized = !1),
            (this._fingerprint = ''),
            this.reset(),
            this.eventBus._on('pagesinit', () => {
              (this._isPagesLoaded = !1),
                this.eventBus._on(
                  'pagesloaded',
                  (i) => {
                    this._isPagesLoaded = !!i.pagesCount;
                  },
                  { once: !0 }
                );
            });
        }
        initialize({
          fingerprint: e,
          resetHistory: t = !1,
          updateUrl: i = !1,
        }) {
          if (!e || 'string' != typeof e)
            return void console.error(
              'PDFHistory.initialize: The "fingerprint" must be a non-empty string.'
            );
          this._initialized && this.reset();
          const r = '' !== this._fingerprint && this._fingerprint !== e;
          (this._fingerprint = e),
            (this._updateUrl = !0 === i),
            (this._initialized = !0),
            b(this, lW, Tle).call(this);
          const s = window.history.state;
          if (
            ((this._popStateInProgress = !1),
            (this._blockHashChange = 0),
            (this._currentHash = HA()),
            (this._numPositionUpdates = 0),
            (this._uid = this._maxUid = 0),
            (this._destination = null),
            (this._position = null),
            !b(this, Jh, ab).call(this, s, !0) || t)
          ) {
            const {
              hash: a,
              page: l,
              rotation: c,
            } = b(this, WA, dW).call(this, !0);
            return !a || r || t
              ? void b(this, Fs, wo).call(this, null, !0)
              : void b(this, Fs, wo).call(
                  this,
                  { hash: a, page: l, rotation: c },
                  !0
                );
          }
          const o = s.destination;
          b(this, ob, $A).call(this, o, s.uid, !0),
            void 0 !== o.rotation && (this._initialRotation = o.rotation),
            o.dest
              ? ((this._initialBookmark = JSON.stringify(o.dest)),
                (this._destination.page = null))
              : o.hash
              ? (this._initialBookmark = o.hash)
              : o.page && (this._initialBookmark = `page=${o.page}`);
        }
        reset() {
          this._initialized &&
            (b(this, jA, uW).call(this),
            (this._initialized = !1),
            b(this, cW, Ile).call(this)),
            this._updateViewareaTimeout &&
              (clearTimeout(this._updateViewareaTimeout),
              (this._updateViewareaTimeout = null)),
            (this._initialBookmark = null),
            (this._initialRotation = null);
        }
        push({ namedDest: e = null, explicitDest: t, pageNumber: i }) {
          if (!this._initialized) return;
          if (e && 'string' != typeof e)
            return void console.error(
              `PDFHistory.push: "${e}" is not a valid namedDest parameter.`
            );
          if (!Array.isArray(t))
            return void console.error(
              `PDFHistory.push: "${t}" is not a valid explicitDest parameter.`
            );
          if (
            !b(this, sb, UA).call(this, i) &&
            (null !== i || this._destination)
          )
            return void console.error(
              `PDFHistory.push: "${i}" is not a valid pageNumber parameter.`
            );
          const r = e || JSON.stringify(t);
          if (!r) return;
          let s = !1;
          if (
            this._destination &&
            ((function kle(n, e) {
              return (
                'string' == typeof n &&
                'string' == typeof e &&
                (n === e || H_(n).get('nameddest') === e)
              );
            })(this._destination.hash, r) ||
              (function Ple(n, e) {
                function t(i, r) {
                  if (
                    typeof i != typeof r ||
                    Array.isArray(i) ||
                    Array.isArray(r)
                  )
                    return !1;
                  if (null !== i && 'object' == typeof i && null !== r) {
                    if (Object.keys(i).length !== Object.keys(r).length)
                      return !1;
                    for (const s in i) if (!t(i[s], r[s])) return !1;
                    return !0;
                  }
                  return i === r || (Number.isNaN(i) && Number.isNaN(r));
                }
                if (
                  !Array.isArray(n) ||
                  !Array.isArray(e) ||
                  n.length !== e.length
                )
                  return !1;
                for (let i = 0, r = n.length; i < r; i++)
                  if (!t(n[i], e[i])) return !1;
                return !0;
              })(this._destination.dest, t))
          ) {
            if (this._destination.page) return;
            s = !0;
          }
          (this._popStateInProgress && !s) ||
            (b(this, Fs, wo).call(
              this,
              {
                dest: t,
                hash: r,
                page: i,
                rotation: this.linkService.rotation,
              },
              s
            ),
            this._popStateInProgress ||
              ((this._popStateInProgress = !0),
              Promise.resolve().then(() => {
                this._popStateInProgress = !1;
              })));
        }
        pushPage(e) {
          if (this._initialized) {
            if (!b(this, sb, UA).call(this, e))
              return void console.error(
                `PDFHistory.pushPage: "${e}" is not a valid page number.`
              );
            this._destination?.page !== e &&
              (this._popStateInProgress ||
                (b(this, Fs, wo).call(this, {
                  dest: null,
                  hash: `page=${e}`,
                  page: e,
                  rotation: this.linkService.rotation,
                }),
                this._popStateInProgress ||
                  ((this._popStateInProgress = !0),
                  Promise.resolve().then(() => {
                    this._popStateInProgress = !1;
                  }))));
          }
        }
        pushCurrentPosition() {
          !this._initialized ||
            this._popStateInProgress ||
            b(this, rb, zA).call(this);
        }
        back() {
          if (!this._initialized || this._popStateInProgress) return;
          const e = window.history.state;
          b(this, Jh, ab).call(this, e) && e.uid > 0 && window.history.back();
        }
        forward() {
          if (!this._initialized || this._popStateInProgress) return;
          const e = window.history.state;
          b(this, Jh, ab).call(this, e) &&
            e.uid < this._maxUid &&
            window.history.forward();
        }
        get popStateInProgress() {
          return (
            this._initialized &&
            (this._popStateInProgress || this._blockHashChange > 0)
          );
        }
        get initialBookmark() {
          return this._initialized ? this._initialBookmark : null;
        }
        get initialRotation() {
          return this._initialized ? this._initialRotation : null;
        }
      }
      function wo(n, e = !1) {
        const t = e || !this._destination,
          i = {
            fingerprint: this._fingerprint,
            uid: t ? this._uid : this._uid + 1,
            destination: n,
          };
        let r;
        if (
          (b(this, ob, $A).call(this, n, i.uid), this._updateUrl && n?.hash)
        ) {
          const s = document.location.href.split('#', 1)[0];
          s.startsWith('file://') || (r = `${s}#${n.hash}`);
        }
        t
          ? window.history.replaceState(i, '', r)
          : window.history.pushState(i, '', r);
      }
      function zA(n = !1) {
        if (!this._position) return;
        let e = this._position;
        if (
          (n &&
            ((e = Object.assign(Object.create(null), this._position)),
            (e.temporary = !0)),
          !this._destination)
        )
          return void b(this, Fs, wo).call(this, e);
        if (this._destination.temporary)
          return void b(this, Fs, wo).call(this, e, !0);
        if (
          this._destination.hash === e.hash ||
          (!this._destination.page &&
            (BA <= 0 || this._numPositionUpdates <= BA))
        )
          return;
        let t = !1;
        if (
          this._destination.page >= e.first &&
          this._destination.page <= e.page
        ) {
          if (void 0 !== this._destination.dest || !this._destination.first)
            return;
          t = !0;
        }
        b(this, Fs, wo).call(this, e, t);
      }
      function UA(n) {
        return Number.isInteger(n) && n > 0 && n <= this.linkService.pagesCount;
      }
      function ab(n, e = !1) {
        if (!n) return !1;
        if (n.fingerprint !== this._fingerprint) {
          if (!e) return !1;
          {
            if (
              'string' != typeof n.fingerprint ||
              n.fingerprint.length !== this._fingerprint.length
            )
              return !1;
            const [t] = performance.getEntriesByType('navigation');
            if ('reload' !== t?.type) return !1;
          }
        }
        return !(
          !Number.isInteger(n.uid) ||
          n.uid < 0 ||
          null === n.destination ||
          'object' != typeof n.destination
        );
      }
      function $A(n, e, t = !1) {
        this._updateViewareaTimeout &&
          (clearTimeout(this._updateViewareaTimeout),
          (this._updateViewareaTimeout = null)),
          t && n?.temporary && delete n.temporary,
          (this._destination = n),
          (this._uid = e),
          (this._maxUid = Math.max(this._maxUid, e)),
          (this._numPositionUpdates = 0);
      }
      function dW(n = !1) {
        const e = unescape(HA()).substring(1),
          t = H_(e),
          i = t.get('nameddest') || '';
        let r = 0 | t.get('page');
        return (
          (!b(this, sb, UA).call(this, r) || (n && i.length > 0)) && (r = null),
          { hash: e, page: r, rotation: this.linkService.rotation }
        );
      }
      function Mle({ location: n }) {
        this._updateViewareaTimeout &&
          (clearTimeout(this._updateViewareaTimeout),
          (this._updateViewareaTimeout = null)),
          (this._position = {
            hash: n.pdfOpenParams.substring(1),
            page: this.linkService.page,
            first: n.pageNumber,
            rotation: n.rotation,
          }),
          !this._popStateInProgress &&
            (BA > 0 &&
              this._isPagesLoaded &&
              this._destination &&
              !this._destination.page &&
              this._numPositionUpdates++,
            sW > 0 &&
              (this._updateViewareaTimeout = setTimeout(() => {
                this._popStateInProgress || b(this, rb, zA).call(this, !0),
                  (this._updateViewareaTimeout = null);
              }, sW)));
      }
      function Dle({ state: n }) {
        const e = HA(),
          t = this._currentHash !== e;
        if (((this._currentHash = e), !n)) {
          this._uid++;
          const { hash: r, page: s, rotation: o } = b(this, WA, dW).call(this);
          return void b(this, Fs, wo).call(
            this,
            { hash: r, page: s, rotation: o },
            !0
          );
        }
        if (!b(this, Jh, ab).call(this, n)) return;
        (this._popStateInProgress = !0),
          t &&
            (this._blockHashChange++,
            (function Mae(n) {
              return IA.apply(this, arguments);
            })({ target: window, name: 'hashchange', delay: Ale }).then(() => {
              this._blockHashChange--;
            }));
        const i = n.destination;
        b(this, ob, $A).call(this, i, n.uid, !0),
          lH(i.rotation) && (this.linkService.rotation = i.rotation),
          i.dest
            ? this.linkService.goToDestination(i.dest)
            : i.hash
            ? this.linkService.setHash(i.hash)
            : i.page && (this.linkService.page = i.page),
          Promise.resolve().then(() => {
            this._popStateInProgress = !1;
          });
      }
      function uW() {
        (!this._destination || this._destination.temporary) &&
          b(this, rb, zA).call(this);
      }
      function Tle() {
        if (d(this, Lc)) return;
        _(this, Lc, new AbortController());
        const { signal: n } = d(this, Lc);
        this.eventBus._on('updateviewarea', b(this, oW, Mle).bind(this), {
          signal: n,
        }),
          window.addEventListener('popstate', b(this, aW, Dle).bind(this), {
            signal: n,
          }),
          window.addEventListener('pagehide', b(this, jA, uW).bind(this), {
            signal: n,
          });
      }
      function Ile() {
        d(this, Lc)?.abort(), _(this, Lc, null);
      }
      var GA = new WeakMap(),
        qA = new WeakMap(),
        XA = new WeakMap(),
        YA = new WeakMap(),
        lb = new WeakMap();
      class Rle {
        constructor(e) {
          v(this, GA, { writable: !0, value: null }),
            v(this, qA, { writable: !0, value: null }),
            v(this, XA, { writable: !0, value: null }),
            v(this, YA, { writable: !0, value: null }),
            v(this, lb, { writable: !0, value: void 0 }),
            (this.pdfPage = e.pdfPage),
            (this.accessibilityManager = e.accessibilityManager),
            (this.l10n = e.l10n),
            (this.l10n ||= new Zn()),
            (this.annotationEditorLayer = null),
            (this.div = null),
            (this._cancelled = !1),
            _(this, lb, e.uiManager),
            _(this, GA, e.annotationLayer || null),
            _(this, YA, e.textLayer || null),
            _(this, qA, e.drawLayer || null),
            _(this, XA, e.onAppend || null);
        }
        render(e, t = 'display') {
          var i = this;
          return U(function* () {
            if ('display' !== t || i._cancelled) return;
            const r = e.clone({ dontFlip: !0 });
            if (i.div)
              return (
                i.annotationEditorLayer.update({ viewport: r }), void i.show()
              );
            const s = (i.div = document.createElement('div'));
            (s.className = 'annotationEditorLayer'),
              (s.hidden = !0),
              (s.dir = d(i, lb).direction),
              d(i, XA)?.call(i, s),
              (i.annotationEditorLayer = new mae({
                uiManager: d(i, lb),
                div: s,
                accessibilityManager: i.accessibilityManager,
                pageIndex: i.pdfPage.pageNumber - 1,
                l10n: i.l10n,
                viewport: r,
                annotationLayer: d(i, GA),
                textLayer: d(i, YA),
                drawLayer: d(i, qA),
              })),
              i.annotationEditorLayer.render({
                viewport: r,
                div: s,
                annotations: null,
                intent: t,
              }),
              i.show();
          })();
        }
        cancel() {
          (this._cancelled = !0),
            this.div && this.annotationEditorLayer.destroy();
        }
        hide() {
          this.div && (this.div.hidden = !0);
        }
        show() {
          !this.div ||
            this.annotationEditorLayer.isInvisible ||
            (this.div.hidden = !1);
        }
      }
      {
        var cb = new Map();
        const n = navigator.userAgent || '',
          e = navigator.platform || '',
          t = navigator.maxTouchPoints || 1,
          i = /Android/.test(n);
        (/\b(iPad|iPhone|iPod)(?=;)/.test(n) ||
          ('MacIntel' === e && t > 1) ||
          i) &&
          cb.set('maxCanvasPixels', 5242880),
          i && cb.set('useSystemFonts', !1);
      }
      const KA = { BOOLEAN: 1, NUMBER: 2, OBJECT: 4, STRING: 8, UNDEFINED: 16 },
        Eo = {
          allowedGlobalEvents: { value: null, kind: 1 },
          canvasMaxAreaInBytes: { value: -1, kind: 5 },
          isInAutomation: { value: !1, kind: 1 },
          localeProperties: {
            value: { lang: navigator.language || 'en-US' },
            kind: 1,
          },
          nimbusDataStr: { value: '', kind: 1 },
          supportsCaretBrowsingMode: { value: !1, kind: 1 },
          supportsDocumentFonts: { value: !0, kind: 1 },
          supportsIntegratedFind: { value: !1, kind: 1 },
          supportsMouseWheelZoomCtrlKey: { value: !0, kind: 1 },
          supportsMouseWheelZoomMetaKey: { value: !0, kind: 1 },
          supportsPinchToZoom: { value: !0, kind: 1 },
          toolbarDensity: { value: 0, kind: 17 },
          altTextLearnMoreUrl: { value: '', kind: 130 },
          annotationEditorMode: { value: 0, kind: 130 },
          annotationMode: { value: 2, kind: 130 },
          cursorToolOnLoad: { value: 0, kind: 130 },
          debuggerSrc: { value: './debugger.mjs', kind: 2 },
          defaultZoomDelay: { value: 400, kind: 130 },
          defaultZoomValue: { value: '', kind: 130 },
          disableHistory: { value: !1, kind: 2 },
          disablePageLabels: { value: !1, kind: 130 },
          enableAltText: { value: !1, kind: 130 },
          enableGuessAltText: { value: !0, kind: 130 },
          enableHighlightEditor: { value: !1, kind: 130 },
          enableHighlightFloatingButton: { value: !1, kind: 130 },
          enablePermissions: { value: !1, kind: 130 },
          enablePrintAutoRotate: { value: !0, kind: 130 },
          enableScripting: { value: !0, kind: 130 },
          enableUpdatedAddImage: { value: !1, kind: 130 },
          externalLinkRel: { value: 'noopener noreferrer nofollow', kind: 2 },
          externalLinkTarget: { value: 0, kind: 130 },
          highlightEditorColors: {
            value:
              'yellow=#FFFF98,green=#53FFBC,blue=#80EBFF,pink=#FFCBE6,red=#FF4F5F',
            kind: 130,
          },
          historyUpdateUrl: { value: !1, kind: 130 },
          ignoreDestinationZoom: { value: !1, kind: 130 },
          imageResourcesPath: { value: './images/', kind: 2 },
          maxCanvasPixels: { value: 2 ** 25, kind: 2 },
          forcePageColors: { value: !1, kind: 130 },
          pageColorsBackground: { value: 'Canvas', kind: 130 },
          pageColorsForeground: { value: 'CanvasText', kind: 130 },
          pdfBugEnabled: { value: !1, kind: 130 },
          printResolution: { value: 150, kind: 2 },
          sidebarViewOnLoad: { value: -1, kind: 130 },
          scrollModeOnLoad: { value: -1, kind: 130 },
          spreadModeOnLoad: { value: -1, kind: 130 },
          textLayerMode: { value: 1, kind: 130 },
          viewOnLoad: { value: 0, kind: 130 },
          cMapPacked: { value: !0, kind: 4 },
          cMapUrl: { value: '../web/cmaps/', kind: 4 },
          disableAutoFetch: { value: !1, kind: 132 },
          disableFontFace: { value: !1, kind: 132 },
          disableRange: { value: !1, kind: 132 },
          disableStream: { value: !1, kind: 132 },
          docBaseUrl: { value: '', kind: 4 },
          enableHWA: { value: !0, kind: 134 },
          enableXfa: { value: !0, kind: 132 },
          fontExtraProperties: { value: !1, kind: 4 },
          isEvalSupported: { value: !0, kind: 4 },
          isOffscreenCanvasSupported: { value: !0, kind: 4 },
          maxImageSize: { value: -1, kind: 4 },
          pdfBug: { value: !1, kind: 4 },
          standardFontDataUrl: { value: '../web/standard_fonts/', kind: 4 },
          useSystemFonts: {
            value: void 0,
            kind: 4,
            type: KA.BOOLEAN + KA.UNDEFINED,
          },
          verbosity: { value: 1, kind: 4 },
          workerPort: { value: null, kind: 8 },
          workerSrc: { value: '../build/pdf.worker.mjs', kind: 8 },
          defaultUrl: { value: 'compressed.tracemonkey-pldi-09.pdf', kind: 2 },
          sandboxBundleSrc: { value: '../build/pdf.sandbox.mjs', kind: 2 },
          viewerCssTheme: { value: 0, kind: 130 },
          disablePreferences: { value: !1, kind: 2 },
        },
        Ha = new Map();
      for (const [n, e] of cb) Ha.set(n, e);
      let ZA = (() => {
        class n {
          constructor() {
            throw new Error('Cannot initialize AppOptions.');
          }
          static get(t) {
            return Ha.has(t) ? Ha.get(t) : Eo[t]?.value;
          }
          static getAll(t = null, i = !1) {
            const r = Object.create(null);
            for (const s in Eo) {
              const o = Eo[s];
              (t && !(t & o.kind)) ||
                (r[s] = !i && Ha.has(s) ? Ha.get(s) : o.value);
            }
            return r;
          }
          static set(t, i) {
            this.setAll({ [t]: i });
          }
          static setAll(t, i = !1) {
            let r;
            for (const s in t) {
              const o = Eo[s],
                a = t[s];
              if (
                !o ||
                !(
                  typeof a == typeof o.value ||
                  KA[(typeof a).toUpperCase()] & o.type
                )
              )
                continue;
              const { kind: l } = o;
              (i && !(1 & l || 128 & l)) ||
                (this.eventBus && 16 & l && (r ||= new Map()).set(s, a),
                Ha.set(s, a));
            }
            if (r)
              for (const [s, o] of r)
                this.eventBus.dispatch(s.toLowerCase(), {
                  source: this,
                  value: o,
                });
          }
        }
        return Se(n, 'eventBus', void 0), n;
      })();
      ZA._checkDisablePreferences = () => {
        if (ZA.get('disablePreferences')) return !0;
        for (const [n] of Ha)
          if (!cb.has(n)) {
            console.warn(
              'The Preferences may override manually set AppOptions; please use the "disablePreferences"-option to prevent that.'
            );
            break;
          }
        return !1;
      };
      var Co = new WeakMap();
      class Fle {
        constructor(e) {
          v(this, Co, { writable: !0, value: null }),
            (this.pageIndex = e.pageIndex);
        }
        render(e = 'display') {
          var t = this;
          return U(function* () {
            'display' !== e ||
              d(t, Co) ||
              t._cancelled ||
              _(t, Co, new vae({ pageIndex: t.pageIndex }));
          })();
        }
        cancel() {
          (this._cancelled = !0),
            d(this, Co) && (d(this, Co).destroy(), _(this, Co, null));
        }
        setParent(e) {
          d(this, Co)?.setParent(e);
        }
        getDrawLayer() {
          return d(this, Co);
        }
      }
      const hW = {
          Document: null,
          DocumentFragment: null,
          Part: 'group',
          Sect: 'group',
          Div: 'group',
          Aside: 'note',
          NonStruct: 'none',
          P: null,
          H: 'heading',
          Title: null,
          FENote: 'note',
          Sub: 'group',
          Lbl: null,
          Span: null,
          Em: null,
          Strong: null,
          Link: 'link',
          Annot: 'note',
          Form: 'form',
          Ruby: null,
          RB: null,
          RT: null,
          RP: null,
          Warichu: null,
          WT: null,
          WP: null,
          L: 'list',
          LI: 'listitem',
          LBody: null,
          Table: 'table',
          TR: 'row',
          TH: 'columnheader',
          TD: 'cell',
          THead: 'columnheader',
          TBody: null,
          TFoot: null,
          Caption: null,
          Figure: 'figure',
          Formula: null,
          Artifact: null,
        },
        Ole = /^H(\d+)$/;
      var Kr = new WeakMap(),
        QA = new WeakSet(),
        JA = new WeakSet();
      class fW {
        constructor() {
          S(this, JA),
            S(this, QA),
            v(this, Kr, { writable: !0, value: void 0 });
        }
        get renderingDone() {
          return void 0 !== d(this, Kr);
        }
        render(e) {
          if (void 0 !== d(this, Kr)) return d(this, Kr);
          const t = b(this, JA, mW).call(this, e);
          return t?.classList.add('structTree'), _(this, Kr, t);
        }
        hide() {
          d(this, Kr) && !d(this, Kr).hidden && (d(this, Kr).hidden = !0);
        }
        show() {
          d(this, Kr)?.hidden && (d(this, Kr).hidden = !1);
        }
      }
      function pW(n, e) {
        const { alt: t, id: i, lang: r } = n;
        void 0 !== t && e.setAttribute('aria-label', W_(t)),
          void 0 !== i && e.setAttribute('aria-owns', i),
          void 0 !== r && e.setAttribute('lang', W_(r, !0));
      }
      function mW(n) {
        if (!n) return null;
        const e = document.createElement('span');
        if ('role' in n) {
          const { role: t } = n,
            i = t.match(Ole);
          i
            ? (e.setAttribute('role', 'heading'),
              e.setAttribute('aria-level', i[1]))
            : hW[t] && e.setAttribute('role', hW[t]);
        }
        if ((b(this, QA, pW).call(this, n, e), n.children))
          if (1 === n.children.length && 'id' in n.children[0])
            b(this, QA, pW).call(this, n.children[0], e);
          else
            for (const t of n.children) e.append(b(this, JA, mW).call(this, t));
        return e;
      }
      var Wa = new WeakMap(),
        Zr = new WeakMap(),
        ja = new WeakMap(),
        Nc = new WeakMap(),
        eS = new WeakSet();
      class Qr {
        constructor() {
          S(this, eS),
            v(this, Wa, { writable: !0, value: !1 }),
            v(this, Zr, { writable: !0, value: null }),
            v(this, ja, { writable: !0, value: new Map() }),
            v(this, Nc, { writable: !0, value: new Map() });
        }
        setTextMapping(e) {
          _(this, Zr, e);
        }
        enable() {
          if (d(this, Wa))
            throw new Error('TextAccessibilityManager is already enabled.');
          if (!d(this, Zr))
            throw new Error('Text divs and strings have not been set.');
          if (
            (_(this, Wa, !0),
            _(this, Zr, d(this, Zr).slice()),
            d(this, Zr).sort(we(Qr, Qr, tS)),
            d(this, ja).size > 0)
          ) {
            const e = d(this, Zr);
            for (const [t, i] of d(this, ja))
              document.getElementById(t)
                ? b(this, eS, gW).call(this, t, e[i])
                : d(this, ja).delete(t);
          }
          for (const [e, t] of d(this, Nc)) this.addPointerInTextLayer(e, t);
          d(this, Nc).clear();
        }
        disable() {
          d(this, Wa) &&
            (d(this, Nc).clear(), _(this, Zr, null), _(this, Wa, !1));
        }
        removePointerInTextLayer(e) {
          if (!d(this, Wa)) return void d(this, Nc).delete(e);
          const t = d(this, Zr);
          if (!t || 0 === t.length) return;
          const { id: i } = e,
            r = d(this, ja).get(i);
          if (void 0 === r) return;
          const s = t[r];
          d(this, ja).delete(i);
          let o = s.getAttribute('aria-owns');
          o?.includes(i) &&
            ((o = o
              .split(' ')
              .filter((a) => a !== i)
              .join(' ')),
            o
              ? s.setAttribute('aria-owns', o)
              : (s.removeAttribute('aria-owns'),
                s.setAttribute('role', 'presentation')));
        }
        addPointerInTextLayer(e, t) {
          const { id: i } = e;
          if (!i) return null;
          if (!d(this, Wa)) return d(this, Nc).set(e, t), null;
          t && this.removePointerInTextLayer(e);
          const r = d(this, Zr);
          if (!r || 0 === r.length) return null;
          const s = Uh(r, (c) => we(Qr, Qr, tS).call(Qr, e, c) < 0),
            o = Math.max(0, s - 1),
            a = r[o];
          b(this, eS, gW).call(this, i, a), d(this, ja).set(i, o);
          const l = a.parentNode;
          return l?.classList.contains('markedContent') ? l.id : null;
        }
        moveElementInDOM(e, t, i, r) {
          const s = this.addPointerInTextLayer(i, r);
          if (!e.hasChildNodes()) return e.append(t), s;
          const o = Array.from(e.childNodes).filter((c) => c !== t);
          if (0 === o.length) return s;
          const a = i || t,
            l = Uh(o, (c) => we(Qr, Qr, tS).call(Qr, a, c) < 0);
          return 0 === l ? o[0].before(t) : o[l - 1].after(t), s;
        }
      }
      function tS(n, e) {
        const t = n.getBoundingClientRect(),
          i = e.getBoundingClientRect();
        if (0 === t.width && 0 === t.height) return 1;
        if (0 === i.width && 0 === i.height) return -1;
        const o = t.y + t.height / 2,
          c = i.y + i.height / 2;
        return o <= i.y && c >= t.y + t.height
          ? -1
          : c <= t.y && o >= i.y + i.height
          ? 1
          : t.x + t.width / 2 - (i.x + i.width / 2);
      }
      function gW(n, e) {
        const t = e.getAttribute('aria-owns');
        t?.includes(n) || e.setAttribute('aria-owns', t ? `${t} ${n}` : n),
          e.removeAttribute('role');
      }
      var Vc = new WeakMap();
      class Lle {
        constructor({ findController: e, eventBus: t, pageIndex: i }) {
          v(this, Vc, { writable: !0, value: null }),
            (this.findController = e),
            (this.matches = []),
            (this.eventBus = t),
            (this.pageIdx = i),
            (this.textDivs = null),
            (this.textContentItemsStr = null),
            (this.enabled = !1);
        }
        setTextMapping(e, t) {
          (this.textDivs = e), (this.textContentItemsStr = t);
        }
        enable() {
          if (!this.textDivs || !this.textContentItemsStr)
            throw new Error('Text divs and strings have not been set.');
          if (this.enabled)
            throw new Error('TextHighlighter is already enabled.');
          (this.enabled = !0),
            d(this, Vc) ||
              (_(this, Vc, new AbortController()),
              this.eventBus._on(
                'updatetextlayermatches',
                (e) => {
                  (e.pageIndex === this.pageIdx || -1 === e.pageIndex) &&
                    this._updateMatches();
                },
                { signal: d(this, Vc).signal }
              )),
            this._updateMatches();
        }
        disable() {
          this.enabled &&
            ((this.enabled = !1),
            d(this, Vc)?.abort(),
            _(this, Vc, null),
            this._updateMatches(!0));
        }
        _convertMatches(e, t) {
          if (!e) return [];
          const { textContentItemsStr: i } = this;
          let r = 0,
            s = 0;
          const o = i.length - 1,
            a = [];
          for (let l = 0, c = e.length; l < c; l++) {
            let u = e[l];
            for (; r !== o && u >= s + i[r].length; ) (s += i[r].length), r++;
            r === i.length &&
              console.error('Could not find a matching mapping');
            const h = { begin: { divIdx: r, offset: u - s } };
            for (u += t[l]; r !== o && u > s + i[r].length; )
              (s += i[r].length), r++;
            (h.end = { divIdx: r, offset: u - s }), a.push(h);
          }
          return a;
        }
        _renderMatches(e) {
          if (0 === e.length) return;
          const { findController: t, pageIdx: i } = this,
            { textContentItemsStr: r, textDivs: s } = this,
            o = i === t.selected.pageIdx,
            a = t.selected.matchIdx;
          let c = null;
          function h(y, E) {
            const A = y.divIdx;
            return (s[A].textContent = ''), f(A, 0, y.offset, E);
          }
          function f(y, E, A, M) {
            let T = s[y];
            if (T.nodeType === Node.TEXT_NODE) {
              const O = document.createElement('span');
              T.before(O), O.append(T), (s[y] = O), (T = O);
            }
            const k = r[y].substring(E, A),
              P = document.createTextNode(k);
            if (M) {
              const O = document.createElement('span');
              return (
                (O.className = `${M} appended`),
                O.append(P),
                T.append(O),
                M.includes('selected') ? O.offsetLeft : 0
              );
            }
            return T.append(P), 0;
          }
          let p = a,
            m = p + 1;
          if (t.state.highlightAll) (p = 0), (m = e.length);
          else if (!o) return;
          let g = -1,
            w = -1;
          for (let y = p; y < m; y++) {
            const E = e[y],
              A = E.begin;
            if (A.divIdx === g && A.offset === w) continue;
            (g = A.divIdx), (w = A.offset);
            const M = E.end,
              T = o && y === a,
              k = T ? ' selected' : '';
            let P = 0;
            if (
              (c && A.divIdx === c.divIdx
                ? f(c.divIdx, c.offset, A.offset)
                : (null !== c && f(c.divIdx, c.offset, undefined), h(A)),
              A.divIdx === M.divIdx)
            )
              P = f(A.divIdx, A.offset, M.offset, 'highlight' + k);
            else {
              P = f(A.divIdx, A.offset, undefined, 'highlight begin' + k);
              for (let O = A.divIdx + 1, I = M.divIdx; O < I; O++)
                s[O].className = 'highlight middle' + k;
              h(M, 'highlight end' + k);
            }
            (c = M),
              T &&
                t.scrollMatchIntoView({
                  element: s[A.divIdx],
                  selectedLeft: P,
                  pageIndex: i,
                  matchIndex: a,
                });
          }
          c && f(c.divIdx, c.offset, undefined);
        }
        _updateMatches(e = !1) {
          if (!this.enabled && !e) return;
          const { findController: t, matches: i, pageIdx: r } = this,
            { textContentItemsStr: s, textDivs: o } = this;
          let a = -1;
          for (const u of i) {
            for (
              let f = Math.max(a, u.begin.divIdx), p = u.end.divIdx;
              f <= p;
              f++
            ) {
              const m = o[f];
              (m.textContent = s[f]), (m.className = '');
            }
            a = u.end.divIdx + 1;
          }
          t?.highlightMatches &&
            !e &&
            ((this.matches = this._convertMatches(
              t.pageMatches[r] || null,
              t.pageMatchesLength[r] || null
            )),
            this._renderMatches(this.matches));
        }
      }
      var nS = new WeakMap(),
        iS = new WeakMap(),
        ef = new WeakMap(),
        xo = new WeakMap(),
        _W = new WeakSet();
      class Tt {
        constructor({
          pdfPage: e,
          highlighter: t = null,
          accessibilityManager: i = null,
          enablePermissions: r = !1,
          onAppend: s = null,
        }) {
          S(this, _W),
            v(this, nS, { writable: !0, value: !1 }),
            v(this, iS, { writable: !0, value: null }),
            v(this, ef, { writable: !0, value: !1 }),
            v(this, xo, { writable: !0, value: null }),
            (this.pdfPage = e),
            (this.highlighter = t),
            (this.accessibilityManager = i),
            _(this, nS, !0 === r),
            _(this, iS, s),
            (this.div = document.createElement('div')),
            (this.div.tabIndex = 0),
            (this.div.className = 'textLayer');
        }
        render(e, t = null) {
          var i = this;
          return U(function* () {
            if (d(i, ef) && d(i, xo))
              return (
                d(i, xo).update({ viewport: e, onBefore: i.hide.bind(i) }),
                void i.show()
              );
            i.cancel(),
              _(
                i,
                xo,
                new xae({
                  textContentSource: i.pdfPage.streamTextContent(
                    t || { includeMarkedContent: !0, disableNormalization: !0 }
                  ),
                  container: i.div,
                  viewport: e,
                })
              );
            const { textDivs: r, textContentItemsStr: s } = d(i, xo);
            i.highlighter?.setTextMapping(r, s),
              i.accessibilityManager?.setTextMapping(r),
              yield d(i, xo).render(),
              _(i, ef, !0);
            const o = document.createElement('div');
            (o.className = 'endOfContent'),
              i.div.append(o),
              b(i, _W, Nle).call(i, o),
              d(i, iS)?.call(i, i.div),
              i.highlighter?.enable(),
              i.accessibilityManager?.enable();
          })();
        }
        hide() {
          !this.div.hidden &&
            d(this, ef) &&
            (this.highlighter?.disable(), (this.div.hidden = !0));
        }
        show() {
          this.div.hidden &&
            d(this, ef) &&
            ((this.div.hidden = !1), this.highlighter?.enable());
        }
        cancel() {
          d(this, xo)?.cancel(),
            _(this, xo, null),
            this.highlighter?.disable(),
            this.accessibilityManager?.disable(),
            we(Tt, Tt, Vle).call(Tt, this.div);
        }
      }
      function Nle(n) {
        const { div: e } = this;
        e.addEventListener('mousedown', (t) => {
          n.classList.add('active');
        }),
          e.addEventListener('copy', (t) => {
            if (!d(this, nS)) {
              const i = document.getSelection();
              t.clipboardData.setData('text/plain', W_(Eae(i.toString())));
            }
            t.preventDefault(), t.stopPropagation();
          }),
          de(Tt, Tt, Os).set(e, n),
          we(Tt, Tt, Ble).call(Tt);
      }
      function Vle(n) {
        de(this, Tt, Os).delete(n),
          0 === de(this, Tt, Os).size &&
            (de(this, Tt, tf)?.abort(), pa(this, Tt, tf, null));
      }
      function Ble() {
        if (de(this, Tt, tf)) return;
        pa(this, Tt, tf, new AbortController());
        const { signal: n } = de(this, Tt, tf),
          e = (r, s) => {
            s.append(r),
              (r.style.width = ''),
              (r.style.height = ''),
              r.classList.remove('active');
          };
        var t, i;
        document.addEventListener(
          'pointerup',
          () => {
            de(this, Tt, Os).forEach(e);
          },
          { signal: n }
        ),
          document.addEventListener(
            'selectionchange',
            () => {
              const r = document.getSelection();
              if (0 === r.rangeCount) return void de(this, Tt, Os).forEach(e);
              const s = new Set();
              for (let h = 0; h < r.rangeCount; h++) {
                const f = r.getRangeAt(h);
                for (const p of de(this, Tt, Os).keys())
                  !s.has(p) && f.intersectsNode(p) && s.add(p);
              }
              for (const [h, f] of de(this, Tt, Os))
                s.has(h) ? f.classList.add('active') : e(f, h);
              if (
                ((t ??=
                  'none' ===
                  getComputedStyle(
                    de(this, Tt, Os).values().next().value
                  ).getPropertyValue('-moz-user-select')),
                t)
              )
                return;
              const o = r.getRangeAt(0),
                a =
                  i &&
                  (0 === o.compareBoundaryPoints(Range.END_TO_END, i) ||
                    0 === o.compareBoundaryPoints(Range.START_TO_END, i));
              let l = a ? o.startContainer : o.endContainer;
              l.nodeType === Node.TEXT_NODE && (l = l.parentNode);
              const c = l.parentElement.closest('.textLayer'),
                u = de(this, Tt, Os).get(c);
              u &&
                ((u.style.width = c.style.width),
                (u.style.height = c.style.height),
                l.parentElement.insertBefore(u, a ? l : l.nextSibling)),
                (i = o.cloneRange());
            },
            { signal: n }
          );
      }
      var Os = { writable: !0, value: new Map() },
        tf = { writable: !0, value: null };
      class bW {
        constructor({
          pdfPage: e,
          annotationStorage: t = null,
          linkService: i,
          xfaHtml: r = null,
        }) {
          (this.pdfPage = e),
            (this.annotationStorage = t),
            (this.linkService = i),
            (this.xfaHtml = r),
            (this.div = null),
            (this._cancelled = !1);
        }
        render(e, t = 'display') {
          var i = this;
          return U(function* () {
            if ('print' === t) {
              const o = {
                viewport: e.clone({ dontFlip: !0 }),
                div: i.div,
                xfaHtml: i.xfaHtml,
                annotationStorage: i.annotationStorage,
                linkService: i.linkService,
                intent: t,
              };
              return (
                (i.div = document.createElement('div')),
                (o.div = i.div),
                MA.render(o)
              );
            }
            const r = yield i.pdfPage.getXfa();
            if (i._cancelled || !r) return { textDivs: [] };
            const s = {
              viewport: e.clone({ dontFlip: !0 }),
              div: i.div,
              xfaHtml: r,
              annotationStorage: i.annotationStorage,
              linkService: i.linkService,
              intent: t,
            };
            return i.div
              ? MA.update(s)
              : ((i.div = document.createElement('div')),
                (s.div = i.div),
                MA.render(s));
          })();
        }
        cancel() {
          this._cancelled = !0;
        }
        hide() {
          this.div && (this.div.hidden = !0);
        }
      }
      const Hle = {
          annotationEditorUIManager: null,
          annotationStorage: null,
          downloadManager: null,
          enableScripting: !1,
          fieldObjectsPromise: null,
          findController: null,
          hasJSActionsPromise: null,
          get linkService() {
            return new AA();
          },
        },
        Wle = new Map([
          ['canvasWrapper', 0],
          ['textLayer', 1],
          ['annotationLayer', 2],
          ['annotationEditorLayer', 3],
          ['xfaLayer', 3],
        ]);
      var nf = new WeakMap(),
        rS = new WeakMap(),
        rf = new WeakMap(),
        sS = new WeakMap(),
        Bc = new WeakMap(),
        Hc = new WeakMap(),
        oS = new WeakMap(),
        sf = new WeakMap(),
        db = new WeakMap(),
        ub = new WeakMap(),
        za = new WeakMap(),
        af = new WeakMap(),
        Wc = new WeakMap(),
        jc = new WeakSet(),
        hb = new WeakSet(),
        lf = new WeakSet(),
        aS = new WeakSet(),
        lS = new WeakSet(),
        cS = new WeakSet(),
        dS = new WeakSet(),
        uS = new WeakSet(),
        vW = new WeakSet(),
        yW = new WeakSet(),
        hS = new WeakSet();
      class wW {
        constructor(e) {
          S(this, hS),
            S(this, yW),
            S(this, vW),
            S(this, uS),
            S(this, dS),
            S(this, cS),
            S(this, lS),
            S(this, aS),
            S(this, lf),
            S(this, hb),
            S(this, jc),
            v(this, nf, { writable: !0, value: ks.ENABLE_FORMS }),
            v(this, rS, { writable: !0, value: !1 }),
            v(this, rf, { writable: !0, value: !1 }),
            v(this, sS, { writable: !0, value: !1 }),
            v(this, Bc, { writable: !0, value: null }),
            v(this, Hc, { writable: !0, value: null }),
            v(this, oS, { writable: !0, value: null }),
            v(this, sf, { writable: !0, value: null }),
            v(this, db, { writable: !0, value: Bt.INITIAL }),
            v(this, ub, { writable: !0, value: 1 }),
            v(this, za, {
              writable: !0,
              value: {
                directDrawing: !0,
                initialOptionalContent: !0,
                regularAnnotations: !0,
              },
            }),
            v(this, af, { writable: !0, value: new WeakMap() }),
            v(this, Wc, { writable: !0, value: [null, null, null, null] });
          const t = e.container,
            i = e.defaultViewport;
          (this.id = e.id),
            (this.renderingId = 'page' + this.id),
            _(this, Bc, e.layerProperties || Hle),
            (this.pdfPage = null),
            (this.pageLabel = null),
            (this.rotation = 0),
            (this.scale = e.scale || 1),
            (this.viewport = i),
            (this.pdfPageRotate = i.rotation),
            (this._optionalContentConfigPromise =
              e.optionalContentConfigPromise || null),
            _(this, ub, e.textLayerMode ?? 1),
            _(this, nf, e.annotationMode ?? ks.ENABLE_FORMS),
            (this.imageResourcesPath = e.imageResourcesPath || ''),
            (this.maxCanvasPixels =
              e.maxCanvasPixels ?? ZA.get('maxCanvasPixels')),
            (this.pageColors = e.pageColors || null),
            _(this, rS, e.enableHWA || !1),
            (this.eventBus = e.eventBus),
            (this.renderingQueue = e.renderingQueue),
            (this.l10n = e.l10n),
            (this.l10n ||= new Zn()),
            (this.renderTask = null),
            (this.resume = null),
            (this._isStandalone = !this.renderingQueue?.hasViewer()),
            (this._container = t),
            (this._annotationCanvasMap = null),
            (this.annotationLayer = null),
            (this.annotationEditorLayer = null),
            (this.textLayer = null),
            (this.zoomLayer = null),
            (this.xfaLayer = null),
            (this.structTreeLayer = null),
            (this.drawLayer = null);
          const r = document.createElement('div');
          if (
            ((r.className = 'page'),
            r.setAttribute('data-page-number', this.id),
            r.setAttribute('role', 'region'),
            r.setAttribute('data-l10n-id', 'pdfjs-page-landmark'),
            r.setAttribute('data-l10n-args', JSON.stringify({ page: this.id })),
            (this.div = r),
            b(this, hb, fS).call(this),
            t?.append(r),
            this._isStandalone)
          ) {
            t?.style.setProperty(
              '--scale-factor',
              this.scale * Ps.PDF_TO_CSS_UNITS
            );
            const { optionalContentConfigPromise: s } = e;
            s &&
              s.then((o) => {
                s === this._optionalContentConfigPromise &&
                  (d(this, za).initialOptionalContent = o.hasInitialVisibility);
              }),
              e.l10n || this.l10n.translate(this.div);
          }
        }
        get renderingState() {
          return d(this, db);
        }
        set renderingState(e) {
          if (e !== d(this, db))
            switch (
              (_(this, db, e),
              d(this, Hc) && (clearTimeout(d(this, Hc)), _(this, Hc, null)),
              e)
            ) {
              case Bt.PAUSED:
                this.div.classList.remove('loading');
                break;
              case Bt.RUNNING:
                this.div.classList.add('loadingIcon'),
                  _(
                    this,
                    Hc,
                    setTimeout(() => {
                      this.div.classList.add('loading'), _(this, Hc, null);
                    }, 0)
                  );
                break;
              case Bt.INITIAL:
              case Bt.FINISHED:
                this.div.classList.remove('loadingIcon', 'loading');
            }
        }
        setPdfPage(e) {
          this._isStandalone &&
            ('CanvasText' === this.pageColors?.foreground ||
              'Canvas' === this.pageColors?.background) &&
            (this._container?.style.setProperty(
              '--hcm-highlight-filter',
              e.filterFactory.addHighlightHCMFilter(
                'highlight',
                'CanvasText',
                'Canvas',
                'HighlightText',
                'Highlight'
              )
            ),
            this._container?.style.setProperty(
              '--hcm-highlight-selected-filter',
              e.filterFactory.addHighlightHCMFilter(
                'highlight_selected',
                'CanvasText',
                'Canvas',
                'HighlightText',
                'Highlight'
              )
            )),
            (this.pdfPage = e),
            (this.pdfPageRotate = e.rotate),
            (this.viewport = e.getViewport({
              scale: this.scale * Ps.PDF_TO_CSS_UNITS,
              rotation: (this.rotation + this.pdfPageRotate) % 360,
            })),
            b(this, hb, fS).call(this),
            this.reset();
        }
        destroy() {
          this.reset(), this.pdfPage?.cleanup();
        }
        hasEditableAnnotations() {
          return !!this.annotationLayer?.hasEditableAnnotations();
        }
        get _textHighlighter() {
          return Z_(
            this,
            '_textHighlighter',
            new Lle({
              pageIndex: this.id - 1,
              eventBus: this.eventBus,
              findController: d(this, Bc).findController,
            })
          );
        }
        _resetZoomLayer(e = !1) {
          if (!this.zoomLayer) return;
          const t = this.zoomLayer.firstChild;
          d(this, af).delete(t),
            (t.width = 0),
            (t.height = 0),
            e && this.zoomLayer.remove(),
            (this.zoomLayer = null);
        }
        reset({
          keepZoomLayer: e = !1,
          keepAnnotationLayer: t = !1,
          keepAnnotationEditorLayer: i = !1,
          keepXfaLayer: r = !1,
          keepTextLayer: s = !1,
        } = {}) {
          this.cancelRendering({
            keepAnnotationLayer: t,
            keepAnnotationEditorLayer: i,
            keepXfaLayer: r,
            keepTextLayer: s,
          }),
            (this.renderingState = Bt.INITIAL);
          const o = this.div,
            a = o.childNodes,
            l = (e && this.zoomLayer) || null,
            c = (t && this.annotationLayer?.div) || null,
            u = (i && this.annotationEditorLayer?.div) || null,
            h = (r && this.xfaLayer?.div) || null,
            f = (s && this.textLayer?.div) || null;
          for (let p = a.length - 1; p >= 0; p--) {
            const m = a[p];
            switch (m) {
              case l:
              case c:
              case u:
              case h:
              case f:
                continue;
            }
            m.remove();
            const g = d(this, Wc).indexOf(m);
            g >= 0 && (d(this, Wc)[g] = null);
          }
          o.removeAttribute('data-loaded'),
            c && this.annotationLayer.hide(),
            u && this.annotationEditorLayer.hide(),
            h && this.xfaLayer.hide(),
            f && this.textLayer.hide(),
            this.structTreeLayer?.hide(),
            l ||
              (this.canvas &&
                (d(this, af).delete(this.canvas),
                (this.canvas.width = 0),
                (this.canvas.height = 0),
                delete this.canvas),
              this._resetZoomLayer());
        }
        toggleEditingMode(e) {
          this.hasEditableAnnotations() &&
            (_(this, sS, e),
            this.reset({
              keepZoomLayer: !0,
              keepAnnotationLayer: !0,
              keepAnnotationEditorLayer: !0,
              keepXfaLayer: !0,
              keepTextLayer: !0,
            }));
        }
        update({
          scale: e = 0,
          rotation: t = null,
          optionalContentConfigPromise: i = null,
          drawingDelay: r = -1,
        }) {
          if (
            ((this.scale = e || this.scale),
            'number' == typeof t && (this.rotation = t),
            i instanceof Promise &&
              ((this._optionalContentConfigPromise = i),
              i.then((o) => {
                i === this._optionalContentConfigPromise &&
                  (d(this, za).initialOptionalContent = o.hasInitialVisibility);
              })),
            (d(this, za).directDrawing = !0),
            (this.viewport = this.viewport.clone({
              scale: this.scale * Ps.PDF_TO_CSS_UNITS,
              rotation: (this.rotation + this.pdfPageRotate) % 360,
            })),
            b(this, hb, fS).call(this),
            this._isStandalone &&
              this._container?.style.setProperty(
                '--scale-factor',
                this.viewport.scale
              ),
            this.canvas)
          ) {
            let o = !1;
            if (d(this, rf))
              if (0 === this.maxCanvasPixels) o = !0;
              else if (this.maxCanvasPixels > 0) {
                const { width: l, height: c } = this.viewport,
                  { sx: u, sy: h } = this.outputScale;
                o =
                  ((Math.floor(l) * u) | 0) * ((Math.floor(c) * h) | 0) >
                  this.maxCanvasPixels;
              }
            const a = r >= 0 && r < 1e3;
            if (a || o) {
              if (
                (a &&
                  !o &&
                  this.renderingState !== Bt.FINISHED &&
                  (this.cancelRendering({
                    keepZoomLayer: !0,
                    keepAnnotationLayer: !0,
                    keepAnnotationEditorLayer: !0,
                    keepXfaLayer: !0,
                    keepTextLayer: !0,
                    cancelExtraDelay: r,
                  }),
                  (this.renderingState = Bt.FINISHED),
                  (d(this, za).directDrawing = !1)),
                this.cssTransform({
                  target: this.canvas,
                  redrawAnnotationLayer: !0,
                  redrawAnnotationEditorLayer: !0,
                  redrawXfaLayer: !0,
                  redrawTextLayer: !a,
                  hideTextLayer: a,
                }),
                a)
              )
                return;
              return void this.eventBus.dispatch('pagerendered', {
                source: this,
                pageNumber: this.id,
                cssTransform: !0,
                timestamp: performance.now(),
                error: d(this, sf),
              });
            }
            !this.zoomLayer &&
              !this.canvas.hidden &&
              ((this.zoomLayer = this.canvas.parentNode),
              (this.zoomLayer.style.position = 'absolute'));
          }
          this.zoomLayer &&
            this.cssTransform({ target: this.zoomLayer.firstChild }),
            this.reset({
              keepZoomLayer: !0,
              keepAnnotationLayer: !0,
              keepAnnotationEditorLayer: !0,
              keepXfaLayer: !0,
              keepTextLayer: !0,
            });
        }
        cancelRendering({
          keepAnnotationLayer: e = !1,
          keepAnnotationEditorLayer: t = !1,
          keepXfaLayer: i = !1,
          keepTextLayer: r = !1,
          cancelExtraDelay: s = 0,
        } = {}) {
          this.renderTask &&
            (this.renderTask.cancel(s), (this.renderTask = null)),
            (this.resume = null),
            this.textLayer &&
              (!r || !this.textLayer.div) &&
              (this.textLayer.cancel(), (this.textLayer = null)),
            this.structTreeLayer &&
              !this.textLayer &&
              (this.structTreeLayer = null),
            this.annotationLayer &&
              (!e || !this.annotationLayer.div) &&
              (this.annotationLayer.cancel(),
              (this.annotationLayer = null),
              (this._annotationCanvasMap = null)),
            this.annotationEditorLayer &&
              (!t || !this.annotationEditorLayer.div) &&
              (this.drawLayer &&
                (this.drawLayer.cancel(), (this.drawLayer = null)),
              this.annotationEditorLayer.cancel(),
              (this.annotationEditorLayer = null)),
            this.xfaLayer &&
              (!i || !this.xfaLayer.div) &&
              (this.xfaLayer.cancel(),
              (this.xfaLayer = null),
              this._textHighlighter?.disable());
        }
        cssTransform({
          target: e,
          redrawAnnotationLayer: t = !1,
          redrawAnnotationEditorLayer: i = !1,
          redrawXfaLayer: r = !1,
          redrawTextLayer: s = !1,
          hideTextLayer: o = !1,
        }) {
          if (!e.hasAttribute('zooming')) {
            e.setAttribute('zooming', !0);
            const { style: l } = e;
            l.width = l.height = '';
          }
          const a = d(this, af).get(e);
          if (this.viewport !== a) {
            const l = this.viewport.rotation - a.rotation,
              c = Math.abs(l);
            let u = 1,
              h = 1;
            if (90 === c || 270 === c) {
              const { width: f, height: p } = this.viewport;
              (u = p / f), (h = f / p);
            }
            e.style.transform = `rotate(${l}deg) scale(${u}, ${h})`;
          }
          t && this.annotationLayer && b(this, aS, EW).call(this),
            i &&
              this.annotationEditorLayer &&
              (this.drawLayer && b(this, cS, xW).call(this),
              b(this, lS, CW).call(this)),
            r && this.xfaLayer && b(this, dS, AW).call(this),
            this.textLayer &&
              (o
                ? (this.textLayer.hide(), this.structTreeLayer?.hide())
                : s && b(this, uS, SW).call(this));
        }
        get width() {
          return this.viewport.width;
        }
        get height() {
          return this.viewport.height;
        }
        getPagePoint(e, t) {
          return this.viewport.convertToPdfPoint(e, t);
        }
        draw() {
          var e = this;
          return U(function* () {
            e.renderingState !== Bt.INITIAL &&
              (console.error('Must be in new state before drawing'), e.reset());
            const {
              div: t,
              l10n: i,
              pageColors: r,
              pdfPage: s,
              viewport: o,
            } = e;
            if (!s)
              throw (
                ((e.renderingState = Bt.FINISHED),
                new Error('pdfPage is not loaded'))
              );
            e.renderingState = Bt.RUNNING;
            const a = document.createElement('div');
            if (
              (a.classList.add('canvasWrapper'),
              b(e, jc, cf).call(e, a, 'canvasWrapper'),
              !e.textLayer &&
                0 !== d(e, ub) &&
                !s.isPureXfa &&
                ((e._accessibilityManager ||= new Qr()),
                (e.textLayer = new Tt({
                  pdfPage: s,
                  highlighter: e._textHighlighter,
                  accessibilityManager: e._accessibilityManager,
                  enablePermissions: 2 === d(e, ub),
                  onAppend: (P) => {
                    e.l10n.pause(),
                      b(e, jc, cf).call(e, P, 'textLayer'),
                      e.l10n.resume();
                  },
                }))),
              !e.annotationLayer && d(e, nf) !== ks.DISABLE)
            ) {
              const {
                annotationStorage: P,
                annotationEditorUIManager: O,
                downloadManager: I,
                enableScripting: C,
                fieldObjectsPromise: R,
                hasJSActionsPromise: $,
                linkService: q,
              } = d(e, Bc);
              (e._annotationCanvasMap ||= new Map()),
                (e.annotationLayer = new PH({
                  pdfPage: s,
                  annotationStorage: P,
                  imageResourcesPath: e.imageResourcesPath,
                  renderForms: d(e, nf) === ks.ENABLE_FORMS,
                  linkService: q,
                  downloadManager: I,
                  enableScripting: C,
                  hasJSActionsPromise: $,
                  fieldObjectsPromise: R,
                  annotationCanvasMap: e._annotationCanvasMap,
                  accessibilityManager: e._accessibilityManager,
                  annotationEditorUIManager: O,
                  onAppend: (oe) => {
                    b(e, jc, cf).call(e, oe, 'annotationLayer');
                  },
                }));
            }
            const { width: c, height: u } = o,
              h = document.createElement('canvas');
            h.setAttribute('role', 'presentation'), (h.hidden = !0);
            const f = !(!r?.background || !r?.foreground);
            let p = (P) => {
              (!f || P) && ((h.hidden = !1), (p = null));
            };
            a.append(h), (e.canvas = h);
            const m = h.getContext('2d', {
                alpha: !1,
                willReadFrequently: !d(e, rS),
              }),
              g = (e.outputScale = new xoe());
            if (0 === e.maxCanvasPixels) {
              const P = 1 / e.scale;
              (g.sx *= P), (g.sy *= P), _(e, rf, !0);
            } else if (e.maxCanvasPixels > 0) {
              const O = Math.sqrt(e.maxCanvasPixels / (c * u));
              g.sx > O || g.sy > O
                ? ((g.sx = O), (g.sy = O), _(e, rf, !0))
                : _(e, rf, !1);
            }
            const w = aH(g.sx),
              y = aH(g.sy);
            (h.width = j_(c * g.sx, w[0])), (h.height = j_(u * g.sy, y[0]));
            const { style: E } = h;
            (E.width = j_(c, w[1]) + 'px'),
              (E.height = j_(u, y[1]) + 'px'),
              d(e, af).set(h, o);
            const M = {
                canvasContext: m,
                transform: g.scaled ? [g.sx, 0, 0, g.sy, 0, 0] : null,
                viewport: o,
                annotationMode: d(e, nf),
                optionalContentConfigPromise: e._optionalContentConfigPromise,
                annotationCanvasMap: e._annotationCanvasMap,
                pageColors: r,
                isEditing: d(e, sS),
              },
              T = (e.renderTask = s.render(M));
            T.onContinue = (P) => {
              if (
                (p?.(!1),
                e.renderingQueue && !e.renderingQueue.isHighestPriority(e))
              )
                return (
                  (e.renderingState = Bt.PAUSED),
                  void (e.resume = () => {
                    (e.renderingState = Bt.RUNNING), P();
                  })
                );
              P();
            };
            const k = T.promise.then(
              U(function* () {
                p?.(!0),
                  yield b(e, hS, MW).call(e, T),
                  b(e, uS, SW).call(e),
                  e.annotationLayer && (yield b(e, aS, EW).call(e));
                const { annotationEditorUIManager: P } = d(e, Bc);
                P &&
                  ((e.drawLayer ||= new Fle({ pageIndex: e.id })),
                  yield b(e, cS, xW).call(e),
                  e.drawLayer.setParent(a),
                  e.annotationEditorLayer ||
                    (e.annotationEditorLayer = new Rle({
                      uiManager: P,
                      pdfPage: s,
                      l10n: i,
                      accessibilityManager: e._accessibilityManager,
                      annotationLayer: e.annotationLayer?.annotationLayer,
                      textLayer: e.textLayer,
                      drawLayer: e.drawLayer.getDrawLayer(),
                      onAppend: (O) => {
                        b(e, jc, cf).call(e, O, 'annotationEditorLayer');
                      },
                    })),
                  b(e, lS, CW).call(e));
              }),
              (P) => (P instanceof SA || p?.(!0), b(e, hS, MW).call(e, T, P))
            );
            if (s.isPureXfa) {
              if (!e.xfaLayer) {
                const { annotationStorage: P, linkService: O } = d(e, Bc);
                e.xfaLayer = new bW({
                  pdfPage: s,
                  annotationStorage: P,
                  linkService: O,
                });
              }
              b(e, dS, AW).call(e);
            }
            return (
              t.setAttribute('data-loaded', !0),
              e.eventBus.dispatch('pagerender', {
                source: e,
                pageNumber: e.id,
              }),
              k
            );
          })();
        }
        setPageLabel(e) {
          (this.pageLabel = 'string' == typeof e ? e : null),
            this.div.setAttribute(
              'data-l10n-args',
              JSON.stringify({ page: this.pageLabel ?? this.id })
            ),
            null !== this.pageLabel
              ? this.div.setAttribute('data-page-label', this.pageLabel)
              : this.div.removeAttribute('data-page-label');
        }
        get thumbnailCanvas() {
          const {
            directDrawing: e,
            initialOptionalContent: t,
            regularAnnotations: i,
          } = d(this, za);
          return e && t && i ? this.canvas : null;
        }
      }
      function cf(n, e) {
        const t = Wle.get(e),
          i = d(this, Wc)[t];
        if (((d(this, Wc)[t] = n), i)) i.replaceWith(n);
        else {
          for (let r = t - 1; r >= 0; r--) {
            const s = d(this, Wc)[r];
            if (s) return void s.after(n);
          }
          this.div.prepend(n);
        }
      }
      function fS() {
        const { viewport: n } = this;
        if (this.pdfPage) {
          if (d(this, oS) === n.rotation) return;
          _(this, oS, n.rotation);
        }
        Cae(this.div, n, !0, !1);
      }
      function fb(n, e) {
        this.eventBus.dispatch(n, {
          source: this,
          pageNumber: this.id,
          error: e,
        });
      }
      function EW() {
        return pS.apply(this, arguments);
      }
      function pS() {
        return (pS = U(function* () {
          let n = null;
          try {
            yield this.annotationLayer.render(this.viewport, 'display');
          } catch (e) {
            console.error(`#renderAnnotationLayer: "${e}".`), (n = e);
          } finally {
            b(this, lf, fb).call(this, 'annotationlayerrendered', n);
          }
        })).apply(this, arguments);
      }
      function CW() {
        return mS.apply(this, arguments);
      }
      function mS() {
        return (mS = U(function* () {
          let n = null;
          try {
            yield this.annotationEditorLayer.render(this.viewport, 'display');
          } catch (e) {
            console.error(`#renderAnnotationEditorLayer: "${e}".`), (n = e);
          } finally {
            b(this, lf, fb).call(this, 'annotationeditorlayerrendered', n);
          }
        })).apply(this, arguments);
      }
      function xW() {
        return gS.apply(this, arguments);
      }
      function gS() {
        return (gS = U(function* () {
          try {
            yield this.drawLayer.render('display');
          } catch (n) {
            console.error(`#renderDrawLayer: "${n}".`);
          }
        })).apply(this, arguments);
      }
      function AW() {
        return _S.apply(this, arguments);
      }
      function _S() {
        return (_S = U(function* () {
          let n = null;
          try {
            const e = yield this.xfaLayer.render(this.viewport, 'display');
            e?.textDivs &&
              this._textHighlighter &&
              b(this, yW, zle).call(this, e.textDivs);
          } catch (e) {
            console.error(`#renderXfaLayer: "${e}".`), (n = e);
          } finally {
            this.xfaLayer?.div &&
              (this.l10n.pause(),
              b(this, jc, cf).call(this, this.xfaLayer.div, 'xfaLayer'),
              this.l10n.resume()),
              b(this, lf, fb).call(this, 'xfalayerrendered', n);
          }
        })).apply(this, arguments);
      }
      function SW() {
        return bS.apply(this, arguments);
      }
      function bS() {
        return (bS = U(function* () {
          if (!this.textLayer) return;
          let n = null;
          try {
            yield this.textLayer.render(this.viewport);
          } catch (e) {
            if (e instanceof pae) return;
            console.error(`#renderTextLayer: "${e}".`), (n = e);
          }
          b(this, lf, fb).call(this, 'textlayerrendered', n),
            b(this, vW, jle).call(this);
        })).apply(this, arguments);
      }
      function jle() {
        return vS.apply(this, arguments);
      }
      function vS() {
        return (vS = U(function* () {
          if (!this.textLayer) return;
          this.structTreeLayer ||= new fW();
          const n = yield this.structTreeLayer.renderingDone
              ? null
              : this.pdfPage.getStructTree(),
            e = this.structTreeLayer?.render(n);
          e && (this.l10n.pause(), this.canvas?.append(e), this.l10n.resume()),
            this.structTreeLayer?.show();
        })).apply(this, arguments);
      }
      function zle(n) {
        return yS.apply(this, arguments);
      }
      function yS() {
        return (yS = U(function* (n) {
          const e = yield this.pdfPage.getTextContent(),
            t = [];
          for (const i of e.items) t.push(i.str);
          this._textHighlighter.setTextMapping(n, t),
            this._textHighlighter.enable();
        })).apply(this, arguments);
      }
      function MW(n) {
        return wS.apply(this, arguments);
      }
      function wS() {
        return (wS = U(function* (n, e = null) {
          if (
            (n === this.renderTask && (this.renderTask = null), e instanceof SA)
          )
            _(this, sf, null);
          else if (
            (_(this, sf, e),
            (this.renderingState = Bt.FINISHED),
            this._resetZoomLayer(!0),
            (d(this, za).regularAnnotations = !n.separateAnnots),
            this.eventBus.dispatch('pagerendered', {
              source: this,
              pageNumber: this.id,
              cssTransform: !1,
              timestamp: performance.now(),
              error: d(this, sf),
            }),
            e)
          )
            throw e;
        })).apply(this, arguments);
      }
      function ES() {
        return (ES = U(function* (n) {
          const t = ''.split('#', 1)[0];
          let {
            info: i,
            metadata: r,
            contentDispositionFilename: s,
            contentLength: o,
          } = yield n.getMetadata();
          if (!o) {
            const { length: a } = yield n.getDownloadInfo();
            o = a;
          }
          return {
            ...i,
            baseURL: t,
            filesize: o,
            filename: s || yae(''),
            metadata: r?.getRaw(),
            authors: r?.get('dc:creator'),
            numPages: n.numPages,
            URL: '',
          };
        })).apply(this, arguments);
      }
      class $le {
        constructor(e) {
          this._ready = new Promise((t, i) => {
            import(e)
              .then((s) => {
                t(s.QuickJSSandbox());
              })
              .catch(i);
          });
        }
        createSandbox(e) {
          var t = this;
          return U(function* () {
            (yield t._ready).create(e);
          })();
        }
        dispatchEventInSandbox(e) {
          var t = this;
          return U(function* () {
            const i = yield t._ready;
            setTimeout(() => i.dispatchEvent(e), 0);
          })();
        }
        destroySandbox() {
          var e = this;
          return U(function* () {
            (yield e._ready).nukeSandbox();
          })();
        }
      }
      var Ao = new WeakMap(),
        df = new WeakMap(),
        CS = new WeakMap(),
        uf = new WeakMap(),
        hf = new WeakMap(),
        xS = new WeakMap(),
        Bi = new WeakMap(),
        Ua = new WeakMap(),
        pb = new WeakMap(),
        An = new WeakMap(),
        Jr = new WeakMap(),
        DW = new WeakSet(),
        mb = new WeakSet(),
        AS = new WeakSet(),
        TW = new WeakSet(),
        ff = new WeakSet();
      class Gle {
        constructor({
          eventBus: e,
          externalServices: t = null,
          docProperties: i = null,
        }) {
          S(this, ff),
            S(this, TW),
            S(this, AS),
            S(this, mb),
            S(this, DW),
            v(this, Ao, { writable: !0, value: null }),
            v(this, df, { writable: !0, value: null }),
            v(this, CS, { writable: !0, value: null }),
            v(this, uf, { writable: !0, value: null }),
            v(this, hf, { writable: !0, value: null }),
            v(this, xS, { writable: !0, value: null }),
            v(this, Bi, { writable: !0, value: null }),
            v(this, Ua, { writable: !0, value: null }),
            v(this, pb, { writable: !0, value: !1 }),
            v(this, An, { writable: !0, value: null }),
            v(this, Jr, { writable: !0, value: null }),
            _(this, hf, e),
            _(this, xS, t),
            _(this, CS, i);
        }
        setViewer(e) {
          _(this, Ua, e);
        }
        setDocument(e) {
          var t = this;
          return U(function* () {
            if ((d(t, Bi) && (yield b(t, ff, gb).call(t)), _(t, Bi, e), !e))
              return;
            const [i, r, s] = yield Promise.all([
              e.getFieldObjects(),
              e.getCalculationOrderIds(),
              e.getJSActions(),
            ]);
            if (!i && !s) return void (yield b(t, ff, gb).call(t));
            if (e !== d(t, Bi)) return;
            try {
              _(t, An, b(t, TW, Xle).call(t));
            } catch (l) {
              return (
                console.error(`setDocument: "${l.message}".`),
                void (yield b(t, ff, gb).call(t))
              );
            }
            const o = d(t, hf);
            _(t, uf, new AbortController());
            const { signal: a } = d(t, uf);
            o._on(
              'updatefromsandbox',
              (l) => {
                l?.source === window && b(t, DW, qle).call(t, l.detail);
              },
              { signal: a }
            ),
              o._on(
                'dispatcheventinsandbox',
                (l) => {
                  d(t, An)?.dispatchEventInSandbox(l.detail);
                },
                { signal: a }
              ),
              o._on(
                'pagechanging',
                ({ pageNumber: l, previous: c }) => {
                  l !== c && (b(t, AS, IW).call(t, c), b(t, mb, MS).call(t, l));
                },
                { signal: a }
              ),
              o._on(
                'pagerendered',
                ({ pageNumber: l }) => {
                  t._pageOpenPending.has(l) &&
                    l === d(t, Ua).currentPageNumber &&
                    b(t, mb, MS).call(t, l);
                },
                { signal: a }
              ),
              o._on(
                'pagesdestroy',
                U(function* () {
                  yield b(t, AS, IW).call(t, d(t, Ua).currentPageNumber),
                    yield d(t, An)?.dispatchEventInSandbox({
                      id: 'doc',
                      name: 'WillClose',
                    }),
                    d(t, Ao)?.resolve();
                }),
                { signal: a }
              );
            try {
              const l = yield d(t, CS).call(t, e);
              if (e !== d(t, Bi)) return;
              yield d(t, An).createSandbox({
                objects: i,
                calculationOrder: r,
                appInfo: {
                  platform: navigator.platform,
                  language: navigator.language,
                },
                docInfo: { ...l, actions: s },
              }),
                o.dispatch('sandboxcreated', { source: t });
            } catch (l) {
              return (
                console.error(`setDocument: "${l.message}".`),
                void (yield b(t, ff, gb).call(t))
              );
            }
            yield d(t, An)?.dispatchEventInSandbox({ id: 'doc', name: 'Open' }),
              yield b(t, mb, MS).call(t, d(t, Ua).currentPageNumber, !0),
              Promise.resolve().then(() => {
                e === d(t, Bi) && _(t, pb, !0);
              });
          })();
        }
        dispatchWillSave() {
          var e = this;
          return U(function* () {
            return d(e, An)?.dispatchEventInSandbox({
              id: 'doc',
              name: 'WillSave',
            });
          })();
        }
        dispatchDidSave() {
          var e = this;
          return U(function* () {
            return d(e, An)?.dispatchEventInSandbox({
              id: 'doc',
              name: 'DidSave',
            });
          })();
        }
        dispatchWillPrint() {
          var e = this;
          return U(function* () {
            if (d(e, An)) {
              yield d(e, Jr)?.promise, _(e, Jr, Promise.withResolvers());
              try {
                yield d(e, An).dispatchEventInSandbox({
                  id: 'doc',
                  name: 'WillPrint',
                });
              } catch (t) {
                throw (d(e, Jr).resolve(), _(e, Jr, null), t);
              }
              yield d(e, Jr).promise;
            }
          })();
        }
        dispatchDidPrint() {
          var e = this;
          return U(function* () {
            return d(e, An)?.dispatchEventInSandbox({
              id: 'doc',
              name: 'DidPrint',
            });
          })();
        }
        get destroyPromise() {
          return d(this, df)?.promise || null;
        }
        get ready() {
          return d(this, pb);
        }
        get _pageOpenPending() {
          return Z_(this, '_pageOpenPending', new Set());
        }
        get _visitedPages() {
          return Z_(this, '_visitedPages', new Map());
        }
      }
      function qle(n) {
        return SS.apply(this, arguments);
      }
      function SS() {
        return (SS = U(function* (n) {
          const e = d(this, Ua),
            t = e.isInPresentationMode || e.isChangingPresentationMode,
            { id: i, siblings: r, command: s, value: o } = n;
          if (!i) {
            switch (s) {
              case 'clear':
                console.clear();
                break;
              case 'error':
                console.error(o);
                break;
              case 'layout':
                if (!t) {
                  const l = (function Foe(n) {
                    let e = Ke.VERTICAL,
                      t = Ln.NONE;
                    switch (n) {
                      case 'SinglePage':
                        e = Ke.PAGE;
                        break;
                      case 'OneColumn':
                        break;
                      case 'TwoPageLeft':
                        e = Ke.PAGE;
                      case 'TwoColumnLeft':
                        t = Ln.ODD;
                        break;
                      case 'TwoPageRight':
                        e = Ke.PAGE;
                      case 'TwoColumnRight':
                        t = Ln.EVEN;
                    }
                    return { scrollMode: e, spreadMode: t };
                  })(o);
                  e.spreadMode = l.spreadMode;
                }
                break;
              case 'page-num':
                e.currentPageNumber = o + 1;
                break;
              case 'print':
                yield e.pagesPromise,
                  d(this, hf).dispatch('print', { source: this });
                break;
              case 'println':
                console.log(o);
                break;
              case 'zoom':
                t || (e.currentScaleValue = o);
                break;
              case 'SaveAs':
                d(this, hf).dispatch('download', { source: this });
                break;
              case 'FirstPage':
                e.currentPageNumber = 1;
                break;
              case 'LastPage':
                e.currentPageNumber = e.pagesCount;
                break;
              case 'NextPage':
                e.nextPage();
                break;
              case 'PrevPage':
                e.previousPage();
                break;
              case 'ZoomViewIn':
                t || e.increaseScale();
                break;
              case 'ZoomViewOut':
                t || e.decreaseScale();
                break;
              case 'WillPrintFinished':
                d(this, Jr)?.resolve(), _(this, Jr, null);
            }
            return;
          }
          if (t && n.focus) return;
          delete n.id, delete n.siblings;
          const a = r ? [i, ...r] : [i];
          for (const l of a) {
            const c = document.querySelector(`[data-element-id="${l}"]`);
            c
              ? c.dispatchEvent(
                  new CustomEvent('updatefromsandbox', { detail: n })
                )
              : d(this, Bi)?.annotationStorage.setValue(l, n);
          }
        })).apply(this, arguments);
      }
      function MS(n) {
        return DS.apply(this, arguments);
      }
      function DS() {
        return (DS = U(function* (n, e = !1) {
          var t = this;
          const i = d(this, Bi),
            r = this._visitedPages;
          if ((e && _(this, Ao, Promise.withResolvers()), !d(this, Ao))) return;
          const s = d(this, Ua).getPageView(n - 1);
          if (s?.renderingState !== Bt.FINISHED)
            return void this._pageOpenPending.add(n);
          this._pageOpenPending.delete(n);
          const o = U(function* () {
            const a = yield r.has(n) ? null : s.pdfPage?.getJSActions();
            i === d(t, Bi) &&
              (yield d(t, An)?.dispatchEventInSandbox({
                id: 'page',
                name: 'PageOpen',
                pageNumber: n,
                actions: a,
              }));
          })();
          r.set(n, o);
        })).apply(this, arguments);
      }
      function IW(n) {
        return TS.apply(this, arguments);
      }
      function TS() {
        return (TS = U(function* (n) {
          const e = d(this, Bi),
            t = this._visitedPages;
          if (!d(this, Ao) || this._pageOpenPending.has(n)) return;
          const i = t.get(n);
          i &&
            (t.set(n, null),
            yield i,
            e === d(this, Bi) &&
              (yield d(this, An)?.dispatchEventInSandbox({
                id: 'page',
                name: 'PageClose',
                pageNumber: n,
              })));
        })).apply(this, arguments);
      }
      function Xle() {
        if ((_(this, df, Promise.withResolvers()), d(this, An)))
          throw new Error('#initScripting: Scripting already exists.');
        return d(this, xS).createScripting();
      }
      function gb() {
        return IS.apply(this, arguments);
      }
      function IS() {
        return (IS = U(function* () {
          if (!d(this, An))
            return _(this, Bi, null), void d(this, df)?.resolve();
          d(this, Ao) &&
            (yield Promise.race([
              d(this, Ao).promise,
              new Promise((n) => {
                setTimeout(n, 1e3);
              }),
            ]).catch(() => {}),
            _(this, Ao, null)),
            _(this, Bi, null);
          try {
            yield d(this, An).destroySandbox();
          } catch {}
          d(this, Jr)?.reject(new Error('Scripting destroyed.')),
            _(this, Jr, null),
            d(this, uf)?.abort(),
            _(this, uf, null),
            this._pageOpenPending.clear(),
            this._visitedPages.clear(),
            _(this, An, null),
            _(this, pb, !1),
            d(this, df)?.resolve();
        })).apply(this, arguments);
      }
      class Yle extends Gle {
        constructor(e) {
          e.externalServices ||
            window.addEventListener('updatefromsandbox', (t) => {
              e.eventBus.dispatch('updatefromsandbox', {
                source: window,
                detail: t.detail,
              });
            }),
            (e.externalServices ||= {
              createScripting: () => new $le(e.sandboxBundleSrc),
            }),
            (e.docProperties ||= (t) =>
              (function Ule(n) {
                return ES.apply(this, arguments);
              })(t)),
            super(e);
        }
      }
      class Zle {
        constructor() {
          (this.pdfViewer = null),
            (this.pdfThumbnailViewer = null),
            (this.onIdle = null),
            (this.highestPriorityPage = null),
            (this.idleTimeout = null),
            (this.printing = !1),
            (this.isThumbnailViewEnabled = !1),
            Object.defineProperty(this, 'hasViewer', {
              value: () => !!this.pdfViewer,
            });
        }
        setViewer(e) {
          this.pdfViewer = e;
        }
        setThumbnailViewer(e) {
          this.pdfThumbnailViewer = e;
        }
        isHighestPriority(e) {
          return this.highestPriorityPage === e.renderingId;
        }
        renderHighestPriority(e) {
          this.idleTimeout &&
            (clearTimeout(this.idleTimeout), (this.idleTimeout = null)),
            !this.pdfViewer.forceRendering(e) &&
              ((this.isThumbnailViewEnabled &&
                this.pdfThumbnailViewer?.forceRendering()) ||
                this.printing ||
                (this.onIdle &&
                  (this.idleTimeout = setTimeout(
                    this.onIdle.bind(this),
                    3e4
                  ))));
        }
        getHighestPriority(e, t, i, r = !1) {
          const s = e.views,
            o = s.length;
          if (0 === o) return null;
          for (let h = 0; h < o; h++) {
            const f = s[h].view;
            if (!this.isViewFinished(f)) return f;
          }
          const a = e.first.id,
            l = e.last.id;
          if (l - a + 1 > o) {
            const h = e.ids;
            for (let f = 1, p = l - a; f < p; f++) {
              const m = i ? a + f : l - f;
              if (h.has(m)) continue;
              const g = t[m - 1];
              if (!this.isViewFinished(g)) return g;
            }
          }
          let c = i ? l : a - 2,
            u = t[c];
          return (u && !this.isViewFinished(u)) ||
            (r && ((c += i ? 1 : -1), (u = t[c]), u && !this.isViewFinished(u)))
            ? u
            : null;
        }
        isViewFinished(e) {
          return e.renderingState === Bt.FINISHED;
        }
        renderView(e) {
          switch (e.renderingState) {
            case Bt.FINISHED:
              return !1;
            case Bt.PAUSED:
              (this.highestPriorityPage = e.renderingId), e.resume();
              break;
            case Bt.RUNNING:
              this.highestPriorityPage = e.renderingId;
              break;
            case Bt.INITIAL:
              (this.highestPriorityPage = e.renderingId),
                e
                  .draw()
                  .finally(() => {
                    this.renderHighestPriority();
                  })
                  .catch((t) => {
                    t instanceof SA || console.error(`renderView: "${t}"`);
                  });
          }
          return !0;
        }
      }
      function PW(n) {
        return Object.values(yr).includes(n) && n !== yr.DISABLE;
      }
      var $a = new WeakMap(),
        pf = new WeakMap(),
        kS = new WeakSet();
      eH = Symbol.iterator;
      class Qle {
        constructor(e) {
          S(this, kS),
            v(this, $a, { writable: !0, value: new Set() }),
            v(this, pf, { writable: !0, value: 0 }),
            _(this, pf, e);
        }
        push(e) {
          const t = d(this, $a);
          t.has(e) && t.delete(e),
            t.add(e),
            t.size > d(this, pf) && b(this, kS, RW).call(this);
        }
        resize(e, t = null) {
          _(this, pf, e);
          const i = d(this, $a);
          if (t) {
            const r = i.size;
            let s = 1;
            for (const o of i)
              if ((t.has(o.id) && (i.delete(o), i.add(o)), ++s > r)) break;
          }
          for (; i.size > d(this, pf); ) b(this, kS, RW).call(this);
        }
        has(e) {
          return d(this, $a).has(e);
        }
        [eH]() {
          return d(this, $a).keys();
        }
      }
      function RW() {
        const n = d(this, $a).keys().next().value;
        n?.destroy(), d(this, $a).delete(n);
      }
      var zc = new WeakMap(),
        PS = new WeakMap(),
        RS = new WeakMap(),
        So = new WeakMap(),
        bi = new WeakMap(),
        mf = new WeakMap(),
        bb = new WeakMap(),
        FS = new WeakMap(),
        OS = new WeakMap(),
        LS = new WeakMap(),
        NS = new WeakMap(),
        Uc = new WeakMap(),
        VS = new WeakMap(),
        $c = new WeakMap(),
        gf = new WeakMap(),
        vb = new WeakMap(),
        Gc = new WeakMap(),
        yb = new WeakMap(),
        BS = new WeakMap(),
        wb = new WeakMap(),
        _f = new WeakMap(),
        qc = new WeakMap(),
        Eb = new WeakMap(),
        FW = new WeakSet(),
        OW = new WeakSet(),
        LW = new WeakSet(),
        bf = new WeakSet(),
        Cb = new WeakSet(),
        NW = new WeakSet(),
        HS = new WeakSet(),
        VW = new WeakMap(),
        Mo = new WeakSet(),
        WS = new WeakSet(),
        BW = new WeakSet(),
        HW = new WeakSet(),
        WW = new WeakSet(),
        jS = new WeakSet(),
        jW = new WeakSet(),
        xb = new WeakSet();
      class zW {
        constructor(e) {
          S(this, xb),
            S(this, jW),
            S(this, jS),
            S(this, WW),
            S(this, HW),
            S(this, BW),
            S(this, WS),
            S(this, Mo),
            v(this, VW, { get: ice, set: void 0 }),
            S(this, HS),
            S(this, NW),
            S(this, Cb),
            S(this, bf),
            S(this, LW),
            S(this, OW),
            S(this, FW),
            v(this, zc, { writable: !0, value: null }),
            v(this, PS, { writable: !0, value: null }),
            v(this, RS, { writable: !0, value: null }),
            v(this, So, { writable: !0, value: yr.NONE }),
            v(this, bi, { writable: !0, value: null }),
            v(this, mf, { writable: !0, value: ks.ENABLE_FORMS }),
            v(this, bb, { writable: !0, value: null }),
            v(this, FS, { writable: !0, value: !1 }),
            v(this, OS, { writable: !0, value: !1 }),
            v(this, LS, { writable: !0, value: !1 }),
            v(this, NS, { writable: !0, value: !1 }),
            v(this, Uc, { writable: !0, value: null }),
            v(this, VS, { writable: !0, value: null }),
            v(this, $c, { writable: !0, value: null }),
            v(this, gf, { writable: !0, value: null }),
            v(this, vb, { writable: !0, value: !1 }),
            v(this, Gc, { writable: !0, value: null }),
            v(this, yb, { writable: !0, value: !1 }),
            v(this, BS, { writable: !0, value: 0 }),
            v(this, wb, {
              writable: !0,
              value: new ResizeObserver(b(this, jW, ace).bind(this)),
            }),
            v(this, _f, { writable: !0, value: null }),
            v(this, qc, { writable: !0, value: null }),
            v(this, Eb, { writable: !0, value: 1 });
          const t = '4.5.136';
          if (kH !== t)
            throw new Error(
              `The API version "${kH}" does not match the Viewer version "${t}".`
            );
          if (
            ((this.container = e.container),
            (this.viewer = e.viewer || e.container.firstElementChild),
            'DIV' !== this.container?.tagName || 'DIV' !== this.viewer?.tagName)
          )
            throw new Error('Invalid `container` and/or `viewer` option.');
          if (
            this.container.offsetParent &&
            'absolute' !== getComputedStyle(this.container).position
          )
            throw new Error('The `container` must be absolutely positioned.');
          d(this, wb).observe(this.container),
            (this.eventBus = e.eventBus),
            (this.linkService = e.linkService || new AA()),
            (this.downloadManager = e.downloadManager || null),
            (this.findController = e.findController || null),
            _(this, PS, e.altTextManager || null),
            this.findController &&
              (this.findController.onIsPageVisible = (r) =>
                this._getVisiblePages().ids.has(r)),
            (this._scriptingManager = e.scriptingManager || null),
            _(this, Eb, e.textLayerMode ?? 1),
            _(this, mf, e.annotationMode ?? ks.ENABLE_FORMS),
            _(this, So, e.annotationEditorMode ?? yr.NONE),
            _(this, RS, e.annotationEditorHighlightColors || null),
            _(this, OS, !0 === e.enableHighlightFloatingButton),
            _(this, NS, !0 === e.enableUpdatedAddImage),
            (this.imageResourcesPath = e.imageResourcesPath || ''),
            (this.enablePrintAutoRotate = e.enablePrintAutoRotate || !1),
            (this.removePageBorders = e.removePageBorders || !1),
            (this.maxCanvasPixels = e.maxCanvasPixels),
            (this.l10n = e.l10n),
            (this.l10n ||= new Zn()),
            _(this, LS, e.enablePermissions || !1),
            (this.pageColors = e.pageColors || null),
            _(this, VS, e.mlManager || null),
            _(this, FS, e.enableHWA || !1),
            (this.defaultRenderingQueue = !e.renderingQueue),
            this.defaultRenderingQueue
              ? ((this.renderingQueue = new Zle()),
                this.renderingQueue.setViewer(this))
              : (this.renderingQueue = e.renderingQueue);
          const { abortSignal: i } = e;
          i?.addEventListener(
            'abort',
            () => {
              d(this, wb).disconnect(), _(this, wb, null);
            },
            { once: !0 }
          ),
            (this.scroll = (function Aoe(n, e, t) {
              const i = function (o) {
                  s ||
                    (s = window.requestAnimationFrame(function () {
                      s = null;
                      const l = n.scrollLeft,
                        c = r.lastX;
                      l !== c && (r.right = l > c), (r.lastX = l);
                      const u = n.scrollTop,
                        h = r.lastY;
                      u !== h && (r.down = u > h), (r.lastY = u), e(r);
                    }));
                },
                r = {
                  right: !0,
                  down: !0,
                  lastX: n.scrollLeft,
                  lastY: n.scrollTop,
                  _eventHandler: i,
                };
              let s = null;
              return (
                n.addEventListener('scroll', i, { useCapture: !0, signal: t }),
                t?.addEventListener(
                  'abort',
                  () => window.cancelAnimationFrame(s),
                  { once: !0 }
                ),
                r
              );
            })(this.container, this._scrollUpdate.bind(this), i)),
            (this.presentationModeState = 0),
            this._resetView(),
            this.removePageBorders &&
              this.viewer.classList.add('removePageBorders'),
            b(this, jS, GW).call(this),
            this.eventBus._on(
              'thumbnailrendered',
              ({ pageNumber: r, pdfPage: s }) => {
                const o = this._pages[r - 1];
                d(this, zc).has(o) || s?.cleanup();
              }
            ),
            e.l10n || this.l10n.translate(this.container);
        }
        get pagesCount() {
          return this._pages.length;
        }
        getPageView(e) {
          return this._pages[e];
        }
        getCachedPageViews() {
          return new Set(d(this, zc));
        }
        get pageViewsReady() {
          return this._pages.every((e) => e?.pdfPage);
        }
        get renderForms() {
          return d(this, mf) === ks.ENABLE_FORMS;
        }
        get enableScripting() {
          return !!this._scriptingManager;
        }
        get currentPageNumber() {
          return this._currentPageNumber;
        }
        set currentPageNumber(e) {
          if (!Number.isInteger(e)) throw new Error('Invalid page number.');
          this.pdfDocument &&
            (this._setCurrentPageNumber(e, !0) ||
              console.error(`currentPageNumber: "${e}" is not a valid page.`));
        }
        _setCurrentPageNumber(e, t = !1) {
          if (this._currentPageNumber === e)
            return t && b(this, WS, $W).call(this), !0;
          if (!(0 < e && e <= this.pagesCount)) return !1;
          const i = this._currentPageNumber;
          return (
            (this._currentPageNumber = e),
            this.eventBus.dispatch('pagechanging', {
              source: this,
              pageNumber: e,
              pageLabel: this._pageLabels?.[e - 1] ?? null,
              previous: i,
            }),
            t && b(this, WS, $W).call(this),
            !0
          );
        }
        get currentPageLabel() {
          return this._pageLabels?.[this._currentPageNumber - 1] ?? null;
        }
        set currentPageLabel(e) {
          if (!this.pdfDocument) return;
          let t = 0 | e;
          if (this._pageLabels) {
            const i = this._pageLabels.indexOf(e);
            i >= 0 && (t = i + 1);
          }
          this._setCurrentPageNumber(t, !0) ||
            console.error(`currentPageLabel: "${e}" is not a valid page.`);
        }
        get currentScale() {
          return 0 !== this._currentScale ? this._currentScale : 1;
        }
        set currentScale(e) {
          if (isNaN(e)) throw new Error('Invalid numeric scale.');
          this.pdfDocument && b(this, Mo, Ga).call(this, e, { noScroll: !1 });
        }
        get currentScaleValue() {
          return this._currentScaleValue;
        }
        set currentScaleValue(e) {
          this.pdfDocument && b(this, Mo, Ga).call(this, e, { noScroll: !1 });
        }
        get pagesRotation() {
          return this._pagesRotation;
        }
        set pagesRotation(e) {
          if (!lH(e)) throw new Error('Invalid pages rotation angle.');
          if (
            !this.pdfDocument ||
            ((e %= 360) < 0 && (e += 360), this._pagesRotation === e)
          )
            return;
          this._pagesRotation = e;
          const t = this._currentPageNumber;
          this.refresh(!0, { rotation: e }),
            this._currentScaleValue &&
              b(this, Mo, Ga).call(this, this._currentScaleValue, {
                noScroll: !0,
              }),
            this.eventBus.dispatch('rotationchanging', {
              source: this,
              pagesRotation: e,
              pageNumber: t,
            }),
            this.defaultRenderingQueue && this.update();
        }
        get firstPagePromise() {
          return this.pdfDocument ? this._firstPageCapability.promise : null;
        }
        get onePageRendered() {
          return this.pdfDocument
            ? this._onePageRenderedCapability.promise
            : null;
        }
        get pagesPromise() {
          return this.pdfDocument ? this._pagesCapability.promise : null;
        }
        get _layerProperties() {
          const e = this;
          return Z_(this, '_layerProperties', {
            get annotationEditorUIManager() {
              return d(e, bi);
            },
            get annotationStorage() {
              return e.pdfDocument?.annotationStorage;
            },
            get downloadManager() {
              return e.downloadManager;
            },
            get enableScripting() {
              return !!e._scriptingManager;
            },
            get fieldObjectsPromise() {
              return e.pdfDocument?.getFieldObjects();
            },
            get findController() {
              return e.findController;
            },
            get hasJSActionsPromise() {
              return e.pdfDocument?.hasJSActions();
            },
            get linkService() {
              return e.linkService;
            },
          });
        }
        getAllText() {
          var e = this;
          return U(function* () {
            const t = [],
              i = [];
            for (let r = 1, s = e.pdfDocument.numPages; r <= s; ++r) {
              if (d(e, yb)) return null;
              i.length = 0;
              const o = yield e.pdfDocument.getPage(r),
                { items: a } = yield o.getTextContent();
              for (const l of a)
                l.str && i.push(l.str), l.hasEOL && i.push('\n');
              t.push(W_(i.join('')));
            }
            return t.join('\n');
          })();
        }
        setDocument(e) {
          var t = this;
          if (
            (this.pdfDocument &&
              (this.eventBus.dispatch('pagesdestroy', { source: this }),
              this._cancelRendering(),
              this._resetView(),
              this.findController?.setDocument(null),
              this._scriptingManager?.setDocument(null),
              d(this, bi) && (d(this, bi).destroy(), _(this, bi, null))),
            (this.pdfDocument = e),
            !e)
          )
            return;
          const i = e.numPages,
            r = e.getPage(1),
            s = e.getOptionalContentConfig({ intent: 'display' }),
            o = d(this, LS) ? e.getPermissions() : Promise.resolve(),
            { eventBus: a, pageColors: l, viewer: c } = this;
          _(this, Uc, new AbortController());
          const { signal: u } = d(this, Uc);
          if (i > 1e4) {
            console.warn(
              'Forcing PAGE-scrolling for performance reasons, given the length of the document.'
            );
            const p = (this._scrollMode = Ke.PAGE);
            a.dispatch('scrollmodechanged', { source: this, mode: p });
          }
          this._pagesCapability.promise.then(
            () => {
              a.dispatch('pagesloaded', { source: this, pagesCount: i });
            },
            () => {}
          ),
            a._on(
              'pagerender',
              (p) => {
                const m = this._pages[p.pageNumber - 1];
                m && d(this, zc).push(m);
              },
              { signal: u }
            );
          const f = (p) => {
            p.cssTransform ||
              (this._onePageRenderedCapability.resolve({
                timestamp: p.timestamp,
              }),
              a._off('pagerendered', f));
          };
          a._on('pagerendered', f, { signal: u }),
            Promise.all([r, o])
              .then(([p, m]) => {
                if (e !== this.pdfDocument) return;
                this._firstPageCapability.resolve(p),
                  (this._optionalContentConfigPromise = s);
                const {
                  annotationEditorMode: g,
                  annotationMode: w,
                  textLayerMode: y,
                } = b(this, FW, Jle).call(this, m);
                if (0 !== y) {
                  const T = _(this, Gc, document.createElement('div'));
                  (T.id = 'hiddenCopyElement'), c.before(T);
                }
                if (g !== yr.DISABLE) {
                  const T = g;
                  e.isPureXfa
                    ? console.warn('Warning: XFA-editing is not implemented.')
                    : PW(T)
                    ? (_(
                        this,
                        bi,
                        new gae(
                          this.container,
                          c,
                          d(this, PS),
                          a,
                          e,
                          l,
                          d(this, RS),
                          d(this, OS),
                          d(this, NS),
                          d(this, VS)
                        )
                      ),
                      a.dispatch('annotationeditoruimanager', {
                        source: this,
                        uiManager: d(this, bi),
                      }),
                      T !== yr.NONE && d(this, bi).updateMode(T))
                    : console.error(`Invalid AnnotationEditor mode: ${T}`);
                }
                const E = this._scrollMode === Ke.PAGE ? null : c,
                  A = this.currentScale,
                  M = p.getViewport({ scale: A * Ps.PDF_TO_CSS_UNITS });
                c.style.setProperty('--scale-factor', M.scale),
                  ('CanvasText' === l?.foreground ||
                    'Canvas' === l?.background) &&
                    (c.style.setProperty(
                      '--hcm-highlight-filter',
                      e.filterFactory.addHighlightHCMFilter(
                        'highlight',
                        'CanvasText',
                        'Canvas',
                        'HighlightText',
                        'Highlight'
                      )
                    ),
                    c.style.setProperty(
                      '--hcm-highlight-selected-filter',
                      e.filterFactory.addHighlightHCMFilter(
                        'highlight_selected',
                        'CanvasText',
                        'Canvas',
                        'HighlightText',
                        'ButtonText'
                      )
                    ));
                for (let T = 1; T <= i; ++T) {
                  const k = new wW({
                    container: E,
                    eventBus: a,
                    id: T,
                    scale: A,
                    defaultViewport: M.clone(),
                    optionalContentConfigPromise: s,
                    renderingQueue: this.renderingQueue,
                    textLayerMode: y,
                    annotationMode: w,
                    imageResourcesPath: this.imageResourcesPath,
                    maxCanvasPixels: this.maxCanvasPixels,
                    pageColors: l,
                    l10n: this.l10n,
                    layerProperties: this._layerProperties,
                    enableHWA: d(this, FS),
                  });
                  this._pages.push(k);
                }
                this._pages[0]?.setPdfPage(p),
                  this._scrollMode === Ke.PAGE
                    ? b(this, bf, Ab).call(this)
                    : this._spreadMode !== Ln.NONE && this._updateSpreadMode(),
                  b(this, OW, ece)
                    .call(this, u)
                    .then(
                      U(function* () {
                        if (e !== t.pdfDocument) return;
                        if (
                          (t.findController?.setDocument(e),
                          t._scriptingManager?.setDocument(e),
                          d(t, Gc) &&
                            document.addEventListener(
                              'copy',
                              b(t, LW, tce).bind(t, y),
                              { signal: u }
                            ),
                          d(t, bi) &&
                            a.dispatch('annotationeditormodechanged', {
                              source: t,
                              mode: d(t, So),
                            }),
                          e.loadingParams.disableAutoFetch || i > 5e3)
                        )
                          return void t._pagesCapability.resolve();
                        let T = i - 1;
                        if (T <= 0) t._pagesCapability.resolve();
                        else
                          for (let k = 2; k <= i; ++k) {
                            const P = e.getPage(k).then(
                              (O) => {
                                const I = t._pages[k - 1];
                                I.pdfPage || I.setPdfPage(O),
                                  0 == --T && t._pagesCapability.resolve();
                              },
                              (O) => {
                                console.error(
                                  `Unable to get page ${k} to initialize viewer`,
                                  O
                                ),
                                  0 == --T && t._pagesCapability.resolve();
                              }
                            );
                            k % 250 == 0 && (yield P);
                          }
                      })
                    ),
                  a.dispatch('pagesinit', { source: this }),
                  e.getMetadata().then(({ info: T }) => {
                    e === this.pdfDocument &&
                      T.Language &&
                      (c.lang = T.Language);
                  }),
                  this.defaultRenderingQueue && this.update();
              })
              .catch((p) => {
                console.error('Unable to initialize viewer', p),
                  this._pagesCapability.reject(p);
              });
        }
        setPageLabels(e) {
          if (this.pdfDocument) {
            e
              ? Array.isArray(e) && this.pdfDocument.numPages === e.length
                ? (this._pageLabels = e)
                : ((this._pageLabels = null),
                  console.error('setPageLabels: Invalid page labels.'))
              : (this._pageLabels = null);
            for (let t = 0, i = this._pages.length; t < i; t++)
              this._pages[t].setPageLabel(this._pageLabels?.[t] ?? null);
          }
        }
        _resetView() {
          (this._pages = []),
            (this._currentPageNumber = 1),
            (this._currentScale = 0),
            (this._currentScaleValue = null),
            (this._pageLabels = null),
            _(this, zc, new Qle(10)),
            (this._location = null),
            (this._pagesRotation = 0),
            (this._optionalContentConfigPromise = null),
            (this._firstPageCapability = Promise.withResolvers()),
            (this._onePageRenderedCapability = Promise.withResolvers()),
            (this._pagesCapability = Promise.withResolvers()),
            (this._scrollMode = Ke.VERTICAL),
            (this._previousScrollMode = Ke.UNKNOWN),
            (this._spreadMode = Ln.NONE),
            _(this, _f, { previousPageNumber: 1, scrollDown: !0, pages: [] }),
            d(this, Uc)?.abort(),
            _(this, Uc, null),
            (this.viewer.textContent = ''),
            this._updateScrollMode(),
            this.viewer.removeAttribute('lang'),
            d(this, Gc)?.remove(),
            _(this, Gc, null),
            b(this, xb, GS).call(this);
        }
        _scrollUpdate() {
          0 !== this.pagesCount && this.update();
        }
        pageLabelToPageNumber(e) {
          if (!this._pageLabels) return null;
          const t = this._pageLabels.indexOf(e);
          return t < 0 ? null : t + 1;
        }
        scrollPageIntoView({
          pageNumber: e,
          destArray: t = null,
          allowNegativeOffset: i = !1,
          ignoreDestinationZoom: r = !1,
        }) {
          if (!this.pdfDocument) return;
          const s = Number.isInteger(e) && this._pages[e - 1];
          if (!s)
            return void console.error(
              `scrollPageIntoView: "${e}" is not a valid pageNumber parameter.`
            );
          if (this.isInPresentationMode || !t)
            return void this._setCurrentPageNumber(e, !0);
          let u,
            h,
            o = 0,
            a = 0,
            l = 0,
            c = 0;
          const f = s.rotation % 180 != 0,
            p = (f ? s.height : s.width) / s.scale / Ps.PDF_TO_CSS_UNITS,
            m = (f ? s.width : s.height) / s.scale / Ps.PDF_TO_CSS_UNITS;
          let g = 0;
          switch (t[1].name) {
            case 'XYZ':
              (o = t[2]),
                (a = t[3]),
                (g = t[4]),
                (o = null !== o ? o : 0),
                (a = null !== a ? a : m);
              break;
            case 'Fit':
            case 'FitB':
              g = 'page-fit';
              break;
            case 'FitH':
            case 'FitBH':
              (a = t[2]),
                (g = 'page-width'),
                null === a && this._location
                  ? ((o = this._location.left), (a = this._location.top))
                  : ('number' != typeof a || a < 0) && (a = m);
              break;
            case 'FitV':
            case 'FitBV':
              (o = t[2]), (l = p), (c = m), (g = 'page-height');
              break;
            case 'FitR':
              (o = t[2]), (a = t[3]), (l = t[4] - o), (c = t[5] - a);
              let A = iH,
                M = rH;
              this.removePageBorders && (A = M = 0),
                (u =
                  (this.container.clientWidth - A) / l / Ps.PDF_TO_CSS_UNITS),
                (h =
                  (this.container.clientHeight - M) / c / Ps.PDF_TO_CSS_UNITS),
                (g = Math.min(Math.abs(u), Math.abs(h)));
              break;
            default:
              return void console.error(
                `scrollPageIntoView: "${t[1].name}" is not a valid destination type.`
              );
          }
          if (
            (r ||
              (g && g !== this._currentScale
                ? (this.currentScaleValue = g)
                : 0 === this._currentScale &&
                  (this.currentScaleValue = 'auto')),
            'page-fit' === g && !t[4])
          )
            return void b(this, Cb, US).call(this, s);
          const w = [
            s.viewport.convertToViewportPoint(o, a),
            s.viewport.convertToViewportPoint(o + l, a + c),
          ];
          let y = Math.min(w[0][0], w[1][0]),
            E = Math.min(w[0][1], w[1][1]);
          i || ((y = Math.max(y, 0)), (E = Math.max(E, 0))),
            b(this, Cb, US).call(this, s, { left: y, top: E });
        }
        _updateLocation(e) {
          const t = this._currentScale,
            i = this._currentScaleValue,
            r = parseFloat(i) === t ? Math.round(1e4 * t) / 100 : i,
            s = e.id,
            a = this.container,
            l = this._pages[s - 1].getPagePoint(
              a.scrollLeft - e.x,
              a.scrollTop - e.y
            ),
            c = Math.round(l[0]),
            u = Math.round(l[1]);
          let h = `#page=${s}`;
          this.isInPresentationMode || (h += `&zoom=${r},${c},${u}`),
            (this._location = {
              pageNumber: s,
              scale: r,
              top: u,
              left: c,
              rotation: this._pagesRotation,
              pdfOpenParams: h,
            });
        }
        update() {
          const e = this._getVisiblePages(),
            t = e.views,
            i = t.length;
          if (0 === i) return;
          const r = Math.max(10, 2 * i + 1);
          d(this, zc).resize(r, e.ids),
            this.renderingQueue.renderHighestPriority(e);
          const s =
              this._spreadMode === Ln.NONE &&
              (this._scrollMode === Ke.PAGE ||
                this._scrollMode === Ke.VERTICAL),
            o = this._currentPageNumber;
          let a = !1;
          for (const l of t) {
            if (l.percent < 100) break;
            if (l.id === o && s) {
              a = !0;
              break;
            }
          }
          this._setCurrentPageNumber(a ? o : t[0].id),
            this._updateLocation(e.first),
            this.eventBus.dispatch('updateviewarea', {
              source: this,
              location: this._location,
            });
        }
        containsElement(e) {
          return this.container.contains(e);
        }
        focus() {
          this.container.focus();
        }
        get _isContainerRtl() {
          return 'rtl' === getComputedStyle(this.container).direction;
        }
        get isInPresentationMode() {
          return 3 === this.presentationModeState;
        }
        get isChangingPresentationMode() {
          return 2 === this.presentationModeState;
        }
        get isHorizontalScrollbarEnabled() {
          return (
            !this.isInPresentationMode &&
            this.container.scrollWidth > this.container.clientWidth
          );
        }
        get isVerticalScrollbarEnabled() {
          return (
            !this.isInPresentationMode &&
            this.container.scrollHeight > this.container.clientHeight
          );
        }
        _getVisiblePages() {
          const e =
              this._scrollMode === Ke.PAGE ? d(this, _f).pages : this._pages,
            t = this._scrollMode === Ke.HORIZONTAL;
          return (function Moe({
            scrollEl: n,
            views: e,
            sortByVisibility: t = !1,
            horizontal: i = !1,
            rtl: r = !1,
          }) {
            const s = n.scrollTop,
              o = s + n.clientHeight,
              a = n.scrollLeft,
              l = a + n.clientWidth,
              h = [],
              f = new Set(),
              p = e.length;
            let m = Uh(
              e,
              i
                ? function u(E) {
                    const A = E.div,
                      M = A.offsetLeft + A.clientLeft;
                    return r ? M < l : M + A.clientWidth > a;
                  }
                : function c(E) {
                    const A = E.div;
                    return A.offsetTop + A.clientTop + A.clientHeight > s;
                  }
            );
            m > 0 &&
              m < p &&
              !i &&
              (m = (function Soe(n, e, t) {
                if (n < 2) return n;
                let i = e[n].div,
                  r = i.offsetTop + i.clientTop;
                r >= t && ((i = e[n - 1].div), (r = i.offsetTop + i.clientTop));
                for (
                  let s = n - 2;
                  s >= 0 &&
                  ((i = e[s].div),
                  !(i.offsetTop + i.clientTop + i.clientHeight <= r));
                  --s
                )
                  n = s;
                return n;
              })(m, e, s));
            let g = i ? l : -1;
            for (let E = m; E < p; E++) {
              const A = e[E],
                M = A.div,
                T = M.offsetLeft + M.clientLeft,
                k = M.offsetTop + M.clientTop,
                P = M.clientWidth,
                O = M.clientHeight,
                I = T + P,
                C = k + O;
              if (-1 === g) C >= o && (g = C);
              else if ((i ? T : k) > g) break;
              if (C <= s || k >= o || I <= a || T >= l) continue;
              const R = Math.max(0, s - k) + Math.max(0, C - o),
                oe = (P - (Math.max(0, a - T) + Math.max(0, I - l))) / P;
              h.push({
                id: A.id,
                x: T,
                y: k,
                view: A,
                percent: (((O - R) / O) * oe * 100) | 0,
                widthPercent: (100 * oe) | 0,
              }),
                f.add(A.id);
            }
            const w = h[0],
              y = h.at(-1);
            return (
              t &&
                h.sort(function (E, A) {
                  const M = E.percent - A.percent;
                  return Math.abs(M) > 0.001 ? -M : E.id - A.id;
                }),
              { first: w, last: y, views: h, ids: f }
            );
          })({
            scrollEl: this.container,
            views: e,
            sortByVisibility: !0,
            horizontal: t,
            rtl: t && this._isContainerRtl,
          });
        }
        cleanup() {
          for (const e of this._pages)
            e.renderingState !== Bt.FINISHED && e.reset();
        }
        _cancelRendering() {
          for (const e of this._pages) e.cancelRendering();
        }
        forceRendering(e) {
          const t = e || this._getVisiblePages(),
            i = b(this, WW, oce).call(this, t),
            s = this.renderingQueue.getHighestPriority(
              t,
              this._pages,
              i,
              this._spreadMode !== Ln.NONE && this._scrollMode !== Ke.HORIZONTAL
            );
          return (
            !!s &&
            (b(this, HW, sce)
              .call(this, s)
              .then(() => {
                this.renderingQueue.renderView(s);
              }),
            !0)
          );
        }
        get hasEqualPageSizes() {
          const e = this._pages[0];
          for (let t = 1, i = this._pages.length; t < i; ++t) {
            const r = this._pages[t];
            if (r.width !== e.width || r.height !== e.height) return !1;
          }
          return !0;
        }
        getPagesOverview() {
          let e;
          return this._pages.map((t) => {
            const i = t.pdfPage.getViewport({ scale: 1 }),
              r = cH(i);
            if (void 0 === e) e = r;
            else if (this.enablePrintAutoRotate && r !== e)
              return {
                width: i.height,
                height: i.width,
                rotation: (i.rotation - 90) % 360,
              };
            return { width: i.width, height: i.height, rotation: i.rotation };
          });
        }
        get optionalContentConfigPromise() {
          return this.pdfDocument
            ? this._optionalContentConfigPromise
              ? this._optionalContentConfigPromise
              : (console.error(
                  'optionalContentConfigPromise: Not initialized yet.'
                ),
                this.pdfDocument.getOptionalContentConfig({
                  intent: 'display',
                }))
            : Promise.resolve(null);
        }
        set optionalContentConfigPromise(e) {
          if (!(e instanceof Promise))
            throw new Error(`Invalid optionalContentConfigPromise: ${e}`);
          this.pdfDocument &&
            this._optionalContentConfigPromise &&
            ((this._optionalContentConfigPromise = e),
            this.refresh(!1, { optionalContentConfigPromise: e }),
            this.eventBus.dispatch('optionalcontentconfigchanged', {
              source: this,
              promise: e,
            }));
        }
        get scrollMode() {
          return this._scrollMode;
        }
        set scrollMode(e) {
          if (this._scrollMode !== e) {
            if (
              !(function Toe(n) {
                return (
                  Number.isInteger(n) &&
                  Object.values(Ke).includes(n) &&
                  n !== Ke.UNKNOWN
                );
              })(e)
            )
              throw new Error(`Invalid scroll mode: ${e}`);
            this.pagesCount > 1e4 ||
              ((this._previousScrollMode = this._scrollMode),
              (this._scrollMode = e),
              this.eventBus.dispatch('scrollmodechanged', {
                source: this,
                mode: e,
              }),
              this._updateScrollMode(this._currentPageNumber));
          }
        }
        _updateScrollMode(e = null) {
          const t = this._scrollMode,
            i = this.viewer;
          i.classList.toggle('scrollHorizontal', t === Ke.HORIZONTAL),
            i.classList.toggle('scrollWrapped', t === Ke.WRAPPED),
            this.pdfDocument &&
              e &&
              (t === Ke.PAGE
                ? b(this, bf, Ab).call(this)
                : this._previousScrollMode === Ke.PAGE &&
                  this._updateSpreadMode(),
              this._currentScaleValue &&
                isNaN(this._currentScaleValue) &&
                b(this, Mo, Ga).call(this, this._currentScaleValue, {
                  noScroll: !0,
                }),
              this._setCurrentPageNumber(e, !0),
              this.update());
        }
        get spreadMode() {
          return this._spreadMode;
        }
        set spreadMode(e) {
          if (this._spreadMode !== e) {
            if (
              !(function Ioe(n) {
                return (
                  Number.isInteger(n) &&
                  Object.values(Ln).includes(n) &&
                  n !== Ln.UNKNOWN
                );
              })(e)
            )
              throw new Error(`Invalid spread mode: ${e}`);
            (this._spreadMode = e),
              this.eventBus.dispatch('spreadmodechanged', {
                source: this,
                mode: e,
              }),
              this._updateSpreadMode(this._currentPageNumber);
          }
        }
        _updateSpreadMode(e = null) {
          if (!this.pdfDocument) return;
          const t = this.viewer,
            i = this._pages;
          if (this._scrollMode === Ke.PAGE) b(this, bf, Ab).call(this);
          else if (((t.textContent = ''), this._spreadMode === Ln.NONE))
            for (const r of this._pages) t.append(r.div);
          else {
            const r = this._spreadMode - 1;
            let s = null;
            for (let o = 0, a = i.length; o < a; ++o)
              null === s
                ? ((s = document.createElement('div')),
                  (s.className = 'spread'),
                  t.append(s))
                : o % 2 === r && ((s = s.cloneNode(!1)), t.append(s)),
                s.append(i[o].div);
          }
          e &&
            (this._currentScaleValue &&
              isNaN(this._currentScaleValue) &&
              b(this, Mo, Ga).call(this, this._currentScaleValue, {
                noScroll: !0,
              }),
            this._setCurrentPageNumber(e, !0),
            this.update());
        }
        _getPageAdvance(e, t = !1) {
          switch (this._scrollMode) {
            case Ke.WRAPPED: {
              const { views: i } = this._getVisiblePages(),
                r = new Map();
              for (const { id: s, y: o, percent: a, widthPercent: l } of i) {
                if (0 === a || l < 100) continue;
                let c = r.get(o);
                c || r.set(o, (c ||= [])), c.push(s);
              }
              for (const s of r.values()) {
                const o = s.indexOf(e);
                if (-1 === o) continue;
                const a = s.length;
                if (1 === a) break;
                if (t)
                  for (let l = o - 1, c = 0; l >= c; l--) {
                    const h = s[l + 1] - 1;
                    if (s[l] < h) return e - h;
                  }
                else
                  for (let l = o + 1, c = a; l < c; l++) {
                    const h = s[l - 1] + 1;
                    if (s[l] > h) return h - e;
                  }
                if (t) {
                  const l = s[0];
                  if (l < e) return e - l + 1;
                } else {
                  const l = s[a - 1];
                  if (l > e) return l - e + 1;
                }
                break;
              }
              break;
            }
            case Ke.HORIZONTAL:
              break;
            case Ke.PAGE:
            case Ke.VERTICAL: {
              if (this._spreadMode === Ln.NONE) break;
              const i = this._spreadMode - 1;
              if (t && e % 2 !== i) break;
              if (!t && e % 2 === i) break;
              const { views: r } = this._getVisiblePages(),
                s = t ? e - 1 : e + 1;
              for (const { id: o, percent: a, widthPercent: l } of r)
                if (o === s) {
                  if (a > 0 && 100 === l) return 2;
                  break;
                }
              break;
            }
          }
          return 1;
        }
        nextPage() {
          const e = this._currentPageNumber,
            t = this.pagesCount;
          if (e >= t) return !1;
          const i = this._getPageAdvance(e, !1) || 1;
          return (this.currentPageNumber = Math.min(e + i, t)), !0;
        }
        previousPage() {
          const e = this._currentPageNumber;
          if (e <= 1) return !1;
          const t = this._getPageAdvance(e, !0) || 1;
          return (this.currentPageNumber = Math.max(e - t, 1)), !0;
        }
        updateScale({
          drawingDelay: e,
          scaleFactor: t = null,
          steps: i = null,
          origin: r,
        }) {
          if (null === i && null === t)
            throw new Error(
              'Invalid updateScale options: either `steps` or `scaleFactor` must be provided.'
            );
          if (!this.pdfDocument) return;
          let s = this._currentScale;
          if (t > 0 && 1 !== t) s = Math.round(s * t * 100) / 100;
          else if (i) {
            const o = i > 0 ? 1.1 : 1 / 1.1,
              a = i > 0 ? Math.ceil : Math.floor;
            i = Math.abs(i);
            do {
              s = a(10 * (s * o).toFixed(2)) / 10;
            } while (--i > 0);
          }
          (s = Math.max(0.1, Math.min(10, s))),
            b(this, Mo, Ga).call(this, s, {
              noScroll: !1,
              drawingDelay: e,
              origin: r,
            });
        }
        increaseScale(e = {}) {
          this.updateScale({ ...e, steps: e.steps ?? 1 });
        }
        decreaseScale(e = {}) {
          this.updateScale({ ...e, steps: -(e.steps ?? 1) });
        }
        get containerTopLeft() {
          return (
            d(this, bb) ||
            _(this, bb, [this.container.offsetTop, this.container.offsetLeft])
          );
        }
        get annotationEditorMode() {
          return d(this, bi) ? d(this, So) : yr.DISABLE;
        }
        set annotationEditorMode({
          mode: e,
          editId: t = null,
          isFromKeyboard: i = !1,
        }) {
          if (!d(this, bi))
            throw new Error('The AnnotationEditor is not enabled.');
          if (d(this, So) === e) return;
          if (!PW(e)) throw new Error(`Invalid AnnotationEditor mode: ${e}`);
          if (!this.pdfDocument) return;
          const { eventBus: r } = this,
            s = () => {
              b(this, xb, GS).call(this),
                _(this, So, e),
                d(this, bi).updateMode(e, t, i),
                r.dispatch('annotationeditormodechanged', {
                  source: this,
                  mode: e,
                });
            };
          if (e === yr.NONE || d(this, So) === yr.NONE) {
            const o = e !== yr.NONE;
            o || this.pdfDocument.annotationStorage.resetModifiedIds();
            for (const l of this._pages) l.toggleEditingMode(o);
            const a = b(this, BW, rce).call(this);
            if (o && a) {
              b(this, xb, GS).call(this),
                _(this, $c, ({ pageNumber: c }) => {
                  a.delete(c), 0 === a.size && _(this, gf, setTimeout(s, 0));
                });
              const { signal: l } = d(this, Uc);
              return void r._on('pagerendered', d(this, $c), { signal: l });
            }
          }
          s();
        }
        set annotationEditorParams({ type: e, value: t }) {
          if (!d(this, bi))
            throw new Error('The AnnotationEditor is not enabled.');
          d(this, bi).updateParams(e, t);
        }
        refresh(e = !1, t = Object.create(null)) {
          if (this.pdfDocument) {
            for (const i of this._pages) i.update(t);
            null !== d(this, qc) &&
              (clearTimeout(d(this, qc)), _(this, qc, null)),
              e || this.update();
          }
        }
      }
      function Jle(n) {
        const e = {
          annotationEditorMode: d(this, So),
          annotationMode: d(this, mf),
          textLayerMode: d(this, Eb),
        };
        return (
          n &&
            (!n.includes(K_.COPY) && 1 === d(this, Eb) && (e.textLayerMode = 2),
            n.includes(K_.MODIFY_CONTENTS) ||
              (e.annotationEditorMode = yr.DISABLE),
            !n.includes(K_.MODIFY_ANNOTATIONS) &&
              !n.includes(K_.FILL_INTERACTIVE_FORMS) &&
              d(this, mf) === ks.ENABLE_FORMS &&
              (e.annotationMode = ks.ENABLE)),
          e
        );
      }
      function ece(n) {
        return zS.apply(this, arguments);
      }
      function zS() {
        return (zS = U(function* (n) {
          if (
            'hidden' === document.visibilityState ||
            !this.container.offsetParent ||
            0 === this._getVisiblePages().views.length
          )
            return;
          const e = Promise.withResolvers();
          function t() {
            'hidden' === document.visibilityState && e.resolve();
          }
          document.addEventListener('visibilitychange', t, { signal: n }),
            yield Promise.race([
              this._onePageRenderedCapability.promise,
              e.promise,
            ]),
            document.removeEventListener('visibilitychange', t);
        })).apply(this, arguments);
      }
      function tce(n, e) {
        const t = document.getSelection(),
          { focusNode: i, anchorNode: r } = t;
        if (r && i && t.containsNode(d(this, Gc))) {
          if (d(this, vb) || 2 === n)
            return e.preventDefault(), void e.stopPropagation();
          _(this, vb, !0);
          const { classList: s } = this.viewer;
          s.add('copyAll');
          const o = new AbortController();
          window.addEventListener(
            'keydown',
            (a) => _(this, yb, 'Escape' === a.key),
            { signal: o.signal }
          ),
            this.getAllText()
              .then(
                (function () {
                  var a = U(function* (l) {
                    null !== l && (yield navigator.clipboard.writeText(l));
                  });
                  return function (l) {
                    return a.apply(this, arguments);
                  };
                })()
              )
              .catch((a) => {
                console.warn(
                  `Something goes wrong when extracting the text: ${a.message}`
                );
              })
              .finally(() => {
                _(this, vb, !1),
                  _(this, yb, !1),
                  o.abort(),
                  s.remove('copyAll');
              }),
            e.preventDefault(),
            e.stopPropagation();
        }
      }
      function Ab() {
        if (this._scrollMode !== Ke.PAGE)
          throw new Error('#ensurePageViewVisible: Invalid scrollMode value.');
        const n = this._currentPageNumber,
          e = d(this, _f),
          t = this.viewer;
        if (
          ((t.textContent = ''),
          (e.pages.length = 0),
          this._spreadMode !== Ln.NONE || this.isInPresentationMode)
        ) {
          const i = new Set(),
            r = this._spreadMode - 1;
          -1 === r
            ? i.add(n - 1)
            : n % 2 !== r
            ? (i.add(n - 1), i.add(n))
            : (i.add(n - 2), i.add(n - 1));
          const s = document.createElement('div');
          if (((s.className = 'spread'), this.isInPresentationMode)) {
            const o = document.createElement('div');
            (o.className = 'dummyPage'), s.append(o);
          }
          for (const o of i) {
            const a = this._pages[o];
            a && (s.append(a.div), e.pages.push(a));
          }
          t.append(s);
        } else {
          const i = this._pages[n - 1];
          t.append(i.div), e.pages.push(i);
        }
        (e.scrollDown = n >= e.previousPageNumber), (e.previousPageNumber = n);
      }
      function US(n, e = null) {
        const { div: t, id: i } = n;
        if (
          (this._currentPageNumber !== i && this._setCurrentPageNumber(i),
          this._scrollMode === Ke.PAGE &&
            (b(this, bf, Ab).call(this), this.update()),
          !e && !this.isInPresentationMode)
        ) {
          const r = t.offsetLeft + t.clientLeft,
            s = r + t.clientWidth,
            { scrollLeft: o, clientWidth: a } = this.container;
          (this._scrollMode === Ke.HORIZONTAL || r < o || s > o + a) &&
            (e = { left: 0, top: 0 });
        }
        sH(t, e),
          !this._currentScaleValue && this._location && (this._location = null);
      }
      function nce(n) {
        return (
          n === this._currentScale || Math.abs(n - this._currentScale) < 1e-15
        );
      }
      function UW(
        n,
        e,
        {
          noScroll: t = !1,
          preset: i = !1,
          drawingDelay: r = -1,
          origin: s = null,
        }
      ) {
        if (
          ((this._currentScaleValue = e.toString()),
          b(this, NW, nce).call(this, n))
        )
          return void (
            i &&
            this.eventBus.dispatch('scalechanging', {
              source: this,
              scale: n,
              presetValue: e,
            })
          );
        this.viewer.style.setProperty(
          '--scale-factor',
          n * Ps.PDF_TO_CSS_UNITS
        );
        const o = r >= 0 && r < 1e3;
        this.refresh(!0, { scale: n, drawingDelay: o ? r : -1 }),
          o &&
            _(
              this,
              qc,
              setTimeout(() => {
                _(this, qc, null), this.refresh();
              }, r)
            );
        const a = this._currentScale;
        if (((this._currentScale = n), !t)) {
          let c,
            l = this._currentPageNumber;
          if (
            (this._location &&
              !(this.isInPresentationMode || this.isChangingPresentationMode) &&
              ((l = this._location.pageNumber),
              (c = [
                null,
                { name: 'XYZ' },
                this._location.left,
                this._location.top,
                null,
              ])),
            this.scrollPageIntoView({
              pageNumber: l,
              destArray: c,
              allowNegativeOffset: !0,
            }),
            Array.isArray(s))
          ) {
            const u = n / a - 1,
              [h, f] = this.containerTopLeft;
            (this.container.scrollLeft += (s[0] - f) * u),
              (this.container.scrollTop += (s[1] - h) * u);
          }
        }
        this.eventBus.dispatch('scalechanging', {
          source: this,
          scale: n,
          presetValue: i ? e : void 0,
        }),
          this.defaultRenderingQueue && this.update();
      }
      function ice() {
        return this._spreadMode !== Ln.NONE &&
          this._scrollMode !== Ke.HORIZONTAL
          ? 2
          : 1;
      }
      function Ga(n, e) {
        let t = parseFloat(n);
        if (t > 0) (e.preset = !1), b(this, HS, UW).call(this, t, n, e);
        else {
          const i = this._pages[this._currentPageNumber - 1];
          if (!i) return;
          let r = iH,
            s = rH;
          this.isInPresentationMode
            ? ((r = s = 4), this._spreadMode !== Ln.NONE && (r *= 2))
            : this.removePageBorders
            ? (r = s = 0)
            : this._scrollMode === Ke.HORIZONTAL && ([r, s] = [s, r]);
          const o =
              (((this.container.clientWidth - r) / i.width) * i.scale) /
              d(this, VW),
            a = ((this.container.clientHeight - s) / i.height) * i.scale;
          switch (n) {
            case 'page-actual':
              t = 1;
              break;
            case 'page-width':
              t = o;
              break;
            case 'page-height':
              t = a;
              break;
            case 'page-fit':
              t = Math.min(o, a);
              break;
            case 'auto':
              const l = cH(i) ? o : Math.min(a, o);
              t = Math.min(Coe, l);
              break;
            default:
              return void console.error(
                `#setScale: "${n}" is an unknown zoom value.`
              );
          }
          (e.preset = !0), b(this, HS, UW).call(this, t, n, e);
        }
      }
      function $W() {
        const n = this._pages[this._currentPageNumber - 1];
        this.isInPresentationMode &&
          b(this, Mo, Ga).call(this, this._currentScaleValue, { noScroll: !0 }),
          b(this, Cb, US).call(this, n);
      }
      function rce() {
        const n = this._getVisiblePages(),
          e = [],
          { ids: t, views: i } = n;
        for (const r of i) {
          const { view: s } = r;
          s.hasEditableAnnotations() ? e.push(r) : t.delete(s.id);
        }
        return 0 === e.length
          ? null
          : (this.renderingQueue.renderHighestPriority({
              first: e[0],
              last: e.at(-1),
              views: e,
              ids: t,
            }),
            t);
      }
      function sce(n) {
        return $S.apply(this, arguments);
      }
      function $S() {
        return ($S = U(function* (n) {
          if (n.pdfPage) return n.pdfPage;
          try {
            const e = yield this.pdfDocument.getPage(n.id);
            return n.pdfPage || n.setPdfPage(e), e;
          } catch (e) {
            return console.error('Unable to get page for page view', e), null;
          }
        })).apply(this, arguments);
      }
      function oce(n) {
        if (1 === n.first?.id) return !0;
        if (n.last?.id === this.pagesCount) return !1;
        switch (this._scrollMode) {
          case Ke.PAGE:
            return d(this, _f).scrollDown;
          case Ke.HORIZONTAL:
            return this.scroll.right;
        }
        return this.scroll.down;
      }
      function GW(n = this.container.clientHeight) {
        n !== d(this, BS) &&
          (_(this, BS, n),
          koe.setProperty('--viewer-container-height', `${n}px`));
      }
      function ace(n) {
        for (const e of n)
          if (e.target === this.container) {
            b(this, jS, GW).call(
              this,
              Math.floor(e.borderBoxSize[0].blockSize)
            ),
              _(this, bb, null);
            break;
          }
      }
      function GS() {
        d(this, $c) &&
          (this.eventBus._off('pagerendered', d(this, $c)), _(this, $c, null)),
          null !== d(this, gf) &&
            (clearTimeout(d(this, gf)), _(this, gf, null));
      }
      class lce extends zW {
        _resetView() {
          super._resetView(),
            (this._scrollMode = Ke.PAGE),
            (this._spreadMode = Ln.NONE);
        }
        set scrollMode(e) {}
        _updateScrollMode() {}
        set spreadMode(e) {}
        _updateSpreadMode() {}
      }
      var cce = Ft.AnnotationLayerBuilder,
        dce = Ft.DownloadManager,
        uce = Ft.EventBus,
        hce = Ft.FindState,
        qW = Ft.GenericL10n,
        Xc = Ft.LinkTarget,
        XW = Ft.PDFFindController,
        fce = Ft.PDFHistory,
        YW = Ft.PDFLinkService,
        pce = Ft.PDFPageView,
        mce = Ft.PDFScriptingManager,
        KW = Ft.PDFSinglePageViewer,
        ZW = Ft.PDFViewer,
        gce = Ft.ProgressBar,
        _ce = Ft.RenderingStates,
        bce = Ft.ScrollMode,
        vce = Ft.SimpleLinkService,
        yce = Ft.SpreadMode,
        wce = Ft.StructTreeLayerBuilder,
        Ece = Ft.TextLayerBuilder,
        Cce = Ft.XfaLayerBuilder,
        xce = Ft.parseQueryString;
      function qS(n, e, t) {
        n[e] = t;
      }
      function vf() {
        return typeof window > 'u';
      }
      const Mce = ['pdfViewerContainer'];
      vf() || qS(Ls, 'verbosity', YB.INFOS),
        typeof Promise.withResolvers > 'u' &&
          window &&
          (window.Promise.withResolvers = () => {
            let n, e;
            return {
              promise: new Promise((i, r) => {
                (n = i), (e = r);
              }),
              resolve: n,
              reject: e,
            };
          });
      var Er = (() => (
        ((Er = Er || {})[(Er.DISABLED = 0)] = 'DISABLED'),
        (Er[(Er.ENABLED = 1)] = 'ENABLED'),
        (Er[(Er.ENHANCED = 2)] = 'ENHANCED'),
        Er
      ))();
      let QW = (() => {
        class n {
          set cMapsUrl(t) {
            this._cMapsUrl = t;
          }
          set page(t) {
            const i = (t = parseInt(t, 10) || 1);
            this._pdf && (t = this.getValidPageNumber(t)),
              (this._page = t),
              i !== t && this.pageChange.emit(t);
          }
          set renderText(t) {
            this._renderText = t;
          }
          set renderTextMode(t) {
            this._renderTextMode = t;
          }
          set originalSize(t) {
            this._originalSize = t;
          }
          set showAll(t) {
            this._showAll = t;
          }
          set stickToPage(t) {
            this._stickToPage = t;
          }
          set zoom(t) {
            t <= 0 || (this._zoom = t);
          }
          get zoom() {
            return this._zoom;
          }
          set zoomScale(t) {
            this._zoomScale = t;
          }
          get zoomScale() {
            return this._zoomScale;
          }
          set rotation(t) {
            'number' == typeof t && t % 90 == 0
              ? (this._rotation = t)
              : console.warn('Invalid pages rotation angle.');
          }
          set externalLinkTarget(t) {
            this._externalLinkTarget = t;
          }
          set autoresize(t) {
            this._canAutoResize = !!t;
          }
          set fitToPage(t) {
            this._fitToPage = !!t;
          }
          set showBorders(t) {
            this._showBorders = !!t;
          }
          static getLinkTarget(t) {
            switch (t) {
              case 'blank':
                return Xc.BLANK;
              case 'none':
                return Xc.NONE;
              case 'self':
                return Xc.SELF;
              case 'parent':
                return Xc.PARENT;
              case 'top':
                return Xc.TOP;
            }
            return null;
          }
          constructor(t, i) {
            if (
              ((this.element = t),
              (this.ngZone = i),
              (this.isVisible = !1),
              (this._cMapsUrl =
                typeof Ls < 'u'
                  ? `https://unpkg.com/pdfjs-dist@${V_}/cmaps/`
                  : null),
              (this._imageResourcesPath =
                typeof Ls < 'u'
                  ? `https://unpkg.com/pdfjs-dist@${V_}/web/images/`
                  : void 0),
              (this._renderText = !0),
              (this._renderTextMode = Er.ENABLED),
              (this._stickToPage = !1),
              (this._originalSize = !0),
              (this._page = 1),
              (this._zoom = 1),
              (this._zoomScale = 'page-width'),
              (this._rotation = 0),
              (this._showAll = !0),
              (this._canAutoResize = !0),
              (this._fitToPage = !1),
              (this._externalLinkTarget = 'blank'),
              (this._showBorders = !1),
              (this.pageScrollTimeout = null),
              (this.isInitialized = !1),
              (this.destroy$ = new Le()),
              (this.afterLoadComplete = new ke()),
              (this.pageRendered = new ke()),
              (this.pageInitialized = new ke()),
              (this.textLayerRendered = new ke()),
              (this.onError = new ke()),
              (this.onProgress = new ke()),
              (this.pageChange = new ke(!0)),
              vf())
            )
              return;
            let r;
            const s = V_;
            (r =
              window[`pdfWorkerSrc${s}`] ||
              (window.hasOwnProperty('pdfWorkerSrc') &&
              'string' == typeof window.pdfWorkerSrc &&
              window.pdfWorkerSrc
                ? window.pdfWorkerSrc
                : `https://cdn.jsdelivr.net/npm/pdfjs-dist@${s}/legacy/build/pdf.worker.min.mjs`)),
              qS(XB, 'workerSrc', r);
          }
          ngAfterViewChecked() {
            if (this.isInitialized) return;
            const t = this.pdfViewerContainer.nativeElement.offsetParent;
            !0 !== this.isVisible || null != t
              ? !1 === this.isVisible &&
                null != t &&
                ((this.isVisible = !0),
                setTimeout(() => {
                  this.initialize(), this.ngOnChanges({ src: this.src });
                }))
              : (this.isVisible = !1);
          }
          ngOnInit() {
            this.initialize(), this.setupResizeListener();
          }
          ngOnDestroy() {
            this.clear(), this.destroy$.next(), (this.loadingTask = null);
          }
          ngOnChanges(t) {
            if (!vf() && this.isVisible)
              if ('src' in t) this.loadPDF();
              else if (this._pdf) {
                if (
                  (('renderText' in t || 'showAll' in t) &&
                    (this.setupViewer(), this.resetPdfDocument()),
                  'page' in t)
                ) {
                  const { page: i } = t;
                  if (i.currentValue === this._latestScrolledPage) return;
                  this.pdfViewer.scrollPageIntoView({ pageNumber: this._page });
                }
                this.update();
              }
          }
          updateSize() {
            Vs(this._pdf.getPage(this.pdfViewer.currentPageNumber))
              .pipe(se(this.destroy$))
              .subscribe({
                next: (t) => {
                  const i = this._rotation + t.rotate,
                    r =
                      t.getViewport({ scale: this._zoom, rotation: i }).width *
                      n.CSS_UNITS;
                  let s = this._zoom,
                    o = !0;
                  if (
                    !this._originalSize ||
                    (this._fitToPage &&
                      r > this.pdfViewerContainer.nativeElement.clientWidth)
                  ) {
                    const a = t.getViewport({ scale: 1, rotation: i });
                    (s = this.getScale(a.width, a.height)),
                      (o = !this._stickToPage);
                  }
                  this.pdfViewer.pagesPromise?.then(() => {
                    (this.pdfViewer.currentScale = s),
                      o &&
                        this.pdfViewer.scrollPageIntoView({
                          pageNumber: t.pageNumber,
                          ignoreDestinationZoom: !0,
                        });
                  });
                },
              });
          }
          clear() {
            this.loadingTask &&
              !this.loadingTask.destroyed &&
              this.loadingTask.destroy(),
              this._pdf &&
                ((this._latestScrolledPage = 0),
                this._pdf.destroy(),
                (this._pdf = void 0)),
              this.pdfViewer && this.pdfViewer.setDocument(null),
              this.pdfLinkService &&
                this.pdfLinkService.setDocument(null, null),
              this.pdfFindController &&
                this.pdfFindController.setDocument(null);
          }
          getPDFLinkServiceConfig() {
            const t = n.getLinkTarget(this._externalLinkTarget);
            return t ? { externalLinkTarget: t } : {};
          }
          initEventBus() {
            (this.eventBus = (function Ace(n, e) {
              const t = new n.EventBus();
              return (
                (function Sce(n, e) {
                  St(n, 'documentload')
                    .pipe(se(e))
                    .subscribe(() => {
                      const t = document.createEvent('CustomEvent');
                      t.initCustomEvent('documentload', !0, !0, {}),
                        window.dispatchEvent(t);
                    }),
                    St(n, 'pagerendered')
                      .pipe(se(e))
                      .subscribe(
                        ({ pageNumber: t, cssTransform: i, source: r }) => {
                          const s = document.createEvent('CustomEvent');
                          s.initCustomEvent('pagerendered', !0, !0, {
                            pageNumber: t,
                            cssTransform: i,
                          }),
                            r.div.dispatchEvent(s);
                        }
                      ),
                    St(n, 'textlayerrendered')
                      .pipe(se(e))
                      .subscribe(({ pageNumber: t, source: i }) => {
                        const r = document.createEvent('CustomEvent');
                        r.initCustomEvent('textlayerrendered', !0, !0, {
                          pageNumber: t,
                        }),
                          i.textLayerDiv?.dispatchEvent(r);
                      }),
                    St(n, 'pagechanging')
                      .pipe(se(e))
                      .subscribe(({ pageNumber: t, source: i }) => {
                        const r = document.createEvent('UIEvents');
                        r.initEvent('pagechanging', !0, !0),
                          (r.pageNumber = t),
                          i.container.dispatchEvent(r);
                      }),
                    St(n, 'pagesinit')
                      .pipe(se(e))
                      .subscribe(({ source: t }) => {
                        const i = document.createEvent('CustomEvent');
                        i.initCustomEvent('pagesinit', !0, !0, null),
                          t.container.dispatchEvent(i);
                      }),
                    St(n, 'pagesloaded')
                      .pipe(se(e))
                      .subscribe(({ pagesCount: t, source: i }) => {
                        const r = document.createEvent('CustomEvent');
                        r.initCustomEvent('pagesloaded', !0, !0, {
                          pagesCount: t,
                        }),
                          i.container.dispatchEvent(r);
                      }),
                    St(n, 'scalechange')
                      .pipe(se(e))
                      .subscribe(({ scale: t, presetValue: i, source: r }) => {
                        const s = document.createEvent('UIEvents');
                        s.initEvent('scalechange', !0, !0),
                          (s.scale = t),
                          (s.presetValue = i),
                          r.container.dispatchEvent(s);
                      }),
                    St(n, 'updateviewarea')
                      .pipe(se(e))
                      .subscribe(({ location: t, source: i }) => {
                        const r = document.createEvent('UIEvents');
                        r.initEvent('updateviewarea', !0, !0),
                          (r.location = t),
                          i.container.dispatchEvent(r);
                      }),
                    St(n, 'find')
                      .pipe(se(e))
                      .subscribe(
                        ({
                          source: t,
                          type: i,
                          query: r,
                          phraseSearch: s,
                          caseSensitive: o,
                          highlightAll: a,
                          findPrevious: l,
                        }) => {
                          if (t === window) return;
                          const c = document.createEvent('CustomEvent');
                          c.initCustomEvent('find' + i, !0, !0, {
                            query: r,
                            phraseSearch: s,
                            caseSensitive: o,
                            highlightAll: a,
                            findPrevious: l,
                          }),
                            window.dispatchEvent(c);
                        }
                      ),
                    St(n, 'attachmentsloaded')
                      .pipe(se(e))
                      .subscribe(({ attachmentsCount: t, source: i }) => {
                        const r = document.createEvent('CustomEvent');
                        r.initCustomEvent('attachmentsloaded', !0, !0, {
                          attachmentsCount: t,
                        }),
                          i.container.dispatchEvent(r);
                      }),
                    St(n, 'sidebarviewchanged')
                      .pipe(se(e))
                      .subscribe(({ view: t, source: i }) => {
                        const r = document.createEvent('CustomEvent');
                        r.initCustomEvent('sidebarviewchanged', !0, !0, {
                          view: t,
                        }),
                          i.outerContainer.dispatchEvent(r);
                      }),
                    St(n, 'pagemode')
                      .pipe(se(e))
                      .subscribe(({ mode: t, source: i }) => {
                        const r = document.createEvent('CustomEvent');
                        r.initCustomEvent('pagemode', !0, !0, { mode: t }),
                          i.pdfViewer.container.dispatchEvent(r);
                      }),
                    St(n, 'namedaction')
                      .pipe(se(e))
                      .subscribe(({ action: t, source: i }) => {
                        const r = document.createEvent('CustomEvent');
                        r.initCustomEvent('namedaction', !0, !0, { action: t }),
                          i.pdfViewer.container.dispatchEvent(r);
                      }),
                    St(n, 'presentationmodechanged')
                      .pipe(se(e))
                      .subscribe(({ active: t, switchInProgress: i }) => {
                        const r = document.createEvent('CustomEvent');
                        r.initCustomEvent('presentationmodechanged', !0, !0, {
                          active: t,
                          switchInProgress: i,
                        }),
                          window.dispatchEvent(r);
                      }),
                    St(n, 'outlineloaded')
                      .pipe(se(e))
                      .subscribe(({ outlineCount: t, source: i }) => {
                        const r = document.createEvent('CustomEvent');
                        r.initCustomEvent('outlineloaded', !0, !0, {
                          outlineCount: t,
                        }),
                          i.container.dispatchEvent(r);
                      });
                })(t, e),
                t
              );
            })(Ib, this.destroy$)),
              St(this.eventBus, 'pagerendered')
                .pipe(se(this.destroy$))
                .subscribe((t) => {
                  this.pageRendered.emit(t);
                }),
              St(this.eventBus, 'pagesinit')
                .pipe(se(this.destroy$))
                .subscribe((t) => {
                  this.pageInitialized.emit(t);
                }),
              St(this.eventBus, 'pagechanging')
                .pipe(se(this.destroy$))
                .subscribe(({ pageNumber: t }) => {
                  this.pageScrollTimeout &&
                    clearTimeout(this.pageScrollTimeout),
                    (this.pageScrollTimeout = window.setTimeout(() => {
                      (this._latestScrolledPage = t), this.pageChange.emit(t);
                    }, 100));
                }),
              St(this.eventBus, 'textlayerrendered')
                .pipe(se(this.destroy$))
                .subscribe((t) => {
                  this.textLayerRendered.emit(t);
                });
          }
          initPDFServices() {
            (this.pdfLinkService = new YW({
              eventBus: this.eventBus,
              ...this.getPDFLinkServiceConfig(),
            })),
              (this.pdfFindController = new XW({
                eventBus: this.eventBus,
                linkService: this.pdfLinkService,
              }));
          }
          getPDFOptions() {
            return {
              eventBus: this.eventBus,
              container: this.element.nativeElement.querySelector('div'),
              removePageBorders: !this._showBorders,
              linkService: this.pdfLinkService,
              textLayerMode: this._renderText
                ? this._renderTextMode
                : Er.DISABLED,
              findController: this.pdfFindController,
              l10n: new qW('en'),
              imageResourcesPath: this._imageResourcesPath,
              annotationEditorMode: qB.DISABLE,
            };
          }
          setupViewer() {
            this.pdfViewer && this.pdfViewer.setDocument(null),
              qS(Ls, 'disableTextLayer', !this._renderText),
              this.initPDFServices(),
              (this.pdfViewer = this._showAll
                ? new ZW(this.getPDFOptions())
                : new KW(this.getPDFOptions())),
              this.pdfLinkService.setViewer(this.pdfViewer),
              (this.pdfViewer._currentPageNumber = this._page);
          }
          getValidPageNumber(t) {
            return t < 1 ? 1 : t > this._pdf.numPages ? this._pdf.numPages : t;
          }
          getDocumentParams() {
            const t = typeof this.src;
            if (!this._cMapsUrl) return this.src;
            const i = {
              cMapUrl: this._cMapsUrl,
              cMapPacked: !0,
              enableXfa: !0,
              isEvalSupported: !1,
            };
            return (
              'string' === t
                ? (i.url = this.src)
                : 'object' === t &&
                  (void 0 !== this.src.byteLength
                    ? (i.data = this.src)
                    : Object.assign(i, this.src)),
              i
            );
          }
          loadPDF() {
            if (!this.src) return;
            if (this.lastLoaded === this.src) return void this.update();
            this.clear(),
              this.setupViewer(),
              (this.loadingTask = KB(this.getDocumentParams())),
              (this.loadingTask.onProgress = (i) => {
                this.onProgress.emit(i);
              });
            const t = this.src;
            Vs(this.loadingTask.promise)
              .pipe(se(this.destroy$))
              .subscribe({
                next: (i) => {
                  (this._pdf = i),
                    (this.lastLoaded = t),
                    this.afterLoadComplete.emit(i),
                    this.resetPdfDocument(),
                    this.update();
                },
                error: (i) => {
                  (this.lastLoaded = null), this.onError.emit(i);
                },
              });
          }
          update() {
            (this.page = this._page), this.render();
          }
          render() {
            (this._page = this.getValidPageNumber(this._page)),
              (0 !== this._rotation ||
                this.pdfViewer.pagesRotation !== this._rotation) &&
                this.pdfViewer.firstPagePromise?.then(
                  () => (this.pdfViewer.pagesRotation = this._rotation)
                ),
              this._stickToPage &&
                setTimeout(() => {
                  this.pdfViewer.currentPageNumber = this._page;
                }),
              this.updateSize();
          }
          getScale(t, i) {
            const r = this._showBorders ? 2 * n.BORDER_WIDTH : 0,
              s = this.pdfViewerContainer.nativeElement.clientWidth - r,
              o = this.pdfViewerContainer.nativeElement.clientHeight - r;
            if (0 === o || 0 === i || 0 === s || 0 === t) return 1;
            let a = 1;
            switch (this._zoomScale) {
              case 'page-fit':
                a = Math.min(o / i, s / t);
                break;
              case 'page-height':
                a = o / i;
                break;
              default:
                a = s / t;
            }
            return (this._zoom * a) / n.CSS_UNITS;
          }
          resetPdfDocument() {
            this.pdfLinkService.setDocument(this._pdf, null),
              this.pdfFindController.setDocument(this._pdf),
              this.pdfViewer.setDocument(this._pdf);
          }
          initialize() {
            vf() ||
              !this.isVisible ||
              ((this.isInitialized = !0),
              this.initEventBus(),
              this.setupViewer());
          }
          setupResizeListener() {
            vf() ||
              this.ngZone.runOutsideAngular(() => {
                St(window, 'resize')
                  .pipe(
                    gu(100),
                    di(() => this._canAutoResize && !!this._pdf),
                    se(this.destroy$)
                  )
                  .subscribe(() => {
                    this.updateSize();
                  });
              });
          }
        }
        return (
          (n.CSS_UNITS = 96 / 72),
          (n.BORDER_WIDTH = 9),
          (n.ɵfac = function (t) {
            return new (t || n)(D(Ne), D(ue));
          }),
          (n.ɵcmp = _n({
            type: n,
            selectors: [['pdf-viewer']],
            viewQuery: function (t, i) {
              if ((1 & t && vn(Mce, 5), 2 & t)) {
                let r;
                ut((r = ht())) && (i.pdfViewerContainer = r.first);
              }
            },
            inputs: {
              src: 'src',
              cMapsUrl: ['c-maps-url', 'cMapsUrl'],
              page: 'page',
              renderText: ['render-text', 'renderText'],
              renderTextMode: ['render-text-mode', 'renderTextMode'],
              originalSize: ['original-size', 'originalSize'],
              showAll: ['show-all', 'showAll'],
              stickToPage: ['stick-to-page', 'stickToPage'],
              zoom: 'zoom',
              zoomScale: ['zoom-scale', 'zoomScale'],
              rotation: 'rotation',
              externalLinkTarget: [
                'external-link-target',
                'externalLinkTarget',
              ],
              autoresize: 'autoresize',
              fitToPage: ['fit-to-page', 'fitToPage'],
              showBorders: ['show-borders', 'showBorders'],
            },
            outputs: {
              afterLoadComplete: 'after-load-complete',
              pageRendered: 'page-rendered',
              pageInitialized: 'pages-initialized',
              textLayerRendered: 'text-layer-rendered',
              onError: 'error',
              onProgress: 'on-progress',
              pageChange: 'pageChange',
            },
            features: [ri],
            decls: 3,
            vars: 0,
            consts: [
              [1, 'rd-pdf-viewer-container'],
              ['pdfViewerContainer', ''],
              [1, 'pdfViewer'],
            ],
            template: function (t, i) {
              1 & t && (z(0, 'div', 0, 1), ct(2, 'div', 2), G());
            },
            styles: [
              '.rd-pdf-viewer-container[_ngcontent-%COMP%]{overflow-x:auto;position:absolute;height:100%;width:100%;-webkit-overflow-scrolling:touch}[_nghost-%COMP%]{display:block;position:relative}[_nghost-%COMP%]    {--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--viewer-container-height: 0;--annotation-unfocused-field-background: url("data:image/svg+xml;charset=UTF-8,<svg width=\'1px\' height=\'1px\' xmlns=\'http://www.w3.org/2000/svg\'><rect width=\'100%\' height=\'100%\' style=\'fill:rgba(0, 54, 255, 0.13);\'/></svg>");--xfa-unfocused-field-background: var( --annotation-unfocused-field-background );--page-border-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAYAAAByUDbMAAAA1ElEQVQ4jbWUWw6EIAxFy2NFs/8NzR4UJhpqLsdi5mOmSSMUOfYWqv3S0gMr4XlYH/64gZa/gN3ANYA7KAXALt4ktoQ5MI9YxqaG8bWmsIysMuT6piSQCa4whZThCu8CM4zP9YJaKci9jicPq3NcBWYoPMGUlhG7ivtkB+gVyFY75wXghOvh8t5mto1Mdim6e+MBqH6XsY+YAwjpq3vGF7weTWQptLEDVCZvPTMl5JZZsdh47FHW6qFMyvLYqjcnmdFfY9Xk/KDOlzCusX2mi/ofM7MPkzBcSp4Q1/wAAAAASUVORK5CYII=) 9 9 repeat;--scale-factor: 1;--focus-outline: solid 2px blue;--hover-outline: dashed 2px blue;--freetext-line-height: 1.35;--freetext-padding: 2px;--editorInk-editing-cursor: pointer}@media screen and (forced-colors: active){[_nghost-%COMP%]    {--pdfViewer-padding-bottom: 9px;--page-margin: 8px auto -1px;--page-border: 1px solid CanvasText;--page-border-image: none;--spreadHorizontalWrapped-margin-LR: 3.5px}}@media (forced-colors: active){[_nghost-%COMP%]    {--focus-outline: solid 3px ButtonText;--hover-outline: dashed 3px ButtonText}}[_nghost-%COMP%]     .textLayer{position:absolute;text-align:initial;inset:0;overflow:hidden;opacity:.2;line-height:1;-webkit-text-size-adjust:none;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0}[_nghost-%COMP%]     .textLayer span, [_nghost-%COMP%]     .textLayer br{color:transparent;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}[_nghost-%COMP%]     .textLayer span.markedContent{top:0;height:0}[_nghost-%COMP%]     .textLayer .highlight{margin:-1px;padding:1px;background-color:#b400aa;border-radius:4px}[_nghost-%COMP%]     .textLayer .highlight.appended{position:initial}[_nghost-%COMP%]     .textLayer .highlight.begin{border-radius:4px 0 0 4px}[_nghost-%COMP%]     .textLayer .highlight.end{border-radius:0 4px 4px 0}[_nghost-%COMP%]     .textLayer .highlight.middle{border-radius:0}[_nghost-%COMP%]     .textLayer .highlight.selected{background-color:#006400}[_nghost-%COMP%]     .textLayer ::selection{background:rgb(0,0,255)}[_nghost-%COMP%]     .textLayer br::selection{background:transparent}[_nghost-%COMP%]     .textLayer .endOfContent{display:block;position:absolute;inset:100% 0 0;z-index:-1;cursor:default;-webkit-user-select:none;user-select:none}[_nghost-%COMP%]     .textLayer .endOfContent.active{top:0}@media (forced-colors: active){[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input:required, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea:required, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select:required, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:required, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:required{outline:1.5px solid selectedItem}}[_nghost-%COMP%]     .annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0}[_nghost-%COMP%]     .annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;transform-origin:0 0}[_nghost-%COMP%]     .annotationLayer .linkAnnotation>a, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.pushButton>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.pushButton>canvas{width:100%;height:100%}[_nghost-%COMP%]     .annotationLayer .linkAnnotation>a:hover, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.pushButton>a:hover{opacity:.2;background:rgb(255,255,0);box-shadow:0 2px 10px #ff0}[_nghost-%COMP%]     .annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input{background-image:var(--annotation-unfocused-field-background);border:1px solid transparent;box-sizing:border-box;font:calc(9px * var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input:required, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea:required, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select:required, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:required, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:required{outline:1.5px solid red}[_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select option{padding:0}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea{resize:none}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input[disabled], [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea[disabled], [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select[disabled], [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled], [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled]{background:none;border:1px solid transparent;cursor:not-allowed}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input:hover, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea:hover, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select:hover, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:hover, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:hover{border:1px solid rgb(0,0,0)}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input:focus, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea:focus, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:1px solid transparent}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input :focus, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea :focus, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select :focus, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox :focus, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton :focus{background-image:none;background-color:transparent;outline:auto}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:"";display:block;position:absolute}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:30%;top:20%;width:50%}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input{-webkit-appearance:none;appearance:none}[_nghost-%COMP%]     .annotationLayer .popupTriggerArea{height:100%;width:100%}[_nghost-%COMP%]     .annotationLayer .popupWrapper{position:absolute;font-size:calc(9px * var(--scale-factor));width:100%;min-width:calc(180px * var(--scale-factor));pointer-events:none}[_nghost-%COMP%]     .annotationLayer .popup{position:absolute;max-width:calc(180px * var(--scale-factor));background-color:#ff9;box-shadow:0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) #888;border-radius:calc(2px * var(--scale-factor));padding:calc(6px * var(--scale-factor));margin-left:calc(5px * var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}[_nghost-%COMP%]     .annotationLayer .popup>*{font-size:calc(9px * var(--scale-factor))}[_nghost-%COMP%]     .annotationLayer .popup h1{display:inline-block}[_nghost-%COMP%]     .annotationLayer .popupDate{display:inline-block;margin-left:calc(5px * var(--scale-factor))}[_nghost-%COMP%]     .annotationLayer .popupContent{border-top:1px solid rgb(51,51,51);margin-top:calc(2px * var(--scale-factor));padding-top:calc(2px * var(--scale-factor))}[_nghost-%COMP%]     .annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px * var(--scale-factor))}[_nghost-%COMP%]     .annotationLayer .highlightAnnotation, [_nghost-%COMP%]     .annotationLayer .underlineAnnotation, [_nghost-%COMP%]     .annotationLayer .squigglyAnnotation, [_nghost-%COMP%]     .annotationLayer .strikeoutAnnotation, [_nghost-%COMP%]     .annotationLayer .freeTextAnnotation, [_nghost-%COMP%]     .annotationLayer .lineAnnotation svg line, [_nghost-%COMP%]     .annotationLayer .squareAnnotation svg rect, [_nghost-%COMP%]     .annotationLayer .circleAnnotation svg ellipse, [_nghost-%COMP%]     .annotationLayer .polylineAnnotation svg polyline, [_nghost-%COMP%]     .annotationLayer .polygonAnnotation svg polygon, [_nghost-%COMP%]     .annotationLayer .caretAnnotation, [_nghost-%COMP%]     .annotationLayer .inkAnnotation svg polyline, [_nghost-%COMP%]     .annotationLayer .stampAnnotation, [_nghost-%COMP%]     .annotationLayer .fileAttachmentAnnotation{cursor:pointer}[_nghost-%COMP%]     .annotationLayer section svg{position:absolute;width:100%;height:100%}[_nghost-%COMP%]     .annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:transparent;-webkit-user-select:none;user-select:none;pointer-events:none}[_nghost-%COMP%]     .annotationLayer .annotationTextContent span{width:100%;display:inline-block}@media (forced-colors: active){[_nghost-%COMP%]     .xfaLayer *:required{outline:1.5px solid selectedItem}}[_nghost-%COMP%]     .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}[_nghost-%COMP%]     .xfaLayer .highlight.appended{position:initial}[_nghost-%COMP%]     .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}[_nghost-%COMP%]     .xfaLayer .highlight.end{border-radius:0 4px 4px 0}[_nghost-%COMP%]     .xfaLayer .highlight.middle{border-radius:0}[_nghost-%COMP%]     .xfaLayer .highlight.selected{background-color:#cbdfcb}[_nghost-%COMP%]     .xfaLayer ::selection{background:rgb(0,0,255)}[_nghost-%COMP%]     .xfaPage{overflow:hidden;position:relative}[_nghost-%COMP%]     .xfaContentarea{position:absolute}[_nghost-%COMP%]     .xfaPrintOnly{display:none}[_nghost-%COMP%]     .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}[_nghost-%COMP%]     .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:transparent;padding:0;margin:0;pointer-events:auto;line-height:inherit}[_nghost-%COMP%]     .xfaLayer *:required{outline:1.5px solid red}[_nghost-%COMP%]     .xfaLayer div{pointer-events:none}[_nghost-%COMP%]     .xfaLayer svg{pointer-events:none}[_nghost-%COMP%]     .xfaLayer svg *{pointer-events:none}[_nghost-%COMP%]     .xfaLayer a{color:#00f}[_nghost-%COMP%]     .xfaRich li{margin-left:3em}[_nghost-%COMP%]     .xfaFont{color:#000;font-weight:400;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}[_nghost-%COMP%]     .xfaCaption{overflow:hidden;flex:0 0 auto}[_nghost-%COMP%]     .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}[_nghost-%COMP%]     .xfaLabel{height:100%;width:100%}[_nghost-%COMP%]     .xfaLeft{display:flex;flex-direction:row;align-items:center}[_nghost-%COMP%]     .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}[_nghost-%COMP%]     .xfaLeft>.xfaCaption, [_nghost-%COMP%]     .xfaLeft>.xfaCaptionForCheckButton, [_nghost-%COMP%]     .xfaRight>.xfaCaption, [_nghost-%COMP%]     .xfaRight>.xfaCaptionForCheckButton{max-height:100%}[_nghost-%COMP%]     .xfaTop{display:flex;flex-direction:column;align-items:flex-start}[_nghost-%COMP%]     .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}[_nghost-%COMP%]     .xfaTop>.xfaCaption, [_nghost-%COMP%]     .xfaTop>.xfaCaptionForCheckButton, [_nghost-%COMP%]     .xfaBottom>.xfaCaption, [_nghost-%COMP%]     .xfaBottom>.xfaCaptionForCheckButton{width:100%}[_nghost-%COMP%]     .xfaBorder{background-color:transparent;position:absolute;pointer-events:none}[_nghost-%COMP%]     .xfaWrapped{width:100%;height:100%}[_nghost-%COMP%]     .xfaTextfield:focus, [_nghost-%COMP%]     .xfaSelect:focus{background-image:none;background-color:transparent;outline:auto;outline-offset:-1px}[_nghost-%COMP%]     .xfaCheckbox:focus, [_nghost-%COMP%]     .xfaRadio:focus{outline:auto}[_nghost-%COMP%]     .xfaTextfield, [_nghost-%COMP%]     .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}[_nghost-%COMP%]     .xfaTop>.xfaTextfield, [_nghost-%COMP%]     .xfaTop>.xfaSelect, [_nghost-%COMP%]     .xfaBottom>.xfaTextfield, [_nghost-%COMP%]     .xfaBottom>.xfaSelect{flex:0 1 auto}[_nghost-%COMP%]     .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}[_nghost-%COMP%]     .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}[_nghost-%COMP%]     .xfaCheckbox, [_nghost-%COMP%]     .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}[_nghost-%COMP%]     .xfaRich{white-space:pre-wrap;width:100%;height:100%}[_nghost-%COMP%]     .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}[_nghost-%COMP%]     .xfaLrTb, [_nghost-%COMP%]     .xfaRlTb, [_nghost-%COMP%]     .xfaTb{display:flex;flex-direction:column;align-items:stretch}[_nghost-%COMP%]     .xfaLr{display:flex;flex-direction:row;align-items:stretch}[_nghost-%COMP%]     .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}[_nghost-%COMP%]     .xfaTb>div{justify-content:left}[_nghost-%COMP%]     .xfaPosition{position:relative}[_nghost-%COMP%]     .xfaArea{position:relative}[_nghost-%COMP%]     .xfaValignMiddle{display:flex;align-items:center}[_nghost-%COMP%]     .xfaTable{display:flex;flex-direction:column;align-items:stretch}[_nghost-%COMP%]     .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}[_nghost-%COMP%]     .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}[_nghost-%COMP%]     .xfaTable .xfaRlRow>div{flex:1}[_nghost-%COMP%]     .xfaNonInteractive input, [_nghost-%COMP%]     .xfaNonInteractive textarea, [_nghost-%COMP%]     .xfaDisabled input, [_nghost-%COMP%]     .xfaDisabled textarea, [_nghost-%COMP%]     .xfaReadOnly input, [_nghost-%COMP%]     .xfaReadOnly textarea{background:initial}@media print{[_nghost-%COMP%]     .xfaTextfield, [_nghost-%COMP%]     .xfaSelect{background:transparent}[_nghost-%COMP%]     .xfaSelect{-webkit-appearance:none;appearance:none;text-indent:1px;text-overflow:""}}[_nghost-%COMP%]     [data-editor-rotation="90"]{transform:rotate(90deg)}[_nghost-%COMP%]     [data-editor-rotation="180"]{transform:rotate(180deg)}[_nghost-%COMP%]     [data-editor-rotation="270"]{transform:rotate(270deg)}[_nghost-%COMP%]     .annotationEditorLayer{background:transparent;position:absolute;top:0;left:0;font-size:calc(100px * var(--scale-factor));transform-origin:0 0}[_nghost-%COMP%]     .annotationEditorLayer .selectedEditor{outline:var(--focus-outline);resize:none}[_nghost-%COMP%]     .annotationEditorLayer .freeTextEditor{position:absolute;background:transparent;border-radius:3px;padding:calc(var(--freetext-padding) * var(--scale-factor));resize:none;width:auto;height:auto;z-index:1;transform-origin:0 0;touch-action:none}[_nghost-%COMP%]     .annotationEditorLayer .freeTextEditor .internal{background:transparent;border:none;top:0;left:0;overflow:visible;white-space:nowrap;resize:none;font:10px sans-serif;line-height:var(--freetext-line-height)}[_nghost-%COMP%]     .annotationEditorLayer .freeTextEditor .overlay{position:absolute;display:none;background:transparent;top:0;left:0;width:100%;height:100%}[_nghost-%COMP%]     .annotationEditorLayer .freeTextEditor .overlay.enabled{display:block}[_nghost-%COMP%]     .annotationEditorLayer .freeTextEditor .internal:empty:before{content:attr(default-content);color:gray}[_nghost-%COMP%]     .annotationEditorLayer .freeTextEditor .internal:focus{outline:none}[_nghost-%COMP%]     .annotationEditorLayer .inkEditor.disabled{resize:none}[_nghost-%COMP%]     .annotationEditorLayer .inkEditor.disabled.selectedEditor{resize:horizontal}[_nghost-%COMP%]     .annotationEditorLayer .freeTextEditor:hover:not(.selectedEditor), [_nghost-%COMP%]     .annotationEditorLayer .inkEditor:hover:not(.selectedEditor){outline:var(--hover-outline)}[_nghost-%COMP%]     .annotationEditorLayer .inkEditor{position:absolute;background:transparent;border-radius:3px;overflow:auto;width:100%;height:100%;z-index:1;transform-origin:0 0;cursor:auto}[_nghost-%COMP%]     .annotationEditorLayer .inkEditor.editing{resize:none;cursor:var(--editorInk-editing-cursor),pointer}[_nghost-%COMP%]     .annotationEditorLayer .inkEditor .inkEditorCanvas{position:absolute;top:0;left:0;width:100%;height:100%;touch-action:none}[_nghost-%COMP%]     [data-main-rotation="90"]{transform:rotate(90deg) translateY(-100%)}[_nghost-%COMP%]     [data-main-rotation="180"]{transform:rotate(180deg) translate(-100%,-100%)}[_nghost-%COMP%]     [data-main-rotation="270"]{transform:rotate(270deg) translate(-100%)}[_nghost-%COMP%]     .pdfViewer{padding-bottom:var(--pdfViewer-padding-bottom)}[_nghost-%COMP%]     .pdfViewer .canvasWrapper{overflow:hidden}[_nghost-%COMP%]     .pdfViewer .page{direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);border-image:var(--page-border-image);background-clip:content-box;background-color:#fff}[_nghost-%COMP%]     .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}[_nghost-%COMP%]     .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}[_nghost-%COMP%]     .pdfViewer.singlePageView{display:inline-block}[_nghost-%COMP%]     .pdfViewer.singlePageView .page{margin:0;border:none}[_nghost-%COMP%]     .pdfViewer.scrollHorizontal, [_nghost-%COMP%]     .pdfViewer.scrollWrapped, [_nghost-%COMP%]     .spread{margin-left:3.5px;margin-right:3.5px;text-align:center}[_nghost-%COMP%]     .pdfViewer.scrollHorizontal, [_nghost-%COMP%]     .spread{white-space:nowrap}[_nghost-%COMP%]     .pdfViewer.removePageBorders, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .spread, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .spread{margin-left:0;margin-right:0}[_nghost-%COMP%]     .spread .page, [_nghost-%COMP%]     .spread .dummyPage, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .page, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .page, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .spread, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .spread{display:inline-block;vertical-align:middle}[_nghost-%COMP%]     .spread .page, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .page, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .page{margin-left:var(--spreadHorizontalWrapped-margin-LR);margin-right:var(--spreadHorizontalWrapped-margin-LR)}[_nghost-%COMP%]     .pdfViewer.removePageBorders .spread .page, [_nghost-%COMP%]     .pdfViewer.removePageBorders.scrollHorizontal .page, [_nghost-%COMP%]     .pdfViewer.removePageBorders.scrollWrapped .page{margin-left:5px;margin-right:5px}[_nghost-%COMP%]     .pdfViewer .page canvas{margin:0;display:block}[_nghost-%COMP%]     .pdfViewer .page canvas[hidden]{display:none}[_nghost-%COMP%]     .pdfViewer .page .loadingIcon{position:absolute;display:block;inset:0;background:url(data:image/gif;base64,R0lGODlhGAAYAPQQAM7Ozvr6+uDg4LCwsOjo6I6OjsjIyJycnNjY2KioqMDAwPLy8nZ2doaGhri4uGhoaP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/ilPcHRpbWl6ZWQgd2l0aCBodHRwczovL2V6Z2lmLmNvbS9vcHRpbWl6ZQAh+QQJBwAQACwAAAAAGAAYAAAFmiAkjiTkOGVaBgjZNGSgkgKjjM8zLoI8iy+BKCdiCX8iBeMAhEEIPRXLxViYUE9CbCQoFAzFhHY3zkaT3oPvBz1zE4UBsr1eWZH4vAowOBwGAHk8AoQLfH6Agm0Ed3qOAXWOIgQKiWyFJQgDgJEpdG+WEACNEFNFmKVlVzJQk6qdkwqBoi1mebJ3ALNGeIZHtGSwNDS1RZKueCEAIfkECQcAEAAsAAAAABgAGAAABZcgJI4kpChlWgYCWRQkEKgjURgjw4zOg9CjVwuiEyEeO6CxkBC9nA+HiuUqLEyoBZI0Mx4SAFFgQCDZuguBoGv6Dtg0gvpqdhxQQDkBzuUr/4A1JwMKP39pc2mDhYCIc4GQYn6QCwCMeY91l0p6dBAEJ0OfcFRimZ91Mwt0alxxAIZyRmuAsKxDLKKvZbM1tJxmvGKRpn8hACH5BAkHABAALAAAAAAYABgAAAWhICSOJGQYZVoGAnkcJBKoI3EAY1GMCtPSosSBINKJBIwGkHdwBGGQA0OhYpEGQxNqkYzNIITBACEKKBaxxNfBeOCO4vMy0Hg8nDHFeCktkKtfNAtoS4UqAicKBj9zBAKPC4iKi4aRkISGmWWBmjUIAIyHkCUEAKCVo2WmREecVqoCgZhgP4NHrGWCj7e3szSpuxAsoVWxnp6cVV4kyZW+KSEAIfkECQcAEAAsAAAAABgAGAAABZkgJI4kBABlWgYEOQykEKgjMSDjcYxG0dKi108nEhQKQN4rCIMkCgbawjWYnSCLY2yGVSgEooBhWqsGGwxc0RtNBgoMhmJ1QgETjANYFeBKyUmBKQQIdT9JDmgPDQ6EhoKJD4sOgpWWgiwChyqEBH5hmptSoSOZgJ4kLKWkYTF7C2SaqaM/hEWygay4mYG8t6uffFuzl1iANCEAIfkECQcAEAAsAAAAABgAGAAABZ0gJI4khCBlmhKkopBCoI6LIozDMAIHO4uuBVBnOiR+I4FrCDwAZsKdQnaCLIwwmRUA8JmioprWUCjcwlwUMnAoG0qL03k2KCS8cC0UjOzDCQKBfHQFDAwFU4CCfgqFhy9+kZJWgzSKSAcPZn+BfQENDw8OljGWJAFeDoZPYTBnC1GdSXqnsoBolSulX2GyP6hgvnG0KrS3NJNhuSQhACH5BAkHABAALAAAAAAYABgAAAWaICSOJCQIZZoupGGQRKCOC0CMijIiwz2LABtQZxoMfjQhxAXszWQ7gOwECRhh0MCJJRJARTUoIHFAgbfI6uBwAJS01J/i4PClVYHvfV8lbLlIBmwFbQt+aGmChG18jXeGT4dICQxlb4g/AQUMDER9XjR6BAdiDQwINDBmkAsPDVh4cX4imw53iLKuaVqAcUsPqEiidkt6j4AzIQAh+QQJBwAQACwAAAAAGAAYAAAFmSAkjiREEGWaBiSCtCoZCMsIAKOg1LEo0KKbaKFQ9EYLoOkFuQlirNxzCQkUW9GZ0hQd4nyDAWr4G/esYSbyZFYZwu3jqiuvr8u8I2BwOAwASXh1e31/doeHC3klWnElfAlTd46MfQUGk2stCVEGBQWSdCciDg5VDAVYKoEiDQ0iBwxGcj9RDw8+qHIzebc2DJJQJK6qiKVyIQAh+QQJBwAQACwAAAAAGAAYAAAFmSAkjiS0LGWaBiRBtCoZCKgoCCMB1DF0sz6cCQDo5W62l28XAyZFpyECBv3lnCbhUqHMIo0Qg4Jbmn1jRCa4iV27TzfXGjEecOFWMN1OdvvfPGUuXSoKBw6EXokrAwcHRVU0UAeEBANAAAmUI1gNDyhjJgUHLW0iDg8FIqOnBQZrDA9TELE2rEYIDw4jta2LMpCrqld/YQpgIQAh+QQJBwAQACwAAAAAGAAYAAAFmyAkjiS0LGWaBiRBkKw6BgIqCsJcyyMe4yJajhcEml5H26o1PN2QQd3uFiv2AADlAgflIbDdZLgkABOJgep5LfWty4p4zeU+w+XsvJWXliEKDwdEBgMKYQ4PDw1qK3EDCCMAiQ5BCV0LCj+FSDQkgCgGBiYHAy2MIgoMghAHqw4HAGsNDEMFBTekdgwKI7aRB2MwkL2rVHoQoWchACH5BAkHABAALAAAAAAYABgAAAWWICSOJLQsZZoGJEGQrDoGAioKwlzLIx7jIlqOFwSaXkfbqjU83ZBB3e4WK0qrCxyU55peid0qcUwuixyNx6PhILsAcAJazXYj4lvz2MkLiFsHDAlEcABKZwwMBX8pBgoKQxAIigpBA1sLBj+PSDQkB4uSACYDlTMyBgWDEKVnl2QFBUigN61gBQYjtLV5JZ4jtlR6omMhACH5BAkHABAALAAAAAAYABgAAAWaICSOJLQsZZoGJEGQrDoGAioKwlzLIx7jIlqOFwSaXkdbidYanm7I4AjwYDh6saJuJ3JUG1mZi9srPA7EcRimJLrfJYWZUVC8TziXnEG3u/E+cIJaPAFrPQl1aQAIbRAGBZGHJQiMUQKRBkEKbQsAPZaEXQcslSYKmjMyAAdXj34ACkNEiUgDA5t+PAQHn6Ogjkuzry2DNwhuIQAh+QQFBwAQACwAAAAAGAAYAAAFnCAkjiS0LGVaBgBJEGSguo8zCsK4CPIsMg+ECCcKEH0ix6MwhJl4KiOp8UCdmrEbo6EoHpxF8A6aBBZ6vhf5dmAkkGr0CoWs21WGQ2FvsI9xC3l7B311fy93iWGKJQQOhHCAJQB6A3IqcWwJLU90i2FkUiMKlhBELEI6MwgDXRAGhQgAYD6tTqRFAJxpA6mvrqazSKJJhUWMpjlIIQA7) center no-repeat}[_nghost-%COMP%]     .pdfViewer .page .loadingIcon.notVisible{background:none}[_nghost-%COMP%]     .pdfViewer.enablePermissions .textLayer span{-webkit-user-select:none!important;user-select:none!important;cursor:not-allowed}[_nghost-%COMP%]     .pdfPresentationMode .pdfViewer{padding-bottom:0}[_nghost-%COMP%]     .pdfPresentationMode .spread{margin:0}[_nghost-%COMP%]     .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid transparent}',
            ],
          })),
          n
        );
      })();
      function Dce(n, e) {
        if (1 & n) {
          const t = Ui();
          z(0, 'button', 39),
            pe('click', function () {
              return Hn(t), Be(), Wn(Go(12).toggle());
            }),
            z(1, 'mat-icon'),
            Ue(2, 'menu'),
            G()();
        }
      }
      function Tce(n, e) {
        1 & n &&
          (z(0, 'span', 40), Ue(1, 'Angular 5+ Component to render PDF'), G());
      }
      function Ice(n, e) {
        1 & n && ct(0, 'iframe', 41);
      }
      function kce(n, e) {
        if (
          (1 & n &&
            (z(0, 'div', 42),
            Ue(1),
            (function zP(n, e) {
              const t = Xe();
              let i;
              const r = n + ze;
              t.firstCreatePass
                ? ((i = (function Y8(n, e) {
                    if (e)
                      for (let t = e.length - 1; t >= 0; t--) {
                        const i = e[t];
                        if (n === i.name) return i;
                      }
                  })(e, t.pipeRegistry)),
                  (t.data[r] = i),
                  i.onDestroy && (t.destroyHooks ??= []).push(r, i.onDestroy))
                : (i = t.data[r]);
              const s = i.factory || (i.factory = Lo(i.type)),
                o = Jn(D);
              try {
                const a = Kf(!1),
                  l = s();
                return (
                  Kf(a),
                  (function T5(n, e, t, i) {
                    t >= n.data.length &&
                      ((n.data[t] = null), (n.blueprint[t] = null)),
                      (e[t] = i);
                  })(t, H(), r, l),
                  l
                );
              } finally {
                Jn(o);
              }
            })(2, 'json'),
            G()),
          2 & n)
        ) {
          const t = Be();
          Y(1), ds(' ', UP(2, 1, t.error.message), ' ');
        }
      }
      function Pce(n, e) {
        if (1 & n) {
          const t = Ui();
          z(0, 'mat-form-field', 34)(1, 'mat-label'),
            Ue(2, 'Select an option'),
            G(),
            z(3, 'mat-select', 43),
            pe('valueChange', function (r) {
              return Hn(t), Wn((Be().zoomScale = r));
            }),
            z(4, 'mat-option', 44),
            Ue(5, 'Page Width'),
            G(),
            z(6, 'mat-option', 45),
            Ue(7, 'Page Height'),
            G(),
            z(8, 'mat-option', 46),
            Ue(9, 'Page Fit'),
            G()()();
        }
        if (2 & n) {
          const t = Be();
          Y(3), X('value', t.zoomScale);
        }
      }
      function Rce(n, e) {
        if (1 & n) {
          const t = Ui();
          Wi(),
            tr(),
            z(0, 'div', 14)(1, 'mat-slide-toggle', 15),
            pe('ngModelChange', function (r) {
              return Hn(t), Wn((Be().stickToPage = r));
            }),
            Ue(2, ' Stick to page '),
            G()();
        }
        if (2 & n) {
          const t = Be();
          Y(1), X('ngModel', t.stickToPage);
        }
      }
      function Fce(n, e) {
        if ((1 & n && (z(0, 'span'), Ue(1), G()), 2 & n)) {
          const t = Be(2);
          Y(1), ds('of ', t.pdf.numPages, '');
        }
      }
      function Oce(n, e) {
        if (1 & n) {
          const t = Ui();
          Wi(),
            tr(),
            z(0, 'div', 14)(1, 'button', 18),
            pe('click', function () {
              return Hn(t), Wn(Be().incrementPage(-1));
            }),
            Ue(2, ' Previous '),
            G(),
            z(3, 'mat-form-field', 23)(4, 'input', 47),
            pe('ngModelChange', function (r) {
              return Hn(t), Wn((Be().page = r));
            }),
            G(),
            z(5, 'mat-error'),
            Ue(6, 'Input is not a number!'),
            G()(),
            Ie(7, Fce, 2, 1, 'span', 33),
            z(8, 'button', 18),
            pe('click', function () {
              return Hn(t), Wn(Be().incrementPage(1));
            }),
            Ue(9, ' Next '),
            G()();
        }
        if (2 & n) {
          const t = Be();
          Y(4), X('ngModel', t.page), Y(3), X('ngIf', t.pdf);
        }
      }
      function Lce(n, e) {
        if (1 & n) {
          const t = Ui();
          Wi(),
            tr(),
            z(0, 'div', 14)(1, 'mat-slide-toggle', 15),
            pe('ngModelChange', function (r) {
              return Hn(t), Wn((Be().isOutlineShown = r));
            }),
            Ue(2, ' Show outline '),
            G()();
        }
        if (2 & n) {
          const t = Be();
          Y(1), X('ngModel', t.isOutlineShown);
        }
      }
      function Nce(n, e) {
        if (1 & n) {
          const t = Ui();
          z(0, 'ul')(1, 'li')(2, 'a', 50),
            pe('click', function () {
              const s = Hn(t).$implicit;
              return Wn(Be(3).navigateTo(s.dest));
            }),
            Ue(3),
            G()()();
        }
        if (2 & n) {
          const t = e.$implicit;
          Y(3), ds(' ', t.title, ' ');
        }
      }
      function Vce(n, e) {
        if (1 & n) {
          const t = Ui();
          z(0, 'ul', 49)(1, 'li')(2, 'a', 50),
            pe('click', function () {
              const s = Hn(t).$implicit;
              return Wn(Be(2).navigateTo(s.dest));
            }),
            Ue(3),
            G(),
            Ie(4, Nce, 4, 1, 'ul', 51),
            G()();
        }
        if (2 & n) {
          const t = e.$implicit;
          Y(3), ds(' ', t.title, ' '), Y(1), X('ngForOf', t.items);
        }
      }
      function Bce(n, e) {
        if (
          (1 & n && (Wi(), tr(), z(0, 'div'), Ie(1, Vce, 5, 2, 'ul', 48), G()),
          2 & n)
        ) {
          const t = Be();
          Y(1), X('ngForOf', t.outline);
        }
      }
      function Hce(n, e) {
        if (
          (1 & n &&
            (z(0, 'div', 52)(1, 'div', 53),
            ct(2, 'div', 54),
            G(),
            z(3, 'span'),
            Ue(4),
            G()()),
          2 & n)
        ) {
          const t = Be();
          Y(2),
            Rl(
              'width',
              (t.progressData.loaded / t.progressData.total) * 100 + '%'
            ),
            Y(2),
            ds(
              '',
              t.getInt((t.progressData.loaded / t.progressData.total) * 100),
              '%'
            );
        }
      }
      let Wce = (() => {
          class n {
            constructor() {
              (this.pdfSrc = './assets/pdf-test.pdf'),
                (this.page = 1),
                (this.rotation = 0),
                (this.zoom = 1),
                (this.zoomScale = 'page-width'),
                (this.originalSize = !1),
                (this.renderText = !0),
                (this.isLoaded = !1),
                (this.stickToPage = !1),
                (this.showAll = !0),
                (this.autoresize = !0),
                (this.fitToPage = !1),
                (this.isOutlineShown = !1),
                (this.pdfQuery = ''),
                (this.mobile = !1);
            }
            ngOnInit() {
              window.screen.width <= 768 && (this.mobile = !0);
            }
            loadPdf() {
              const t = new XMLHttpRequest();
              t.open('GET', '/assets/pdf-test.pdf', !0),
                (t.responseType = 'blob'),
                (t.onload = (i) => {
                  if ((console.log(t), 200 === t.status)) {
                    const r = new Blob([t.response], {
                      type: 'application/pdf',
                    });
                    this.pdfSrc = URL.createObjectURL(r);
                  }
                }),
                t.send();
            }
            setCustomWorkerPath() {
              window.pdfWorkerSrc = '/lib/pdfjs-dist/build/pdf.worker.js';
            }
            incrementPage(t) {
              this.page += t;
            }
            incrementZoom(t) {
              this.zoom += t;
            }
            rotate(t) {
              this.rotation += t;
            }
            onFileSelected() {
              const t = document.querySelector('#file');
              if (typeof FileReader < 'u') {
                const i = new FileReader();
                (i.onload = (r) => {
                  this.pdfSrc = r.target.result;
                }),
                  i.readAsArrayBuffer(t.files[0]);
              }
            }
            afterLoadComplete(t) {
              (this.pdf = t), this.loadOutline();
            }
            loadOutline() {
              this.pdf.getOutline().then((t) => {
                this.outline = t;
              });
            }
            onError(t) {
              if (((this.error = t), 'PasswordException' === t.name)) {
                const i = prompt(
                  'This document is password protected. Enter the password:'
                );
                i && ((this.error = null), this.setPassword(i));
              }
            }
            setPassword(t) {
              let i;
              (i =
                this.pdfSrc instanceof ArrayBuffer
                  ? { data: this.pdfSrc }
                  : 'string' == typeof this.pdfSrc
                  ? { url: this.pdfSrc }
                  : { ...this.pdfSrc }),
                (i.password = t),
                (this.pdfSrc = i);
            }
            onProgress(t) {
              console.log(t),
                (this.progressData = t),
                (this.isLoaded = t.loaded >= t.total),
                (this.error = null);
            }
            getInt(t) {
              return Math.round(t);
            }
            navigateTo(t) {
              this.pdfComponent.pdfLinkService.goToDestination(t);
            }
            scrollToPage() {
              this.pdfComponent.pdfViewer.scrollPageIntoView({ pageNumber: 3 });
            }
            pageRendered(t) {
              console.log('(page-rendered)', t);
            }
            pageInitialized(t) {
              console.log('(page-initialized)', t);
            }
            pageChange(t) {
              console.log('(page-change)', t);
            }
            searchQueryChanged(t) {
              const i = t !== this.pdfQuery ? '' : 'again';
              (this.pdfQuery = t),
                this.pdfComponent.eventBus.dispatch('find', {
                  type: i,
                  query: this.pdfQuery,
                  highlightAll: !0,
                  caseSensitive: !1,
                  phraseSearch: !0,
                });
            }
            onResize(t) {
              this.mobile = t.target.innerWidth <= 768;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = _n({
              type: n,
              selectors: [['pdf-viewer-app']],
              viewQuery: function (t, i) {
                if ((1 & t && vn(QW, 5), 2 & t)) {
                  let r;
                  ut((r = ht())) && (i.pdfComponent = r.first);
                }
              },
              hostBindings: function (t, i) {
                1 & t &&
                  pe(
                    'resize',
                    function (s) {
                      return i.onResize(s);
                    },
                    0,
                    dI
                  );
              },
              decls: 82,
              vars: 40,
              consts: [
                ['color', 'primary'],
                [
                  'class',
                  'toggle-menu',
                  'mat-raised-button',
                  '',
                  3,
                  'click',
                  4,
                  'ngIf',
                ],
                ['class', 'description hide-md', 4, 'ngIf'],
                [1, 'spacer'],
                [
                  'src',
                  'https://ghbtns.com/github-btn.html?user=vadimdez&repo=rd-pdf-viewer&type=star&count=true',
                  'frameborder',
                  '0',
                  'scrolling',
                  '0',
                  'width',
                  '170px',
                  'height',
                  '20px',
                  4,
                  'ngIf',
                ],
                [
                  'href',
                  'https://github.com/vadimdez/rd-pdf-viewer',
                  'mat-raised-button',
                  '',
                  1,
                  'button',
                ],
                [1, 'example-container'],
                [3, 'mode', 'opened'],
                ['drawer', ''],
                [1, 'mb', 'full-width'],
                [
                  'matInput',
                  '',
                  'type',
                  'text',
                  'placeholder',
                  'Set URL of the PDF file',
                  3,
                  'ngModel',
                  'ngModelChange',
                ],
                [1, 'select-file__container'],
                ['type', 'file', 'id', 'file', 3, 'change'],
                ['class', 'error mb', 4, 'ngIf'],
                [1, 'mb'],
                [3, 'ngModel', 'ngModelChange'],
                [1, 'mb', 3, 'hidden'],
                ['class', 'full-width', 4, 'ngIf'],
                ['mat-button', '', 'type', 'button', 3, 'click'],
                [
                  'xmlns',
                  'http://www.w3.org/2000/svg',
                  'width',
                  '20',
                  'height',
                  '20',
                  'viewBox',
                  '0 0 24 24',
                  'fill',
                  'none',
                  'stroke',
                  'currentColor',
                  'stroke-width',
                  '2',
                  'stroke-linecap',
                  'round',
                  'stroke-linejoin',
                  'round',
                ],
                ['cx', '11', 'cy', '11', 'r', '8'],
                ['x1', '21', 'y1', '21', 'x2', '16.65', 'y2', '16.65'],
                ['x1', '8', 'y1', '11', 'x2', '14', 'y2', '11'],
                [1, 'page-number'],
                [
                  'matInput',
                  '',
                  'type',
                  'number',
                  'placeholder',
                  'Zoom',
                  'pattern',
                  '-?[0-9]*(\\.[0-9]+)?',
                  3,
                  'ngModel',
                  'ngModelChange',
                ],
                ['x1', '11', 'y1', '8', 'x2', '11', 'y2', '14'],
                ['class', 'mb', 4, 'ngIf'],
                [
                  'mat-button',
                  '',
                  'type',
                  'button',
                  'matTooltip',
                  'Rotate left',
                  3,
                  'matTooltipPosition',
                  'click',
                ],
                [
                  'xmlns',
                  'http://www.w3.org/2000/svg',
                  'width',
                  '20',
                  'height',
                  '20',
                  'viewBox',
                  '0 0 24 24',
                  'fill',
                  'none',
                  'stroke',
                  'currentColor',
                  'stroke-width',
                  '2',
                  'stroke-linecap',
                  'round',
                  'stroke-linejoin',
                  'round',
                  'transform',
                  'scale(-1,1)',
                ],
                ['points', '23 4 23 10 17 10'],
                ['d', 'M20.49 15a9 9 0 1 1-2.12-9.36L23 10'],
                [
                  'matInput',
                  '',
                  'type',
                  'number',
                  'placeholder',
                  'Rotation',
                  'disabled',
                  '',
                  3,
                  'ngModel',
                ],
                [
                  'mat-button',
                  '',
                  'type',
                  'button',
                  'matTooltip',
                  'Rotate right',
                  3,
                  'matTooltipPosition',
                  'click',
                ],
                [4, 'ngIf'],
                [1, 'full-width'],
                [
                  'matInput',
                  '',
                  'id',
                  'pdfQueryInput',
                  'type',
                  'text',
                  'placeholder',
                  'Search...',
                  3,
                  'value',
                  'input',
                  'keyup.enter',
                ],
                ['queryInp', ''],
                ['id', 'progress', 4, 'ngIf'],
                [
                  3,
                  'src',
                  'page',
                  'rotation',
                  'original-size',
                  'show-all',
                  'fit-to-page',
                  'zoom',
                  'zoom-scale',
                  'stick-to-page',
                  'render-text',
                  'external-link-target',
                  'autoresize',
                  'show-borders',
                  'pageChange',
                  'after-load-complete',
                  'error',
                  'on-progress',
                  'page-rendered',
                  'pages-initialized',
                ],
                ['mat-raised-button', '', 1, 'toggle-menu', 3, 'click'],
                [1, 'description', 'hide-md'],
                [
                  'src',
                  'https://ghbtns.com/github-btn.html?user=vadimdez&repo=rd-pdf-viewer&type=star&count=true',
                  'frameborder',
                  '0',
                  'scrolling',
                  '0',
                  'width',
                  '170px',
                  'height',
                  '20px',
                ],
                [1, 'error', 'mb'],
                [3, 'value', 'valueChange'],
                ['value', 'page-width'],
                ['value', 'page-height'],
                ['value', 'page-fit'],
                [
                  'matInput',
                  '',
                  'type',
                  'number',
                  'placeholder',
                  'Page',
                  'pattern',
                  '-?[0-9]*(\\.[0-9]+)?',
                  3,
                  'ngModel',
                  'ngModelChange',
                ],
                ['class', 'outline-list', 4, 'ngFor', 'ngForOf'],
                [1, 'outline-list'],
                [3, 'click'],
                [4, 'ngFor', 'ngForOf'],
                ['id', 'progress'],
                [1, 'bg'],
                [1, 'bar'],
              ],
              template: function (t, i) {
                if (1 & t) {
                  const r = Ui();
                  z(0, 'mat-toolbar', 0)(1, 'mat-toolbar-row'),
                    Ie(2, Dce, 3, 0, 'button', 1),
                    z(3, 'span'),
                    Ue(4, 'rd-pdf-viewer'),
                    G(),
                    Ie(5, Tce, 2, 0, 'span', 2),
                    ct(6, 'span', 3),
                    Ie(7, Ice, 1, 0, 'iframe', 4),
                    z(8, 'a', 5),
                    Ue(9, 'Get Started'),
                    G()()(),
                    z(10, 'mat-drawer-container', 6)(11, 'mat-drawer', 7, 8)(
                      13,
                      'mat-form-field',
                      9
                    )(14, 'mat-label'),
                    Ue(15, 'Set URL of the PDF file'),
                    G(),
                    z(16, 'input', 10),
                    pe('ngModelChange', function (o) {
                      return (i.pdfSrc = o);
                    }),
                    G()(),
                    z(17, 'div', 11)(18, 'p'),
                    Ue(
                      19,
                      ' Or render preview by just selecting PDF file (no upload required) '
                    ),
                    G(),
                    z(20, 'input', 12),
                    pe('change', function () {
                      return i.onFileSelected();
                    }),
                    G()(),
                    Ie(21, kce, 3, 3, 'div', 13),
                    z(22, 'div', 14)(23, 'mat-slide-toggle', 15),
                    pe('ngModelChange', function (o) {
                      return (i.originalSize = o);
                    }),
                    Ue(24, ' Original size '),
                    G()(),
                    z(25, 'div', 16)(26, 'mat-slide-toggle', 15),
                    pe('ngModelChange', function (o) {
                      return (i.fitToPage = o);
                    }),
                    Ue(27, ' Fit to page '),
                    G()(),
                    z(28, 'div', 14)(29, 'mat-slide-toggle', 15),
                    pe('ngModelChange', function (o) {
                      return (i.renderText = o);
                    }),
                    Ue(30, ' Render text layer '),
                    G()(),
                    z(31, 'div', 14)(32, 'mat-slide-toggle', 15),
                    pe('ngModelChange', function (o) {
                      return (i.autoresize = o);
                    }),
                    Ue(33, ' Auto resize '),
                    G()(),
                    z(34, 'div', 14)(35, 'mat-slide-toggle', 15),
                    pe('ngModelChange', function (o) {
                      return (i.showAll = o);
                    }),
                    Ue(36, ' Show all pages '),
                    G()(),
                    Ie(37, Pce, 10, 1, 'mat-form-field', 17),
                    z(38, 'div', 9)(39, 'button', 18),
                    pe('click', function () {
                      return i.incrementZoom(-0.1);
                    }),
                    Wi(),
                    z(40, 'svg', 19),
                    ct(41, 'circle', 20)(42, 'line', 21)(43, 'line', 22),
                    G()(),
                    tr(),
                    z(44, 'mat-form-field', 23)(45, 'input', 24),
                    pe('ngModelChange', function (o) {
                      return (i.zoom = o);
                    }),
                    G(),
                    z(46, 'mat-error'),
                    Ue(47, 'Input is not a number!'),
                    G()(),
                    z(48, 'button', 18),
                    pe('click', function () {
                      return i.incrementZoom(0.1);
                    }),
                    Wi(),
                    z(49, 'svg', 19),
                    ct(50, 'circle', 20)(51, 'line', 21)(52, 'line', 25)(
                      53,
                      'line',
                      22
                    ),
                    G()()(),
                    Ie(54, Rce, 3, 1, 'div', 26),
                    Ie(55, Oce, 10, 2, 'div', 26),
                    tr(),
                    z(56, 'div', 14)(57, 'button', 27),
                    pe('click', function () {
                      return i.rotate(-90);
                    }),
                    Wi(),
                    z(58, 'svg', 28),
                    ct(59, 'polyline', 29)(60, 'path', 30),
                    G()(),
                    tr(),
                    z(61, 'mat-form-field', 23),
                    ct(62, 'input', 31),
                    z(63, 'mat-error'),
                    Ue(64, 'Input is not a number!'),
                    G()(),
                    z(65, 'button', 32),
                    pe('click', function () {
                      return i.rotate(90);
                    }),
                    Wi(),
                    z(66, 'svg', 19),
                    ct(67, 'polyline', 29)(68, 'path', 30),
                    G()()(),
                    Ie(69, Lce, 3, 1, 'div', 26),
                    Ie(70, Bce, 2, 1, 'div', 33),
                    tr(),
                    z(71, 'div', 14)(72, 'mat-form-field', 34)(73, 'mat-label'),
                    Ue(74, 'Search'),
                    G(),
                    z(75, 'input', 35, 36),
                    pe('input', function (o) {
                      return i.searchQueryChanged(o.target.value);
                    })('keyup.enter', function () {
                      Hn(r);
                      const o = Go(76);
                      return Wn(i.searchQueryChanged(o.value));
                    }),
                    G(),
                    z(77, 'mat-hint'),
                    Ue(78, 'Search in entire pdf'),
                    G()()(),
                    Ie(79, Hce, 5, 3, 'div', 37),
                    G(),
                    z(80, 'mat-drawer-content')(81, 'pdf-viewer', 38),
                    pe('pageChange', function (o) {
                      return (i.page = o);
                    })('after-load-complete', function (o) {
                      return i.afterLoadComplete(o);
                    })('error', function (o) {
                      return i.onError(o);
                    })('on-progress', function (o) {
                      return i.onProgress(o);
                    })('page-rendered', function (o) {
                      return i.pageRendered(o);
                    })('pages-initialized', function (o) {
                      return i.pageInitialized(o);
                    })('pageChange', function (o) {
                      return i.pageChange(o);
                    }),
                    G()()();
                }
                2 & t &&
                  (Y(2),
                  X('ngIf', i.mobile),
                  Y(1),
                  zy('title ', i.mobile ? 'mob' : 'desk', ''),
                  Y(2),
                  X('ngIf', !i.mobile),
                  Y(2),
                  X('ngIf', !i.mobile),
                  Y(4),
                  X('mode', i.mobile ? 'push' : 'side')('opened', !i.mobile),
                  Y(5),
                  X('ngModel', i.pdfSrc),
                  Y(5),
                  X('ngIf', i.error),
                  Y(2),
                  X('ngModel', i.originalSize),
                  Y(2),
                  X('hidden', !i.originalSize),
                  Y(1),
                  X('ngModel', i.fitToPage),
                  Y(3),
                  X('ngModel', i.renderText),
                  Y(3),
                  X('ngModel', i.autoresize),
                  Y(3),
                  X('ngModel', i.showAll),
                  Y(2),
                  X('ngIf', !i.originalSize),
                  Y(8),
                  X('ngModel', i.zoom),
                  Y(9),
                  X('ngIf', i.showAll),
                  Y(1),
                  X('ngIf', (i.stickToPage && i.showAll) || !i.showAll),
                  Y(2),
                  X('matTooltipPosition', 'above'),
                  Y(5),
                  X('ngModel', i.rotation),
                  Y(3),
                  X('matTooltipPosition', 'above'),
                  Y(4),
                  X('ngIf', i.showAll),
                  Y(1),
                  X('ngIf', i.showAll && i.isOutlineShown),
                  Y(5),
                  X('value', i.pdfQuery),
                  Y(4),
                  X('ngIf', !i.isLoaded && !i.error && i.progressData),
                  Y(2),
                  X('src', i.pdfSrc)('page', i.page)('rotation', i.rotation)(
                    'original-size',
                    i.originalSize
                  )('show-all', i.showAll)('fit-to-page', i.fitToPage)(
                    'zoom',
                    i.zoom
                  )('zoom-scale', i.zoomScale)('stick-to-page', i.stickToPage)(
                    'render-text',
                    i.renderText
                  )('external-link-target', 'blank')(
                    'autoresize',
                    i.autoresize
                  )('show-borders', !1));
              },
              dependencies: [
                yR,
                Zd,
                lm,
                b0,
                MF,
                A0,
                _0,
                HQ,
                BQ,
                TJ,
                EJ,
                pE,
                mE,
                fJ,
                UL,
                vte,
                xL,
                jJ,
                qL,
                nN,
                iN,
                qm,
                Zee,
                ane,
                QW,
                SR,
              ],
              styles: [
                'mat-toolbar[_ngcontent-%COMP%]{position:fixed;top:0;left:0;right:0;z-index:100}.select-file__container[_ngcontent-%COMP%]{margin-top:10px;margin-bottom:20px}.select-file__container[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin-bottom:0}.page-number[_ngcontent-%COMP%]{width:80px}.mb[_ngcontent-%COMP%]{margin-bottom:15px}pdf-viewer[_ngcontent-%COMP%]{display:block}.error[_ngcontent-%COMP%]{color:#ff4146}#progress[_ngcontent-%COMP%]{margin-top:50px;width:100px;text-align:center;margin-left:auto;margin-right:auto}#progress[_ngcontent-%COMP%]   .bar[_ngcontent-%COMP%], #progress[_ngcontent-%COMP%]   .bg[_ngcontent-%COMP%]{height:20px}#progress[_ngcontent-%COMP%]   .bg[_ngcontent-%COMP%]{background-color:#e3e3e3}#progress[_ngcontent-%COMP%]   .bar[_ngcontent-%COMP%]{width:0;max-width:100%;background-color:#3f51b5;transition:.5s width}.outline-list[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{cursor:pointer}.outline-list[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{color:#ea1f62}.spacer[_ngcontent-%COMP%]{flex:1 1 auto}mat-drawer[_ngcontent-%COMP%]{width:320px;padding:12px}mat-drawer-container[_ngcontent-%COMP%]{position:absolute;inset:64px 0 0}pdf-viewer[_ngcontent-%COMP%]{height:100%}.title[_ngcontent-%COMP%]{width:284px;text-align:left}.title.mob[_ngcontent-%COMP%]{text-align:center}a.button[_ngcontent-%COMP%]{display:flex;justify-content:space-evenly}.full-width[_ngcontent-%COMP%]{width:100%}',
              ],
            })),
            n
          );
        })(),
        jce = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Ze({ type: n, bootstrap: [Wce] })),
            (n.ɵinj = qe({ imports: [qR, o9, sZ, lne, cne] })),
            n
          );
        })();
      document.write(
        '<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>'
      ),
        document.write(
          '<script>(adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: "ca-pub-7000744132425449", enable_page_level_ads: true });</script>'
        ),
        XY()
          .bootstrapModule(jce)
          .catch((n) => console.error(n));
    },
  },
  (Tb) => {
    Tb((Tb.s = 541));
  },
]);
